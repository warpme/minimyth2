From 195eb07fb106fbabf164a1989860adcc132ab9d2 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Fri, 14 Jun 2013 19:53:14 +0100
Subject: [PATCH 45/56] Player: Enable AVSync to recover quicker after a seek
 or program change

The a/v timecodes can get out of step by 10's of seconds after a seek
or a livetv program change.  This can cause frames to be doubled or dropped
until the a/v streams get back in step.

This patch checks the a/v timecode difference and if larger than 1 second
disables frame dropping or doubling.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
Signed-off-by: Jean-Yves Avenard <jyavenard@mythtv.org>
---
 mythtv/libs/libmythtv/mythplayer.cpp |   81 ++++++++++++++++++++++++++++++----
 mythtv/libs/libmythtv/mythplayer.h   |    4 +-
 2 files changed, 76 insertions(+), 9 deletions(-)

diff --git a/mythtv/libs/libmythtv/mythplayer.cpp b/mythtv/libs/libmythtv/mythplayer.cpp
index c269ab8..c92d01d 100644
--- a/mythtv/libs/libmythtv/mythplayer.cpp
+++ b/mythtv/libs/libmythtv/mythplayer.cpp
@@ -223,7 +223,9 @@ MythPlayer::MythPlayer(PlayerFlags flags)
       refreshrate(0),
       lastsync(false),              repeat_delay(0),
       disp_timecode(0),             avsync_audiopaused(false),
+      avsync_holdoff(0),
       // Time Code stuff
+      prev_audiotime(0),
       prevtc(0),                    prevrp(0),
       // LiveTVChain stuff
       m_tv(NULL),                   isDummy(false),
@@ -1779,6 +1781,11 @@ void MythPlayer::InitAVSync(void)
     videosync->Start();
 
     avsync_adjustment = 0;
+    avsync_avg = 0;
+    lastsync = false;
+    avsync_holdoff = 0;
+    prev_audiotime = 0;
+    prevtc = 0;
 
     repeat_delay = 0;
 
@@ -1817,7 +1824,7 @@ int64_t MythPlayer::AVSyncGetAudiotime(void)
 void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
 {
     int repeat_pict  = 0;
-    int64_t timecode = audio.GetAudioTime();
+    int64_t timecode = 0;
 
     if (buffer)
     {
@@ -1974,6 +1981,7 @@ void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
                 .arg(diverge));
     }
 
+    bool bOK = false;
     if (audio.HasAudioOut() && normal_speed)
     {
         // must be sampled here due to Show delays
@@ -1992,8 +2000,48 @@ void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
                 .arg(avsync_predictor_enabled)
                 .arg(vsync_delay_clock)
                  );
-        if (currentaudiotime != 0 && timecode != 0)
-        { // currentaudiotime == 0 after a seek
+
+        // Max acceptable difference in timecodes
+        int maxdiff = (10 * frame_interval) / 1000;
+
+        if (avsync_holdoff > 0)
+            --avsync_holdoff;
+        // currentaudiotime == 0 after a seek
+        else if (timecode == 0 || currentaudiotime == 0 || prevtc == 0)
+            avsync_holdoff = 1;
+        else if (abs(timecode - prevtc) > maxdiff)
+        {
+            LOG(VB_PLAYBACK, LOG_INFO, LOC + QString(
+                    "Discontinuous video timecodes %1 -> %2")
+                .arg(prevtc)
+                .arg(timecode)
+            );
+            avsync_holdoff = 5;
+        }
+        else if (abs(currentaudiotime - prev_audiotime) > maxdiff)
+        {
+            LOG(VB_PLAYBACK, LOG_INFO, LOC + QString(
+                    "Discontinuous audio timecodes %1 -> %2")
+                .arg(prev_audiotime)
+                .arg(currentaudiotime)
+            );
+            // This is most common after SwitchToProgram
+            int frames = (currentaudiotime - prev_audiotime) / ((frame_interval + 999) / 1000);
+            avsync_holdoff = min(max(frames, 10), 50);
+        }
+        else if (abs(timecode - currentaudiotime) > 4000)
+        {
+            LOG(VB_PLAYBACK, LOG_INFO, LOC + QString(
+                    "Excessive A/V timecode difference: audio %1 video %2")
+                .arg(currentaudiotime)
+                .arg(timecode)
+            );
+            avsync_holdoff = 10;
+        }
+        else
+        {
+            bOK = true;
+
             // The time at the start of this frame (ie, now) is given by
             // last->timecode
             if (prevtc != 0)
@@ -2018,7 +2066,6 @@ void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
                         ++framesPlayedExtra;
                 }
             }
-            prevtc = timecode;
             prevrp = repeat_pict;
 
             // usec
@@ -2050,16 +2097,24 @@ void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
             else
                 lastsync = false;
         }
-        else
-        {
-            ResetAVSync();
-        }
+
+        prev_audiotime = currentaudiotime;
     }
     else
     {
         LOG(VB_PLAYBACK | VB_TIMESTAMP, LOG_INFO, LOC +
             QString("A/V no sync proc ns:%1").arg(normal_speed));
     }
+
+    if (!bOK)
+    {
+        ResetAVSync();
+        avsync_avg = 0;
+        avsync_adjustment = 0;
+        lastsync = false;
+    }
+
+    prevtc = timecode;
 }
 
 void MythPlayer::RefreshPauseFrame(void)
@@ -2669,6 +2724,10 @@ void MythPlayer::SwitchToProgram(void)
     }
 
     Play();
+
+    // Holdoff a/v sync while decoder and ringbuffer settle down
+    avsync_holdoff = 25;
+
     LOG(VB_PLAYBACK, LOG_INFO, LOC + "SwitchToProgram - end");
 }
 
@@ -2826,6 +2885,12 @@ void MythPlayer::JumpToProgram(void)
         DoJumpToFrame(nextpos, kInaccuracyNone);
 
     player_ctx->SetPlayerChangingBuffers(false);
+
+    audio.Pause(true);
+
+    // Holdoff a/v sync while decoder and ringbuffer settle down
+    avsync_holdoff = 25;
+
     LOG(VB_PLAYBACK, LOG_INFO, LOC + "JumpToProgram - end");
 }
 
diff --git a/mythtv/libs/libmythtv/mythplayer.h b/mythtv/libs/libmythtv/mythplayer.h
index 56e4624..84c8218 100644
--- a/mythtv/libs/libmythtv/mythplayer.h
+++ b/mythtv/libs/libmythtv/mythplayer.h
@@ -816,9 +816,11 @@ class MTV_PUBLIC MythPlayer
     int        repeat_delay;
     int64_t    disp_timecode;
     bool       avsync_audiopaused;
+    int        avsync_holdoff;
 
     // Time Code stuff
-    int        prevtc;        ///< 32 bit timecode if last VideoFrame shown
+    int64_t    prev_audiotime; // audio timecode at last a/v sync
+    int64_t    prevtc;        ///< timecode if last VideoFrame shown
     int        prevrp;        ///< repeat_pict of last frame
     int64_t    tc_wrap[TCTYPESMAX];
     int64_t    tc_lastval[TCTYPESMAX];
-- 
1.7.10.2

