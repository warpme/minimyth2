From: Ao Xu <ao.xu@amlogic.com>
Subject: [PATCH 07/32] [FROM_LIST] drm: meson: add primary and overlay plane
 support for S4

Update plane register configurations in the Meson DRM driver
to support the Amlogic S4 SoC. These adjustments ensure proper
handling of display planes with S4-specific hardware requirements.

Signed-off-by: Ao Xu <ao.xu@amlogic.com>
Signed-off-by: devmfc <devmfc@mvand.net>
---
 drivers/gpu/drm/meson/meson_crtc.c      | 90 ++++++++++++++++++-------
 drivers/gpu/drm/meson/meson_overlay.c   |  7 +-
 drivers/gpu/drm/meson/meson_plane.c     | 24 ++++---
 drivers/gpu/drm/meson/meson_registers.h | 16 +++++
 4 files changed, 102 insertions(+), 35 deletions(-)

diff --git a/drivers/gpu/drm/meson/meson_crtc.c b/drivers/gpu/drm/meson/meson_crtc.c
index d70616da8c..64c7450b7f 100644
--- a/drivers/gpu/drm/meson/meson_crtc.c
+++ b/drivers/gpu/drm/meson/meson_crtc.c
@@ -28,6 +28,7 @@
 #include "meson_osd_afbcd.h"
 
 #define MESON_G12A_VIU_OFFSET	0x5ec0
+#define MESON_S4_VIU_OFFSET	0xb6c0
 
 /* CRTC definition */
 
@@ -479,21 +480,60 @@ void meson_crtc_irq(struct meson_drm *priv)
 		writel_relaxed(priv->viu.vd1_if0_gen_reg,
 				priv->io_base + meson_crtc->viu_offset +
 				_REG(VD2_IF0_GEN_REG));
-		writel_relaxed(priv->viu.vd1_if0_gen_reg2,
-				priv->io_base + meson_crtc->viu_offset +
-				_REG(VD1_IF0_GEN_REG2));
-		writel_relaxed(priv->viu.viu_vd1_fmt_ctrl,
-				priv->io_base + meson_crtc->viu_offset +
-				_REG(VIU_VD1_FMT_CTRL));
-		writel_relaxed(priv->viu.viu_vd1_fmt_ctrl,
-				priv->io_base + meson_crtc->viu_offset +
-				_REG(VIU_VD2_FMT_CTRL));
-		writel_relaxed(priv->viu.viu_vd1_fmt_w,
-				priv->io_base + meson_crtc->viu_offset +
-				_REG(VIU_VD1_FMT_W));
-		writel_relaxed(priv->viu.viu_vd1_fmt_w,
-				priv->io_base + meson_crtc->viu_offset +
-				_REG(VIU_VD2_FMT_W));
+
+		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4)) {
+			writel_relaxed(priv->viu.vd1_if0_gen_reg2,
+					priv->io_base +
+					_REG(VD1_IF0_GEN_REG2_S4));
+			writel_relaxed(priv->viu.viu_vd1_fmt_ctrl,
+					priv->io_base +
+					_REG(VIU_VD1_FMT_CTRL_S4));
+			writel_relaxed(priv->viu.viu_vd1_fmt_ctrl,
+					priv->io_base +
+					_REG(VIU_VD2_FMT_CTRL_S4));
+			writel_relaxed(priv->viu.viu_vd1_fmt_w,
+					priv->io_base +
+					_REG(VIU_VD1_FMT_W_S4));
+			writel_relaxed(priv->viu.viu_vd1_fmt_w,
+					priv->io_base +
+					_REG(VIU_VD2_FMT_W_S4));
+
+			writel_relaxed(priv->viu.vd1_range_map_y,
+					priv->io_base +
+					_REG(VD1_IF0_RANGE_MAP_Y_S4));
+			writel_relaxed(priv->viu.vd1_range_map_cb,
+					priv->io_base +
+					_REG(VD1_IF0_RANGE_MAP_CB_S4));
+			writel_relaxed(priv->viu.vd1_range_map_cr,
+					priv->io_base +
+					_REG(VD1_IF0_RANGE_MAP_CR_S4));
+		} else {
+			writel_relaxed(priv->viu.vd1_if0_gen_reg2,
+					priv->io_base + meson_crtc->viu_offset +
+					_REG(VD1_IF0_GEN_REG2));
+			writel_relaxed(priv->viu.viu_vd1_fmt_ctrl,
+					priv->io_base + meson_crtc->viu_offset +
+					_REG(VIU_VD1_FMT_CTRL));
+			writel_relaxed(priv->viu.viu_vd1_fmt_ctrl,
+					priv->io_base + meson_crtc->viu_offset +
+					_REG(VIU_VD2_FMT_CTRL));
+			writel_relaxed(priv->viu.viu_vd1_fmt_w,
+					priv->io_base + meson_crtc->viu_offset +
+					_REG(VIU_VD1_FMT_W));
+			writel_relaxed(priv->viu.viu_vd1_fmt_w,
+					priv->io_base + meson_crtc->viu_offset +
+					_REG(VIU_VD2_FMT_W));
+
+			writel_relaxed(priv->viu.vd1_range_map_y,
+					priv->io_base + meson_crtc->viu_offset +
+					_REG(VD1_IF0_RANGE_MAP_Y));
+			writel_relaxed(priv->viu.vd1_range_map_cb,
+					priv->io_base + meson_crtc->viu_offset +
+					_REG(VD1_IF0_RANGE_MAP_CB));
+			writel_relaxed(priv->viu.vd1_range_map_cr,
+					priv->io_base + meson_crtc->viu_offset +
+					_REG(VD1_IF0_RANGE_MAP_CR));
+		}
 		writel_relaxed(priv->viu.vd1_if0_canvas0,
 				priv->io_base + meson_crtc->viu_offset +
 				_REG(VD1_IF0_CANVAS0));
@@ -592,15 +632,7 @@ void meson_crtc_irq(struct meson_drm *priv)
 				_REG(VD2_IF0_LUMA_PSEL));
 		writel_relaxed(0, priv->io_base + meson_crtc->viu_offset +
 				_REG(VD2_IF0_CHROMA_PSEL));
-		writel_relaxed(priv->viu.vd1_range_map_y,
-				priv->io_base + meson_crtc->viu_offset +
-				_REG(VD1_IF0_RANGE_MAP_Y));
-		writel_relaxed(priv->viu.vd1_range_map_cb,
-				priv->io_base + meson_crtc->viu_offset +
-				_REG(VD1_IF0_RANGE_MAP_CB));
-		writel_relaxed(priv->viu.vd1_range_map_cr,
-				priv->io_base + meson_crtc->viu_offset +
-				_REG(VD1_IF0_RANGE_MAP_CR));
+
 		writel_relaxed(VPP_VSC_BANK_LENGTH(4) |
 			       VPP_HSC_BANK_LENGTH(4) |
 			       VPP_SC_VD_EN_ENABLE |
@@ -692,10 +724,16 @@ int meson_crtc_create(struct meson_drm *priv)
 		return ret;
 	}
 
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4)) {
 		meson_crtc->enable_osd1 = meson_g12a_crtc_enable_osd1;
 		meson_crtc->enable_vd1 = meson_g12a_crtc_enable_vd1;
-		meson_crtc->viu_offset = MESON_G12A_VIU_OFFSET;
+
+		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4))
+			meson_crtc->viu_offset = MESON_S4_VIU_OFFSET;
+		else
+			meson_crtc->viu_offset = MESON_G12A_VIU_OFFSET;
+
 		meson_crtc->enable_osd1_afbc =
 					meson_crtc_g12a_enable_osd1_afbc;
 		meson_crtc->disable_osd1_afbc =
diff --git a/drivers/gpu/drm/meson/meson_overlay.c b/drivers/gpu/drm/meson/meson_overlay.c
index 7f98de3884..3cf2efa407 100644
--- a/drivers/gpu/drm/meson/meson_overlay.c
+++ b/drivers/gpu/drm/meson/meson_overlay.c
@@ -733,7 +733,12 @@ static void meson_overlay_atomic_disable(struct drm_plane *plane,
 	priv->viu.vd1_enabled = false;
 
 	/* Disable VD1 */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4)) {
+		writel_relaxed(0, priv->io_base + _REG(VD1_BLEND_SRC_CTRL));
+		writel_relaxed(0, priv->io_base + _REG(VD2_BLEND_SRC_CTRL));
+		writel_relaxed(0, priv->io_base + _REG(VD1_IF0_GEN_REG + 0x2db0));
+		writel_relaxed(0, priv->io_base + _REG(VD2_IF0_GEN_REG + 0x2db0));
+	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
 		writel_relaxed(0, priv->io_base + _REG(VD1_BLEND_SRC_CTRL));
 		writel_relaxed(0, priv->io_base + _REG(VD2_BLEND_SRC_CTRL));
 		writel_relaxed(0, priv->io_base + _REG(VD1_IF0_GEN_REG + 0x17b0));
diff --git a/drivers/gpu/drm/meson/meson_plane.c b/drivers/gpu/drm/meson/meson_plane.c
index b43ac61201..79cfa42af0 100644
--- a/drivers/gpu/drm/meson/meson_plane.c
+++ b/drivers/gpu/drm/meson/meson_plane.c
@@ -161,7 +161,8 @@ static void meson_plane_atomic_update(struct drm_plane *plane,
 
 	/* Check if AFBC decoder is required for this buffer */
 	if ((meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
-	     meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) &&
+	     meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) ||
+	     meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4)) &&
 	    fb->modifier & DRM_FORMAT_MOD_ARM_AFBC(MESON_MOD_AFBC_VALID_BITS))
 		priv->viu.osd1_afbcd = true;
 	else
@@ -181,7 +182,8 @@ static void meson_plane_atomic_update(struct drm_plane *plane,
 	priv->viu.osd1_blk0_cfg[0] = canvas_id_osd1 << OSD_CANVAS_SEL;
 
 	if (priv->viu.osd1_afbcd) {
-		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) ||
+		    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4)) {
 			/* This is the internal decoding memory address */
 			priv->viu.osd1_blk1_cfg4 = MESON_G12A_AFBCD_OUT_ADDR;
 			priv->viu.osd1_blk0_cfg[0] |= OSD_ENDIANNESS_BE;
@@ -205,7 +207,8 @@ static void meson_plane_atomic_update(struct drm_plane *plane,
 		priv->viu.osd1_blk0_cfg[0] |= OSD_OUTPUT_COLOR_RGB;
 
 	if (priv->viu.osd1_afbcd &&
-	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+	    (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) ||
+	     meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4))) {
 		priv->viu.osd1_blk0_cfg[0] |= OSD_MALI_SRC_EN |
 			priv->afbcd.ops->fmt_to_blk_mode(fb->modifier,
 							  fb->format->format);
@@ -357,7 +360,8 @@ static void meson_plane_atomic_update(struct drm_plane *plane,
 	priv->viu.osd1_blk0_cfg[3] = ((dest.x2 - 1) << 16) | dest.x1;
 	priv->viu.osd1_blk0_cfg[4] = ((dest.y2 - 1) << 16) | dest.y1;
 
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4)) {
 		priv->viu.osd_blend_din0_scope_h = ((dest.x2 - 1) << 16) | dest.x1;
 		priv->viu.osd_blend_din0_scope_v = ((dest.y2 - 1) << 16) | dest.y1;
 		priv->viu.osb_blend0_size = dst_h << 16 | dst_w;
@@ -377,7 +381,8 @@ static void meson_plane_atomic_update(struct drm_plane *plane,
 		priv->afbcd.format = fb->format->format;
 
 		/* Calculate decoder write stride */
-		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) ||
+		    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4))
 			priv->viu.osd1_blk2_cfg4 =
 				meson_g12a_afbcd_line_stride(priv);
 	}
@@ -408,7 +413,8 @@ static void meson_plane_atomic_disable(struct drm_plane *plane,
 	}
 
 	/* Disable OSD1 */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4))
 		writel_bits_relaxed(VIU_OSD1_POSTBLD_SRC_OSD1, 0,
 				    priv->io_base + _REG(OSD1_BLEND_SRC_CTRL));
 	else
@@ -439,7 +445,8 @@ static bool meson_plane_format_mod_supported(struct drm_plane *plane,
 		return true;
 
 	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) &&
-	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4))
 		return false;
 
 	if (modifier & ~DRM_FORMAT_MOD_ARM_AFBC(MESON_MOD_AFBC_VALID_BITS))
@@ -546,7 +553,8 @@ int meson_plane_create(struct meson_drm *priv)
 
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM))
 		format_modifiers = format_modifiers_afbc_gxm;
-	else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+	else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A) ||
+		 meson_vpu_is_compatible(priv, VPU_COMPATIBLE_S4))
 		format_modifiers = format_modifiers_afbc_g12a;
 
 	ret = drm_universal_plane_init(priv->drm, plane, 0xFF,
diff --git a/drivers/gpu/drm/meson/meson_registers.h b/drivers/gpu/drm/meson/meson_registers.h
index 3d73d00a1f..c62ee8bac2 100644
--- a/drivers/gpu/drm/meson/meson_registers.h
+++ b/drivers/gpu/drm/meson/meson_registers.h
@@ -328,6 +328,22 @@
 #define VIU_VD2_FMT_CTRL 0x1a88
 #define VIU_VD2_FMT_W 0x1a89
 
+#define VD1_IF0_RANGE_MAP_Y_S4 0x4816
+#define VD1_IF0_RANGE_MAP_CB_S4 0x4817
+#define VD1_IF0_RANGE_MAP_CR_S4 0x4818
+#define VD1_IF0_GEN_REG2_S4 0x4819
+#define VD1_IF0_GEN_REG3_S4 0x481c
+#define VIU_VD1_FMT_CTRL_S4 0x481d
+#define VIU_VD1_FMT_W_S4 0x481e
+
+#define VD2_IF0_RANGE_MAP_Y_S4 0x4896
+#define VD2_IF0_RANGE_MAP_CB_S4 0x4897
+#define VD2_IF0_RANGE_MAP_CR_S4  0x4898
+#define VD2_IF0_GEN_REG2_S4 0x4899
+#define VD2_IF0_GEN_REG3_S4 0x489c
+#define VIU_VD2_FMT_CTRL_S4 0x489d
+#define VIU_VD2_FMT_W_S4    0x489e
+
 /* VIU Matrix Registers */
 #define VIU_OSD1_MATRIX_CTRL 0x1a90
 #define VIU_OSD1_MATRIX_COEF00_01 0x1a91
-- 
2.46.0

