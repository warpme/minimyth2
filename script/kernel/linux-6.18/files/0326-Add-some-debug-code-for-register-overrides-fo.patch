
From: devmfc <devmfc@mvand.net>
Subject: [PATCH 26/32] [DEVMFC] Add some debug code for register overrides for
 testing rx delay settings

---
 .../ethernet/stmicro/stmmac/dwmac-meson8b.c   | 76 ++++++++++++++++++-
 1 file changed, 74 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c
index 9c2d62d133..1bde7509c1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c
@@ -68,13 +68,37 @@
  */
 #define PRG_ETH0_ADJ_SKEW		GENMASK(24, 20)
 
+#define PRG_ETH0_START_CALIBRATION	BIT(25)
+
+    /* 0: falling edge, 1: rising edge */
+#define PRG_ETH0_TEST_EDGE		BIT(26)
+
+/* Select one signal from {RXDV, RXD[3:0]} to calibrate */
+#define PRG_ETH0_SIGNAL_TO_CALIBRATE	GENMASK(29, 27)
+
 #define PRG_ETH1			0x4
 
+/* Signal switch position in 1ns resolution */
+#define PRG_ETH1_SIGNAL_SWITCH_POSITION	GENMASK(4, 0)
+
+/* RXC (RX clock) length in 1ns resolution */
+#define PRG_ETH1_RX_CLK_LENGTH		GENMASK(9, 5)
+
+#define PRG_ETH1_CALI_WAITING_FOR_EVENT	BIT(10)
+
+#define PRG_ETH1_SIGNAL_UNDER_TEST	GENMASK(13, 11)
+
+/* 0: falling edge, 1: rising edge */
+#define PRG_ETH1_RESULT_EDGE		BIT(14)
+
+#define PRG_ETH1_RESULT_IS_VALID	BIT(15)
+
+
 /* Defined for adding a delay to the input RX_CLK for better timing.
  * Each step is 200ps. These bits are used with external RGMII PHYs
  * because RGMII RX only has the small window. cfg_rxclk_dly can
  * adjust the window between RX_CLK and RX_DATA and improve the stability
- * of "rx data valid".
+ * of "rx data valid". only valid on G12A and later?
  */
 #define PRG_ETH1_CFG_RXCLK_DLY		GENMASK(19, 16)
 
@@ -306,6 +330,7 @@ static int meson8b_init_rgmii_delays(struct meson8b_dwmac *dwmac)
 		cfg_rxclk_dly = 0;
 		break;
 	case PHY_INTERFACE_MODE_RGMII_TXID:
+		dev_info(dwmac->dev, "DEVMFC: %s Selected RGMII-TXID phy-mode, so not setting TX clock skew on mac side\n", __func__);
 		delay_config = rx_adj_config;
 		break;
 	case PHY_INTERFACE_MODE_RGMII_ID:
@@ -320,6 +345,8 @@ static int meson8b_init_rgmii_delays(struct meson8b_dwmac *dwmac)
 	}
 
 	if (delay_config & PRG_ETH0_ADJ_ENABLE) {
+		dev_info(dwmac->dev, "DEVMFC: %s Old fashioned RX delay selected, configuring timing adjustment clock\n", __func__);
+
 		if (!dwmac->timing_adj_clk) {
 			dev_err(dwmac->dev,
 				"The timing-adjustment clock is mandatory for the RX delay re-timing\n");
@@ -336,6 +363,9 @@ static int meson8b_init_rgmii_delays(struct meson8b_dwmac *dwmac)
 		}
 	}
 
+	if(delay_config & PRG_ETH0_TXDLY_MASK)
+		dev_info(dwmac->dev, "DEVMFC: %s, enabling mac side TX clock delay: %d\n", __func__, dwmac->tx_delay_ns);
+
 	meson8b_dwmac_mask_bits(dwmac, PRG_ETH0, PRG_ETH0_TXDLY_MASK |
 				PRG_ETH0_ADJ_ENABLE | PRG_ETH0_ADJ_SETUP |
 				PRG_ETH0_ADJ_DELAY | PRG_ETH0_ADJ_SKEW,
@@ -389,6 +419,25 @@ static int meson8b_init_prg_eth(struct meson8b_dwmac *dwmac)
 	return 0;
 }
 
+int cmdline_mc_val = -1;
+module_param_named(mc_val, cmdline_mc_val, int, 0); // 0 is permission? dwmac-meson8b.mc_val=0x1621
+MODULE_PARM_DESC(mc_val, "Kernel commandline mc_val. Is override value for the complete (u32|0xffff_ffff) ETH_REG0 register");
+
+int cmdline_cali_val = -1;
+module_param_named(cali_val, cmdline_cali_val, int, 0); // 0 is permission? dwmac-meson8b.cali_val = 0x40000
+MODULE_PARM_DESC(cali_val, "Kernel commandline cali_val. Is override value for the complete (u32|0xffff_ffff) ETH_REG1 register");
+
+static void debug_show_regs(struct meson8b_dwmac* dwmac, char* state_name)
+{
+	u32 tmp_val;
+	
+	tmp_val = readl(dwmac->regs + PRG_ETH0);
+	dev_info(dwmac->dev, "DEVMFC:  %s eth reg0 value: 0x%08X\n", state_name, tmp_val);
+
+	tmp_val = readl(dwmac->regs + PRG_ETH1);
+	dev_info(dwmac->dev, "DEVMFC:  %s eth reg1 value: 0x%08X\n", state_name, tmp_val);
+}
+
 static int meson8b_dwmac_probe(struct platform_device *pdev)
 {
 	struct plat_stmmacenet_data *plat_dat;
@@ -396,6 +445,8 @@ static int meson8b_dwmac_probe(struct platform_device *pdev)
 	struct meson8b_dwmac *dwmac;
 	int ret;
 
+	//pr_info("DEVMFC: %s\n", __func__);
+	
 	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
 	if (ret)
 		return ret;
@@ -474,8 +525,29 @@ static int meson8b_dwmac_probe(struct platform_device *pdev)
 		return ret;
 
 	plat_dat->bsp_priv = dwmac;
+	
+	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (ret)
+		return ret;
+
+	debug_show_regs(dwmac, "after stmmac_dvr_probe");
+	
+	/* DEVMMFC: debug */
+	if (cmdline_mc_val > -1) {
+		dev_info(dwmac->dev, "DEVMFC: set reg0 value to dwmac-meson8b.mc_val: 0x%08X\n", cmdline_mc_val);
+		writel(cmdline_mc_val, dwmac->regs + PRG_ETH0);
+	}
+		
+	if (cmdline_cali_val > -1) {
+		dev_info(dwmac->dev, "DEVMFC: set reg1 value to dwmac-meson8b.cali_val: 0x%08X\n", cmdline_cali_val);
+		writel(cmdline_cali_val, dwmac->regs + PRG_ETH1);
+	}
+	
+	debug_show_regs(dwmac, "resulting");
+	/* end debug */
 
-	return stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	return 0;
+	
 }
 
 static const struct meson8b_dwmac_data meson8b_dwmac_data = {
-- 
2.46.0

