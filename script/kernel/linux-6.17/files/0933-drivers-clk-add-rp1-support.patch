diff --speed-large-files --no-dereference --minimal -Naur linux-6.17-rc4/drivers/clk/bcm/clk-raspberrypi.c linux-6.17-rc4/drivers/clk/bcm/clk-raspberrypi.c
--- linux-6.17-rc4/drivers/clk/bcm/clk-raspberrypi.c	2025-09-01 00:33:07.000000000 +0200
+++ linux-6.17-rc4/drivers/clk/bcm/clk-raspberrypi.c	2025-09-04 17:07:14.814475315 +0200
@@ -173,6 +173,7 @@
 	struct raspberrypi_firmware_prop msg = {
 		.id = cpu_to_le32(data->id),
 		.val = cpu_to_le32(*val),
+		.disable_turbo = cpu_to_le32(0),
 	};
 	int ret;
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.17-rc4/drivers/clk/clk-rp1.c linux-6.17-rc4/drivers/clk/clk-rp1.c
--- linux-6.17-rc4/drivers/clk/clk-rp1.c	2025-09-01 00:33:07.000000000 +0200
+++ linux-6.17-rc4/drivers/clk/clk-rp1.c	2025-08-30 17:08:08.637806180 +0200
@@ -1,203 +1,176 @@
-// SPDX-License-Identifier: GPL-2.0
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2023 Raspberry Pi Ltd.
  *
  * Clock driver for RP1 PCIe multifunction chip.
  */
 
-#include <linux/bitfield.h>
 #include <linux/clk-provider.h>
-#include <linux/regmap.h>
+#include <linux/clkdev.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/io.h>
 #include <linux/math64.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
-#include <linux/units.h>
+#include <linux/rp1_platform.h>
+#include <linux/slab.h>
 
-#include <dt-bindings/clock/raspberrypi,rp1-clocks.h>
+#include <asm/div64.h>
 
-#define PLL_SYS_OFFSET			0x08000
-#define PLL_SYS_CS			(PLL_SYS_OFFSET + 0x00)
-#define PLL_SYS_PWR			(PLL_SYS_OFFSET + 0x04)
-#define PLL_SYS_FBDIV_INT		(PLL_SYS_OFFSET + 0x08)
-#define PLL_SYS_FBDIV_FRAC		(PLL_SYS_OFFSET + 0x0c)
-#define PLL_SYS_PRIM			(PLL_SYS_OFFSET + 0x10)
-#define PLL_SYS_SEC			(PLL_SYS_OFFSET + 0x14)
+#include <dt-bindings/clock/rp1.h>
 
-#define PLL_AUDIO_OFFSET		0x0c000
-#define PLL_AUDIO_CS			(PLL_AUDIO_OFFSET + 0x00)
-#define PLL_AUDIO_PWR			(PLL_AUDIO_OFFSET + 0x04)
-#define PLL_AUDIO_FBDIV_INT		(PLL_AUDIO_OFFSET + 0x08)
-#define PLL_AUDIO_FBDIV_FRAC		(PLL_AUDIO_OFFSET + 0x0c)
-#define PLL_AUDIO_PRIM			(PLL_AUDIO_OFFSET + 0x10)
-#define PLL_AUDIO_SEC			(PLL_AUDIO_OFFSET + 0x14)
-#define PLL_AUDIO_TERN			(PLL_AUDIO_OFFSET + 0x18)
+#define PLL_SYS_CS			0x08000
+#define PLL_SYS_PWR			0x08004
+#define PLL_SYS_FBDIV_INT		0x08008
+#define PLL_SYS_FBDIV_FRAC		0x0800c
+#define PLL_SYS_PRIM			0x08010
+#define PLL_SYS_SEC			0x08014
 
-#define PLL_VIDEO_OFFSET		0x10000
-#define PLL_VIDEO_CS			(PLL_VIDEO_OFFSET + 0x00)
-#define PLL_VIDEO_PWR			(PLL_VIDEO_OFFSET + 0x04)
-#define PLL_VIDEO_FBDIV_INT		(PLL_VIDEO_OFFSET + 0x08)
-#define PLL_VIDEO_FBDIV_FRAC		(PLL_VIDEO_OFFSET + 0x0c)
-#define PLL_VIDEO_PRIM			(PLL_VIDEO_OFFSET + 0x10)
-#define PLL_VIDEO_SEC			(PLL_VIDEO_OFFSET + 0x14)
+#define PLL_AUDIO_CS			0x0c000
+#define PLL_AUDIO_PWR			0x0c004
+#define PLL_AUDIO_FBDIV_INT		0x0c008
+#define PLL_AUDIO_FBDIV_FRAC		0x0c00c
+#define PLL_AUDIO_PRIM			0x0c010
+#define PLL_AUDIO_SEC			0x0c014
 
-#define GPCLK_OE_CTRL			0x00000
+#define PLL_VIDEO_CS			0x10000
+#define PLL_VIDEO_PWR			0x10004
+#define PLL_VIDEO_FBDIV_INT		0x10008
+#define PLL_VIDEO_FBDIV_FRAC		0x1000c
+#define PLL_VIDEO_PRIM			0x10010
+#define PLL_VIDEO_SEC			0x10014
 
-#define CLK_SYS_OFFSET			0x00014
-#define CLK_SYS_CTRL			(CLK_SYS_OFFSET + 0x00)
-#define CLK_SYS_DIV_INT			(CLK_SYS_OFFSET + 0x04)
-#define CLK_SYS_SEL			(CLK_SYS_OFFSET + 0x0c)
+#define CLK_SYS_CTRL			0x00014
+#define CLK_SYS_DIV_INT			0x00018
+#define CLK_SYS_SEL			0x00020
 
-#define CLK_SLOW_OFFSET			0x00024
-#define CLK_SLOW_SYS_CTRL		(CLK_SLOW_OFFSET + 0x00)
-#define CLK_SLOW_SYS_DIV_INT		(CLK_SLOW_OFFSET + 0x04)
-#define CLK_SLOW_SYS_SEL		(CLK_SLOW_OFFSET + 0x0c)
+#define CLK_SLOW_SYS_CTRL		0x00024
+#define CLK_SLOW_SYS_DIV_INT		0x00028
+#define CLK_SLOW_SYS_SEL		0x00030
 
-#define CLK_DMA_OFFSET			0x00044
-#define CLK_DMA_CTRL			(CLK_DMA_OFFSET + 0x00)
-#define CLK_DMA_DIV_INT			(CLK_DMA_OFFSET + 0x04)
-#define CLK_DMA_SEL			(CLK_DMA_OFFSET + 0x0c)
+#define CLK_DMA_CTRL			0x00044
+#define CLK_DMA_DIV_INT			0x00048
+#define CLK_DMA_SEL			0x00050
 
-#define CLK_UART_OFFSET			0x00054
-#define CLK_UART_CTRL			(CLK_UART_OFFSET + 0x00)
-#define CLK_UART_DIV_INT		(CLK_UART_OFFSET + 0x04)
-#define CLK_UART_SEL			(CLK_UART_OFFSET + 0x0c)
+#define CLK_UART_CTRL			0x00054
+#define CLK_UART_DIV_INT		0x00058
+#define CLK_UART_SEL			0x00060
 
-#define CLK_ETH_OFFSET			0x00064
-#define CLK_ETH_CTRL			(CLK_ETH_OFFSET + 0x00)
-#define CLK_ETH_DIV_INT			(CLK_ETH_OFFSET + 0x04)
-#define CLK_ETH_SEL			(CLK_ETH_OFFSET + 0x0c)
+#define CLK_ETH_CTRL			0x00064
+#define CLK_ETH_DIV_INT			0x00068
+#define CLK_ETH_SEL			0x00070
 
-#define CLK_PWM0_OFFSET			0x00074
-#define CLK_PWM0_CTRL			(CLK_PWM0_OFFSET + 0x00)
-#define CLK_PWM0_DIV_INT		(CLK_PWM0_OFFSET + 0x04)
-#define CLK_PWM0_DIV_FRAC		(CLK_PWM0_OFFSET + 0x08)
-#define CLK_PWM0_SEL			(CLK_PWM0_OFFSET + 0x0c)
+#define CLK_PWM0_CTRL			0x00074
+#define CLK_PWM0_DIV_INT		0x00078
+#define CLK_PWM0_DIV_FRAC		0x0007c
+#define CLK_PWM0_SEL			0x00080
 
-#define CLK_PWM1_OFFSET			0x00084
-#define CLK_PWM1_CTRL			(CLK_PWM1_OFFSET + 0x00)
-#define CLK_PWM1_DIV_INT		(CLK_PWM1_OFFSET + 0x04)
-#define CLK_PWM1_DIV_FRAC		(CLK_PWM1_OFFSET + 0x08)
-#define CLK_PWM1_SEL			(CLK_PWM1_OFFSET + 0x0c)
+#define CLK_PWM1_CTRL			0x00084
+#define CLK_PWM1_DIV_INT		0x00088
+#define CLK_PWM1_DIV_FRAC		0x0008c
+#define CLK_PWM1_SEL			0x00090
 
-#define CLK_AUDIO_IN_OFFSET		0x00094
-#define CLK_AUDIO_IN_CTRL		(CLK_AUDIO_IN_OFFSET + 0x00)
-#define CLK_AUDIO_IN_DIV_INT		(CLK_AUDIO_IN_OFFSET + 0x04)
-#define CLK_AUDIO_IN_SEL		(CLK_AUDIO_IN_OFFSET + 0x0c)
+#define CLK_AUDIO_IN_CTRL		0x00094
+#define CLK_AUDIO_IN_DIV_INT		0x00098
+#define CLK_AUDIO_IN_SEL		0x000a0
 
-#define CLK_AUDIO_OUT_OFFSET		0x000a4
-#define CLK_AUDIO_OUT_CTRL		(CLK_AUDIO_OUT_OFFSET + 0x00)
-#define CLK_AUDIO_OUT_DIV_INT		(CLK_AUDIO_OUT_OFFSET + 0x04)
-#define CLK_AUDIO_OUT_SEL		(CLK_AUDIO_OUT_OFFSET + 0x0c)
+#define CLK_AUDIO_OUT_CTRL		0x000a4
+#define CLK_AUDIO_OUT_DIV_INT		0x000a8
+#define CLK_AUDIO_OUT_SEL		0x000b0
 
-#define CLK_I2S_OFFSET			0x000b4
-#define CLK_I2S_CTRL			(CLK_I2S_OFFSET + 0x00)
-#define CLK_I2S_DIV_INT			(CLK_I2S_OFFSET + 0x04)
-#define CLK_I2S_SEL			(CLK_I2S_OFFSET + 0x0c)
+#define CLK_I2S_CTRL			0x000b4
+#define CLK_I2S_DIV_INT			0x000b8
+#define CLK_I2S_SEL			0x000c0
 
-#define CLK_MIPI0_CFG_OFFSET		0x000c4
-#define CLK_MIPI0_CFG_CTRL		(CLK_MIPI0_CFG_OFFSET + 0x00)
-#define CLK_MIPI0_CFG_DIV_INT		(CLK_MIPI0_CFG_OFFSET + 0x04)
-#define CLK_MIPI0_CFG_SEL		(CLK_MIPI0_CFG_OFFSET + 0x0c)
+#define CLK_MIPI0_CFG_CTRL		0x000c4
+#define CLK_MIPI0_CFG_DIV_INT		0x000c8
+#define CLK_MIPI0_CFG_SEL		0x000d0
 
-#define CLK_MIPI1_CFG_OFFSET		0x000d4
-#define CLK_MIPI1_CFG_CTRL		(CLK_MIPI1_CFG_OFFSET + 0x00)
-#define CLK_MIPI1_CFG_DIV_INT		(CLK_MIPI1_CFG_OFFSET + 0x04)
-#define CLK_MIPI1_CFG_SEL		(CLK_MIPI1_CFG_OFFSET + 0x0c)
+#define CLK_MIPI1_CFG_CTRL		0x000d4
+#define CLK_MIPI1_CFG_DIV_INT		0x000d8
+#define CLK_MIPI1_CFG_SEL		0x000e0
 
-#define CLK_PCIE_AUX_OFFSET		0x000e4
-#define CLK_PCIE_AUX_CTRL		(CLK_PCIE_AUX_OFFSET + 0x00)
-#define CLK_PCIE_AUX_DIV_INT		(CLK_PCIE_AUX_OFFSET + 0x04)
-#define CLK_PCIE_AUX_SEL		(CLK_PCIE_AUX_OFFSET + 0x0c)
+#define CLK_PCIE_AUX_CTRL		0x000e4
+#define CLK_PCIE_AUX_DIV_INT		0x000e8
+#define CLK_PCIE_AUX_SEL		0x000f0
 
-#define CLK_USBH0_MICROFRAME_OFFSET	0x000f4
-#define CLK_USBH0_MICROFRAME_CTRL	(CLK_USBH0_MICROFRAME_OFFSET + 0x00)
-#define CLK_USBH0_MICROFRAME_DIV_INT	(CLK_USBH0_MICROFRAME_OFFSET + 0x04)
-#define CLK_USBH0_MICROFRAME_SEL	(CLK_USBH0_MICROFRAME_OFFSET + 0x0c)
+#define CLK_USBH0_MICROFRAME_CTRL	0x000f4
+#define CLK_USBH0_MICROFRAME_DIV_INT	0x000f8
+#define CLK_USBH0_MICROFRAME_SEL	0x00100
 
-#define CLK_USBH1_MICROFRAME_OFFSET	0x00104
-#define CLK_USBH1_MICROFRAME_CTRL	(CLK_USBH1_MICROFRAME_OFFSET + 0x00)
-#define CLK_USBH1_MICROFRAME_DIV_INT	(CLK_USBH1_MICROFRAME_OFFSET + 0x04)
-#define CLK_USBH1_MICROFRAME_SEL	(CLK_USBH1_MICROFRAME_OFFSET + 0x0c)
+#define CLK_USBH1_MICROFRAME_CTRL	0x00104
+#define CLK_USBH1_MICROFRAME_DIV_INT	0x00108
+#define CLK_USBH1_MICROFRAME_SEL	0x00110
 
-#define CLK_USBH0_SUSPEND_OFFSET	0x00114
-#define CLK_USBH0_SUSPEND_CTRL		(CLK_USBH0_SUSPEND_OFFSET + 0x00)
-#define CLK_USBH0_SUSPEND_DIV_INT	(CLK_USBH0_SUSPEND_OFFSET + 0x04)
-#define CLK_USBH0_SUSPEND_SEL		(CLK_USBH0_SUSPEND_OFFSET + 0x0c)
+#define CLK_USBH0_SUSPEND_CTRL		0x00114
+#define CLK_USBH0_SUSPEND_DIV_INT	0x00118
+#define CLK_USBH0_SUSPEND_SEL		0x00120
 
-#define CLK_USBH1_SUSPEND_OFFSET	0x00124
-#define CLK_USBH1_SUSPEND_CTRL		(CLK_USBH1_SUSPEND_OFFSET + 0x00)
-#define CLK_USBH1_SUSPEND_DIV_INT	(CLK_USBH1_SUSPEND_OFFSET + 0x04)
-#define CLK_USBH1_SUSPEND_SEL		(CLK_USBH1_SUSPEND_OFFSET + 0x0c)
+#define CLK_USBH1_SUSPEND_CTRL		0x00124
+#define CLK_USBH1_SUSPEND_DIV_INT	0x00128
+#define CLK_USBH1_SUSPEND_SEL		0x00130
 
-#define CLK_ETH_TSU_OFFSET		0x00134
-#define CLK_ETH_TSU_CTRL		(CLK_ETH_TSU_OFFSET + 0x00)
-#define CLK_ETH_TSU_DIV_INT		(CLK_ETH_TSU_OFFSET + 0x04)
-#define CLK_ETH_TSU_SEL			(CLK_ETH_TSU_OFFSET + 0x0c)
+#define CLK_ETH_TSU_CTRL		0x00134
+#define CLK_ETH_TSU_DIV_INT		0x00138
+#define CLK_ETH_TSU_SEL			0x00140
 
-#define CLK_ADC_OFFSET			0x00144
-#define CLK_ADC_CTRL			(CLK_ADC_OFFSET + 0x00)
-#define CLK_ADC_DIV_INT			(CLK_ADC_OFFSET + 0x04)
-#define CLK_ADC_SEL			(CLK_ADC_OFFSET + 0x0c)
+#define CLK_ADC_CTRL			0x00144
+#define CLK_ADC_DIV_INT			0x00148
+#define CLK_ADC_SEL			0x00150
 
-#define CLK_SDIO_TIMER_OFFSET		0x00154
-#define CLK_SDIO_TIMER_CTRL		(CLK_SDIO_TIMER_OFFSET + 0x00)
-#define CLK_SDIO_TIMER_DIV_INT		(CLK_SDIO_TIMER_OFFSET + 0x04)
-#define CLK_SDIO_TIMER_SEL		(CLK_SDIO_TIMER_OFFSET + 0x0c)
+#define CLK_SDIO_TIMER_CTRL		0x00154
+#define CLK_SDIO_TIMER_DIV_INT		0x00158
+#define CLK_SDIO_TIMER_SEL		0x00160
 
-#define CLK_SDIO_ALT_SRC_OFFSET		0x00164
-#define CLK_SDIO_ALT_SRC_CTRL		(CLK_SDIO_ALT_SRC_OFFSET + 0x00)
-#define CLK_SDIO_ALT_SRC_DIV_INT	(CLK_SDIO_ALT_SRC_OFFSET + 0x04)
-#define CLK_SDIO_ALT_SRC_SEL		(CLK_SDIO_ALT_SRC_OFFSET + 0x0c)
+#define CLK_SDIO_ALT_SRC_CTRL		0x00164
+#define CLK_SDIO_ALT_SRC_DIV_INT	0x00168
+#define CLK_SDIO_ALT_SRC_SEL		0x00170
 
-#define CLK_GP0_OFFSET			0x00174
-#define CLK_GP0_CTRL			(CLK_GP0_OFFSET + 0x00)
-#define CLK_GP0_DIV_INT			(CLK_GP0_OFFSET + 0x04)
-#define CLK_GP0_DIV_FRAC		(CLK_GP0_OFFSET + 0x08)
-#define CLK_GP0_SEL			(CLK_GP0_OFFSET + 0x0c)
+#define CLK_GP0_CTRL			0x00174
+#define CLK_GP0_DIV_INT			0x00178
+#define CLK_GP0_DIV_FRAC		0x0017c
+#define CLK_GP0_SEL			0x00180
 
-#define CLK_GP1_OFFSET			0x00184
-#define CLK_GP1_CTRL			(CLK_GP1_OFFSET + 0x00)
-#define CLK_GP1_DIV_INT			(CLK_GP1_OFFSET + 0x04)
-#define CLK_GP1_DIV_FRAC		(CLK_GP1_OFFSET + 0x08)
-#define CLK_GP1_SEL			(CLK_GP1_OFFSET + 0x0c)
+#define CLK_GP1_CTRL			0x00184
+#define CLK_GP1_DIV_INT			0x00188
+#define CLK_GP1_DIV_FRAC		0x0018c
+#define CLK_GP1_SEL			0x00190
 
-#define CLK_GP2_OFFSET			0x00194
-#define CLK_GP2_CTRL			(CLK_GP2_OFFSET + 0x00)
-#define CLK_GP2_DIV_INT			(CLK_GP2_OFFSET + 0x04)
-#define CLK_GP2_DIV_FRAC		(CLK_GP2_OFFSET + 0x08)
-#define CLK_GP2_SEL			(CLK_GP2_OFFSET + 0x0c)
+#define CLK_GP2_CTRL			0x00194
+#define CLK_GP2_DIV_INT			0x00198
+#define CLK_GP2_DIV_FRAC		0x0019c
+#define CLK_GP2_SEL			0x001a0
 
-#define CLK_GP3_OFFSET			0x001a4
-#define CLK_GP3_CTRL			(CLK_GP3_OFFSET + 0x00)
-#define CLK_GP3_DIV_INT			(CLK_GP3_OFFSET + 0x04)
-#define CLK_GP3_DIV_FRAC		(CLK_GP3_OFFSET + 0x08)
-#define CLK_GP3_SEL			(CLK_GP3_OFFSET + 0x0c)
+#define CLK_GP3_CTRL			0x001a4
+#define CLK_GP3_DIV_INT			0x001a8
+#define CLK_GP3_DIV_FRAC		0x001ac
+#define CLK_GP3_SEL			0x001b0
 
-#define CLK_GP4_OFFSET			0x001b4
-#define CLK_GP4_CTRL			(CLK_GP4_OFFSET + 0x00)
-#define CLK_GP4_DIV_INT			(CLK_GP4_OFFSET + 0x04)
-#define CLK_GP4_DIV_FRAC		(CLK_GP4_OFFSET + 0x08)
-#define CLK_GP4_SEL			(CLK_GP4_OFFSET + 0x0c)
+#define CLK_GP4_CTRL			0x001b4
+#define CLK_GP4_DIV_INT			0x001b8
+#define CLK_GP4_DIV_FRAC		0x001bc
+#define CLK_GP4_SEL			0x001c0
 
-#define CLK_GP5_OFFSET			0x001c4
-#define CLK_GP5_CTRL			(CLK_GP5_OFFSET + 0x00)
-#define CLK_GP5_DIV_INT			(CLK_GP5_OFFSET + 0x04)
-#define CLK_GP5_DIV_FRAC		(CLK_GP5_OFFSET + 0x08)
-#define CLK_GP5_SEL			(CLK_GP5_OFFSET + 0x0c)
+#define CLK_GP5_CTRL			0x001c4
+#define CLK_GP5_DIV_INT			0x001c8
+#define CLK_GP5_DIV_FRAC		0x001cc
+#define CLK_GP5_SEL			0x001d0
 
 #define CLK_SYS_RESUS_CTRL		0x0020c
 
 #define CLK_SLOW_SYS_RESUS_CTRL		0x00214
 
-#define FC0_OFFSET			0x0021c
-#define FC0_REF_KHZ			(FC0_OFFSET + 0x00)
-#define FC0_MIN_KHZ			(FC0_OFFSET + 0x04)
-#define FC0_MAX_KHZ			(FC0_OFFSET + 0x08)
-#define FC0_DELAY			(FC0_OFFSET + 0x0c)
-#define FC0_INTERVAL			(FC0_OFFSET + 0x10)
-#define FC0_SRC				(FC0_OFFSET + 0x14)
-#define FC0_STATUS			(FC0_OFFSET + 0x18)
-#define FC0_RESULT			(FC0_OFFSET + 0x1c)
+#define FC0_REF_KHZ			0x0021c
+#define FC0_MIN_KHZ			0x00220
+#define FC0_MAX_KHZ			0x00224
+#define FC0_DELAY			0x00228
+#define FC0_INTERVAL			0x0022c
+#define FC0_SRC				0x00230
+#define FC0_STATUS			0x00234
+#define FC0_RESULT			0x00238
 #define FC_SIZE				0x20
 #define FC_COUNT			8
 #define FC_NUM(idx, off)		((idx) * 32 + (off))
@@ -220,21 +193,25 @@
 #define VIDEO_CLK_MIPI1_DPI_DIV_FRAC	(VIDEO_CLOCKS_OFFSET + 0x0038)
 #define VIDEO_CLK_MIPI1_DPI_SEL		(VIDEO_CLOCKS_OFFSET + 0x003c)
 
-#define DIV_INT_8BIT_MAX		GENMASK(7, 0)	/* max divide for most clocks */
-#define DIV_INT_16BIT_MAX		GENMASK(15, 0)	/* max divide for GPx, PWM */
-#define DIV_INT_24BIT_MAX               GENMASK(23, 0)	/* max divide for CLK_SYS */
+#define DIV_INT_8BIT_MAX		0x000000ffu /* max divide for most clocks */
+#define DIV_INT_16BIT_MAX		0x0000ffffu /* max divide for GPx, PWM */
+#define DIV_INT_24BIT_MAX               0x00ffffffu /* max divide for CLK_SYS */
 
 #define FC0_STATUS_DONE			BIT(4)
 #define FC0_STATUS_RUNNING		BIT(8)
 #define FC0_RESULT_FRAC_SHIFT		5
 
-#define PLL_PRIM_DIV1_MASK		GENMASK(18, 16)
-#define PLL_PRIM_DIV2_MASK		GENMASK(14, 12)
+#define PLL_PRIM_DIV1_SHIFT		16
+#define PLL_PRIM_DIV1_MASK		0x00070000
+#define PLL_PRIM_DIV2_SHIFT		12
+#define PLL_PRIM_DIV2_MASK		0x00007000
 
-#define PLL_SEC_DIV_MASK		GENMASK(12, 8)
+#define PLL_SEC_DIV_SHIFT		8
+#define PLL_SEC_DIV_WIDTH		5
+#define PLL_SEC_DIV_MASK		0x00001f00
 
 #define PLL_CS_LOCK			BIT(31)
-#define PLL_CS_REFDIV_MASK		BIT(1)
+#define PLL_CS_REFDIV_SHIFT		0
 
 #define PLL_PWR_PD			BIT(0)
 #define PLL_PWR_DACPD			BIT(1)
@@ -242,7 +219,7 @@
 #define PLL_PWR_POSTDIVPD		BIT(3)
 #define PLL_PWR_4PHASEPD		BIT(4)
 #define PLL_PWR_VCOPD			BIT(5)
-#define PLL_PWR_MASK			GENMASK(5, 0)
+#define PLL_PWR_MASK			0x0000003f
 
 #define PLL_SEC_RST			BIT(16)
 #define PLL_SEC_IMPL			BIT(31)
@@ -258,30 +235,44 @@
 
 /* Clock fields for all clocks */
 #define CLK_CTRL_ENABLE			BIT(11)
-#define CLK_CTRL_AUXSRC_MASK		GENMASK(9, 5)
+#define CLK_CTRL_AUXSRC_MASK		0x000003e0
+#define CLK_CTRL_AUXSRC_SHIFT		5
 #define CLK_CTRL_SRC_SHIFT		0
 #define CLK_DIV_FRAC_BITS		16
 
-#define LOCK_TIMEOUT_US			100000
-#define LOCK_POLL_DELAY_US		5
+#define KHz				1000
+#define MHz				(KHz * KHz)
+#define LOCK_TIMEOUT_NS			100000000
+#define FC_TIMEOUT_NS			100000000
 
-#define MAX_CLK_PARENTS			16
+#define MAX_CLK_PARENTS	8
+
+#define MEASURE_CLOCK_RATE
+const char * const fc0_ref_clk_name = "clk_slow_sys";
+
+#define ABS_DIFF(a, b) ((a) > (b) ? (a) - (b) : (b) - (a))
+#define DIV_U64_NEAREST(a, b) div_u64(((a) + ((b) >> 1)), (b))
+
+/*
+ * Names of the reference clock for the pll cores.  This name must match
+ * the DT reference clock-output-name.
+ */
+static const char *const ref_clock = "xosc";
 
-#define PLL_DIV_INVALID			19
 /*
  * Secondary PLL channel output divider table.
- * Divider values range from 8 to 19, where
- * 19 means invalid.
+ * Divider values range from 8 to 19.
+ * Invalid values default to 19
  */
 static const struct clk_div_table pll_sec_div_table[] = {
-	{ 0x00, PLL_DIV_INVALID },
-	{ 0x01, PLL_DIV_INVALID },
-	{ 0x02, PLL_DIV_INVALID },
-	{ 0x03, PLL_DIV_INVALID },
-	{ 0x04, PLL_DIV_INVALID },
-	{ 0x05, PLL_DIV_INVALID },
-	{ 0x06, PLL_DIV_INVALID },
-	{ 0x07, PLL_DIV_INVALID },
+	{ 0x00, 19 },
+	{ 0x01, 19 },
+	{ 0x02, 19 },
+	{ 0x03, 19 },
+	{ 0x04, 19 },
+	{ 0x05, 19 },
+	{ 0x06, 19 },
+	{ 0x07, 19 },
 	{ 0x08,  8 },
 	{ 0x09,  9 },
 	{ 0x0a, 10 },
@@ -293,26 +284,25 @@
 	{ 0x10, 16 },
 	{ 0x11, 17 },
 	{ 0x12, 18 },
-	{ 0x13, PLL_DIV_INVALID },
-	{ 0x14, PLL_DIV_INVALID },
-	{ 0x15, PLL_DIV_INVALID },
-	{ 0x16, PLL_DIV_INVALID },
-	{ 0x17, PLL_DIV_INVALID },
-	{ 0x18, PLL_DIV_INVALID },
-	{ 0x19, PLL_DIV_INVALID },
-	{ 0x1a, PLL_DIV_INVALID },
-	{ 0x1b, PLL_DIV_INVALID },
-	{ 0x1c, PLL_DIV_INVALID },
-	{ 0x1d, PLL_DIV_INVALID },
-	{ 0x1e, PLL_DIV_INVALID },
-	{ 0x1f, PLL_DIV_INVALID },
+	{ 0x13, 19 },
+	{ 0x14, 19 },
+	{ 0x15, 19 },
+	{ 0x16, 19 },
+	{ 0x17, 19 },
+	{ 0x18, 19 },
+	{ 0x19, 19 },
+	{ 0x1a, 19 },
+	{ 0x1b, 19 },
+	{ 0x1c, 19 },
+	{ 0x1d, 19 },
+	{ 0x1e, 19 },
+	{ 0x1f, 19 },
 	{ 0 }
 };
 
 struct rp1_clockman {
 	struct device *dev;
 	void __iomem *regs;
-	struct regmap *regmap;
 	spinlock_t regs_lock; /* spinlock for all clocks */
 
 	/* Must be last */
@@ -320,72 +310,184 @@
 };
 
 struct rp1_pll_core_data {
+	const char *name;
 	u32 cs_reg;
 	u32 pwr_reg;
 	u32 fbdiv_int_reg;
 	u32 fbdiv_frac_reg;
+	unsigned long flags;
 	u32 fc0_src;
 };
 
 struct rp1_pll_data {
+	const char *name;
+	const char *source_pll;
 	u32 ctrl_reg;
+	unsigned long flags;
 	u32 fc0_src;
 };
 
 struct rp1_pll_ph_data {
+	const char *name;
+	const char *source_pll;
 	unsigned int phase;
 	unsigned int fixed_divider;
 	u32 ph_reg;
+	unsigned long flags;
 	u32 fc0_src;
 };
 
 struct rp1_pll_divider_data {
+	const char *name;
+	const char *source_pll;
 	u32 sec_reg;
+	unsigned long flags;
 	u32 fc0_src;
 };
 
 struct rp1_clock_data {
+	const char *name;
+	const char *const parents[MAX_CLK_PARENTS];
 	int num_std_parents;
 	int num_aux_parents;
-	u32 oe_mask;
+	unsigned long flags;
 	u32 clk_src_mask;
 	u32 ctrl_reg;
 	u32 div_int_reg;
 	u32 div_frac_reg;
 	u32 sel_reg;
 	u32 div_int_max;
-	unsigned long max_freq;
 	u32 fc0_src;
 };
 
-struct rp1_clk_desc {
-	struct clk_hw *(*clk_register)(struct rp1_clockman *clockman,
-				       struct rp1_clk_desc *desc);
-	const void *data;
+struct rp1_pll_core {
 	struct clk_hw hw;
 	struct rp1_clockman *clockman;
+	const struct rp1_pll_core_data *data;
 	unsigned long cached_rate;
+};
+
+struct rp1_pll {
+	struct clk_hw hw;
 	struct clk_divider div;
+	struct rp1_clockman *clockman;
+	const struct rp1_pll_data *data;
+	unsigned long cached_rate;
+};
+
+struct rp1_pll_ph {
+	struct clk_hw hw;
+	struct rp1_clockman *clockman;
+	const struct rp1_pll_ph_data *data;
+};
+
+struct rp1_clock {
+	struct clk_hw hw;
+	struct rp1_clockman *clockman;
+	const struct rp1_clock_data *data;
+	unsigned long cached_rate;
 };
 
+static void rp1_debugfs_regset(struct rp1_clockman *clockman, u32 base,
+			       const struct debugfs_reg32 *regs,
+			       size_t nregs, struct dentry *dentry)
+{
+	struct debugfs_regset32 *regset;
+
+	regset = devm_kzalloc(clockman->dev, sizeof(*regset), GFP_KERNEL);
+	if (!regset)
+		return;
+
+	regset->regs = regs;
+	regset->nregs = nregs;
+	regset->base = clockman->regs + base;
+
+	debugfs_create_regset32("regdump", 0444, dentry, regset);
+}
+
+static inline u32 set_register_field(u32 reg, u32 val, u32 mask, u32 shift)
+{
+	reg &= ~mask;
+	reg |= (val << shift) & mask;
+	return reg;
+}
+
 static inline
 void clockman_write(struct rp1_clockman *clockman, u32 reg, u32 val)
 {
-	regmap_write(clockman->regmap, reg, val);
+	writel(val, clockman->regs + reg);
 }
 
 static inline u32 clockman_read(struct rp1_clockman *clockman, u32 reg)
 {
-	u32 val;
+	return readl(clockman->regs + reg);
+}
 
-	regmap_read(clockman->regmap, reg, &val);
+#ifdef MEASURE_CLOCK_RATE
+static unsigned long clockman_measure_clock(struct rp1_clockman *clockman,
+					    const char *clk_name,
+					    unsigned int fc0_src)
+{
+	struct clk *ref_clk = __clk_lookup(fc0_ref_clk_name);
+	unsigned long result;
+	ktime_t timeout;
+	unsigned int fc_idx, fc_offset, fc_src;
 
-	return val;
+	fc_idx = fc0_src / 32;
+	fc_src = fc0_src % 32;
+
+	/* fc_src == 0 is invalid. */
+	if (!fc_src || fc_idx >= FC_COUNT)
+		return 0;
+
+	fc_offset = fc_idx * FC_SIZE;
+
+	/* Ensure the frequency counter is idle. */
+	timeout = ktime_add_ns(ktime_get(), FC_TIMEOUT_NS);
+	while (clockman_read(clockman, fc_offset + FC0_STATUS) & FC0_STATUS_RUNNING) {
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_err(clockman->dev, "%s: FC0 busy timeout\n",
+				clk_name);
+			return 0;
+		}
+		cpu_relax();
+	}
+
+	spin_lock(&clockman->regs_lock);
+	clockman_write(clockman, fc_offset + FC0_REF_KHZ,
+		       clk_get_rate(ref_clk) / KHz);
+	clockman_write(clockman, fc_offset + FC0_MIN_KHZ, 0);
+	clockman_write(clockman, fc_offset + FC0_MAX_KHZ, 0x1ffffff);
+	clockman_write(clockman, fc_offset + FC0_INTERVAL, 8);
+	clockman_write(clockman, fc_offset + FC0_DELAY, 7);
+	clockman_write(clockman, fc_offset + FC0_SRC, fc_src);
+	spin_unlock(&clockman->regs_lock);
+
+	/* Ensure the frequency counter is idle. */
+	timeout = ktime_add_ns(ktime_get(), FC_TIMEOUT_NS);
+	while (!(clockman_read(clockman, fc_offset + FC0_STATUS) & FC0_STATUS_DONE)) {
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_err(clockman->dev, "%s: FC0 wait timeout\n",
+				clk_name);
+			return 0;
+		}
+		cpu_relax();
+	}
+
+	result = clockman_read(clockman, fc_offset + FC0_RESULT);
+
+	/* Disable FC0 */
+	spin_lock(&clockman->regs_lock);
+	clockman_write(clockman, fc_offset + FC0_SRC, 0);
+	spin_unlock(&clockman->regs_lock);
+
+	return result;
 }
+#endif
 
 static int rp1_pll_core_is_on(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *pll_core = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
 	struct rp1_clockman *clockman = pll_core->clockman;
 	const struct rp1_pll_core_data *data = pll_core->data;
 	u32 pwr = clockman_read(clockman, data->pwr_reg);
@@ -395,11 +497,11 @@
 
 static int rp1_pll_core_on(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *pll_core = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
 	struct rp1_clockman *clockman = pll_core->clockman;
 	const struct rp1_pll_core_data *data = pll_core->data;
-	u32 fbdiv_frac, val;
-	int ret;
+	u32 fbdiv_frac;
+	ktime_t timeout;
 
 	spin_lock(&clockman->regs_lock);
 
@@ -408,7 +510,7 @@
 		clockman_write(clockman, data->pwr_reg, PLL_PWR_MASK);
 		clockman_write(clockman, data->fbdiv_int_reg, 20);
 		clockman_write(clockman, data->fbdiv_frac_reg, 0);
-		clockman_write(clockman, data->cs_reg, PLL_CS_REFDIV_MASK);
+		clockman_write(clockman, data->cs_reg, 1 << PLL_CS_REFDIV_SHIFT);
 	}
 
 	/* Come out of reset. */
@@ -417,19 +519,22 @@
 	spin_unlock(&clockman->regs_lock);
 
 	/* Wait for the PLL to lock. */
-	ret = regmap_read_poll_timeout(clockman->regmap, data->cs_reg, val,
-				       val & PLL_CS_LOCK,
-				       LOCK_POLL_DELAY_US, LOCK_TIMEOUT_US);
-	if (ret)
-		dev_err(clockman->dev, "%s: can't lock PLL\n",
-			clk_hw_get_name(hw));
+	timeout = ktime_add_ns(ktime_get(), LOCK_TIMEOUT_NS);
+	while (!(clockman_read(clockman, data->cs_reg) & PLL_CS_LOCK)) {
+		if (ktime_after(ktime_get(), timeout)) {
+			dev_err(clockman->dev, "%s: can't lock PLL\n",
+				clk_hw_get_name(hw));
+			return -ETIMEDOUT;
+		}
+		cpu_relax();
+	}
 
-	return ret;
+	return 0;
 }
 
 static void rp1_pll_core_off(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *pll_core = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
 	struct rp1_clockman *clockman = pll_core->clockman;
 	const struct rp1_pll_core_data *data = pll_core->data;
 
@@ -443,14 +548,13 @@
 						 unsigned long parent_rate,
 						 u32 *div_int, u32 *div_frac)
 {
-	u32 fbdiv_int, fbdiv_frac;
 	unsigned long calc_rate;
-	u64 shifted_fbdiv_int;
+	u32 fbdiv_int, fbdiv_frac;
 	u64 div_fp64; /* 32.32 fixed point fraction. */
 
 	/* Factor of reference clock to VCO frequency. */
 	div_fp64 = (u64)(rate) << 32;
-	div_fp64 = DIV_ROUND_CLOSEST_ULL(div_fp64, parent_rate);
+	div_fp64 = DIV_U64_NEAREST(div_fp64, parent_rate);
 
 	/* Round the fractional component at 24 bits. */
 	div_fp64 += 1 << (32 - 24 - 1);
@@ -458,10 +562,8 @@
 	fbdiv_int = div_fp64 >> 32;
 	fbdiv_frac = (div_fp64 >> (32 - 24)) & 0xffffff;
 
-	shifted_fbdiv_int = (u64)fbdiv_int << 24;
-	calc_rate = (u64)parent_rate * (shifted_fbdiv_int + fbdiv_frac);
-	calc_rate += BIT(23);
-	calc_rate >>= 24;
+	calc_rate =
+		((u64)parent_rate * (((u64)fbdiv_int << 24) + fbdiv_frac) + (1 << 23)) >> 24;
 
 	*div_int = fbdiv_int;
 	*div_frac = fbdiv_frac;
@@ -472,12 +574,15 @@
 static int rp1_pll_core_set_rate(struct clk_hw *hw,
 				 unsigned long rate, unsigned long parent_rate)
 {
-	struct rp1_clk_desc *pll_core = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
 	struct rp1_clockman *clockman = pll_core->clockman;
 	const struct rp1_pll_core_data *data = pll_core->data;
 	unsigned long calc_rate;
 	u32 fbdiv_int, fbdiv_frac;
 
+	// todo: is this needed??
+	//rp1_pll_off(hw);
+
 	/* Disable dividers to start with. */
 	spin_lock(&clockman->regs_lock);
 	clockman_write(clockman, data->fbdiv_int_reg, 0);
@@ -494,8 +599,7 @@
 	spin_unlock(&clockman->regs_lock);
 
 	/* Check that reference frequency is no greater than VCO / 16. */
-	if (WARN_ON_ONCE(parent_rate > (rate / 16)))
-		return -ERANGE;
+	BUG_ON(parent_rate > (rate / 16));
 
 	pll_core->cached_rate = calc_rate;
 
@@ -503,7 +607,7 @@
 	/* Don't need to divide ref unless parent_rate > (output freq / 16) */
 	clockman_write(clockman, data->cs_reg,
 		       clockman_read(clockman, data->cs_reg) |
-				     PLL_CS_REFDIV_MASK);
+				     (1 << PLL_CS_REFDIV_SHIFT));
 	spin_unlock(&clockman->regs_lock);
 
 	return 0;
@@ -512,20 +616,16 @@
 static unsigned long rp1_pll_core_recalc_rate(struct clk_hw *hw,
 					      unsigned long parent_rate)
 {
-	struct rp1_clk_desc *pll_core = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
 	struct rp1_clockman *clockman = pll_core->clockman;
 	const struct rp1_pll_core_data *data = pll_core->data;
 	u32 fbdiv_int, fbdiv_frac;
 	unsigned long calc_rate;
-	u64 shifted_fbdiv_int;
 
 	fbdiv_int = clockman_read(clockman, data->fbdiv_int_reg);
 	fbdiv_frac = clockman_read(clockman, data->fbdiv_frac_reg);
-
-	shifted_fbdiv_int = (u64)fbdiv_int << 24;
-	calc_rate = (u64)parent_rate * (shifted_fbdiv_int + fbdiv_frac);
-	calc_rate += BIT(23);
-	calc_rate >>= 24;
+	calc_rate =
+		((u64)parent_rate * (((u64)fbdiv_int << 24) + fbdiv_frac) + (1 << 23)) >> 24;
 
 	return calc_rate;
 }
@@ -534,9 +634,34 @@
 				    unsigned long *parent_rate)
 {
 	u32 fbdiv_int, fbdiv_frac;
+	long calc_rate;
 
-	return get_pll_core_divider(hw, rate, *parent_rate,
-				    &fbdiv_int, &fbdiv_frac);
+	calc_rate = get_pll_core_divider(hw, rate, *parent_rate,
+					 &fbdiv_int, &fbdiv_frac);
+	return calc_rate;
+}
+
+static void rp1_pll_core_debug_init(struct clk_hw *hw, struct dentry *dentry)
+{
+	struct rp1_pll_core *pll_core = container_of(hw, struct rp1_pll_core, hw);
+	struct rp1_clockman *clockman = pll_core->clockman;
+	const struct rp1_pll_core_data *data = pll_core->data;
+	struct debugfs_reg32 *regs;
+
+	regs = devm_kcalloc(clockman->dev, 4, sizeof(*regs), GFP_KERNEL);
+	if (!regs)
+		return;
+
+	regs[0].name = "cs";
+	regs[0].offset = data->cs_reg;
+	regs[1].name = "pwr";
+	regs[1].offset = data->pwr_reg;
+	regs[2].name = "fbdiv_int";
+	regs[2].offset = data->fbdiv_int_reg;
+	regs[3].name = "fbdiv_frac";
+	regs[3].offset = data->fbdiv_frac_reg;
+
+	rp1_debugfs_regset(clockman, 0, regs, 4, dentry);
 }
 
 static void get_pll_prim_dividers(unsigned long rate, unsigned long parent_rate,
@@ -545,13 +670,13 @@
 	unsigned int div1, div2;
 	unsigned int best_div1 = 7, best_div2 = 7;
 	unsigned long best_rate_diff =
-		abs_diff(DIV_ROUND_CLOSEST(parent_rate, best_div1 * best_div2), rate);
-	unsigned long rate_diff, calc_rate;
+		ABS_DIFF(DIV_ROUND_CLOSEST(parent_rate, best_div1 * best_div2), rate);
+	long rate_diff, calc_rate;
 
 	for (div1 = 1; div1 <= 7; div1++) {
 		for (div2 = 1; div2 <= div1; div2++) {
 			calc_rate = DIV_ROUND_CLOSEST(parent_rate, div1 * div2);
-			rate_diff = abs_diff(calc_rate, rate);
+			rate_diff = ABS_DIFF(calc_rate, rate);
 
 			if (calc_rate == rate) {
 				best_div1 = div1;
@@ -573,41 +698,43 @@
 static int rp1_pll_set_rate(struct clk_hw *hw,
 			    unsigned long rate, unsigned long parent_rate)
 {
-	struct rp1_clk_desc *pll = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll *pll = container_of(hw, struct rp1_pll, hw);
 	struct rp1_clockman *clockman = pll->clockman;
 	const struct rp1_pll_data *data = pll->data;
-
 	u32 prim, prim_div1, prim_div2;
 
 	get_pll_prim_dividers(rate, parent_rate, &prim_div1, &prim_div2);
 
 	spin_lock(&clockman->regs_lock);
 	prim = clockman_read(clockman, data->ctrl_reg);
-	prim &= ~PLL_PRIM_DIV1_MASK;
-	prim |= FIELD_PREP(PLL_PRIM_DIV1_MASK, prim_div1);
-	prim &= ~PLL_PRIM_DIV2_MASK;
-	prim |= FIELD_PREP(PLL_PRIM_DIV2_MASK, prim_div2);
+	prim = set_register_field(prim, prim_div1, PLL_PRIM_DIV1_MASK,
+				  PLL_PRIM_DIV1_SHIFT);
+	prim = set_register_field(prim, prim_div2, PLL_PRIM_DIV2_MASK,
+				  PLL_PRIM_DIV2_SHIFT);
 	clockman_write(clockman, data->ctrl_reg, prim);
 	spin_unlock(&clockman->regs_lock);
 
+#ifdef MEASURE_CLOCK_RATE
+	clockman_measure_clock(clockman, data->name, data->fc0_src);
+#endif
 	return 0;
 }
 
 static unsigned long rp1_pll_recalc_rate(struct clk_hw *hw,
 					 unsigned long parent_rate)
 {
-	struct rp1_clk_desc *pll = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll *pll = container_of(hw, struct rp1_pll, hw);
 	struct rp1_clockman *clockman = pll->clockman;
 	const struct rp1_pll_data *data = pll->data;
 	u32 prim, prim_div1, prim_div2;
 
 	prim = clockman_read(clockman, data->ctrl_reg);
-	prim_div1 = FIELD_GET(PLL_PRIM_DIV1_MASK, prim);
-	prim_div2 = FIELD_GET(PLL_PRIM_DIV2_MASK, prim);
+	prim_div1 = (prim & PLL_PRIM_DIV1_MASK) >> PLL_PRIM_DIV1_SHIFT;
+	prim_div2 = (prim & PLL_PRIM_DIV2_MASK) >> PLL_PRIM_DIV2_SHIFT;
 
 	if (!prim_div1 || !prim_div2) {
 		dev_err(clockman->dev, "%s: (%s) zero divider value\n",
-			__func__, clk_hw_get_name(hw));
+			__func__, data->name);
 		return 0;
 	}
 
@@ -624,22 +751,41 @@
 	return DIV_ROUND_CLOSEST(*parent_rate, div1 * div2);
 }
 
+static void rp1_pll_debug_init(struct clk_hw *hw,
+			       struct dentry *dentry)
+{
+	struct rp1_pll *pll = container_of(hw, struct rp1_pll, hw);
+	struct rp1_clockman *clockman = pll->clockman;
+	const struct rp1_pll_data *data = pll->data;
+	struct debugfs_reg32 *regs;
+
+	regs = devm_kcalloc(clockman->dev, 1, sizeof(*regs), GFP_KERNEL);
+	if (!regs)
+		return;
+
+	regs[0].name = "prim";
+	regs[0].offset = data->ctrl_reg;
+
+	rp1_debugfs_regset(clockman, 0, regs, 1, dentry);
+}
+
 static int rp1_pll_ph_is_on(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *pll_ph = container_of(hw, struct rp1_clk_desc, hw);
-	struct rp1_clockman *clockman = pll_ph->clockman;
-	const struct rp1_pll_ph_data *data = pll_ph->data;
+	struct rp1_pll_ph *pll = container_of(hw, struct rp1_pll_ph, hw);
+	struct rp1_clockman *clockman = pll->clockman;
+	const struct rp1_pll_ph_data *data = pll->data;
 
 	return !!(clockman_read(clockman, data->ph_reg) & PLL_PH_EN);
 }
 
 static int rp1_pll_ph_on(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *pll_ph = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
 	struct rp1_clockman *clockman = pll_ph->clockman;
 	const struct rp1_pll_ph_data *data = pll_ph->data;
 	u32 ph_reg;
 
+	/* todo: ensure pri/sec is enabled! */
 	spin_lock(&clockman->regs_lock);
 	ph_reg = clockman_read(clockman, data->ph_reg);
 	ph_reg |= data->phase << PLL_PH_PHASE_SHIFT;
@@ -647,12 +793,15 @@
 	clockman_write(clockman, data->ph_reg, ph_reg);
 	spin_unlock(&clockman->regs_lock);
 
+#ifdef MEASURE_CLOCK_RATE
+	clockman_measure_clock(clockman, data->name, data->fc0_src);
+#endif
 	return 0;
 }
 
 static void rp1_pll_ph_off(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *pll_ph = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
 	struct rp1_clockman *clockman = pll_ph->clockman;
 	const struct rp1_pll_ph_data *data = pll_ph->data;
 
@@ -662,10 +811,28 @@
 	spin_unlock(&clockman->regs_lock);
 }
 
+static int rp1_pll_ph_set_rate(struct clk_hw *hw,
+			       unsigned long rate, unsigned long parent_rate)
+{
+	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
+	const struct rp1_pll_ph_data *data = pll_ph->data;
+	struct rp1_clockman *clockman = pll_ph->clockman;
+
+	/* Nothing really to do here! */
+	WARN_ON(data->fixed_divider != 1 && data->fixed_divider != 2);
+	WARN_ON(rate != parent_rate / data->fixed_divider);
+
+#ifdef MEASURE_CLOCK_RATE
+	if (rp1_pll_ph_is_on(hw))
+		clockman_measure_clock(clockman, data->name, data->fc0_src);
+#endif
+	return 0;
+}
+
 static unsigned long rp1_pll_ph_recalc_rate(struct clk_hw *hw,
 					    unsigned long parent_rate)
 {
-	struct rp1_clk_desc *pll_ph = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
 	const struct rp1_pll_ph_data *data = pll_ph->data;
 
 	return parent_rate / data->fixed_divider;
@@ -674,15 +841,33 @@
 static long rp1_pll_ph_round_rate(struct clk_hw *hw, unsigned long rate,
 				  unsigned long *parent_rate)
 {
-	struct rp1_clk_desc *pll_ph = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
 	const struct rp1_pll_ph_data *data = pll_ph->data;
 
 	return *parent_rate / data->fixed_divider;
 }
 
+static void rp1_pll_ph_debug_init(struct clk_hw *hw,
+				  struct dentry *dentry)
+{
+	struct rp1_pll_ph *pll_ph = container_of(hw, struct rp1_pll_ph, hw);
+	const struct rp1_pll_ph_data *data = pll_ph->data;
+	struct rp1_clockman *clockman = pll_ph->clockman;
+	struct debugfs_reg32 *regs;
+
+	regs = devm_kcalloc(clockman->dev, 1, sizeof(*regs), GFP_KERNEL);
+	if (!regs)
+		return;
+
+	regs[0].name = "ph_reg";
+	regs[0].offset = data->ph_reg;
+
+	rp1_debugfs_regset(clockman, 0, regs, 1, dentry);
+}
+
 static int rp1_pll_divider_is_on(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *divider = container_of(hw, struct rp1_clk_desc, div.hw);
+	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
 	struct rp1_clockman *clockman = divider->clockman;
 	const struct rp1_pll_data *data = divider->data;
 
@@ -691,7 +876,7 @@
 
 static int rp1_pll_divider_on(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *divider = container_of(hw, struct rp1_clk_desc, div.hw);
+	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
 	struct rp1_clockman *clockman = divider->clockman;
 	const struct rp1_pll_data *data = divider->data;
 
@@ -702,18 +887,20 @@
 		       clockman_read(clockman, data->ctrl_reg) & ~PLL_SEC_RST);
 	spin_unlock(&clockman->regs_lock);
 
+#ifdef MEASURE_CLOCK_RATE
+	clockman_measure_clock(clockman, data->name, data->fc0_src);
+#endif
 	return 0;
 }
 
 static void rp1_pll_divider_off(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *divider = container_of(hw, struct rp1_clk_desc, div.hw);
+	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
 	struct rp1_clockman *clockman = divider->clockman;
 	const struct rp1_pll_data *data = divider->data;
 
 	spin_lock(&clockman->regs_lock);
-	clockman_write(clockman, data->ctrl_reg,
-		       clockman_read(clockman, data->ctrl_reg) | PLL_SEC_RST);
+	clockman_write(clockman, data->ctrl_reg, PLL_SEC_RST);
 	spin_unlock(&clockman->regs_lock);
 }
 
@@ -721,7 +908,7 @@
 				    unsigned long rate,
 				    unsigned long parent_rate)
 {
-	struct rp1_clk_desc *divider = container_of(hw, struct rp1_clk_desc, div.hw);
+	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
 	struct rp1_clockman *clockman = divider->clockman;
 	const struct rp1_pll_data *data = divider->data;
 	u32 div, sec;
@@ -731,20 +918,21 @@
 
 	spin_lock(&clockman->regs_lock);
 	sec = clockman_read(clockman, data->ctrl_reg);
-	sec &= ~PLL_SEC_DIV_MASK;
-	sec |= FIELD_PREP(PLL_SEC_DIV_MASK, div);
+	sec = set_register_field(sec, div, PLL_SEC_DIV_MASK, PLL_SEC_DIV_SHIFT);
 
 	/* Must keep the divider in reset to change the value. */
 	sec |= PLL_SEC_RST;
 	clockman_write(clockman, data->ctrl_reg, sec);
 
-	/* must sleep 10 pll vco cycles */
-	ndelay(div64_ul(10ULL * div * NSEC_PER_SEC, parent_rate));
-
+	// todo: must sleep 10 pll vco cycles
 	sec &= ~PLL_SEC_RST;
 	clockman_write(clockman, data->ctrl_reg, sec);
 	spin_unlock(&clockman->regs_lock);
 
+#ifdef MEASURE_CLOCK_RATE
+	if (rp1_pll_divider_is_on(hw))
+		clockman_measure_clock(clockman, data->name, data->fc0_src);
+#endif
 	return 0;
 }
 
@@ -761,9 +949,26 @@
 	return clk_divider_ops.round_rate(hw, rate, parent_rate);
 }
 
+static void rp1_pll_divider_debug_init(struct clk_hw *hw, struct dentry *dentry)
+{
+	struct rp1_pll *divider = container_of(hw, struct rp1_pll, div.hw);
+	struct rp1_clockman *clockman = divider->clockman;
+	const struct rp1_pll_data *data = divider->data;
+	struct debugfs_reg32 *regs;
+
+	regs = devm_kcalloc(clockman->dev, 1, sizeof(*regs), GFP_KERNEL);
+	if (!regs)
+		return;
+
+	regs[0].name = "sec";
+	regs[0].offset = data->ctrl_reg;
+
+	rp1_debugfs_regset(clockman, 0, regs, 1, dentry);
+}
+
 static int rp1_clock_is_on(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *clock = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
 	struct rp1_clockman *clockman = clock->clockman;
 	const struct rp1_clock_data *data = clock->data;
 
@@ -773,11 +978,12 @@
 static unsigned long rp1_clock_recalc_rate(struct clk_hw *hw,
 					   unsigned long parent_rate)
 {
-	struct rp1_clk_desc *clock = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
 	struct rp1_clockman *clockman = clock->clockman;
 	const struct rp1_clock_data *data = clock->data;
 	u64 calc_rate;
 	u64 div;
+
 	u32 frac;
 
 	div = clockman_read(clockman, data->div_int_reg);
@@ -798,35 +1004,30 @@
 
 static int rp1_clock_on(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *clock = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
 	struct rp1_clockman *clockman = clock->clockman;
 	const struct rp1_clock_data *data = clock->data;
 
 	spin_lock(&clockman->regs_lock);
 	clockman_write(clockman, data->ctrl_reg,
 		       clockman_read(clockman, data->ctrl_reg) | CLK_CTRL_ENABLE);
-	/* If this is a GPCLK, turn on the output-enable */
-	if (data->oe_mask)
-		clockman_write(clockman, GPCLK_OE_CTRL,
-			       clockman_read(clockman, GPCLK_OE_CTRL) | data->oe_mask);
 	spin_unlock(&clockman->regs_lock);
 
+#ifdef MEASURE_CLOCK_RATE
+	clockman_measure_clock(clockman, data->name, data->fc0_src);
+#endif
 	return 0;
 }
 
 static void rp1_clock_off(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *clock = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
 	struct rp1_clockman *clockman = clock->clockman;
 	const struct rp1_clock_data *data = clock->data;
 
 	spin_lock(&clockman->regs_lock);
 	clockman_write(clockman, data->ctrl_reg,
 		       clockman_read(clockman, data->ctrl_reg) & ~CLK_CTRL_ENABLE);
-	/* If this is a GPCLK, turn off the output-enable */
-	if (data->oe_mask)
-		clockman_write(clockman, GPCLK_OE_CTRL,
-			       clockman_read(clockman, GPCLK_OE_CTRL) & ~data->oe_mask);
 	spin_unlock(&clockman->regs_lock);
 }
 
@@ -848,9 +1049,9 @@
 	 */
 	if (data->div_frac_reg) {
 		div = (u64)parent_rate << CLK_DIV_FRAC_BITS;
-		div = DIV_ROUND_CLOSEST_ULL(div, rate);
+		div = DIV_U64_NEAREST(div, rate);
 	} else {
-		div = DIV_ROUND_CLOSEST_ULL(parent_rate, rate);
+		div = DIV_U64_NEAREST(parent_rate, rate);
 		div <<= CLK_DIV_FRAC_BITS;
 	}
 
@@ -863,7 +1064,7 @@
 
 static u8 rp1_clock_get_parent(struct clk_hw *hw)
 {
-	struct rp1_clk_desc *clock = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
 	struct rp1_clockman *clockman = clock->clockman;
 	const struct rp1_clock_data *data = clock->data;
 	u32 sel, ctrl;
@@ -889,7 +1090,7 @@
 		 * the AUXSRC register field.
 		 */
 		ctrl = clockman_read(clockman, data->ctrl_reg);
-		parent = FIELD_GET(CLK_CTRL_AUXSRC_MASK, ctrl);
+		parent = (ctrl & CLK_CTRL_AUXSRC_MASK) >> CLK_CTRL_AUXSRC_SHIFT;
 		parent += data->num_std_parents;
 	}
 
@@ -898,7 +1099,7 @@
 
 static int rp1_clock_set_parent(struct clk_hw *hw, u8 index)
 {
-	struct rp1_clk_desc *clock = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
 	struct rp1_clockman *clockman = clock->clockman;
 	const struct rp1_clock_data *data = clock->data;
 	u32 ctrl, sel;
@@ -908,28 +1109,27 @@
 
 	if (index >= data->num_std_parents) {
 		/* This is an aux source request */
-		if (index >= data->num_std_parents + data->num_aux_parents) {
-			spin_unlock(&clockman->regs_lock);
+		if (index >= data->num_std_parents + data->num_aux_parents)
 			return -EINVAL;
-		}
 
 		/* Select parent from aux list */
-		ctrl &= ~CLK_CTRL_AUXSRC_MASK;
-		ctrl |= FIELD_PREP(CLK_CTRL_AUXSRC_MASK, index - data->num_std_parents);
+		ctrl = set_register_field(ctrl, index - data->num_std_parents,
+					  CLK_CTRL_AUXSRC_MASK,
+					  CLK_CTRL_AUXSRC_SHIFT);
 		/* Set src to aux list */
-		ctrl &= ~data->clk_src_mask;
-		ctrl |= (AUX_SEL << CLK_CTRL_SRC_SHIFT) & data->clk_src_mask;
+		ctrl = set_register_field(ctrl, AUX_SEL, data->clk_src_mask,
+					  CLK_CTRL_SRC_SHIFT);
 	} else {
-		ctrl &= ~data->clk_src_mask;
-		ctrl |= (index << CLK_CTRL_SRC_SHIFT) & data->clk_src_mask;
+		ctrl = set_register_field(ctrl, index, data->clk_src_mask,
+					  CLK_CTRL_SRC_SHIFT);
 	}
 
 	clockman_write(clockman, data->ctrl_reg, ctrl);
 	spin_unlock(&clockman->regs_lock);
 
 	sel = rp1_clock_get_parent(hw);
-	if (sel != index)
-		return -EINVAL;
+	WARN(sel != index, "(%s): Parent index req %u returned back %u\n",
+	     data->name, index, sel);
 
 	return 0;
 }
@@ -939,11 +1139,18 @@
 					 unsigned long parent_rate,
 					 u8 parent)
 {
-	struct rp1_clk_desc *clock = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
 	struct rp1_clockman *clockman = clock->clockman;
 	const struct rp1_clock_data *data = clock->data;
 	u32 div = rp1_clock_choose_div(rate, parent_rate, data);
 
+	WARN(rate > 4000000000ll, "rate is -ve (%d)\n", (int)rate);
+
+	if (WARN(!div,
+		 "clk divider calculated as 0! (%s, rate %ld, parent rate %ld)\n",
+		 data->name, rate, parent_rate))
+		div = 1 << CLK_DIV_FRAC_BITS;
+
 	spin_lock(&clockman->regs_lock);
 
 	clockman_write(clockman, data->div_int_reg, div >> CLK_DIV_FRAC_BITS);
@@ -953,8 +1160,12 @@
 	spin_unlock(&clockman->regs_lock);
 
 	if (parent != 0xff)
-		return rp1_clock_set_parent(hw, parent);
+		rp1_clock_set_parent(hw, parent);
 
+#ifdef MEASURE_CLOCK_RATE
+	if (rp1_clock_is_on(hw))
+		clockman_measure_clock(clockman, data->name, data->fc0_src);
+#endif
 	return 0;
 }
 
@@ -970,14 +1181,13 @@
 					   unsigned long *prate,
 					   unsigned long *calc_rate)
 {
-	struct rp1_clk_desc *clock = container_of(hw, struct rp1_clk_desc, hw);
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
 	const struct rp1_clock_data *data = clock->data;
 	struct clk_hw *parent;
 	u32 div;
 	u64 tmp;
 
 	parent = clk_hw_get_parent_by_index(hw, parent_idx);
-
 	*prate = clk_hw_get_rate(parent);
 	div = rp1_clock_choose_div(rate, *prate, data);
 
@@ -989,16 +1199,7 @@
 	/* Recalculate to account for rounding errors */
 	tmp = (u64)*prate << CLK_DIV_FRAC_BITS;
 	tmp = div_u64(tmp, div);
-
-	/*
-	 * Prevent overclocks - if all parent choices result in
-	 * a downstream clock in excess of the maximum, then the
-	 * call to set the clock will fail.
-	 */
-	if (tmp > data->max_freq)
-		*calc_rate = 0;
-	else
-		*calc_rate = tmp;
+	*calc_rate = tmp;
 }
 
 static int rp1_clock_determine_rate(struct clk_hw *hw,
@@ -1041,11 +1242,11 @@
 		rp1_clock_choose_div_and_prate(hw, i, req->rate, &prate,
 					       &calc_rate);
 
-		if (abs_diff(calc_rate, req->rate) < best_rate_diff) {
+		if (ABS_DIFF(calc_rate, req->rate) < best_rate_diff) {
 			best_parent = parent;
 			best_prate = prate;
 			best_rate = calc_rate;
-			best_rate_diff = abs_diff(calc_rate, req->rate);
+			best_rate_diff = ABS_DIFF(calc_rate, req->rate);
 
 			if (best_rate_diff == 0)
 				break;
@@ -1062,6 +1263,31 @@
 	return 0;
 }
 
+static void rp1_clk_debug_init(struct clk_hw *hw, struct dentry *dentry)
+{
+	struct rp1_clock *clock = container_of(hw, struct rp1_clock, hw);
+	struct rp1_clockman *clockman = clock->clockman;
+	const struct rp1_clock_data *data = clock->data;
+	struct debugfs_reg32 *regs;
+	int i;
+
+	regs = devm_kcalloc(clockman->dev, 4, sizeof(*regs), GFP_KERNEL);
+	if (!regs)
+		return;
+
+	i = 0;
+	regs[i].name = "ctrl";
+	regs[i++].offset = data->ctrl_reg;
+	regs[i].name = "div_int";
+	regs[i++].offset = data->div_int_reg;
+	regs[i].name = "div_frac";
+	regs[i++].offset = data->div_frac_reg;
+	regs[i].name = "sel";
+	regs[i++].offset = data->sel_reg;
+
+	rp1_debugfs_regset(clockman, 0, regs, i, dentry);
+}
+
 static const struct clk_ops rp1_pll_core_ops = {
 	.is_prepared = rp1_pll_core_is_on,
 	.prepare = rp1_pll_core_on,
@@ -1069,20 +1295,24 @@
 	.set_rate = rp1_pll_core_set_rate,
 	.recalc_rate = rp1_pll_core_recalc_rate,
 	.round_rate = rp1_pll_core_round_rate,
+	.debug_init = rp1_pll_core_debug_init,
 };
 
 static const struct clk_ops rp1_pll_ops = {
 	.set_rate = rp1_pll_set_rate,
 	.recalc_rate = rp1_pll_recalc_rate,
 	.round_rate = rp1_pll_round_rate,
+	.debug_init = rp1_pll_debug_init,
 };
 
 static const struct clk_ops rp1_pll_ph_ops = {
 	.is_prepared = rp1_pll_ph_is_on,
 	.prepare = rp1_pll_ph_on,
 	.unprepare = rp1_pll_ph_off,
+	.set_rate = rp1_pll_ph_set_rate,
 	.recalc_rate = rp1_pll_ph_recalc_rate,
 	.round_rate = rp1_pll_ph_round_rate,
+	.debug_init = rp1_pll_ph_debug_init,
 };
 
 static const struct clk_ops rp1_pll_divider_ops = {
@@ -1092,6 +1322,7 @@
 	.set_rate = rp1_pll_divider_set_rate,
 	.recalc_rate = rp1_pll_divider_recalc_rate,
 	.round_rate = rp1_pll_divider_round_rate,
+	.debug_init = rp1_pll_divider_debug_init,
 };
 
 static const struct clk_ops rp1_clk_ops = {
@@ -1104,372 +1335,729 @@
 	.set_rate_and_parent = rp1_clock_set_rate_and_parent,
 	.set_rate = rp1_clock_set_rate,
 	.determine_rate = rp1_clock_determine_rate,
+	.debug_init = rp1_clk_debug_init,
 };
 
+static bool rp1_clk_is_claimed(const char *name);
+
+static struct clk_hw *rp1_register_pll_core(struct rp1_clockman *clockman,
+					    const void *data)
+{
+	const struct rp1_pll_core_data *pll_core_data = data;
+	struct rp1_pll_core *pll_core;
+	struct clk_init_data init;
+	int ret;
+
+	memset(&init, 0, sizeof(init));
+
+	/* All of the PLL cores derive from the external oscillator. */
+	init.parent_names = &ref_clock;
+	init.num_parents = 1;
+	init.name = pll_core_data->name;
+	init.ops = &rp1_pll_core_ops;
+	init.flags = pll_core_data->flags | CLK_IGNORE_UNUSED | CLK_IS_CRITICAL;
+
+	pll_core = kzalloc(sizeof(*pll_core), GFP_KERNEL);
+	if (!pll_core)
+		return NULL;
+
+	pll_core->clockman = clockman;
+	pll_core->data = pll_core_data;
+	pll_core->hw.init = &init;
+
+	ret = devm_clk_hw_register(clockman->dev, &pll_core->hw);
+	if (ret) {
+		kfree(pll_core);
+		return NULL;
+	}
+
+	return &pll_core->hw;
+}
+
 static struct clk_hw *rp1_register_pll(struct rp1_clockman *clockman,
-				       struct rp1_clk_desc *desc)
+				       const void *data)
 {
+	const struct rp1_pll_data *pll_data = data;
+	struct rp1_pll *pll;
+	struct clk_init_data init;
 	int ret;
 
-	desc->clockman = clockman;
+	memset(&init, 0, sizeof(init));
 
-	ret = devm_clk_hw_register(clockman->dev, &desc->hw);
-	if (ret)
-		return ERR_PTR(ret);
+	init.parent_names = &pll_data->source_pll;
+	init.num_parents = 1;
+	init.name = pll_data->name;
+	init.ops = &rp1_pll_ops;
+	init.flags = pll_data->flags | CLK_IGNORE_UNUSED | CLK_IS_CRITICAL;
 
-	return &desc->hw;
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return NULL;
+
+	pll->clockman = clockman;
+	pll->data = pll_data;
+	pll->hw.init = &init;
+
+	ret = devm_clk_hw_register(clockman->dev, &pll->hw);
+	if (ret) {
+		kfree(pll);
+		return NULL;
+	}
+
+	return &pll->hw;
+}
+
+static struct clk_hw *rp1_register_pll_ph(struct rp1_clockman *clockman,
+					  const void *data)
+{
+	const struct rp1_pll_ph_data *ph_data = data;
+	struct rp1_pll_ph *ph;
+	struct clk_init_data init;
+	int ret;
+
+	memset(&init, 0, sizeof(init));
+
+	/* All of the PLLs derive from the external oscillator. */
+	init.parent_names = &ph_data->source_pll;
+	init.num_parents = 1;
+	init.name = ph_data->name;
+	init.ops = &rp1_pll_ph_ops;
+	init.flags = ph_data->flags | CLK_IGNORE_UNUSED;
+
+	ph = kzalloc(sizeof(*ph), GFP_KERNEL);
+	if (!ph)
+		return NULL;
+
+	ph->clockman = clockman;
+	ph->data = ph_data;
+	ph->hw.init = &init;
+
+	ret = devm_clk_hw_register(clockman->dev, &ph->hw);
+	if (ret) {
+		kfree(ph);
+		return NULL;
+	}
+
+	return &ph->hw;
 }
 
 static struct clk_hw *rp1_register_pll_divider(struct rp1_clockman *clockman,
-					       struct rp1_clk_desc *desc)
+					       const void *data)
 {
-	const struct rp1_pll_data *divider_data = desc->data;
+	const struct rp1_pll_data *divider_data = data;
+	struct rp1_pll *divider;
+	struct clk_init_data init;
 	int ret;
 
-	desc->div.reg = clockman->regs + divider_data->ctrl_reg;
-	desc->div.shift = __ffs(PLL_SEC_DIV_MASK);
-	desc->div.width = __ffs(~(PLL_SEC_DIV_MASK >> desc->div.shift));
-	desc->div.flags = CLK_DIVIDER_ROUND_CLOSEST;
-	desc->div.lock = &clockman->regs_lock;
-	desc->div.hw.init = desc->hw.init;
-	desc->div.table = pll_sec_div_table;
+	memset(&init, 0, sizeof(init));
 
-	desc->clockman = clockman;
+	init.parent_names = &divider_data->source_pll;
+	init.num_parents = 1;
+	init.name = divider_data->name;
+	init.ops = &rp1_pll_divider_ops;
+	init.flags = divider_data->flags | CLK_IGNORE_UNUSED;
 
-	ret = devm_clk_hw_register(clockman->dev, &desc->div.hw);
+	divider = devm_kzalloc(clockman->dev, sizeof(*divider), GFP_KERNEL);
+	if (!divider)
+		return NULL;
+
+	divider->div.reg = clockman->regs + divider_data->ctrl_reg;
+	divider->div.shift = PLL_SEC_DIV_SHIFT;
+	divider->div.width = PLL_SEC_DIV_WIDTH;
+	divider->div.flags = CLK_DIVIDER_ROUND_CLOSEST;
+	divider->div.lock = &clockman->regs_lock;
+	divider->div.hw.init = &init;
+	divider->div.table = pll_sec_div_table;
+
+	if (!rp1_clk_is_claimed(divider_data->source_pll))
+		init.flags |= CLK_IS_CRITICAL;
+	if (!rp1_clk_is_claimed(divider_data->name))
+		divider->div.flags |= CLK_IS_CRITICAL;
+
+	divider->clockman = clockman;
+	divider->data = divider_data;
+
+	ret = devm_clk_hw_register(clockman->dev, &divider->div.hw);
 	if (ret)
 		return ERR_PTR(ret);
 
-	return &desc->div.hw;
+	return &divider->div.hw;
 }
 
 static struct clk_hw *rp1_register_clock(struct rp1_clockman *clockman,
-					 struct rp1_clk_desc *desc)
+					 const void *data)
 {
-	const struct rp1_clock_data *clock_data = desc->data;
+	const struct rp1_clock_data *clock_data = data;
+	struct rp1_clock *clock;
+	struct clk_init_data init;
 	int ret;
 
-	if (WARN_ON_ONCE(MAX_CLK_PARENTS <
-	       clock_data->num_std_parents + clock_data->num_aux_parents))
-		return ERR_PTR(-EINVAL);
-
+	BUG_ON(MAX_CLK_PARENTS <
+	       clock_data->num_std_parents + clock_data->num_aux_parents);
 	/* There must be a gap for the AUX selector */
-	if (WARN_ON_ONCE(clock_data->num_std_parents > AUX_SEL &&
-			 desc->hw.init->parent_data[AUX_SEL].index != -1))
-		return ERR_PTR(-EINVAL);
+	BUG_ON((clock_data->num_std_parents > AUX_SEL) &&
+	       strcmp("-", clock_data->parents[AUX_SEL]));
 
-	desc->clockman = clockman;
+	memset(&init, 0, sizeof(init));
+	init.parent_names = clock_data->parents;
+	init.num_parents =
+		clock_data->num_std_parents + clock_data->num_aux_parents;
+	init.name = clock_data->name;
+	init.flags = clock_data->flags | CLK_IGNORE_UNUSED;
+	init.ops = &rp1_clk_ops;
 
-	ret = devm_clk_hw_register(clockman->dev, &desc->hw);
+	clock = devm_kzalloc(clockman->dev, sizeof(*clock), GFP_KERNEL);
+	if (!clock)
+		return NULL;
+
+	clock->clockman = clockman;
+	clock->data = clock_data;
+	clock->hw.init = &init;
+
+	ret = devm_clk_hw_register(clockman->dev, &clock->hw);
 	if (ret)
 		return ERR_PTR(ret);
 
-	return &desc->hw;
+	return &clock->hw;
 }
 
+struct rp1_clk_desc {
+	struct clk_hw *(*clk_register)(struct rp1_clockman *clockman,
+				       const void *data);
+	const void *data;
+};
+
 /* Assignment helper macros for different clock types. */
-#define _REGISTER(f, ...)	{ .clk_register = f, __VA_ARGS__ }
+#define _REGISTER(f, ...) { .clk_register = f, .data = __VA_ARGS__ }
 
-#define CLK_DATA(type, ...)	.data = &(struct type) { __VA_ARGS__ }
+#define REGISTER_PLL_CORE(...)	_REGISTER(&rp1_register_pll_core,	\
+					  &(struct rp1_pll_core_data)	\
+					  {__VA_ARGS__})
 
 #define REGISTER_PLL(...)	_REGISTER(&rp1_register_pll,		\
-					  __VA_ARGS__)
+					  &(struct rp1_pll_data)		\
+					  {__VA_ARGS__})
+
+#define REGISTER_PLL_PH(...)	_REGISTER(&rp1_register_pll_ph,		\
+					  &(struct rp1_pll_ph_data)	\
+					  {__VA_ARGS__})
 
 #define REGISTER_PLL_DIV(...)	_REGISTER(&rp1_register_pll_divider,	\
-					  __VA_ARGS__)
+					  &(struct rp1_pll_data)	\
+					  {__VA_ARGS__})
 
 #define REGISTER_CLK(...)	_REGISTER(&rp1_register_clock,		\
-					  __VA_ARGS__)
+					  &(struct rp1_clock_data)	\
+					  {__VA_ARGS__})
 
-static struct rp1_clk_desc pll_sys_core_desc = REGISTER_PLL(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"pll_sys_core",
-		(const struct clk_parent_data[]) { { .index = 0 } },
-		&rp1_pll_core_ops,
-		CLK_IS_CRITICAL
-	),
-	CLK_DATA(rp1_pll_core_data,
-		 .cs_reg = PLL_SYS_CS,
-		 .pwr_reg = PLL_SYS_PWR,
-		 .fbdiv_int_reg = PLL_SYS_FBDIV_INT,
-		 .fbdiv_frac_reg = PLL_SYS_FBDIV_FRAC,
-	)
-);
+static const struct rp1_clk_desc clk_desc_array[] = {
+	[RP1_PLL_SYS_CORE] = REGISTER_PLL_CORE(
+				.name = "pll_sys_core",
+				.cs_reg = PLL_SYS_CS,
+				.pwr_reg = PLL_SYS_PWR,
+				.fbdiv_int_reg = PLL_SYS_FBDIV_INT,
+				.fbdiv_frac_reg = PLL_SYS_FBDIV_FRAC,
+				),
 
-static struct rp1_clk_desc pll_audio_core_desc = REGISTER_PLL(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"pll_audio_core",
-		(const struct clk_parent_data[]) { { .index = 0 } },
-		&rp1_pll_core_ops,
-		CLK_IS_CRITICAL
-	),
-	CLK_DATA(rp1_pll_core_data,
-		 .cs_reg = PLL_AUDIO_CS,
-		 .pwr_reg = PLL_AUDIO_PWR,
-		 .fbdiv_int_reg = PLL_AUDIO_FBDIV_INT,
-		 .fbdiv_frac_reg = PLL_AUDIO_FBDIV_FRAC,
-	)
-);
+	[RP1_PLL_AUDIO_CORE] = REGISTER_PLL_CORE(
+				.name = "pll_audio_core",
+				.cs_reg = PLL_AUDIO_CS,
+				.pwr_reg = PLL_AUDIO_PWR,
+				.fbdiv_int_reg = PLL_AUDIO_FBDIV_INT,
+				.fbdiv_frac_reg = PLL_AUDIO_FBDIV_FRAC,
+				),
 
-static struct rp1_clk_desc pll_video_core_desc = REGISTER_PLL(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"pll_video_core",
-		(const struct clk_parent_data[]) { { .index = 0 } },
-		&rp1_pll_core_ops,
-		CLK_IS_CRITICAL
-	),
-	CLK_DATA(rp1_pll_core_data,
-		 .cs_reg = PLL_VIDEO_CS,
-		 .pwr_reg = PLL_VIDEO_PWR,
-		 .fbdiv_int_reg = PLL_VIDEO_FBDIV_INT,
-		 .fbdiv_frac_reg = PLL_VIDEO_FBDIV_FRAC,
-	)
-);
+	[RP1_PLL_VIDEO_CORE] = REGISTER_PLL_CORE(
+				.name = "pll_video_core",
+				.cs_reg = PLL_VIDEO_CS,
+				.pwr_reg = PLL_VIDEO_PWR,
+				.fbdiv_int_reg = PLL_VIDEO_FBDIV_INT,
+				.fbdiv_frac_reg = PLL_VIDEO_FBDIV_FRAC,
+				),
 
-static struct rp1_clk_desc pll_sys_desc = REGISTER_PLL(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"pll_sys",
-		(const struct clk_parent_data[]) {
-			{ .hw = &pll_sys_core_desc.hw }
-		},
-		&rp1_pll_ops,
-		0
-	),
-	CLK_DATA(rp1_pll_data,
-		 .ctrl_reg = PLL_SYS_PRIM,
-		 .fc0_src = FC_NUM(0, 2),
-	)
-);
+	[RP1_PLL_SYS] = REGISTER_PLL(
+				.name = "pll_sys",
+				.source_pll = "pll_sys_core",
+				.ctrl_reg = PLL_SYS_PRIM,
+				.fc0_src = FC_NUM(0, 2),
+				),
 
-static struct rp1_clk_desc pll_sys_sec_desc = REGISTER_PLL_DIV(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"pll_sys_sec",
-		(const struct clk_parent_data[]) {
-			{ .hw = &pll_sys_core_desc.hw }
-		},
-		&rp1_pll_divider_ops,
-		0
-	),
-	CLK_DATA(rp1_pll_data,
-		 .ctrl_reg = PLL_SYS_SEC,
-		 .fc0_src = FC_NUM(2, 2),
-	)
-);
+	[RP1_PLL_AUDIO] = REGISTER_PLL(
+				.name = "pll_audio",
+				.source_pll = "pll_audio_core",
+				.ctrl_reg = PLL_AUDIO_PRIM,
+				.fc0_src = FC_NUM(4, 2),
+				),
 
-static struct rp1_clk_desc clk_eth_tsu_desc = REGISTER_CLK(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"clk_eth_tsu",
-		(const struct clk_parent_data[]) { { .index = 0 } },
-		&rp1_clk_ops,
-		0
-	),
-	CLK_DATA(rp1_clock_data,
-		 .num_std_parents = 0,
-		 .num_aux_parents = 1,
-		 .ctrl_reg = CLK_ETH_TSU_CTRL,
-		 .div_int_reg = CLK_ETH_TSU_DIV_INT,
-		 .sel_reg = CLK_ETH_TSU_SEL,
-		 .div_int_max = DIV_INT_8BIT_MAX,
-		 .max_freq = 50 * HZ_PER_MHZ,
-		 .fc0_src = FC_NUM(5, 7),
-	)
-);
+	[RP1_PLL_VIDEO] = REGISTER_PLL(
+				.name = "pll_video",
+				.source_pll = "pll_video_core",
+				.ctrl_reg = PLL_VIDEO_PRIM,
+				.fc0_src = FC_NUM(3, 2),
+				),
 
-static const struct clk_parent_data clk_eth_parents[] = {
-	{ .hw = &pll_sys_sec_desc.div.hw },
-	{ .hw = &pll_sys_desc.hw },
-};
+	[RP1_PLL_SYS_PRI_PH] = REGISTER_PLL_PH(
+				.name = "pll_sys_pri_ph",
+				.source_pll = "pll_sys",
+				.ph_reg = PLL_SYS_PRIM,
+				.fixed_divider = 2,
+				.phase = RP1_PLL_PHASE_0,
+				.fc0_src = FC_NUM(1, 2),
+				),
 
-static struct rp1_clk_desc clk_eth_desc = REGISTER_CLK(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"clk_eth",
-		clk_eth_parents,
-		&rp1_clk_ops,
-		0
-	),
-	CLK_DATA(rp1_clock_data,
-		 .num_std_parents = 0,
-		 .num_aux_parents = 2,
-		 .ctrl_reg = CLK_ETH_CTRL,
-		 .div_int_reg = CLK_ETH_DIV_INT,
-		 .sel_reg = CLK_ETH_SEL,
-		 .div_int_max = DIV_INT_8BIT_MAX,
-		 .max_freq = 125 * HZ_PER_MHZ,
-		 .fc0_src = FC_NUM(4, 6),
-	)
-);
+	[RP1_PLL_AUDIO_PRI_PH] = REGISTER_PLL_PH(
+				.name = "pll_audio_pri_ph",
+				.source_pll = "pll_audio",
+				.ph_reg = PLL_AUDIO_PRIM,
+				.fixed_divider = 2,
+				.phase = RP1_PLL_PHASE_0,
+				.fc0_src = FC_NUM(5, 1),
+				),
 
-static const struct clk_parent_data clk_sys_parents[] = {
-	{ .index = 0 },
-	{ .index = -1 },
-	{ .hw = &pll_sys_desc.hw },
-};
+	[RP1_PLL_SYS_SEC] = REGISTER_PLL_DIV(
+				.name = "pll_sys_sec",
+				.source_pll = "pll_sys_core",
+				.ctrl_reg = PLL_SYS_SEC,
+				.fc0_src = FC_NUM(2, 2),
+				),
 
-static struct rp1_clk_desc clk_sys_desc = REGISTER_CLK(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"clk_sys",
-		clk_sys_parents,
-		&rp1_clk_ops,
-		CLK_IS_CRITICAL
-	),
-	CLK_DATA(rp1_clock_data,
-		 .num_std_parents = 3,
-		 .num_aux_parents = 0,
-		 .ctrl_reg = CLK_SYS_CTRL,
-		 .div_int_reg = CLK_SYS_DIV_INT,
-		 .sel_reg = CLK_SYS_SEL,
-		 .div_int_max = DIV_INT_24BIT_MAX,
-		 .max_freq = 200 * HZ_PER_MHZ,
-		 .fc0_src = FC_NUM(0, 4),
-		 .clk_src_mask = 0x3,
-	)
-);
+	[RP1_PLL_AUDIO_SEC] = REGISTER_PLL_DIV(
+				.name = "pll_audio_sec",
+				.source_pll = "pll_audio_core",
+				.ctrl_reg = PLL_AUDIO_SEC,
+				.fc0_src = FC_NUM(6, 2),
+				),
 
-static struct rp1_clk_desc pll_sys_pri_ph_desc = REGISTER_PLL(
-	.hw.init = CLK_HW_INIT_PARENTS_DATA(
-		"pll_sys_pri_ph",
-		(const struct clk_parent_data[]) {
-			{ .hw = &pll_sys_desc.hw }
-		},
-		&rp1_pll_ph_ops,
-		0
-	),
-	CLK_DATA(rp1_pll_ph_data,
-		 .ph_reg = PLL_SYS_PRIM,
-		 .fixed_divider = 2,
-		 .phase = RP1_PLL_PHASE_0,
-		 .fc0_src = FC_NUM(1, 2),
-	)
-);
+	[RP1_PLL_VIDEO_SEC] = REGISTER_PLL_DIV(
+				.name = "pll_video_sec",
+				.source_pll = "pll_video_core",
+				.ctrl_reg = PLL_VIDEO_SEC,
+				.fc0_src = FC_NUM(5, 3),
+				),
 
-static struct rp1_clk_desc *const clk_desc_array[] = {
-	[RP1_PLL_SYS_CORE] = &pll_sys_core_desc,
-	[RP1_PLL_AUDIO_CORE] = &pll_audio_core_desc,
-	[RP1_PLL_VIDEO_CORE] = &pll_video_core_desc,
-	[RP1_PLL_SYS] = &pll_sys_desc,
-	[RP1_CLK_ETH_TSU] = &clk_eth_tsu_desc,
-	[RP1_CLK_ETH] = &clk_eth_desc,
-	[RP1_CLK_SYS] = &clk_sys_desc,
-	[RP1_PLL_SYS_PRI_PH] = &pll_sys_pri_ph_desc,
-	[RP1_PLL_SYS_SEC] = &pll_sys_sec_desc,
-};
+	[RP1_CLK_SYS] = REGISTER_CLK(
+				.name = "clk_sys",
+				.parents = {"xosc", "-", "pll_sys"},
+				.num_std_parents = 3,
+				.num_aux_parents = 0,
+				.ctrl_reg = CLK_SYS_CTRL,
+				.div_int_reg = CLK_SYS_DIV_INT,
+				.sel_reg = CLK_SYS_SEL,
+				.div_int_max = DIV_INT_24BIT_MAX,
+				.fc0_src = FC_NUM(0, 4),
+				.clk_src_mask = 0x3,
+				),
 
-static const struct regmap_range rp1_reg_ranges[] = {
-	regmap_reg_range(PLL_SYS_CS, PLL_SYS_SEC),
-	regmap_reg_range(PLL_AUDIO_CS, PLL_AUDIO_TERN),
-	regmap_reg_range(PLL_VIDEO_CS, PLL_VIDEO_SEC),
-	regmap_reg_range(GPCLK_OE_CTRL, GPCLK_OE_CTRL),
-	regmap_reg_range(CLK_SYS_CTRL, CLK_SYS_DIV_INT),
-	regmap_reg_range(CLK_SYS_SEL, CLK_SYS_SEL),
-	regmap_reg_range(CLK_SLOW_SYS_CTRL, CLK_SLOW_SYS_DIV_INT),
-	regmap_reg_range(CLK_SLOW_SYS_SEL, CLK_SLOW_SYS_SEL),
-	regmap_reg_range(CLK_DMA_CTRL, CLK_DMA_DIV_INT),
-	regmap_reg_range(CLK_DMA_SEL, CLK_DMA_SEL),
-	regmap_reg_range(CLK_UART_CTRL, CLK_UART_DIV_INT),
-	regmap_reg_range(CLK_UART_SEL, CLK_UART_SEL),
-	regmap_reg_range(CLK_ETH_CTRL, CLK_ETH_DIV_INT),
-	regmap_reg_range(CLK_ETH_SEL, CLK_ETH_SEL),
-	regmap_reg_range(CLK_PWM0_CTRL, CLK_PWM0_SEL),
-	regmap_reg_range(CLK_PWM1_CTRL, CLK_PWM1_SEL),
-	regmap_reg_range(CLK_AUDIO_IN_CTRL, CLK_AUDIO_IN_DIV_INT),
-	regmap_reg_range(CLK_AUDIO_IN_SEL, CLK_AUDIO_IN_SEL),
-	regmap_reg_range(CLK_AUDIO_OUT_CTRL, CLK_AUDIO_OUT_DIV_INT),
-	regmap_reg_range(CLK_AUDIO_OUT_SEL, CLK_AUDIO_OUT_SEL),
-	regmap_reg_range(CLK_I2S_CTRL, CLK_I2S_DIV_INT),
-	regmap_reg_range(CLK_I2S_SEL, CLK_I2S_SEL),
-	regmap_reg_range(CLK_MIPI0_CFG_CTRL, CLK_MIPI0_CFG_DIV_INT),
-	regmap_reg_range(CLK_MIPI0_CFG_SEL, CLK_MIPI0_CFG_SEL),
-	regmap_reg_range(CLK_MIPI1_CFG_CTRL, CLK_MIPI1_CFG_DIV_INT),
-	regmap_reg_range(CLK_MIPI1_CFG_SEL, CLK_MIPI1_CFG_SEL),
-	regmap_reg_range(CLK_PCIE_AUX_CTRL, CLK_PCIE_AUX_DIV_INT),
-	regmap_reg_range(CLK_PCIE_AUX_SEL, CLK_PCIE_AUX_SEL),
-	regmap_reg_range(CLK_USBH0_MICROFRAME_CTRL, CLK_USBH0_MICROFRAME_DIV_INT),
-	regmap_reg_range(CLK_USBH0_MICROFRAME_SEL, CLK_USBH0_MICROFRAME_SEL),
-	regmap_reg_range(CLK_USBH1_MICROFRAME_CTRL, CLK_USBH1_MICROFRAME_DIV_INT),
-	regmap_reg_range(CLK_USBH1_MICROFRAME_SEL, CLK_USBH1_MICROFRAME_SEL),
-	regmap_reg_range(CLK_USBH0_SUSPEND_CTRL, CLK_USBH0_SUSPEND_DIV_INT),
-	regmap_reg_range(CLK_USBH0_SUSPEND_SEL, CLK_USBH0_SUSPEND_SEL),
-	regmap_reg_range(CLK_USBH1_SUSPEND_CTRL, CLK_USBH1_SUSPEND_DIV_INT),
-	regmap_reg_range(CLK_USBH1_SUSPEND_SEL, CLK_USBH1_SUSPEND_SEL),
-	regmap_reg_range(CLK_ETH_TSU_CTRL, CLK_ETH_TSU_DIV_INT),
-	regmap_reg_range(CLK_ETH_TSU_SEL, CLK_ETH_TSU_SEL),
-	regmap_reg_range(CLK_ADC_CTRL, CLK_ADC_DIV_INT),
-	regmap_reg_range(CLK_ADC_SEL, CLK_ADC_SEL),
-	regmap_reg_range(CLK_SDIO_TIMER_CTRL, CLK_SDIO_TIMER_DIV_INT),
-	regmap_reg_range(CLK_SDIO_TIMER_SEL, CLK_SDIO_TIMER_SEL),
-	regmap_reg_range(CLK_SDIO_ALT_SRC_CTRL, CLK_SDIO_ALT_SRC_DIV_INT),
-	regmap_reg_range(CLK_SDIO_ALT_SRC_SEL, CLK_SDIO_ALT_SRC_SEL),
-	regmap_reg_range(CLK_GP0_CTRL, CLK_GP0_SEL),
-	regmap_reg_range(CLK_GP1_CTRL, CLK_GP1_SEL),
-	regmap_reg_range(CLK_GP2_CTRL, CLK_GP2_SEL),
-	regmap_reg_range(CLK_GP3_CTRL, CLK_GP3_SEL),
-	regmap_reg_range(CLK_GP4_CTRL, CLK_GP4_SEL),
-	regmap_reg_range(CLK_GP5_CTRL, CLK_GP5_SEL),
-	regmap_reg_range(CLK_SYS_RESUS_CTRL, CLK_SYS_RESUS_CTRL),
-	regmap_reg_range(CLK_SLOW_SYS_RESUS_CTRL, CLK_SLOW_SYS_RESUS_CTRL),
-	regmap_reg_range(FC0_REF_KHZ, FC0_RESULT),
-	regmap_reg_range(VIDEO_CLK_VEC_CTRL, VIDEO_CLK_VEC_DIV_INT),
-	regmap_reg_range(VIDEO_CLK_VEC_SEL, VIDEO_CLK_DPI_DIV_INT),
-	regmap_reg_range(VIDEO_CLK_DPI_SEL, VIDEO_CLK_MIPI1_DPI_SEL),
-};
+	[RP1_CLK_SLOW_SYS] = REGISTER_CLK(
+				.name = "clk_slow_sys",
+				.parents = {"xosc"},
+				.num_std_parents = 1,
+				.num_aux_parents = 0,
+				.ctrl_reg = CLK_SLOW_SYS_CTRL,
+				.div_int_reg = CLK_SLOW_SYS_DIV_INT,
+				.sel_reg = CLK_SLOW_SYS_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(1, 4),
+				.clk_src_mask = 0x1,
+				),
 
-static const struct regmap_access_table rp1_reg_table = {
-	.yes_ranges = rp1_reg_ranges,
-	.n_yes_ranges = ARRAY_SIZE(rp1_reg_ranges),
-};
+	[RP1_CLK_UART] = REGISTER_CLK(
+				.name = "clk_uart",
+				.parents = {"pll_sys_pri_ph",
+					    "pll_video",
+					    "xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 3,
+				.ctrl_reg = CLK_UART_CTRL,
+				.div_int_reg = CLK_UART_DIV_INT,
+				.sel_reg = CLK_UART_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(6, 7),
+				),
 
-static const struct regmap_config rp1_clk_regmap_cfg = {
-	.reg_bits = 32,
-	.val_bits = 32,
-	.reg_stride = 4,
-	.max_register = PLL_VIDEO_SEC,
-	.name = "rp1-clk",
-	.rd_table = &rp1_reg_table,
-	.disable_locking = true,
+	[RP1_CLK_ETH] = REGISTER_CLK(
+				.name = "clk_eth",
+				.parents = {"-"},
+				.num_std_parents = 1,
+				.num_aux_parents = 0,
+				.ctrl_reg = CLK_ETH_CTRL,
+				.div_int_reg = CLK_ETH_DIV_INT,
+				.sel_reg = CLK_ETH_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(4, 6),
+				),
+
+	[RP1_CLK_PWM0] = REGISTER_CLK(
+				.name = "clk_pwm0",
+				.parents = {"pll_audio_pri_ph",
+					    "pll_video_sec",
+					    "xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 3,
+				.ctrl_reg = CLK_PWM0_CTRL,
+				.div_int_reg = CLK_PWM0_DIV_INT,
+				.div_frac_reg = CLK_PWM0_DIV_FRAC,
+				.sel_reg = CLK_PWM0_SEL,
+				.div_int_max = DIV_INT_16BIT_MAX,
+				.fc0_src = FC_NUM(0, 5),
+				),
+
+	[RP1_CLK_PWM1] = REGISTER_CLK(
+				.name = "clk_pwm1",
+				.parents = {"pll_audio_pri_ph",
+					    "pll_video_sec",
+					    "xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 3,
+				.ctrl_reg = CLK_PWM1_CTRL,
+				.div_int_reg = CLK_PWM1_DIV_INT,
+				.div_frac_reg = CLK_PWM1_DIV_FRAC,
+				.sel_reg = CLK_PWM1_SEL,
+				.div_int_max = DIV_INT_16BIT_MAX,
+				.fc0_src = FC_NUM(1, 5),
+				),
+
+	[RP1_CLK_AUDIO_IN] = REGISTER_CLK(
+				.name = "clk_audio_in",
+				.parents = {"-"},
+				.num_std_parents = 1,
+				.num_aux_parents = 0,
+				.ctrl_reg = CLK_AUDIO_IN_CTRL,
+				.div_int_reg = CLK_AUDIO_IN_DIV_INT,
+				.sel_reg = CLK_AUDIO_IN_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(2, 5),
+				),
+
+	[RP1_CLK_AUDIO_OUT] = REGISTER_CLK(
+				.name = "clk_audio_out",
+				.parents = {"-"},
+				.num_std_parents = 1,
+				.num_aux_parents = 0,
+				.ctrl_reg = CLK_AUDIO_OUT_CTRL,
+				.div_int_reg = CLK_AUDIO_OUT_DIV_INT,
+				.sel_reg = CLK_AUDIO_OUT_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(3, 5),
+				),
+
+	[RP1_CLK_I2S] = REGISTER_CLK(
+				.name = "clk_i2s",
+				.parents = {"xosc",
+					    "pll_audio",
+					    "pll_audio_sec"},
+				.num_std_parents = 0,
+				.num_aux_parents = 3,
+				.ctrl_reg = CLK_I2S_CTRL,
+				.div_int_reg = CLK_I2S_DIV_INT,
+				.sel_reg = CLK_I2S_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(4, 4),
+				),
+
+	[RP1_CLK_MIPI0_CFG] = REGISTER_CLK(
+				.name = "clk_mipi0_cfg",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_MIPI0_CFG_CTRL,
+				.div_int_reg = CLK_MIPI0_CFG_DIV_INT,
+				.sel_reg = CLK_MIPI0_CFG_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(4, 5),
+				),
+
+	[RP1_CLK_MIPI1_CFG] = REGISTER_CLK(
+				.name = "clk_mipi1_cfg",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_MIPI1_CFG_CTRL,
+				.div_int_reg = CLK_MIPI1_CFG_DIV_INT,
+				.sel_reg = CLK_MIPI1_CFG_SEL,
+				.clk_src_mask = 1,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(5, 6),
+				),
+
+	[RP1_CLK_ETH_TSU] = REGISTER_CLK(
+				.name = "clk_eth_tsu",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_ETH_TSU_CTRL,
+				.div_int_reg = CLK_ETH_TSU_DIV_INT,
+				.sel_reg = CLK_ETH_TSU_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(5, 7),
+				),
+
+	[RP1_CLK_ADC] = REGISTER_CLK(
+				.name = "clk_adc",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_ADC_CTRL,
+				.div_int_reg = CLK_ADC_DIV_INT,
+				.sel_reg = CLK_ADC_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(5, 5),
+				),
+
+	[RP1_CLK_SDIO_TIMER] = REGISTER_CLK(
+				.name = "clk_sdio_timer",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_SDIO_TIMER_CTRL,
+				.div_int_reg = CLK_SDIO_TIMER_DIV_INT,
+				.sel_reg = CLK_SDIO_TIMER_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(3, 4),
+				),
+
+	[RP1_CLK_SDIO_ALT_SRC] = REGISTER_CLK(
+				.name = "clk_sdio_alt_src",
+				.parents = {"pll_sys"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_SDIO_ALT_SRC_CTRL,
+				.div_int_reg = CLK_SDIO_ALT_SRC_DIV_INT,
+				.sel_reg = CLK_SDIO_ALT_SRC_SEL,
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(5, 4),
+				),
+
+	[RP1_CLK_GP0] = REGISTER_CLK(
+				.name = "clk_gp0",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_GP0_CTRL,
+				.div_int_reg = CLK_GP0_DIV_INT,
+				.div_frac_reg = CLK_GP0_DIV_FRAC,
+				.sel_reg = CLK_GP0_SEL,
+				.div_int_max = DIV_INT_16BIT_MAX,
+				.fc0_src = FC_NUM(0, 1),
+				),
+
+	[RP1_CLK_GP1] = REGISTER_CLK(
+				.name = "clk_gp1",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_GP1_CTRL,
+				.div_int_reg = CLK_GP1_DIV_INT,
+				.div_frac_reg = CLK_GP1_DIV_FRAC,
+				.sel_reg = CLK_GP1_SEL,
+				.div_int_max = DIV_INT_16BIT_MAX,
+				.fc0_src = FC_NUM(1, 1),
+				),
+
+	[RP1_CLK_GP2] = REGISTER_CLK(
+				.name = "clk_gp2",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_GP2_CTRL,
+				.div_int_reg = CLK_GP2_DIV_INT,
+				.div_frac_reg = CLK_GP2_DIV_FRAC,
+				.sel_reg = CLK_GP2_SEL,
+				.div_int_max = DIV_INT_16BIT_MAX,
+				.fc0_src = FC_NUM(2, 1),
+				),
+
+	[RP1_CLK_GP3] = REGISTER_CLK(
+				.name = "clk_gp3",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_GP3_CTRL,
+				.div_int_reg = CLK_GP3_DIV_INT,
+				.div_frac_reg = CLK_GP3_DIV_FRAC,
+				.sel_reg = CLK_GP3_SEL,
+				.div_int_max = DIV_INT_16BIT_MAX,
+				.fc0_src = FC_NUM(3, 1),
+				),
+
+	[RP1_CLK_GP4] = REGISTER_CLK(
+				.name = "clk_gp4",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_GP4_CTRL,
+				.div_int_reg = CLK_GP4_DIV_INT,
+				.div_frac_reg = CLK_GP4_DIV_FRAC,
+				.sel_reg = CLK_GP4_SEL,
+				.div_int_max = DIV_INT_16BIT_MAX,
+				.fc0_src = FC_NUM(4, 1),
+				),
+
+	[RP1_CLK_GP5] = REGISTER_CLK(
+				.name = "clk_gp5",
+				.parents = {"xosc"},
+				.num_std_parents = 0,
+				.num_aux_parents = 1,
+				.ctrl_reg = CLK_GP5_CTRL,
+				.div_int_reg = CLK_GP5_DIV_INT,
+				.div_frac_reg = CLK_GP5_DIV_FRAC,
+				.sel_reg = CLK_GP5_SEL,
+				.div_int_max = DIV_INT_16BIT_MAX,
+				.fc0_src = FC_NUM(5, 1),
+				),
+
+	[RP1_CLK_VEC] = REGISTER_CLK(
+				.name = "clk_vec",
+				.parents = {"pll_sys_pri_ph",
+					    "pll_video_sec",
+					    "pll_video",
+					    "clk_gp0",
+					    "clk_gp1",
+					    "clk_gp2",
+					    "clk_gp3",
+					    "clk_gp4"},
+				.num_std_parents = 0,
+				.num_aux_parents = 8, /* XXX in fact there are more than 8 */
+				.ctrl_reg = VIDEO_CLK_VEC_CTRL,
+				.div_int_reg = VIDEO_CLK_VEC_DIV_INT,
+				.sel_reg = VIDEO_CLK_VEC_SEL,
+				.flags = CLK_SET_RATE_NO_REPARENT, /* Let VEC driver set parent */
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(0, 6),
+				),
+
+	[RP1_CLK_DPI] = REGISTER_CLK(
+				.name = "clk_dpi",
+				.parents = {"pll_sys",
+					    "pll_video_sec",
+					    "pll_video",
+					    "clk_gp0",
+					    "clk_gp1",
+					    "clk_gp2",
+					    "clk_gp3",
+					    "clk_gp4"},
+				.num_std_parents = 0,
+				.num_aux_parents = 8, /* XXX in fact there are more than 8 */
+				.ctrl_reg = VIDEO_CLK_DPI_CTRL,
+				.div_int_reg = VIDEO_CLK_DPI_DIV_INT,
+				.sel_reg = VIDEO_CLK_DPI_SEL,
+				.flags = CLK_SET_RATE_NO_REPARENT, /* Let DPI driver set parent */
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(1, 6),
+				),
+
+	[RP1_CLK_MIPI0_DPI] = REGISTER_CLK(
+				.name = "clk_mipi0_dpi",
+				.parents = {"pll_sys",
+					    "pll_video_sec",
+					    "pll_video",
+					    "clksrc_mipi0_dsi_byteclk",
+					    "clk_gp0",
+					    "clk_gp1",
+					    "clk_gp2",
+					    "clk_gp3"},
+				.num_std_parents = 0,
+				.num_aux_parents = 8, /* XXX in fact there are more than 8 */
+				.ctrl_reg = VIDEO_CLK_MIPI0_DPI_CTRL,
+				.div_int_reg = VIDEO_CLK_MIPI0_DPI_DIV_INT,
+				.div_frac_reg = VIDEO_CLK_MIPI0_DPI_DIV_FRAC,
+				.sel_reg = VIDEO_CLK_MIPI0_DPI_SEL,
+				.flags = CLK_SET_RATE_NO_REPARENT, /* Let DSI driver set parent */
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(2, 6),
+				),
+
+	[RP1_CLK_MIPI1_DPI] = REGISTER_CLK(
+				.name = "clk_mipi1_dpi",
+				.parents = {"pll_sys",
+					    "pll_video_sec",
+					    "pll_video",
+					    "clksrc_mipi1_dsi_byteclk",
+					    "clk_gp0",
+					    "clk_gp1",
+					    "clk_gp2",
+					    "clk_gp3"},
+				.num_std_parents = 0,
+				.num_aux_parents = 8, /* XXX in fact there are more than 8 */
+				.ctrl_reg = VIDEO_CLK_MIPI1_DPI_CTRL,
+				.div_int_reg = VIDEO_CLK_MIPI1_DPI_DIV_INT,
+				.div_frac_reg = VIDEO_CLK_MIPI1_DPI_DIV_FRAC,
+				.sel_reg = VIDEO_CLK_MIPI1_DPI_SEL,
+				.flags = CLK_SET_RATE_NO_REPARENT, /* Let DSI driver set parent */
+				.div_int_max = DIV_INT_8BIT_MAX,
+				.fc0_src = FC_NUM(3, 6),
+				),
 };
 
+static bool rp1_clk_claimed[ARRAY_SIZE(clk_desc_array)];
+
+static bool rp1_clk_is_claimed(const char *name)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(clk_desc_array); i++) {
+		if (clk_desc_array[i].data) {
+			const char *clk_name = *(const char **)(clk_desc_array[i].data);
+
+			if (!strcmp(name, clk_name))
+				return rp1_clk_claimed[i];
+		}
+	}
+
+	return false;
+}
+
 static int rp1_clk_probe(struct platform_device *pdev)
 {
-	const size_t asize = ARRAY_SIZE(clk_desc_array);
-	struct rp1_clk_desc *desc;
+	const struct rp1_clk_desc *desc;
 	struct device *dev = &pdev->dev;
 	struct rp1_clockman *clockman;
+	struct resource *res;
 	struct clk_hw **hws;
+	const size_t asize = ARRAY_SIZE(clk_desc_array);
+	u32 chip_id, platform;
 	unsigned int i;
+	u32 clk_id;
+	int ret;
 
 	clockman = devm_kzalloc(dev, struct_size(clockman, onecell.hws, asize),
 				GFP_KERNEL);
 	if (!clockman)
 		return -ENOMEM;
 
+	rp1_get_platform(&chip_id, &platform);
+
 	spin_lock_init(&clockman->regs_lock);
 	clockman->dev = dev;
-
-	clockman->regs = devm_platform_ioremap_resource(pdev, 0);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	clockman->regs = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(clockman->regs))
 		return PTR_ERR(clockman->regs);
 
-	clockman->regmap = devm_regmap_init_mmio(dev, clockman->regs,
-						 &rp1_clk_regmap_cfg);
-	if (IS_ERR(clockman->regmap)) {
-		dev_err_probe(dev, PTR_ERR(clockman->regmap),
-			      "could not init clock regmap\n");
-		return PTR_ERR(clockman->regmap);
-	}
+	memset(rp1_clk_claimed, 0, sizeof(rp1_clk_claimed));
+	for (i = 0;
+	     !of_property_read_u32_index(pdev->dev.of_node, "claim-clocks",
+					 i, &clk_id);
+	     i++)
+		rp1_clk_claimed[clk_id] = true;
+
+	platform_set_drvdata(pdev, clockman);
 
 	clockman->onecell.num = asize;
 	hws = clockman->onecell.hws;
 
 	for (i = 0; i < asize; i++) {
-		desc = clk_desc_array[i];
-		if (desc && desc->clk_register && desc->data)
-			hws[i] = desc->clk_register(clockman, desc);
+		desc = &clk_desc_array[i];
+		if (desc->clk_register && desc->data)
+			hws[i] = desc->clk_register(clockman, desc->data);
 	}
 
-	platform_set_drvdata(pdev, clockman);
+	ret = of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,
+				     &clockman->onecell);
+	if (ret)
+		return ret;
 
-	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,
-					   &clockman->onecell);
+	return 0;
 }
 
 static const struct of_device_id rp1_clk_of_match[] = {
@@ -1486,9 +2074,12 @@
 	.probe = rp1_clk_probe,
 };
 
-module_platform_driver(rp1_clk_driver);
+static int __init __rp1_clk_driver_init(void)
+{
+	return platform_driver_register(&rp1_clk_driver);
+}
+postcore_initcall(__rp1_clk_driver_init);
 
 MODULE_AUTHOR("Naushir Patuck <naush@raspberrypi.com>");
-MODULE_AUTHOR("Andrea della Porta <andrea.porta@suse.com>");
 MODULE_DESCRIPTION("RP1 clock driver");
 MODULE_LICENSE("GPL");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.17-rc4/drivers/clk/clk-rp1-sdio.c linux-6.17-rc4/drivers/clk/clk-rp1-sdio.c
--- linux-6.17-rc4/drivers/clk/clk-rp1-sdio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17-rc4/drivers/clk/clk-rp1-sdio.c	2025-08-30 17:08:08.637806180 +0200
@@ -0,0 +1,600 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * SDIO clock driver for RP1
+ *
+ * Copyright (C) 2023 Raspberry Pi Ltd.
+ */
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+// Register    : MODE
+#define MODE        0x00000000
+#define MODE_BITS   0x70030000
+#define MODE_RESET  0x00000000
+// Field       : MODE_STEPS_PER_CYCLE
+#define MODE_STEPS_PER_CYCLE_RESET          0x0
+#define MODE_STEPS_PER_CYCLE_BITS           0x70000000
+#define MODE_STEPS_PER_CYCLE_MSB            30
+#define MODE_STEPS_PER_CYCLE_LSB            28
+#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_20 0x0
+#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_10 0x1
+#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_16 0x2
+#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_8  0x3
+#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_12 0x4
+#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_6  0x5
+#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_5  0x6
+#define MODE_STEPS_PER_CYCLE_VALUE_STEPS_4  0x7
+// Field       : MODE_SRC_SEL
+#define MODE_SRC_SEL_RESET                   0x0
+#define MODE_SRC_SEL_BITS                    0x00030000
+#define MODE_SRC_SEL_MSB                     17
+#define MODE_SRC_SEL_LSB                     16
+#define MODE_SRC_SEL_VALUE_STOP              0x0
+#define MODE_SRC_SEL_VALUE_CLK_ALT_SRC       0x1
+#define MODE_SRC_SEL_VALUE_PLL_SYS_VCO       0x2
+#define MODE_SRC_SEL_VALUE_PLL_SYS_VCO_AGAIN 0x3
+// Register    : FROMIP
+#define FROMIP        0x00000004
+#define FROMIP_BITS   0x0f9713ff
+#define FROMIP_RESET  0x00000000
+// Field       : FROMIP_TUNING_CCLK_SEL
+#define FROMIP_TUNING_CCLK_SEL_RESET  0x0
+#define FROMIP_TUNING_CCLK_SEL_BITS   0x0f000000
+#define FROMIP_TUNING_CCLK_SEL_MSB    27
+#define FROMIP_TUNING_CCLK_SEL_LSB    24
+// Field       : FROMIP_TUNING_CCLK_UPDATE
+#define FROMIP_TUNING_CCLK_UPDATE_RESET  0x0
+#define FROMIP_TUNING_CCLK_UPDATE_BITS   0x00800000
+#define FROMIP_TUNING_CCLK_UPDATE_MSB    23
+#define FROMIP_TUNING_CCLK_UPDATE_LSB    23
+// Field       : FROMIP_SAMPLE_CCLK_SEL
+#define FROMIP_SAMPLE_CCLK_SEL_RESET  0x0
+#define FROMIP_SAMPLE_CCLK_SEL_BITS   0x00100000
+#define FROMIP_SAMPLE_CCLK_SEL_MSB    20
+#define FROMIP_SAMPLE_CCLK_SEL_LSB    20
+// Field       : FROMIP_CLK2CARD_ON
+#define FROMIP_CLK2CARD_ON_RESET  0x0
+#define FROMIP_CLK2CARD_ON_BITS   0x00040000
+#define FROMIP_CLK2CARD_ON_MSB    18
+#define FROMIP_CLK2CARD_ON_LSB    18
+// Field       : FROMIP_CARD_CLK_STABLE
+#define FROMIP_CARD_CLK_STABLE_RESET  0x0
+#define FROMIP_CARD_CLK_STABLE_BITS   0x00020000
+#define FROMIP_CARD_CLK_STABLE_MSB    17
+#define FROMIP_CARD_CLK_STABLE_LSB    17
+// Field       : FROMIP_CARD_CLK_EN
+#define FROMIP_CARD_CLK_EN_RESET  0x0
+#define FROMIP_CARD_CLK_EN_BITS   0x00010000
+#define FROMIP_CARD_CLK_EN_MSB    16
+#define FROMIP_CARD_CLK_EN_LSB    16
+// Field       : FROMIP_CLK_GEN_SEL
+#define FROMIP_CLK_GEN_SEL_RESET  0x0
+#define FROMIP_CLK_GEN_SEL_BITS   0x00001000
+#define FROMIP_CLK_GEN_SEL_MSB    12
+#define FROMIP_CLK_GEN_SEL_LSB    12
+// Field       : FROMIP_FREQ_SEL
+#define FROMIP_FREQ_SEL_RESET  0x000
+#define FROMIP_FREQ_SEL_BITS   0x000003ff
+#define FROMIP_FREQ_SEL_MSB    9
+#define FROMIP_FREQ_SEL_LSB    0
+// Register    : LOCAL
+#define LOCAL        0x00000008
+#define LOCAL_BITS   0x1f9713ff
+#define LOCAL_RESET  0x00000000
+// Field       : LOCAL_TUNING_CCLK_SEL
+#define LOCAL_TUNING_CCLK_SEL_RESET  0x00
+#define LOCAL_TUNING_CCLK_SEL_BITS   0x1f000000
+#define LOCAL_TUNING_CCLK_SEL_MSB    28
+#define LOCAL_TUNING_CCLK_SEL_LSB    24
+// Field       : LOCAL_TUNING_CCLK_UPDATE
+#define LOCAL_TUNING_CCLK_UPDATE_RESET  0x0
+#define LOCAL_TUNING_CCLK_UPDATE_BITS   0x00800000
+#define LOCAL_TUNING_CCLK_UPDATE_MSB    23
+#define LOCAL_TUNING_CCLK_UPDATE_LSB    23
+// Field       : LOCAL_SAMPLE_CCLK_SEL
+#define LOCAL_SAMPLE_CCLK_SEL_RESET  0x0
+#define LOCAL_SAMPLE_CCLK_SEL_BITS   0x00100000
+#define LOCAL_SAMPLE_CCLK_SEL_MSB    20
+#define LOCAL_SAMPLE_CCLK_SEL_LSB    20
+// Field       : LOCAL_CLK2CARD_ON
+#define LOCAL_CLK2CARD_ON_RESET  0x0
+#define LOCAL_CLK2CARD_ON_BITS   0x00040000
+#define LOCAL_CLK2CARD_ON_MSB    18
+#define LOCAL_CLK2CARD_ON_LSB    18
+// Field       : LOCAL_CARD_CLK_STABLE
+#define LOCAL_CARD_CLK_STABLE_RESET  0x0
+#define LOCAL_CARD_CLK_STABLE_BITS   0x00020000
+#define LOCAL_CARD_CLK_STABLE_MSB    17
+#define LOCAL_CARD_CLK_STABLE_LSB    17
+// Field       : LOCAL_CARD_CLK_EN
+#define LOCAL_CARD_CLK_EN_RESET  0x0
+#define LOCAL_CARD_CLK_EN_BITS   0x00010000
+#define LOCAL_CARD_CLK_EN_MSB    16
+#define LOCAL_CARD_CLK_EN_LSB    16
+// Field       : LOCAL_CLK_GEN_SEL
+#define LOCAL_CLK_GEN_SEL_RESET               0x0
+#define LOCAL_CLK_GEN_SEL_BITS                0x00001000
+#define LOCAL_CLK_GEN_SEL_MSB                 12
+#define LOCAL_CLK_GEN_SEL_LSB                 12
+#define LOCAL_CLK_GEN_SEL_VALUE_PROGCLOCKMODE 0x0
+#define LOCAL_CLK_GEN_SEL_VALUE_DIVCLOCKMODE  0x1
+// Field       : LOCAL_FREQ_SEL
+#define LOCAL_FREQ_SEL_RESET  0x000
+#define LOCAL_FREQ_SEL_BITS   0x000003ff
+#define LOCAL_FREQ_SEL_MSB    9
+#define LOCAL_FREQ_SEL_LSB    0
+// Register    : USE_LOCAL
+#define USE_LOCAL        0x0000000c
+#define USE_LOCAL_BITS   0x01951001
+#define USE_LOCAL_RESET  0x00000000
+// Field       : USE_LOCAL_TUNING_CCLK_SEL
+#define USE_LOCAL_TUNING_CCLK_SEL_RESET  0x0
+#define USE_LOCAL_TUNING_CCLK_SEL_BITS   0x01000000
+#define USE_LOCAL_TUNING_CCLK_SEL_MSB    24
+#define USE_LOCAL_TUNING_CCLK_SEL_LSB    24
+// Field       : USE_LOCAL_TUNING_CCLK_UPDATE
+#define USE_LOCAL_TUNING_CCLK_UPDATE_RESET  0x0
+#define USE_LOCAL_TUNING_CCLK_UPDATE_BITS   0x00800000
+#define USE_LOCAL_TUNING_CCLK_UPDATE_MSB    23
+#define USE_LOCAL_TUNING_CCLK_UPDATE_LSB    23
+// Field       : USE_LOCAL_SAMPLE_CCLK_SEL
+#define USE_LOCAL_SAMPLE_CCLK_SEL_RESET  0x0
+#define USE_LOCAL_SAMPLE_CCLK_SEL_BITS   0x00100000
+#define USE_LOCAL_SAMPLE_CCLK_SEL_MSB    20
+#define USE_LOCAL_SAMPLE_CCLK_SEL_LSB    20
+// Field       : USE_LOCAL_CLK2CARD_ON
+#define USE_LOCAL_CLK2CARD_ON_RESET  0x0
+#define USE_LOCAL_CLK2CARD_ON_BITS   0x00040000
+#define USE_LOCAL_CLK2CARD_ON_MSB    18
+#define USE_LOCAL_CLK2CARD_ON_LSB    18
+// Field       : USE_LOCAL_CARD_CLK_EN
+#define USE_LOCAL_CARD_CLK_EN_RESET  0x0
+#define USE_LOCAL_CARD_CLK_EN_BITS   0x00010000
+#define USE_LOCAL_CARD_CLK_EN_MSB    16
+#define USE_LOCAL_CARD_CLK_EN_LSB    16
+// Field       : USE_LOCAL_CLK_GEN_SEL
+#define USE_LOCAL_CLK_GEN_SEL_RESET  0x0
+#define USE_LOCAL_CLK_GEN_SEL_BITS   0x00001000
+#define USE_LOCAL_CLK_GEN_SEL_MSB    12
+#define USE_LOCAL_CLK_GEN_SEL_LSB    12
+// Field       : USE_LOCAL_FREQ_SEL
+#define USE_LOCAL_FREQ_SEL_RESET  0x0
+#define USE_LOCAL_FREQ_SEL_BITS   0x00000001
+#define USE_LOCAL_FREQ_SEL_MSB    0
+#define USE_LOCAL_FREQ_SEL_LSB    0
+// Register    : SD_DELAY
+#define SD_DELAY        0x00000010
+#define SD_DELAY_BITS   0x0000001f
+#define SD_DELAY_RESET  0x00000000
+// Field       : SD_DELAY_STEPS
+#define SD_DELAY_STEPS_RESET  0x00
+#define SD_DELAY_STEPS_BITS   0x0000001f
+#define SD_DELAY_STEPS_MSB    4
+#define SD_DELAY_STEPS_LSB    0
+// Register    : RX_DELAY
+#define RX_DELAY        0x00000014
+#define RX_DELAY_BITS   0x19f3331f
+#define RX_DELAY_RESET  0x00000000
+// Field       : RX_DELAY_BYPASS
+#define RX_DELAY_BYPASS_RESET  0x0
+#define RX_DELAY_BYPASS_BITS   0x10000000
+#define RX_DELAY_BYPASS_MSB    28
+#define RX_DELAY_BYPASS_LSB    28
+// Field       : RX_DELAY_FAIL_ACTUAL
+#define RX_DELAY_FAIL_ACTUAL_RESET  0x0
+#define RX_DELAY_FAIL_ACTUAL_BITS   0x08000000
+#define RX_DELAY_FAIL_ACTUAL_MSB    27
+#define RX_DELAY_FAIL_ACTUAL_LSB    27
+// Field       : RX_DELAY_ACTUAL
+#define RX_DELAY_ACTUAL_RESET  0x00
+#define RX_DELAY_ACTUAL_BITS   0x01f00000
+#define RX_DELAY_ACTUAL_MSB    24
+#define RX_DELAY_ACTUAL_LSB    20
+// Field       : RX_DELAY_OFFSET
+#define RX_DELAY_OFFSET_RESET  0x0
+#define RX_DELAY_OFFSET_BITS   0x00030000
+#define RX_DELAY_OFFSET_MSB    17
+#define RX_DELAY_OFFSET_LSB    16
+// Field       : RX_DELAY_OVERFLOW
+#define RX_DELAY_OVERFLOW_RESET       0x0
+#define RX_DELAY_OVERFLOW_BITS        0x00003000
+#define RX_DELAY_OVERFLOW_MSB         13
+#define RX_DELAY_OVERFLOW_LSB         12
+#define RX_DELAY_OVERFLOW_VALUE_ALLOW 0x0
+#define RX_DELAY_OVERFLOW_VALUE_CLAMP 0x1
+#define RX_DELAY_OVERFLOW_VALUE_FAIL  0x2
+// Field       : RX_DELAY_MAP
+#define RX_DELAY_MAP_RESET         0x0
+#define RX_DELAY_MAP_BITS          0x00000300
+#define RX_DELAY_MAP_MSB           9
+#define RX_DELAY_MAP_LSB           8
+#define RX_DELAY_MAP_VALUE_DIRECT  0x0
+#define RX_DELAY_MAP_VALUE         0x1
+#define RX_DELAY_MAP_VALUE_STRETCH 0x2
+// Field       : RX_DELAY_FIXED
+#define RX_DELAY_FIXED_RESET  0x00
+#define RX_DELAY_FIXED_BITS   0x0000001f
+#define RX_DELAY_FIXED_MSB    4
+#define RX_DELAY_FIXED_LSB    0
+// Register    : NDIV
+#define NDIV        0x00000018
+#define NDIV_BITS   0x1fff0000
+#define NDIV_RESET  0x00110000
+// Field       : NDIV_DIVB
+#define NDIV_DIVB_RESET  0x001
+#define NDIV_DIVB_BITS   0x1ff00000
+#define NDIV_DIVB_MSB    28
+#define NDIV_DIVB_LSB    20
+// Field       : NDIV_DIVA
+#define NDIV_DIVA_RESET  0x1
+#define NDIV_DIVA_BITS   0x000f0000
+#define NDIV_DIVA_MSB    19
+#define NDIV_DIVA_LSB    16
+// Register    : CS
+#define CS        0x0000001c
+#define CS_BITS   0x00111101
+#define CS_RESET  0x00000001
+// Field       : CS_RX_DEL_UPDATED
+#define CS_RX_DEL_UPDATED_RESET  0x0
+#define CS_RX_DEL_UPDATED_BITS   0x00100000
+#define CS_RX_DEL_UPDATED_MSB    20
+#define CS_RX_DEL_UPDATED_LSB    20
+// Field       : CS_RX_CLK_RUNNING
+#define CS_RX_CLK_RUNNING_RESET  0x0
+#define CS_RX_CLK_RUNNING_BITS   0x00010000
+#define CS_RX_CLK_RUNNING_MSB    16
+#define CS_RX_CLK_RUNNING_LSB    16
+// Field       : CS_SD_CLK_RUNNING
+#define CS_SD_CLK_RUNNING_RESET  0x0
+#define CS_SD_CLK_RUNNING_BITS   0x00001000
+#define CS_SD_CLK_RUNNING_MSB    12
+#define CS_SD_CLK_RUNNING_LSB    12
+// Field       : CS_TX_CLK_RUNNING
+#define CS_TX_CLK_RUNNING_RESET  0x0
+#define CS_TX_CLK_RUNNING_BITS   0x00000100
+#define CS_TX_CLK_RUNNING_MSB    8
+#define CS_TX_CLK_RUNNING_LSB    8
+// Field       : CS_RESET
+#define CS_RESET_RESET  0x1
+#define CS_RESET_BITS   0x00000001
+#define CS_RESET_MSB    0
+#define CS_RESET_LSB    0
+
+#define FPGA_SRC_RATE 400000000
+
+/* Base number of steps to delay in relation to tx clk.
+ * The relationship of the 3 clocks are as follows:
+ * tx_clk: This clock is provided to the controller. Data is sent out
+ * to the pads using this clock.
+ * sd_clk: This clock is sent out to the card.
+ * rx_clk: This clock is used to sample the data coming back from the card.
+ * This may need to be several steps ahead of the tx_clk. The default rx delay
+ * is used as a base delay, and can be further adjusted by the sd host
+ * controller during the tuning process if using a DDR50 or faster SD card
+ */
+/*
+ * PRJY-1813 - the default SD clock delay needs to be set to ~60% of the total
+ * number of steps to meet tISU (>6ns) and tIH (>2ns) in high-speed mode.
+ * On FPGA this means delay SDCLK by 5, and sample RX with a delay of 6.
+ */
+#define DEFAULT_RX_DELAY 6
+#define DEFAULT_SD_DELAY 5
+
+struct rp1_sdio_clkgen {
+	struct device *dev;
+
+	/* Source clock. Either PLL VCO or fixed freq on FPGA */
+	struct clk *src_clk;
+	/* Desired base frequency. Max freq card can go */
+	struct clk *base_clk;
+
+	struct clk_hw hw;
+	void __iomem *regs;
+
+	/* Starting value of local register before changing freq */
+	u32 local_base;
+};
+
+static inline void clkgen_write(struct rp1_sdio_clkgen *clkgen, u32 reg, u32 val)
+{
+	dev_dbg(clkgen->dev, "%s: write reg 0x%x: 0x%x\n", __func__, reg, val);
+	writel(val, clkgen->regs + reg);
+}
+
+static inline u32 clkgen_read(struct rp1_sdio_clkgen *clkgen, u32 reg)
+{
+	u32 val = readl(clkgen->regs + reg);
+
+	dev_dbg(clkgen->dev, "%s: read reg 0x%x: 0x%x\n", __func__, reg, val);
+	return val;
+}
+
+static int get_steps(unsigned int steps)
+{
+	int ret = -1;
+
+	if (steps == 4)
+		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_4;
+	else if (steps == 5)
+		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_5;
+	else if (steps == 6)
+		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_6;
+	else if (steps == 8)
+		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_8;
+	else if (steps == 10)
+		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_10;
+	else if (steps == 12)
+		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_12;
+	else if (steps == 16)
+		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_16;
+	else if (steps == 20)
+		ret = MODE_STEPS_PER_CYCLE_VALUE_STEPS_20;
+	return ret;
+}
+
+static int rp1_sdio_clk_init(struct rp1_sdio_clkgen *clkgen)
+{
+	unsigned long src_rate = clk_get_rate(clkgen->src_clk);
+	unsigned long base_rate = clk_get_rate(clkgen->base_clk);
+	unsigned int steps = src_rate / base_rate;
+	u32 reg = 0;
+	int steps_value = 0;
+
+	dev_dbg(clkgen->dev, "init: src_rate %lu, base_rate %lu, steps %d\n",
+		src_rate, base_rate, steps);
+
+	/* Assert reset while we set up clkgen */
+	clkgen_write(clkgen, CS, CS_RESET_BITS);
+
+	/* Pick clock source */
+	if (src_rate == FPGA_SRC_RATE) {
+		/* Using ALT SRC */
+		reg |= MODE_SRC_SEL_VALUE_CLK_ALT_SRC << MODE_SRC_SEL_LSB;
+	} else {
+		/* Assume we are using PLL SYS VCO */
+		reg |= MODE_SRC_SEL_VALUE_PLL_SYS_VCO << MODE_SRC_SEL_LSB;
+	}
+
+	/* How many delay steps are available in one cycle for this source */
+	steps_value = get_steps(steps);
+	if (steps_value < 0) {
+		dev_err(clkgen->dev, "Invalid step value: %d\n", steps);
+		return -EINVAL;
+	}
+	reg |= steps_value << MODE_STEPS_PER_CYCLE_LSB;
+
+	/* Mode register is done now*/
+	clkgen_write(clkgen, MODE, reg);
+
+	/* Now set delay mode */
+	/* Clamp value if out of range rx delay is used */
+	reg = RX_DELAY_OVERFLOW_VALUE_CLAMP << RX_DELAY_OVERFLOW_LSB;
+	/* SD tuning bus goes from 0x0 to 0xf but we don't necessarily have that
+	 * many steps available depending on the source so map 0x0 -> 0xf to one
+	 * cycle of rx delay
+	 */
+	reg |= RX_DELAY_MAP_VALUE_STRETCH << RX_DELAY_MAP_LSB;
+
+	/* Default RX delay */
+	dev_dbg(clkgen->dev, "default rx delay %d\n", DEFAULT_RX_DELAY);
+	reg |= (DEFAULT_RX_DELAY & RX_DELAY_FIXED_BITS) << RX_DELAY_FIXED_LSB;
+	clkgen_write(clkgen, RX_DELAY, reg);
+
+	/* Default SD delay */
+	dev_dbg(clkgen->dev, "default sd delay %d\n", DEFAULT_SD_DELAY);
+	reg = (DEFAULT_SD_DELAY & SD_DELAY_STEPS_BITS) << SD_DELAY_STEPS_LSB;
+	clkgen_write(clkgen, SD_DELAY, reg);
+
+	/* We select freq, we turn on tx clock, we turn on sd clk,
+	 * we pick clock generator mode
+	 */
+	reg = USE_LOCAL_FREQ_SEL_BITS | USE_LOCAL_CARD_CLK_EN_BITS |
+	      USE_LOCAL_CLK2CARD_ON_BITS | USE_LOCAL_CLK_GEN_SEL_BITS;
+	clkgen_write(clkgen, USE_LOCAL, reg);
+
+	/* Deassert reset. Reset bit is only writable bit of CS
+	 * reg so fine to write a 0.
+	 */
+	clkgen_write(clkgen, CS, 0);
+
+	return 0;
+}
+
+#define RUNNING	\
+	(CS_TX_CLK_RUNNING_BITS | CS_RX_CLK_RUNNING_BITS | \
+	 CS_SD_CLK_RUNNING_BITS)
+static int rp1_sdio_clk_is_prepared(struct clk_hw *hw)
+{
+	struct rp1_sdio_clkgen *clkgen =
+		container_of(hw, struct rp1_sdio_clkgen, hw);
+	u32 status;
+
+	dev_dbg(clkgen->dev, "is_prepared\n");
+	status = clkgen_read(clkgen, CS);
+	return ((status & RUNNING) == RUNNING);
+}
+
+/* Can define an additional divider if an sd card isn't working at full speed */
+/* #define SLOWDOWN 3 */
+
+static unsigned long rp1_sdio_clk_get_rate(struct clk_hw *hw,
+					   unsigned long parent_rate)
+{
+	/* Get the current rate */
+	struct rp1_sdio_clkgen *clkgen =
+		container_of(hw, struct rp1_sdio_clkgen, hw);
+	unsigned long actual_rate = 0;
+	u32 ndiv_diva;
+	u32 ndiv_divb;
+	u32 tmp;
+	u32 div;
+
+	tmp = clkgen_read(clkgen, LOCAL);
+	if ((tmp & LOCAL_CLK2CARD_ON_BITS) == 0) {
+		dev_dbg(clkgen->dev, "get_rate 0\n");
+		return 0;
+	}
+
+	tmp = clkgen_read(clkgen, NDIV);
+	ndiv_diva = (tmp & NDIV_DIVA_BITS) >> NDIV_DIVA_LSB;
+	ndiv_divb = (tmp & NDIV_DIVB_BITS) >> NDIV_DIVB_LSB;
+	div = ndiv_diva * ndiv_divb;
+	actual_rate = (clk_get_rate(clkgen->base_clk) / div);
+
+#ifdef SLOWDOWN
+	actual_rate *= SLOWDOWN;
+#endif
+
+	dev_dbg(clkgen->dev, "get_rate. ndiv_diva %d, ndiv_divb %d = %lu\n",
+		ndiv_diva, ndiv_divb, actual_rate);
+
+	return actual_rate;
+}
+
+static int rp1_sdio_clk_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct rp1_sdio_clkgen *clkgen =
+		container_of(hw, struct rp1_sdio_clkgen, hw);
+	u32 div;
+	u32 reg;
+
+	dev_dbg(clkgen->dev, "set_rate %lu\n", rate);
+
+	if (rate == 0) {
+		/* Keep tx clock running */
+		clkgen_write(clkgen, LOCAL, LOCAL_CARD_CLK_EN_BITS);
+		return 0;
+	}
+
+#ifdef SLOWDOWN
+	rate /= SLOWDOWN;
+#endif
+
+	div = (clk_get_rate(clkgen->base_clk) / rate) - 1;
+	reg = LOCAL_CLK_GEN_SEL_BITS | LOCAL_CARD_CLK_EN_BITS |
+	      LOCAL_CLK2CARD_ON_BITS | (div << LOCAL_FREQ_SEL_LSB);
+	clkgen_write(clkgen, LOCAL, reg);
+
+	return 0;
+}
+
+#define MAX_NDIV (256 * 8)
+static int rp1_sdio_clk_determine_rate(struct clk_hw *hw,
+				       struct clk_rate_request *req)
+{
+	unsigned long rate;
+	struct rp1_sdio_clkgen *clkgen =
+		container_of(hw, struct rp1_sdio_clkgen, hw);
+	unsigned long base_rate = clk_get_rate(clkgen->base_clk);
+	u32 div;
+
+	/* What is the actual rate I can get if I request xyz */
+	if (req->rate) {
+		div = min((u32)(base_rate / req->rate), (u32)MAX_NDIV);
+		rate = base_rate / div;
+		req->rate = rate;
+		dev_dbg(clkgen->dev, "determine_rate %lu: %lu / %d = %lu\n",
+			req->rate, base_rate, div, rate);
+	} else {
+		rate = 0;
+		dev_dbg(clkgen->dev, "determine_rate %lu: %lu\n", req->rate,
+			rate);
+	}
+
+	return 0;
+}
+
+static const struct clk_ops rp1_sdio_clk_ops = {
+	.is_prepared    = rp1_sdio_clk_is_prepared,
+	.recalc_rate    = rp1_sdio_clk_get_rate,
+	.set_rate       = rp1_sdio_clk_set_rate,
+	.determine_rate = rp1_sdio_clk_determine_rate,
+};
+
+static int rp1_sdio_clk_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct rp1_sdio_clkgen *clkgen;
+	void __iomem *regs;
+	struct clk_init_data init = {};
+	int ret;
+
+	clkgen = devm_kzalloc(&pdev->dev, sizeof(*clkgen), GFP_KERNEL);
+	if (!clkgen)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, clkgen);
+
+	clkgen->dev = &pdev->dev;
+
+	/* Source freq */
+	clkgen->src_clk = devm_clk_get(&pdev->dev, "src");
+	if (IS_ERR(clkgen->src_clk)) {
+		int err = PTR_ERR(clkgen->src_clk);
+
+		dev_err(&pdev->dev, "failed to get src clk: %d\n", err);
+		return err;
+	}
+
+	/* Desired maximum output freq (i.e. base freq) */
+	clkgen->base_clk = devm_clk_get(&pdev->dev, "base");
+	if (IS_ERR(clkgen->base_clk)) {
+		int err = PTR_ERR(clkgen->base_clk);
+
+		dev_err(&pdev->dev, "failed to get base clk: %d\n", err);
+		return err;
+	}
+
+	regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	init.name = node->name;
+	init.ops = &rp1_sdio_clk_ops;
+	init.flags = CLK_GET_RATE_NOCACHE;
+
+	clkgen->hw.init = &init;
+	clkgen->regs = regs;
+
+	dev_info(&pdev->dev, "loaded %s\n", init.name);
+
+	ret = devm_clk_hw_register(&pdev->dev, &clkgen->hw);
+	if (ret)
+		return ret;
+
+	ret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, &clkgen->hw);
+	if (ret)
+		return ret;
+
+	ret = rp1_sdio_clk_init(clkgen);
+	return ret;
+}
+
+static void rp1_sdio_clk_remove(struct platform_device *pdev)
+{
+
+}
+
+static const struct of_device_id rp1_sdio_clk_dt_ids[] = {
+	{ .compatible = "raspberrypi,rp1-sdio-clk", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rp1_sdio_clk_dt_ids);
+
+static struct platform_driver rp1_sdio_clk_driver = {
+	.probe	= rp1_sdio_clk_probe,
+	.remove	= rp1_sdio_clk_remove,
+	.driver	= {
+		.name		= "rp1-sdio-clk",
+		.of_match_table	= rp1_sdio_clk_dt_ids,
+	},
+};
+module_platform_driver(rp1_sdio_clk_driver);
+
+MODULE_AUTHOR("Liam Fraser <liam@raspberrypi.com>");
+MODULE_DESCRIPTION("RP1 SDIO clock driver");
+MODULE_LICENSE("GPL");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.17-rc4/drivers/clk/Kconfig linux-6.17-rc4/drivers/clk/Kconfig
--- linux-6.17-rc4/drivers/clk/Kconfig	2025-09-01 00:33:07.000000000 +0200
+++ linux-6.17-rc4/drivers/clk/Kconfig	2025-09-04 17:07:24.471142014 +0200
@@ -96,6 +96,19 @@
 	  This multi-function device has 3 main PLLs and several clock
 	  generators to drive the internal sub-peripherals.
 
+config COMMON_CLK_RP1
+	tristate "Raspberry Pi RP1-based clock support"
+	depends on PCI || COMPILE_TEST
+	depends on COMMON_CLK
+	help
+	  Enable common clock framework support for Raspberry Pi RP1
+
+config COMMON_CLK_RP1_SDIO
+	tristate "Clock driver for the RP1 SDIO interfaces"
+	depends on MFD_RP1
+	help
+	  SDIO clock driver for the RP1 support chip
+
 config COMMON_CLK_HI655X
 	tristate "Clock driver for Hi655x" if EXPERT
 	depends on (MFD_HI655X_PMIC || COMPILE_TEST)
diff --speed-large-files --no-dereference --minimal -Naur linux-6.17-rc4/drivers/clk/Makefile linux-6.17-rc4/drivers/clk/Makefile
--- linux-6.17-rc4/drivers/clk/Makefile	2025-09-01 00:33:07.000000000 +0200
+++ linux-6.17-rc4/drivers/clk/Makefile	2025-09-04 17:09:24.394475728 +0200
@@ -86,6 +86,7 @@
 obj-$(CONFIG_CLK_QORIQ)			+= clk-qoriq.o
 obj-$(CONFIG_COMMON_CLK_RK808)		+= clk-rk808.o
 obj-$(CONFIG_COMMON_CLK_RP1)            += clk-rp1.o
+obj-$(CONFIG_COMMON_CLK_RP1_SDIO)	+= clk-rp1-sdio.o
 obj-$(CONFIG_COMMON_CLK_HI655X)		+= clk-hi655x.o
 obj-$(CONFIG_COMMON_CLK_S2MPS11)	+= clk-s2mps11.o
 obj-$(CONFIG_COMMON_CLK_SCMI)           += clk-scmi.o
diff --speed-large-files --no-dereference --minimal -Naur linux-6.17-rc4/include/dt-bindings/clock/rp1.h linux-6.17-rc4/include/dt-bindings/clock/rp1.h
--- linux-6.17-rc4/include/dt-bindings/clock/rp1.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17-rc4/include/dt-bindings/clock/rp1.h	2025-09-04 17:07:24.471142014 +0200
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2021 Raspberry Pi Ltd.
+ */
+
+#define RP1_PLL_SYS_CORE		0
+#define RP1_PLL_AUDIO_CORE		1
+#define RP1_PLL_VIDEO_CORE		2
+
+#define RP1_PLL_SYS			3
+#define RP1_PLL_AUDIO			4
+#define RP1_PLL_VIDEO			5
+
+#define RP1_PLL_SYS_PRI_PH		6
+#define RP1_PLL_SYS_SEC_PH		7
+#define RP1_PLL_AUDIO_PRI_PH		8
+
+#define RP1_PLL_SYS_SEC			9
+#define RP1_PLL_AUDIO_SEC		10
+#define RP1_PLL_VIDEO_SEC		11
+
+#define RP1_CLK_SYS			12
+#define RP1_CLK_SLOW_SYS		13
+#define RP1_CLK_DMA			14
+#define RP1_CLK_UART			15
+#define RP1_CLK_ETH			16
+#define RP1_CLK_PWM0			17
+#define RP1_CLK_PWM1			18
+#define RP1_CLK_AUDIO_IN		19
+#define RP1_CLK_AUDIO_OUT		20
+#define RP1_CLK_I2S			21
+#define RP1_CLK_MIPI0_CFG		22
+#define RP1_CLK_MIPI1_CFG		23
+#define RP1_CLK_PCIE_AUX		24
+#define RP1_CLK_USBH0_MICROFRAME	25
+#define RP1_CLK_USBH1_MICROFRAME	26
+#define RP1_CLK_USBH0_SUSPEND		27
+#define RP1_CLK_USBH1_SUSPEND		28
+#define RP1_CLK_ETH_TSU			29
+#define RP1_CLK_ADC			30
+#define RP1_CLK_SDIO_TIMER		31
+#define RP1_CLK_SDIO_ALT_SRC		32
+#define RP1_CLK_GP0			33
+#define RP1_CLK_GP1			34
+#define RP1_CLK_GP2			35
+#define RP1_CLK_GP3			36
+#define RP1_CLK_GP4			37
+#define RP1_CLK_GP5			38
+#define RP1_CLK_VEC			39
+#define RP1_CLK_DPI			40
+#define RP1_CLK_MIPI0_DPI		41
+#define RP1_CLK_MIPI1_DPI		42
diff --speed-large-files --no-dereference --minimal -Naur linux-6.17-rc4/include/linux/rp1_platform.h linux-6.17-rc4/include/linux/rp1_platform.h
--- linux-6.17-rc4/include/linux/rp1_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17-rc4/include/linux/rp1_platform.h	2025-09-04 17:07:24.471142014 +0200
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021-2022 Raspberry Pi Ltd.
+ * All rights reserved.
+ */
+
+#ifndef _RP1_PLATFORM_H
+#define _RP1_PLATFORM_H
+
+#include <vdso/bits.h>
+
+#define RP1_B0_CHIP_ID 0x10001927
+#define RP1_C0_CHIP_ID 0x20001927
+
+#define RP1_PLATFORM_ASIC BIT(1)
+#define RP1_PLATFORM_FPGA BIT(0)
+
+void rp1_get_platform(u32 *chip_id, u32 *platform);
+
+#endif
