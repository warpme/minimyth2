#!/bin/sh
################################################################################
# functions
################################################################################
. /etc/conf

/usr/bin/test "${MM_DEBUG}" = "yes" && set -x

mysql_bin="/usr/bin/mysql --skip-ssl "

#===============================================================================
# general functions.
#===============================================================================
mm_command_run() {
    local COMMAND=$1

    local LOG_DIR
    local LOG_FILE
    local RETURN

    if [ "x${MM_DEBUG}" = "xyes" ] ; then
        LOG_DIR="/var/log"
        LOG_FILE="/var/log/minimyth.log"
        if [ ! -e "${LOG_FILE}" ] && [ -w "${LOG_DIR}" ] ; then
            /bin/touch "${LOG_FILE}"
            /bin/chmod 0666 "${LOG_FILE}"
        fi
    else
        LOG_DIR="/dev"
        LOG_FILE="/dev/null"
    fi

    RETURN=0
    if [ -w "${LOG_FILE}" ] ; then
        /bin/echo "--- execution start: ${COMMAND}"  >> "${LOG_FILE}" 2>&1
        ${COMMAND}                                   >> "${LOG_FILE}" 2>&1
        RETURN=$?
        /bin/echo "--- execution end  : ${COMMAND}"  >> "${LOG_FILE}" 2>&1
    else
        /bin/echo "--- execution start: ${COMMAND}"                   2>&1
        ${COMMAND}                                                    2>&1
        RETURN=$?
        /bin/echo "--- execution end  : ${COMMAND}"                   2>&1
    fi

    /usr/bin/test ${RETURN} -eq 0
    return
}

this_script_done() {
    local script
    local exec_time

    script="$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")" #"

    if [ -e /var/init/${script}.inprogress ] ; then
        exec_time=$(echo "$(date +%s.%N) - $(stat --format='%.9Y' /var/init/${script}.inprogress)" | bc) #"
        echo "${script}: took ${exec_time} sec" >> /var/log/init-script-durations.log

        rm /var/init/${script}.inprogress

        /usr/bin/logger -s -t minimyth -p "local0.info" "[init.d/${script}] Ended, rc=0, took ${exec_time}sec"
    fi

    return 0
}

#===============================================================================
# minimyth.conf functions.
#===============================================================================
mm_minimyth_conf_include() {
    local REMOTE_FILE=$1

    local LOCAL_FILE

    LOCAL_FILE="/etc/minimyth.d/${REMOTE_FILE}"
    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`

    /usr/bin/test ! -e "${LOCAL_FILE}" && mm_confro_get "${REMOTE_FILE}" "${LOCAL_FILE}"
    /usr/bin/test   -e "${LOCAL_FILE}" && . "${LOCAL_FILE}"
}

#===============================================================================
# mm_url_*_get functions.
#===============================================================================
mm_url_get() {
    local URL=$1
    local LOCAL_FILE=$2

    local REMOTE_PROTOCOL
    local REMOTE_SERVER
    local REMOTE_FILE

    REMOTE_PROTOCOL=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 \
                                        | /usr/bin/cut -d: -f1`
    REMOTE_SERVER=`  /bin/echo "${URL}" | /usr/bin/cut -d? -f1 \
                                        | /bin/sed 's%^[^:]*:%%' \
                                        | /bin/sed 's%^//%%' \
                                        | /bin/sed 's%^[^@]*@%%' \
                                        | /bin/sed 's%/[^/]*%%g'`
    REMOTE_FILE=`    /bin/echo "${URL}" | /usr/bin/cut -d? -f1 \
                                        | /bin/sed 's%^[^:]*:%%' \
                                        | /bin/sed 's%^//[^/]*/%/%'`

    case "${REMOTE_PROTOCOL}" in
        conf|confro|confrw|dist|file|http|hunt|tftp)
            mm_url_${REMOTE_PROTOCOL}_get "${LOCAL_FILE}" "${REMOTE_FILE}" "${REMOTE_SERVER}" || return
            ;;
        cifs|nfs)
            REMOTE_FILE=`/bin/echo "${URL}" | /bin/sed "s%${MM_MINIMYTH_BOOT_URL}%%"`
            mm_url_${REMOTE_PROTOCOL}_get "${LOCAL_FILE}" "${REMOTE_FILE}" "${MM_MINIMYTH_BOOT_URL}" || return
            ;;
        *)
            /usr/bin/logger -s -t minimyth -p "local0.info" "mm_url_get: protocol '${REMOTE_PROTOCOL}' is not supported."
            /bin/false || return
            ;;
    esac

    /bin/true
    return
}

mm_url_conf_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    /usr/bin/logger -s -t minimyth -p "local0.error" \
        "function 'mm_url_conf_get' is no longer supported. use 'mm_url_confro_get' or 'mm_url_confrw_get' instead."

    /bin/false
    return
}

mm_url_confro_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    local HOST_NAME
    local REMOTE_FILE_0
    local REMOTE_FILE_1
    local REMOTE_FILE_2

    HOST_NAME=`/bin/hostname`

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%^/%%'`
    if [ -n "${HOST_NAME}" ] ; then
        REMOTE_FILE_0="conf/${HOST_NAME}/${REMOTE_FILE}"
    fi
    REMOTE_FILE_1="conf/default/${REMOTE_FILE}"
    REMOTE_FILE_2="/boot/${REMOTE_FILE}"

    /bin/rm -f "${LOCAL_FILE}"
    ( /usr/bin/test "${LOCAL_FILE}" = "/etc/minimyth.d/minimyth.conf" \
          && mm_url_get "${MM_TFTP_BOOT_URL}${REMOTE_FILE_0}" "${LOCAL_FILE}" \
          && ( /usr/bin/logger -s -t minimyth -p "local0.info" "'${LOCAL_FILE} file downloaded from ${MM_TFTP_BOOT_URL}${REMOTE_FILE_0}'" \
                   || /bin/true \
             ) \
    ) || \
    ( /usr/bin/test -n "${REMOTE_FILE_0}" \
          && mm_url_get "${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_0}" "${LOCAL_FILE}" \
          && ( /usr/bin/logger -s -t minimyth -p "local0.info" "'${LOCAL_FILE} file downloaded from ${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_0}'" \
                   || /bin/true \
             ) \
    ) || \
    ( /usr/bin/test -n "${REMOTE_FILE_1}" \
          && mm_url_get "${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_1}" "${LOCAL_FILE}" \
          && ( /usr/bin/logger -s -t minimyth -p "local0.info" "'${LOCAL_FILE} file downloaded from ${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_1}'" \
                   || /bin/true \
             ) \
    ) || \
    ( /usr/bin/test -n "${REMOTE_FILE_2}" \
          && cp "${REMOTE_FILE_2}" "${LOCAL_FILE}" \
          && ( /usr/bin/logger -s -t minimyth -p "local0.info" "'${LOCAL_FILE} file copied from ${REMOTE_FILE_2}'" \
                   || /bin/true \
             ) \
    ) || \
    return

    return
}

mm_url_confrw_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    local HOST_NAME
    local REMOTE_FILE_0
    local REMOTE_FILE_1

    HOST_NAME=`/bin/hostname`

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%^/%%'`
    if [ -n "${HOST_NAME}" ] ; then
        REMOTE_FILE_0=`/bin/echo ${REMOTE_FILE}`
        REMOTE_FILE_0="conf-rw/${HOST_NAME}/${REMOTE_FILE_0}"
    fi
    /usr/bin/test -e "/boot" && REMOTE_FILE_1="/boot/${REMOTE_FILE}"

    /bin/rm -f "${LOCAL_FILE}"
    ( /usr/bin/test -n "${REMOTE_FILE_0}" \
          && mm_url_get "${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_0}" "${LOCAL_FILE}" \
          && ( /usr/bin/logger -s -t minimyth -p "local0.info" "'${LOCAL_FILE} file downloaded from ${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_0}'" \
                   || /bin/true \
             ) \
    ) || \
    ( /usr/bin/test -n "${REMOTE_FILE_1}" \
          && cp "${REMOTE_FILE_1}" "${LOCAL_FILE}" \
          && ( /usr/bin/logger -s -t minimyth -p "local0.info" "'${LOCAL_FILE} file copied from ${REMOTE_FILE_1}'" \
                   || /bin/true \
             ) \
    ) || \
    return

    return
}

mm_url_dist_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    local REMOTE_FILE_0

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%^/%%'`
    if [ -n "${MM_ROOTFS_IMAGE}" ] ; then
        REMOTE_FILE_0=`/bin/echo ${MM_ROOTFS_IMAGE} | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%[^/]*$%%' | /bin/sed -e 's%/$%%'`
        REMOTE_FILE_0="${REMOTE_FILE_0}/${REMOTE_FILE}"
    else
        REMOTE_FILE_0="/minimyth-${MM_VERSION}/${REMOTE_FILE}"
    fi

    /bin/rm -f "${LOCAL_FILE}"
    ( /usr/bin/test -n "${REMOTE_FILE_0}" \
          && mm_url_get "${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_0}" "${LOCAL_FILE}" \
    ) || \
    return

    return
}

mm_url_file_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    local LOCAL_DIR

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`

    LOCAL_DIR=`/bin/echo "${LOCAL_FILE}" | /bin/sed -e 's%[^/]*$%%' -e 's%/$%%'`
    /usr/bin/test -n "${LOCAL_DIR}" && /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/test -n "${LOCAL_DIR}" && /usr/bin/test ! -d "${LOCAL_DIR}" && return

    /bin/cp -f "${REMOTE_FILE}" "${LOCAL_FILE}" || return

    /usr/bin/logger -s -t minimyth -p "local0.info" "'file:${REMOTE_FILE}' downloaded."

    return
}

mm_url_http_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2
    local REMOTE_SERVER=$3

    local LOCAL_DIR

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%^/%%'`
    REMOTE_FILE="/${REMOTE_FILE}"

    LOCAL_DIR=`/bin/echo "${LOCAL_FILE}" | /bin/sed -e 's%[^/]*$%%' -e 's%/$%%'`
    /usr/bin/test -n "${LOCAL_DIR}" && /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/test -n "${LOCAL_DIR}" && /usr/bin/test ! -d "${LOCAL_DIR}" && return

    rc=`/usr/bin/curl -s -S -f "http://${REMOTE_SERVER}${REMOTE_FILE}" -o "${LOCAL_FILE}" 2>&1`
    if [ $? -ne 0 ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.info" "Download from 'http://${REMOTE_SERVER}${REMOTE_FILE}' returns: '${rc}'"
        /bin/false
    else
        /usr/bin/logger -s -t minimyth -p "local0.info" "'http://${REMOTE_SERVER}${REMOTE_FILE}' downloaded..."
        /bin/true
    fi

    return
}

mm_url_hunt_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    mm_url_dist_get   "${LOCAL_FILE}" "${REMOTE_FILE}" || \
    mm_url_confro_get "${LOCAL_FILE}" "${REMOTE_FILE}" || \
    return

    return
}

mm_url_tftp_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2
    local REMOTE_SERVER=$3

    local LOCAL_DIR

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%^/%%'`
    REMOTE_FILE="/${REMOTE_FILE}"

    LOCAL_DIR=`/bin/echo "${LOCAL_FILE}" | /bin/sed -e 's%[^/]*$%%' -e 's%/$%%'`
    /usr/bin/test -n "${LOCAL_DIR}" && /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/test -n "${LOCAL_DIR}" && /usr/bin/test ! -d "${LOCAL_DIR}" && return

    /usr/bin/tftp -g -r "${REMOTE_FILE}" -l "${LOCAL_FILE}" "${REMOTE_SERVER}" || return

    /usr/bin/logger -s -t minimyth -p "local0.info" "'tftp://${REMOTE_SERVER}${REMOTE_FILE}' downloaded."

    return
}

mm_url_cifs_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2
    local REMOTE_SERVER=$3

    local LOCAL_DIR

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%^/%%'`
    REMOTE_FILE="/${REMOTE_FILE}"

    LOCAL_DIR=`/bin/echo "${LOCAL_FILE}" | /bin/sed -e 's%[^/]*$%%' -e 's%/$%%'`
    /usr/bin/test -n "${LOCAL_DIR}" && /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/test -n "${LOCAL_DIR}" && /usr/bin/test ! -d "${LOCAL_DIR}" && return

    if [ ! -f "/var/lib/minimyth.bootdir.cifs_mounted" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.info" "Mounting '${REMOTE_SERVER}' share for conf and conf-ro operations"
        mm_url_mount "${REMOTE_SERVER}" "/var/minimyth.bootdir" || return
        /bin/touch "/var/lib/minimyth.bootdir.cifs_mounted"
    fi

    /bin/cp "/var/minimyth.bootdir/${REMOTE_FILE}" "${LOCAL_FILE}" || return

    /usr/bin/logger -s -t minimyth -p "local0.info" "File '${REMOTE_SERVER}${REMOTE_FILE}' downloaded."

    return
}

mm_url_nfs_get() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2
    local REMOTE_SERVER=$3

    local LOCAL_DIR

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%^/%%'`
    REMOTE_FILE="/${REMOTE_FILE}"

    LOCAL_DIR=`/bin/echo "${LOCAL_FILE}" | /bin/sed -e 's%[^/]*$%%' -e 's%/$%%'`
    /usr/bin/test -n "${LOCAL_DIR}" && /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/test -n "${LOCAL_DIR}" && /usr/bin/test ! -d "${LOCAL_DIR}" && return

    if [ ! -f "/var/lib/minimyth.bootdir.nfs_mounted" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.info" "Mounting '${REMOTE_SERVER}' share for conf and conf-ro operations"
        mm_url_mount "${REMOTE_SERVER}" "/var/minimyth.bootdir/" || return
        /bin/touch "/var/lib/minimyth.bootdir.nfs_mounted"
    fi

    /bin/cp "/var/minimyth.bootdir/${REMOTE_FILE}" "${LOCAL_FILE}" || return

    /usr/bin/logger -s -t minimyth -p "local0.info" "File '${REMOTE_SERVER}${REMOTE_FILE}' downloaded."

    return
}

#===============================================================================
# mm_url_*_put functions.
#===============================================================================
mm_url_put() {
    local URL=$1
    local LOCAL_FILE=$2

    local REMOTE_PROTOCOL
    local REMOTE_SERVER
    local REMOTE_FILE

    REMOTE_PROTOCOL=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 \
                                        | /usr/bin/cut -d: -f1`
    REMOTE_SERVER=`  /bin/echo "${URL}" | /usr/bin/cut -d? -f1 \
                                        | /bin/sed 's%^[^:]*:%%' \
                                        | /bin/sed 's%^//%%' \
                                        | /bin/sed 's%^[^@]*@%%' \
                                        | /bin/sed 's%/[^/]*%%g'`
    REMOTE_FILE=`    /bin/echo "${URL}" | /usr/bin/cut -d? -f1 \
                                        | /bin/sed 's%^[^:]*:%%' \
                                        | /bin/sed 's%^//[^/]*/%/%'`

    case "${REMOTE_PROTOCOL}" in
        conf|confrw|file|http|tftp)
            mm_url_${REMOTE_PROTOCOL}_put "${LOCAL_FILE}" "${REMOTE_FILE}" "${REMOTE_SERVER}" || return
            ;;
        cifs|nfs)
            REMOTE_FILE=`/bin/echo "${URL}" | /bin/sed "s%${MM_MINIMYTH_BOOT_URL}%%"`
            mm_url_${REMOTE_PROTOCOL}_put "${LOCAL_FILE}" "${REMOTE_FILE}" "${MM_MINIMYTH_BOOT_URL}" || return
            ;;
        *)
            /usr/bin/logger -s -t minimyth -p "local0.info" "mm_url_put: protocol '${REMOTE_PROTOCOL}' is not supported."
            /bin/false || return
            ;;
    esac

    /bin/true
    return
}

mm_url_conf_put() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    /usr/bin/logger -s -t minimyth -p "local0.error" \
        "function 'mm_url_conf_put' is no longer supported. use 'mm_url_confrw_put' instead."

    /bin/false
    return
}

mm_url_confrw_put() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    local HOST_NAME
    local REMOTE_FILE_0
    local REMOTE_FILE_1

    HOST_NAME=`/bin/hostname`

    if [ ! -f "${LOCAL_FILE}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error"  \
            "cannot post conf file '${LOCAL_FILE}' because file not found."
        /bin/false
        return
    fi
    if [ -z "${HOST_NAME}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error"  \
            "cannot post conf file '${LOCAL_FILE}' because hostname is unknown."
        /bin/false
        return
    fi

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%/$%%'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%^/%%'`
    if [ -n "${HOST_NAME}" ] ; then
        REMOTE_FILE_0=`/bin/echo ${REMOTE_FILE}`
        REMOTE_FILE_0="conf-rw/${HOST_NAME}/${REMOTE_FILE_0}"
    fi
    /usr/bin/test -e "/boot" && REMOTE_FILE_1="/boot/${REMOTE_FILE}"

    ( /usr/bin/test -n "${REMOTE_FILE_0}" \
          && mm_url_put "${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_0}" "${LOCAL_FILE}" \
          && ( /usr/bin/logger -s -t minimyth -p "local0.info" "'${LOCAL_FILE} file uploaded as ${MM_MINIMYTH_BOOT_URL}${REMOTE_FILE_0}'" \
                   || /bin/true \
             ) \
    ) || \
    ( /usr/bin/test -n "${REMOTE_FILE_0}" \
          && cp "${LOCAL_FILE}" "${REMOTE_FILE_1}" \
          && ( /usr/bin/logger -s -t minimyth -p "local0.info" "'${LOCAL_FILE} file saved as ${REMOTE_FILE_1}'" \
                   || /bin/true \
             ) \
    ) || \
    return

    return
}

mm_url_file_put() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2

    local REMOTE_DIR

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g'`

    if [ ! -f "${LOCAL_FILE}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error"  \
            "cannot post conf file '${LOCAL_FILE}' because file not found."
        /bin/false
        return
    fi

    REMOTE_DIR=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%[^/]*$%%' -e 's%/$%%'`
    /usr/bin/test -n "${REMOTE_DIR}" && /bin/mkdir -p "${REMOTE_DIR}"
    /usr/bin/test -n "${REMOTE_DIR}" && /usr/bin/test ! -d "${REMOTE_DIR}" && return

    if /bin/cp -f "${LOCAL_FILE}" "${REMOTE_FILE}" ; then
        /usr/bin/logger -s -t minimyth -p "local0.info"  \
            "'file:${REMOTE_FILE}' posted."
        /bin/true
        return
    else
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "'file:${REMOTE_FILE}' failed to post."
        /bin/false
        return
    fi

    return
}

mm_url_http_put() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2
    local REMOTE_SERVER=$3

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%^/%%'`
    REMOTE_FILE="/${REMOTE_FILE}"

    if [ ! -f "${LOCAL_FILE}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error"  \
            "[functions/mm_url_http_put] cannot post conf file '${LOCAL_FILE}' because file not found."
        /bin/false
        return
    fi

    rc=`/usr/bin/curl -s -S -f -T "${LOCAL_FILE}" "http://${REMOTE_SERVER}${REMOTE_FILE}" 2>&1`
    if [ $? -ne 0 ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "Uploading to 'http://${REMOTE_SERVER}${REMOTE_FILE}' failed with error: ${rc}"
        /bin/false
    else
        /usr/bin/logger -s -t minimyth -p "local0.info" \
            "[functs/mm_url_http_put] 'http://${REMOTE_SERVER}${REMOTE_FILE}' uploaded..."
        /bin/true
    fi

    return
}

mm_url_tftp_put() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2
    local REMOTE_SERVER=$3

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%^/%%'`
    REMOTE_FILE="/${REMOTE_FILE}"

    if [ ! -f "${LOCAL_FILE}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error"  \
            "cannot post conf file '${LOCAL_FILE}' because file not found."
        /bin/false
        return
    fi

    if /usr/bin/tftp -p -l "${LOCAL_FILE}" -r "${REMOTE_FILE}" "${REMOTE_SERVER}" ; then
        /usr/bin/logger -s -t minimyth -p "local0.info"  \
            "'tftp://${REMOTE_SERVER}${REMOTE_FILE}' posted."
        /bin/true
        return
    else
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "'tftp://${REMOTE_SERVER}${REMOTE_FILE}' failed to post."
        /bin/false
        return
    fi

    return
}

mm_url_cifs_put() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2
    local REMOTE_SERVER=$3

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%^/%%'`
    REMOTE_FILE="/${REMOTE_FILE}"

    if [ ! -f "${LOCAL_FILE}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error"  \
            "cannot post conf file '${LOCAL_FILE}' because file not found."
        /bin/false
        return
    fi

    if [ ! -f "/var/lib/minimyth.bootdir.cifs_mounted" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.info" "Mounting '${REMOTE_SERVER}' share for conf and conf-ro operation"
        mm_url_mount "${REMOTE_SERVER}" "/var/minimyth.bootdir" || return
        /bin/touch "/var/lib/minimyth.bootdir.cifs_mounted"
    fi

    /bin/cp "${LOCAL_FILE}" "/var/minimyth.bootdir/${REMOTE_FILE}"

    /usr/bin/logger -s -t minimyth -p "local0.info"  \
            "File ${LOCAL_FILE} posted to '${REMOTE_SERVER}${REMOTE_FILE}'."

    return
}

mm_url_nfs_put() {
    local LOCAL_FILE=$1
    local REMOTE_FILE=$2
    local REMOTE_SERVER=$3

    LOCAL_FILE=`/bin/echo "${LOCAL_FILE}"   | /bin/sed -e 's%//*%/%g'`
    REMOTE_FILE=`/bin/echo "${REMOTE_FILE}" | /bin/sed -e 's%//*%/%g' | /bin/sed -e 's%^/%%'`
    REMOTE_FILE="/${REMOTE_FILE}"

    if [ ! -f "${LOCAL_FILE}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error"  \
            "cannot post conf file '${LOCAL_FILE}' because file not found."
        /bin/false
        return
    fi

    if [ ! -f "/var/lib/minimyth.bootdir.nfs_mounted" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.info" "Mounting '${REMOTE_SERVER}' share for conf and conf-ro operation"
        mm_url_mount "${REMOTE_SERVER}" "/var/minimyth.bootdir/" || return
        /bin/touch "/var/lib/minimyth.bootdir.nfs_mounted"
    fi

    /bin/cp "${LOCAL_FILE}" "/var/minimyth.bootdir/${REMOTE_FILE}"

    /usr/bin/logger -s -t minimyth -p "local0.info"  \
            "File ${LOCAL_FILE} posted to '${REMOTE_SERVER}${REMOTE_FILE}'."

    return
}

mm_conf_get() {
    local REMOTE_FILE=$1
    local LOCAL_FILE=$2

    /usr/bin/logger -s -t minimyth -p "local0.error" \
        "function 'mm_conf_get' is no longer supported. use 'mm_confro_get' or 'mm_confrw_get' instead."

    /bin/false
    return
}

mm_confro_get() {
    local REMOTE_FILE=$1
    local LOCAL_FILE=$2

    mm_url_confro_get "${LOCAL_FILE}" "${REMOTE_FILE}" || return

    return
}

mm_confrw_get() {
    local REMOTE_FILE=$1
    local LOCAL_FILE=$2

    mm_url_confrw_get "${LOCAL_FILE}" "${REMOTE_FILE}" || return

    return
}

mm_conf_put() {
    local REMOTE_FILE=$1
    local LOCAL_FILE=$2

    /usr/bin/logger -s -t minimyth -p "local0.error" \
        "function 'mm_conf_put' is no longer supported. use 'mm_confrw_put' instead."

    /bin/false
    return
}

mm_confrw_put() {
    local REMOTE_FILE=$1
    local LOCAL_FILE=$2

    mm_url_confrw_put "${LOCAL_FILE}" "${REMOTE_FILE}" || return

    return
}

#===============================================================================
# mm_directory_* functions.
#===============================================================================

mm_directory_save_to_confrw() {
    # param1: directory to be saved
    # param2: archive filename (without tar.bz2 extenssion)

    local directory=$1
    local archive_filename=$2

    if [ -d ${directory} ] ; then
        cd ${directory}
        tar -jcvvf /tmp/${archive_filename}.tar.bz2 ./*
        mm_confrw_put "${archive_filename}.tar.bz2" "/tmp/${archive_filename}.tar.bz2"
        if [ $? -ne 0 ] ; then
            /usr/bin/logger -s -t minimyth -p "local0.error" "[functions/mm_directory_save_to_confrw] failed to save the ${archive_filename}.tar.bz2 file ..."
            rm -f /tmp/${archive_filename}.tar.bz2
            /bin/false
            return
        fi
        rm -f /tmp/${archive_filename}.tar.bz2
        /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_directory_save_to_confrw] [${directory}] state saved & uploaded as ${archive_filename}.tar.bz2 sucessfuly ..."
        /bin/true
        return
    else
        /usr/bin/logger -s -t minimyth -p "local0.error" "[functions/mm_directory_save_to_confrw] asked to save [${directory}] not exists ..."
        rm -f /tmp/${archive_filename}.tar.bz2
        /bin/false
        return
    fi
}

mm_directory_restore_from_confrw() {
    # param1: directory to be saved
    # param2: archive filename (without tar.bz2 extenssion)

    local directory=$1
    local archive_filename=$2

    mm_confrw_get ${archive_filename}.tar.bz2 /tmp/${archive_filename}.tar.bz2

    if [ ! -e /tmp/${archive_filename}.tar.bz2 ] ; then
        /usr/bin/logger -t minimyth -p "local0.err" "[functions/mm_directory_restore_from_confrw] can't download ${archive_filename}.tar.bz2 archive file from conf-rw ..."
        /bin/false
        return
    else
        /bin/rm -rf ${directory}*
        /bin/mkdir -p ${directory}
        bunzip2 -dc /tmp/${archive_filename}.tar.bz2 | tar -xf - -C ${directory}
        /bin/rm -f /tmp/${archive_filename}.tar.bz2
        /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_directory_restore_from_confrw] state of [${directory}] sucessfuly restored ..."
    fi
    /bin/true
    return
}

mm_message_output() {
    local LEVEL=$1
    local MESSAGE=$2

    if [ `mm_splash_running_test ; /bin/echo $?` -eq 0 ] ; then
        # /usr/bin/logger    -t minimyth -p "local0.${LEVEL}" "${MESSAGE}"
        mm_splash_message_output "${MESSAGE}"
    else
        /usr/bin/logger -s -t minimyth -p "local0.${LEVEL}" "${MESSAGE}"
    fi

    if [ "x${LEVEL}" = "xerr"  ] ; then
        /bin/mkdir -p /var/log
        /bin/touch    /var/log/minimyth.err.log
        if [ -w /var/log/minimyth.err.log ] ; then
            /bin/echo -E "${MESSAGE}" >> /var/log/minimyth.err.log
            /bin/chmod 0666 /var/log/minimyth.err.log
        fi
        mm_splash_command "log ${MESSAGE}"
    fi
    if [ "x${LEVEL}" = "xwarn" ] ; then
        /bin/mkdir -p /var/log
        /bin/touch    /var/log/minimyth.warn.log
        if [ -w /var/log/minimyth.warn.log ] ; then
            /bin/echo -E "${MESSAGE}" >> /var/log/minimyth.warn.log
            /bin/chmod 0666 /var/log/minimyth.warn.log
        fi
        mm_splash_command "log ${MESSAGE}"
    fi
}

mm_uniq() {

    local ARG

    if [ $# -eq 0 ] ; then
        ARG=
        local line=
        while read line ; do
            ARG="${ARG} ${line}"
        done
    else
        ARG=$1
    fi

    /bin/echo `/bin/echo "${ARG}" | /bin/sed -e 's% %\n%g' | /usr/bin/sort | /usr/bin/uniq | /bin/sed -e :a -e '$!N;s/\n/ /;ta' -e 'P;D'`
}

#-------------------------------------------------------------------------------
# mm_url_mount
#
# This function mounts a remote directory as a local directory.
#
# This function takes three arguments:
#     URL: required argument:
#         A URL that points to the remote directory. A URL must have the
#         following form:
#             <protocol>://<username>:<password>@<server>/<path>?<options>
#         where <options> are additional mount options (-o).
#         For example:
#             nfs://server.home/home/public/music
#             cifs://user:pass@server.home/home/public/music,domain=home
#             confrw:themecaches/G.A.N.T..1024.768.sfs<br/>
#         The valid protocol values are: 'nfs', 'cifs', 'http', 'tftp',
#         'confro', 'confrw', 'dist', 'hunt' and 'file'. For 'nfs' 'cifs' and
#         'partlbl', 'bootdevpart'.
#         The URL points to a remote directory. For 'http', 'tftp', 'confro',
#         'confrw', 'dist' and 'hunt', the URL points to a remote file. For
#         'file', the URL point to a local directory or file. For 'partlbl' URL
#         point to partition label. A directory or partition will
#         be mounted at the mount point. A file, which can be a squashfs image
#         (*.sfs.), cramfs image (*.cmg) or a tarball file (*.tar.bz2) will be
#         downloaded and mounted at (for *.sfs and *.cmg files) or downloaded
#         and expanded into (for *.tar.bz2 files) the mount point. The 'confro',
#         'confrw', 'dist' and 'hunt' are special MiniMyth specific URLs. A
#         'dist' URL causes MiniMyth to look for the file in the MiniMyth
#         distribution directory (the directory with the MiniMyth root file
#         system squashfs image). A 'confro' URL causes MiniMyth to look for the
#         file in the MiniMyth read-only configuration directory. A 'confrw' URL
#         causes MiniMyth to look for the file in the MiniMyth read-write
#         configuration directory. A 'hunt' URL causes MiniMyth to look for the
#         file first in the MiniMyth distribution directory and second in the
#         MiniMyth read-only configuration directory.
#     MOUNT_DIR: required argument:
#         The local directory (e.g. /mnt/music) where the URL will be mounted.
#-------------------------------------------------------------------------------
mm_url_mount() {
    local URL="$1"
    local MOUNT_DIR="$2"

    local DIR
    local EXTRA_OPTIONS
    local FILE
    local MOUNT_DEVICE
    local MOUNT_OPTIONS
    local MOUNT_VFSTYPE
    local OPTIONS
    local URL_EXT1
    local URL_EXT2
    local URL_EXTMAX
    local URL_FILE
    local URL_OPTIONS
    local URL_PASSWORD
    local URL_PATH
    local URL_PROTOCOL
    local URL_SERVER
    local URL_USERNAME

    /bin/mkdir -p "${MOUNT_DIR}" || return

    URL_PROTOCOL=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                        /usr/bin/cut -d: -f1`
    URL_USERNAME=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                        /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%[^@]*$%%'  | /bin/sed 's%@$%%' | /usr/bin/cut -d: -f1`
    URL_PASSWORD=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                        /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%[^@]*$%%'  | /bin/sed 's%@$%%' | /usr/bin/cut -d: -f2`
    URL_SERVER=`  /bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                        /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%^[^@]*@%%' | /bin/sed 's%/[^/]*%%g'`
    URL_PATH=`    /bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                        /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//[^/]*/%/%'`
    URL_OPTIONS=` /bin/echo "${URL}"                        | \
                        /bin/sed 's%^[^?]*%%'  | /bin/sed 's%^?%%'`

    URL_FILE=`    /bin/echo "${URL_PATH}" | /bin/sed 's%^.*/%%'`
    URL_EXTMAX=`  /bin/echo "${URL_FILE}" | /bin/sed 's%^.*/%%' |/bin/sed 's%[^.]*%%g' | /usr/bin/wc -c` 
    URL_EXT1=
    /usr/bin/test ${URL_EXTMAX} -ge 1 && URL_EXT1=`/bin/echo ${URL_FILE} | /bin/sed 's%^.*/%%' | /usr/bin/cut -s -d. -f$((${URL_EXTMAX}-0))`
    URL_EXT2=
    /usr/bin/test ${URL_EXTMAX} -ge 2 && URL_EXT2=`/bin/echo ${URL_FILE} | /bin/sed 's%^.*/%%' | /usr/bin/cut -s -d. -f$((${URL_EXTMAX}-1))`

    MOUNT_VFSTYPE=""
    EXTRA_OPTIONS=""
    MOUNT_DEVICE=""
    MOUNT_OPTIONS="${URL_OPTIONS}"
    if   [ "x${URL_PROTOCOL}" = "xnfs" ] ; then
        MOUNT_VFSTYPE="nfs"
        MOUNT_DEVICE="${URL_SERVER}:${URL_PATH}"
        MOUNT_OPTIONS="nolock,${MOUNT_OPTIONS}"
    elif [ "x${URL_PROTOCOL}" = "xcifs" ] ; then
        MOUNT_VFSTYPE="cifs"
        MOUNT_DEVICE="//${URL_SERVER}${URL_PATH}"
        if [ ! "x${URL_PASSWORD}" = "x" ] ; then
            MOUNT_OPTIONS="password=${URL_PASSWORD},${MOUNT_OPTIONS}"
        fi
        if [ ! "x${URL_USERNAME}" = "x" ] ; then
            MOUNT_OPTIONS="username=${URL_USERNAME},${MOUNT_OPTIONS}"
        fi
    elif ( [ "x${URL_PROTOCOL}" = "xhttp"   ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xtftp"   ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xconfro" ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xconfrw" ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xdist"   ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xhunt"   ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xfile"   ] && [ -f "${URL_PATH}" ] ) ; then
        if  [ "x${URL_EXT1}" = "xsfs" ] ; then
            DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
            FILE="image.sfs"
            /bin/mkdir -p "${DIR}"
            /bin/mkdir -p "${DIR}/ro"
            /bin/mkdir -p "${DIR}/rw"
            /bin/mkdir -p "${DIR}/wrk"
            cd "${DIR}"
            mm_url_${URL_PROTOCOL}_get "${FILE}" "${URL_PATH}" "${URL_SERVER}"          || return
            /bin/mount -t squashfs -o loop "${DIR}/${FILE}" "${DIR}/ro"                 || return
            /bin/mount -t overlay -o lowerdir="${DIR}/ro",upperdir="${DIR}/rw",workdir="${DIR}/wrk" none "${MOUNT_DIR}" || return
        elif [ "x${URL_EXT1}" = "xcmg" ] ; then
            DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
            FILE="image.cmg"
            /bin/mkdir -p "${DIR}"
            /bin/mkdir -p "${DIR}/ro"
            /bin/mkdir -p "${DIR}/rw"
            /bin/mkdir -p "${DIR}/wrk"
            cd "${DIR}"
            mm_url_${URL_PROTOCOL}_get "${FILE}" "${URL_PATH}" "${URL_SERVER}"          || return
            /bin/mount -t cramfs -o loop "${DIR}/${FILE}" "${DIR}/ro"                   || return
            /bin/mount -t overlay -o lowerdir="${DIR}/ro",upperdir="${DIR}/rw",workdir="${DIR}/wrk" none "${MOUNT_DIR}" || return
        elif [ "x${URL_EXT1}" = "xbz2" ] && [ "x${URL_EXT2}" = "xtar" ] ; then
            FILE="tmp.tar.bz2~"
            cd "${MOUNT_DIR}"
            mm_url_${URL_PROTOCOL}_get "${FILE}" "${URL_PATH}" "${URL_SERVER}" || return
            /bin/tar -jxf "${FILE}"                                            || return
            /bin/rm -f "${FILE}"                                               || return
        fi
    elif [ "x${URL_PROTOCOL}" = "xfile" ] && [ -d "${URL_PATH}" ] ; then
        /bin/mount --rbind "${URL_PATH}" "${MOUNT_DIR}"
    elif [ "x${URL_PROTOCOL}" = "xpartlbl" ] ; then
        LABEL=`/bin/echo ${URL_PATH} | /bin/sed 's%/*%%g'`
        /bin/mount --label "${LABEL}" "${MOUNT_DIR}"
    elif [ "x${URL_PROTOCOL}" = "xbootdevpart" ] ; then
        PART_NO=`/bin/echo ${URL_PATH} | /bin/sed 's%/*%%g'`
        BOOT_DEV=$(mount | grep -e "/initrd\s"| awk '{print $1}' | sed 's/p[0123456789]//g' | sed 's/\/dev\///g')
        if [ ! x${PART_NO} = "x" ] && [ ! x${BOOT_DEV} = "x" ] ; then
            /bin/mount /dev/${BOOT_DEV}p${PART_NO} "${MOUNT_DIR}"
        else
            /usr/bin/logger -s -t minimyth -p "local0.error" \
                "mm_url_mount: mountng ${URL_PATH} failed (PART_NO=${PART_NO};BOOT_DEV=${BOOT_DEV})"
            /bin/false
            return
        fi
    else
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "mm_url_mount: protocol '${URL_PROTOCOL}' is not supported."
        /bin/false
        return
    fi

    if [ -n "${MOUNT_VFSTYPE}" ] ; then
        OPTIONS=""
        MOUNT_OPTIONS=`/bin/echo ${MOUNT_OPTIONS} | /bin/sed 's%^,%%'`
        MOUNT_OPTIONS=`/bin/echo ${MOUNT_OPTIONS} | /bin/sed 's%,$%%'`
        MOUNT_OPTIONS=`/bin/echo ${MOUNT_OPTIONS} | /bin/sed 's%^  *%%'`
        MOUNT_OPTIONS=`/bin/echo ${MOUNT_OPTIONS} | /bin/sed 's%  *$%%'`
        /usr/bin/test -n "${EXTRA_OPTIONS}" && OPTIONS="${EXTRA_OPTIONS}"
        /usr/bin/test -n "${MOUNT_OPTIONS}" && OPTIONS="${OPTIONS} -o ${MOUNT_OPTIONS}"
        OPTIONS=`/bin/echo ${OPTIONS} | /bin/sed 's%^  *%%'`
        OPTIONS=`/bin/echo ${OPTIONS} | /bin/sed 's%  *$%%'`
        /bin/mount -n -t "${MOUNT_VFSTYPE}" ${OPTIONS} "${MOUNT_DEVICE}" "${MOUNT_DIR}" || return
    fi

    return
}

mm_url_umount() {
    local URL="$1"
    local MOUNT_DIR="$2"

    local DIR
    local FILE
    local URL_EXT1
    local URL_EXT2
    local URL_EXTMAX
    local URL_FILE
    local URL_PATH
    local URL_PROTOCOL

    URL_PROTOCOL=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                        /usr/bin/cut -d: -f1`
    URL_PATH=`    /bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                        /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//[^/]*/%/%'`

    URL_FILE=`    /bin/echo "${URL_PATH}" | /bin/sed 's%^.*/%%'`
    URL_EXTMAX=`  /bin/echo "${URL_FILE}" | /bin/sed 's%^.*/%%' |/bin/sed 's%[^.]*%%g' | /usr/bin/wc -c` 
    URL_EXT1=
    /usr/bin/test ${URL_EXTMAX} -ge 1 && URL_EXT1=`/bin/echo ${URL_FILE} | /bin/sed 's%^.*/%%' | /usr/bin/cut -s -d. -f$((${URL_EXTMAX}-0))`
    URL_EXT2=
    /usr/bin/test ${URL_EXTMAX} -ge 2 && URL_EXT2=`/bin/echo ${URL_FILE} | /bin/sed 's%^.*/%%' | /usr/bin/cut -s -d. -f$((${URL_EXTMAX}-1))`

    if [ "x${URL_PROTOCOL}" = "xnfs"     ] || \
       [ "x${URL_PROTOCOL}" = "xpartlbl" ] || \
       [ "x${URL_PROTOCOL}" = "xcifs"    ] ; then
        if [ -d "${MOUNT_DIR}" ] ; then
            /bin/umount -f "${MOUNT_DIR}"
        fi
    elif ( [ "x${URL_PROTOCOL}" = "xhttp"   ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xtftp"   ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xconfro" ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xconfrw" ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xdist"   ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xhunt"   ] ) || \
         ( [ "x${URL_PROTOCOL}" = "xfile"   ] && [ -f "${URL_PATH}" ] ) ; then
        if [ "x${URL_EXT1}" = "xsfs" ] ; then
            DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
            FILE="image.sfs"
            if [ -d "${MOUNT_DIR}" ] ; then
                /bin/umount -f "${MOUNT_DIR}"
            fi
            if [ -d "${DIR}/ro" ] ; then
                /bin/umount -f "${DIR}/ro"
            fi
            rm -f "${DIR}/${FILE}"
        elif [ "x${URL_EXT1}" = "xcmg" ] ; then
            DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
            FILE="image.cmg"
            if [ -d "${MOUNT_DIR}" ] ; then
                /bin/umount -f "${MOUNT_DIR}"
            fi
            if [ -d "${DIR}/ro" ] ; then
                /bin/umount -f "${DIR}/ro"
            fi
            rm -f "${DIR}/${FILE}"
        elif [ "x${URL_EXT1}" = "xbz2" ] && [ "x${URL_EXT2}" = "xtar" ] ; then
            /bin/rm -rf "${MOUNT_DIR}"
        fi
    else
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "mm_url_umount: protocol '${URL_PROTOCOL}' is not supported."
        /bin/false
        return
    fi

    /bin/true
    return
}

mm_var_get() {
    local VAR=$1

    /bin/echo `set | /bin/grep "^${VAR}=" | /bin/sed 's%^[^=]*=%%' | /bin/sed "s%^'%%" | /bin/sed "s%'$%%"`
}

#===============================================================================
# splash screen functions
#===============================================================================
_mm_var_splash_command='/usr/sbin/fbsplashd'
_mm_var_splash_command_path=`/bin/echo ${_mm_var_splash_command} | /usr/bin/cut -d ' ' -f 1`
_mm_var_splash_command_dir=`/usr/bin/dirname ${_mm_var_splash_command_path}`
_mm_var_splash_command_base=`/usr/bin/basename ${_mm_var_splash_command_path}`
_mm_var_splash_fifo='/lib/splash/cache/.splash'
_mm_var_splash_fifo_dir=`/usr/bin/dirname ${_mm_var_splash_fifo}`
_mm_var_splash_fifo_base=`/usr/bin/basename ${_mm_var_splash_fifo}`
_mm_var_splash_progress_val=1
_mm_var_splash_progress_max=1

mm_splash_running_test() {
    if [ -n "`/bin/pidof ${_mm_var_splash_command_base}`" ] && [ -e ${_mm_var_splash_fifo} ] ; then
        return 0
    else
        return 1
    fi
}

mm_splash_init() {
    local type=$1

    local message

    local DEPTH
    local GEOMETRY
    local LOGLEVEL
    local SPLASH_ENABLE
    local VXRES
    local VYRES
    local XRES
    local YRES
    local XHWTYPE

    SPLASH_ENABLE=yes

    # Disable splash screen when more than kernel critical messages are logged to the console.
    # That is when the loglevel is greater than 3.
    if [ "x${SPLASH_ENABLE}" = "xyes" ] ; then
        LOGLEVEL=`/bin/cat /proc/sys/kernel/printk | /usr/bin/cut -f 1`
        if [ -z "${LOGLEVEL}" ] ; then
            SPLASH_ENABLE='no'
            /usr/bin/logger -t minimyth -p "local0.info" "disabling splash screen due no loglevel is set"
        fi
        if [ -n "${LOGLEVEL}" ] && [ ${LOGLEVEL} -gt 3 ] ; then
            SPLASH_ENABLE='no'
            /usr/bin/logger -t minimyth -p "local0.info" "disabling splash screen due loglevel > 3"
        fi
    fi

    # Disable splash screen when there is no framebuffer device.
    if [ "x${SPLASH_ENABLE}" = "xyes" ] ; then
        if [ ! -e '/dev/fb0' ] ; then 
            SPLASH_ENABLE='no'
            /usr/bin/logger -t minimyth -p "local0.info" "disabling splash screen due no /dev/fb0 framebuffer found"
        fi
    fi

    # Disable splash screen when the video resolution is not compatible.
    # That is when the resolution is not 640x480 or color depth is less than 16.
    if [ "x${SPLASH_ENABLE}" = "xyes" ] ; then
        GEOMETRY=`/usr/sbin/fbset | /bin/grep geometry`
        XRES=` /bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 2`
        YRES=` /bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 3`
        VXRES=`/bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 4`
        VYRES=`/bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 5`
        DEPTH=`/bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 6`
        if [ -z "${XRES}"  ] || \
           [ -z "${YRES}"  ] || \
           [ -z "${VXRES}" ] || \
           [ -z "${VYRES}" ] || \
           [ -z "${DEPTH}" ] ; then
            SPLASH_ENABLE='no'
            /usr/bin/logger -t minimyth -p "local0.info" "disabling splash due unknown gemoetry (Xres:${XRES},Yres:${YRES},VXres:${VXRES},VYres:${VYRES},Depth:${DEPTH}"
        fi
    fi

    if [ "x${SPLASH_ENABLE}" = "xyes" ] ; then
        case "${type}" in
            bootup)   message="starting ..."      ;;
            shutdown) message="shutting down ..." ;;
            reboot)   message="restarting ..."    ;;
            *)        message="${type}"                  ;;
        esac
        /usr/bin/logger -t minimyth -p "local0.info" "starting splash screen. geometry:${XRES}x${YRES},Vres:${VXRES}x${VYRES},${DEPTH}bpp"
        /usr/bin/chvt 1
        /bin/mkdir -p "${_mm_var_splash_fifo_dir}"
        mm_splash_command "exit"
        ${_mm_var_splash_command} --theme="minimyth" --progress="0" --mesg="${message}" --type="${type}"
        mm_splash_command "set mode silent"
        mm_splash_command "repaint"
    fi

    mm_splash_progress_set 0 1

    return 0
}

mm_splash_halt() {

    /usr/bin/logger -t minimyth -p "local0.info" "stopping splash screen"

    mm_splash_command "exit"

    return 0
}

mm_splash_command()
{
    /usr/bin/test `mm_splash_running_test ; /bin/echo $?` -eq 0 && /bin/echo "$1" >> "${_mm_var_splash_fifo}"

    return 0
}

mm_splash_message_output() {
    local MESSAGE=$1

    mm_splash_command "set message ${MESSAGE}"
    mm_splash_command "repaint"

    return 0
}

mm_splash_progress_set() {
    _mm_var_splash_progress_val=$1
    _mm_var_splash_progress_max=$2
 
    /usr/bin/test ${_mm_var_splash_progress_val} -gt ${_mm_var_splash_progress_max} && _mm_var_splash_progress_val=${_mm_var_splash_progress_max}
    mm_splash_command "progress $(( 65535 * ${_mm_var_splash_progress_val} / ${_mm_var_splash_progress_max} ))"
    mm_splash_command "repaint"

    return 0
}

mm_splash_progress_update() {
    _mm_var_splash_progress_val=$((_mm_var_splash_progress_val + 1))
    /usr/bin/test ${_mm_var_splash_progress_val} -gt ${_mm_var_splash_progress_max} && _mm_var_splash_progress_val=${_mm_var_splash_progress_max}
    mm_splash_command "progress $(( 65535 * ${_mm_var_splash_progress_val} / ${_mm_var_splash_progress_max} ))"
    mm_splash_command "repaint"

    return 0
}

#===============================================================================
# mythdb functions.
#===============================================================================
mm_mythdb_buffer_write() {
    local FLUSH=$1
    local COMMAND=$2

    local RETURN

    RETURN=0

    # If buffering is not enabled, then enable flush.
    if [ ! -e /var/cache/mythdb/buffer.enable ] ; then
        FLUSH=1
    fi

    # If mythdb cache directory does not exist, then create it.
    if [ ! -e /var/cache/mythdb/ ] ; then
        /bin/mkdir -p /var/cache/mythdb/
    fi

    # If there is a command, then write it to the buffer.
    if [ -n "${COMMAND}" ] ; then
        /bin/echo "${COMMAND}" >> /var/cache/mythdb/buffer.sql
    fi

    # If flush enabled and there is a buffer, then flush the buffer.
    if [ ${FLUSH} -ne 0 ] ; then
        if [ -e /var/cache/mythdb/buffer.sql ] ; then
            ${mysql_bin} \
                --host=${MM_MASTER_SERVER} \
                --user=${MM_MASTER_DBUSERNAME} \
                --password=${MM_MASTER_DBPASSWORD} \
                --database=${MM_MASTER_DBNAME} \
                < /var/cache/mythdb/buffer.sql
            RETURN=$?
            mv /var/cache/mythdb/buffer.sql /var/log/sql-$$.log
        fi
    fi

    return ${RETURN}
}

mm_mythdb_buffer_create() {
    /bin/mkdir -p /var/cache/mythdb/
    /bin/touch /var/cache/mythdb/buffer.enable

    return 0
}

mm_mythdb_buffer_delete() {

    local RETURN

    mm_mythdb_buffer_write 1
    RETURN=$?
    /bin/rm -f /var/cache/mythdb/buffer.enable

    return ${RETURN}
}

mm_mythdb_test() {

    local RETURN

    mm_mythdb_buffer_write 1 ";"
    RETURN=$?

    return ${RETURN}
}

mm_mythdb_get() {
    local COMMAND=$1

    local RETURN

    mm_mythdb_buffer_write 1 "${COMMAND} ;"
    RETURN=$?

    return ${RETURN}
}

mm_mythdb_set() {
    local COMMAND=$1

    local RETURN

    mm_mythdb_buffer_write 0 "${COMMAND} ;"
    RETURN=$?

    return ${RETURN}
}

mm_mythdb_jumppoints_delete() {
    local DESTINATION=$1

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    if [ -n "${DESTINATION}" ] ; then
        mm_mythdb_set "DELETE FROM jumppoints \
            WHERE hostname=\"${HOST_NAME}\" AND destination=\"${DESTINATION}\""
    else
        mm_mythdb_set "DELETE FROM jumppoints \
            WHERE hostname=\"${HOST_NAME}\""
    fi
}

mm_mythdb_jumppoints_dump() {
    local DESTINATION=$1

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    if [ -n "${DESTINATION}" ] ; then
        mm_mythdb_get "SELECT * FROM jumppoints \
            WHERE hostname=\"${HOST_NAME}\" AND destination=\"${DESTINATION}\""
    else
        mm_mythdb_get "SELECT * FROM jumppoints \
            WHERE hostname=\"${HOST_NAME}\""
    fi
}

mm_mythdb_jumppoints_update() {
    local DESTINATION=$1
    local KEYLIST=$2

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    mm_mythdb_set "UPDATE jumppoints SET keylist=\"${KEYLIST}\" \
        WHERE hostname=\"${HOST_NAME}\" AND destination=\"${DESTINATION}\""
}

mm_mythdb_jumppoints_get() {
    local VALUE=$1

    local DATA

    DATA=`mm_mythdb_jumppoints_dump "$1" | /bin/grep -e "$1" |  /usr/bin/cut -f 3`

    /bin/echo "${DATA}"
}

mm_mythdb_keybindings_delete() {
    local CONTEXT=$1
    local ACTION=$2

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    if   [ -n "${CONTEXT}" ] && [ -n "${ACTION}" ] ; then
        mm_mythdb_set "DELETE FROM keybindings \
            WHERE hostname=\"${HOST_NAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
    elif [ -n "${CONTEXT}" ] ; then
        mm_mythdb_set "DELETE FROM keybindings \
            WHERE hostname=\"${HOST_NAME}\" AND context=\"${CONTEXT}\""
    else
        mm_mythdb_set "DELETE FROM keybindings \
            WHERE hostname=\"${HOST_NAME}\""
    fi
}

mm_mythdb_keybindings_dump() {
    local CONTEXT=$1
    local ACTION=$2

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    if   [ -n "${CONTEXT}" ] && [ -n "${ACTION}" ] ; then
        mm_mythdb_get "SELECT * FROM keybindings \
            WHERE hostname=\"${HOST_NAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
    elif [ -n "${CONTEXT}" ] ; then
        mm_mythdb_get "SELECT * FROM keybindings \
            WHERE hostname=\"${HOST_NAME}\" AND context=\"${CONTEXT}\""
    else
        mm_mythdb_get "SELECT * FROM keybindings \
            WHERE hostname=\"${HOST_NAME}\""
    fi
}

mm_mythdb_keybindings_update() {
    local CONTEXT=$1
    local ACTION=$2
    local KEYLIST=$3

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    mm_mythdb_set "UPDATE keybindings SET keylist=\"${KEYLIST}\" \
        WHERE hostname=\"${HOST_NAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
}

mm_mythdb_music_playlists_dump() {
    mm_mythdb_set "SELECT * FROM music_playlists"
}

mm_mythdb_music_playlists_scope() {
    local MUSICPLAYLIST=$1
    local SCOPE=$2

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    case "${SCOPE}" in
        local)
            mm_mythdb_set "UPDATE music_playlists SET hostname=\"${HOST_NAME}\" WHERE playlist_name=\"${MUSICPLAYLIST}\""
            ;;
        global)
            mm_mythdb_set "UPDATE music_playlists SET hostname=\"\"             WHERE playlist_name=\"${MUSICPLAYLIST}\""
            ;;
    esac
}

mm_mythdb_settings_delete() {
    local VALUE=$1

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    if [ -n "${VALUE}" ] ; then
        mm_mythdb_set "DELETE FROM settings WHERE value=\"${VALUE}\" AND hostname=\"${HOST_NAME}\""
    else
        mm_mythdb_set "DELETE FROM settings WHERE hostname=\"${HOST_NAME}\""
    fi
}

mm_mythdb_settings_dump() {
    local VALUE=$1

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    if [ -n "${VALUE}" ] ; then
        mm_mythdb_get "SELECT * FROM settings WHERE value=\"${VALUE}\" AND hostname=\"${HOST_NAME}\""
    else
        mm_mythdb_get "SELECT * FROM settings WHERE hostname=\"${HOST_NAME}\""
    fi
}

mm_mythdb_settings_update() {
    local VALUE=$1
    local DATA=$2

    local HOST_NAME

    HOST_NAME=`/bin/hostname`

    mm_mythdb_set "UPDATE settings SET data=\"${DATA}\" WHERE value=\"${VALUE}\" AND hostname=\"${HOST_NAME}\""
}

mm_mythdb_settings_set() {
    local VALUE=$1
    local DATA=$2

    local HOST_NAME
    local DATA_CURRENT

    HOST_NAME=`/bin/hostname`

    mm_mythdb_settings_delete "${VALUE}"
    mm_mythdb_set "INSERT INTO settings SET data=\"${DATA}\", value=\"${VALUE}\", hostname=\"${HOST_NAME}\""
}

mm_mythdb_settings_get() {
    local VALUE=$1

    local DATA

    DATA=`mm_mythdb_settings_dump "$1" | /bin/grep -e "$1" |  /usr/bin/cut -f 2`

    /bin/echo "${DATA}"
}


#===============================================================================
# Hardware processing functions.
#===============================================================================

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
mm_hardware_cpu_process() {
    local cpu_process_function=$1

    local vendor
    local family
    local model

    # We only check the first CPU.
    # Thus, wea are assuming all other CPU are the same as the first.
    vendor=`/bin/grep '^vendor_id[[:cntrl:]]*:'  /proc/cpuinfo | /usr/bin/head -n1 | /usr/bin/awk -F ": " '{ print $2 }'`
    family=`/bin/grep '^cpu family[[:cntrl:]]*:' /proc/cpuinfo | /usr/bin/head -n1 | /usr/bin/awk -F ": " '{ print $2 }'`
    model=` /bin/grep '^model[[:cntrl:]]*:'      /proc/cpuinfo | /usr/bin/head -n1 | /usr/bin/awk -F ": " '{ print $2 }'`

    /bin/echo `${cpu_process_function} ${vendor} ${family} ${model}` | mm_uniq
}

mm_hardware_cpu2kernel_map() {
    local vendor=$1
    local family=$2
    local model=$3

    local map
    local map_kernel_modules

    if [ -n "${vendor}" ] ; then
        /bin/cat /etc/hardware.d/cpu2kernel.map                                                                 \
        | /bin/sed -e 's%#.*$%%g' | /bin/sed -e 's% *, *%,%g' | /bin/sed -e 's%^  *%%' | /bin/sed -e 's%  *$%%' \
        | /bin/grep -e "^${vendor},"                                                                            \
        | {
            while read map ; do
                if [ -n "${map}" ] ; then
                    map_family=`        /bin/echo ${map} | /usr/bin/cut -d ',' -f 2`
                    map_model=`         /bin/echo ${map} | /usr/bin/cut -d ',' -f 3`
                    map_kernel_modules=`/bin/echo ${map} | /usr/bin/cut -d ',' -f 4`
                    if ( [ -z "${map_family}" ] || [ "x${map_family}" = "x${family}" ] ) && \
                       ( [ -z "${map_model}"  ] || [ "x${map_model}"  = "x${model}"  ] ) ; then
                        /bin/echo ${map_kernel_modules}
                    fi
                fi
            done
        }
    fi
}

mm_hardware_to_kernel_module_map() {
    local x_driver=$1
    local map_file=$2

    local found
    local map
    local map_kernel_module

    if [ -n "${x_driver}" ] ; then
        /bin/cat ${map_file}                                                                                    \
        | /bin/sed -e 's%#.*$%%g' | /bin/sed -e 's% *, *%,%g' | /bin/sed -e 's%^  *%%' | /bin/sed -e 's%  *$%%' \
        | /bin/grep -e "^${x_driver},"                                                                          \
        | {
            found=
            while read map ; do
                map_kernel_module=
                if [ -n "${map}" ] ; then
                    map_kernel_module=`/bin/echo ${map} | /usr/bin/cut -d ',' -f 2`
                fi
                if [ -z "${found}" ] ; then
                    found=1
                    /bin/echo ${map_kernel_module}
                fi
            done
        }
    fi
}

mm_jump_myth_mainmenu() {
    answer=`mm_mythfrontend_networkcontrol "jump mainmenu"`
    echo "Myth remote control returns:"${answer}
}

mm_show_mythnotify() {
    # mm_show_mythnotify <description> <extra> <type> <timeout> <title> <progres_text> <progress>
    # allowable types are"
    # "error"
    # "warning"
    # "ok"
    # "message"     <- this will show message instead notify
    # <image file>  <- this will show <image>
    # ""            <- this will notify without image
    local text="${1}"
    local extra="${2}"
    local type="${3}"
    local message="${1}\n${2}"
    local title="${5}"
    local result
    local image
    local progress_text
    local progress
    local timeout=8
    #local send_cmd="/usr/bin/socat STDIN udp4:127.0.0.1:6948"
    local send_cmd="/usr/bin/nc -u -w1 127.0.0.1 6948"

    if [ -n ${4} ] ; then
        timeout=${4}
    fi
    if [ "x${title}" = 'x' ] ; then
        title="System"
    else
        title=${5}
    fi
    if [ x${6} = 'x' ] ; then
        progress_text=''
    else
        progress_text=${6}
    fi
    if [ x${7} = 'x' ] ; then
        progress=''
    else
        progress=${7}
    fi

    if [ x${type} = "xmessage" ] ; then
        /bin/echo -e "<mythmessage version=\"1\"> <text>${message}</text> <timeout>$timeout</timeout> </mythmessage>" | ${send_cmd}
    else
        if [ x${type} = "xerror" ] ; then
            image="images/mythnotify/error.png"
        elif [ x${type} = "xwarning" ] ; then
            image="images/mythnotify/warning.png"
        elif [ x${type} = "xok" ] ; then
            image="images/mythnotify/check.png"
        elif [ -z ${type} ] ; then
            image=""
        else
            image=${type}
        fi

        /bin/echo -e "
        <mythnotification version=\"1\">
          <image>${image}</image>
          <text>${title}</text>
          <origin></origin>
          <description>${text}</description>
          <extra>${extra}</extra>
          <progress_text>${progress_text}</progress_text>
          <progress>${progress}</progress>
          <timeout>${timeout}</timeout>
        </mythnotification>" | ${send_cmd}
    fi
}

mm_exec_and_notify() {
#  echo -e $1 > /var/tmp/out.tmp 2>&1
#  local title=`cat /var/tmp/out.tmp`
  local title=`echo -e $1.`
  local result=`${2} | sed -e "s/::.*//g"`
  mm_show_mythnotify "${title}" "${result}" "warning"
}

mm_notify_and_exec() {
  local title=`echo -e $1.`
  mm_show_mythnotify "${title}"
  /bin/sleep 5
  local result=`${2} | sed -e "s/::.*//g"`
}

mm_test_master_db_connection() {
    # Function is testing connection with DB at with MM_MASTER_CONNECTION_TEST_TIMEOUT timeout.
    # When MM_MASTER_CONNECTION_TEST_TIMEOUT sec timeout  is reached - functuion will return false
    # inputs: 
    # if non zero input param.if provieded - function will also display msgs on splash screen

    local show_on_splash=$1

    # Test Myth database connection.
    /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_test_db_conn] Testing connection with DB at '${MM_MASTER_SERVER}'"

    i=0
    while [ $i -lt ${MM_MASTER_CONNECTION_TEST_TIMEOUT} ] ; do
        i=$((${i} + 1))
        if ! mm_mythdb_test ; then
            if [ $i -ge ${MM_MASTER_CONNECTION_TEST_TIMEOUT} ] ; then
                /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_test_db_conn] Cannot connect to DB after ${MM_MASTER_CONNECTION_TEST_TIMEOUT}sec."
                if [ -n ${show_on_splash} ] ; then
                    mm_message_output info "Cannot connect to the DB. MythTV will relay on user search from MythTV uPNP discovery ..."
                fi
                /bin/false
                return
            else
                /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_test_db_conn] Trying connect to DB (${i} of ${MM_MASTER_CONNECTION_TEST_TIMEOUT})"
                if [ -n ${show_on_splash} ] ; then
                    mm_message_output info "Awaiting for MythTV master DB avaliability: (${i} of ${MM_MASTER_CONNECTION_TEST_TIMEOUT} seconds) ..."
                fi
                /bin/sleep 1
            fi
        else
            /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_test_db_conn] Connection with DB at \'${MM_MASTER_SERVER}\' is OK. Good!"
            i=${MM_MASTER_CONNECTION_TEST_TIMEOUT}
        fi
    done

    /bin/true
    return

}

mm_mythfrontend_networkcontrol() {
# 1st param is command
# 2nd param (option) is port. If not provided, function
# will query setting DB

    local command=$1
    local port=$2

    local failed
    local response

    local host
    local port

    failed=1
    response=''

    if [ -n "`/bin/pidof mythfrontend`" ] ; then
        host='localhost'
        if [ x${port} = "x" ] ; then
            port=`mm_mythdb_settings_get NetworkControlPort`
        fi

        response=`/bin/echo -e "${command}\nexit" \
                   | /usr/bin/hose ${host} ${port} --out --in \
                     /bin/sh -c "/bin/cat <&3 & \
                                 /bin/grep '^#' \
                                 | /bin/sed 's%[[:cntrl:]]% %' \
                                 | /bin/grep -v '^# *$' \
                                 | /bin/sed 's%^#%%' \
                                 | /bin/sed 's%  *% %' \
                                 | /bin/sed 's%^ %%' \
                                 | /bin/sed 's% $%%' >&4" \
                     3<&0 4>&1`

         if [ $? -eq 0 ] ; then
             failed=0
         fi
    fi

    /bin/echo ${response}

    if [ ${failed} -eq 1 ] ; then
        /bin/false
        return
    else
        /bin/true
        return
    fi
}

mm_reload_voip_config() {
    if [ "x${MM_VOIP_ENABLED}" = "xyes" ] ; then
        if [ "x${MM_VOIP_LOAD_CONFIG}" = "xyes" ] ; then
            /bin/rm -f /etc/sip-daemon.conf
            mm_confro_get sip-daemon.conf /etc/sip-daemon.conf
            if [ ! -e /etc/sip-daemon.conf ] ; then
                /usr/bin/logger -s -t minimyth -p "local0.error" \
                    "[functions/mm_reload_voip_config] failed to load sip-daemon.conf file..."
                /bin/false
                return
            fi
        fi
        /bin/rm -f /home/minimyth/.mythtv/phone.xml
        mm_confro_get phone-book.xml /home/minimyth/.mythtv/phone.xml
        if [ ! -e /home/minimyth/.mythtv/phone.xml ] ; then
            /usr/bin/logger -s -t minimyth -p "local0.error" \
                "[functions/mm_reload_voip_config] failed to load phone-book.xml file..."
            /bin/false
            return
        fi
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "[functions/mm_reload_voip_config] restarting sip-daemon.py..."
        /bin/touch /tmp/exit.sem
        /bin/sleep 3
        /usr/bin/sip-daemon.sh &
    fi

    if [ "x${MM_OPTICAL_RIP_ENABLED}" = "xyes" ] ; then

        /bin/rm -f /home/minimyth/.MakeMKV/settings.conf
        mm_confro_get makemkv.conf /home/minimyth/.MakeMKV/settings.conf
        if [ ! -e /home/minimyth/.MakeMKV/settings.conf ] ; then
            "[functions/mm_reload_voip_config] failed to load makemkv.conf file..."
            /bin/false
            return
        fi

        /bin/rm -f /home/minimyth/.MakeMKV/sdf.bin
        mm_confro_get sdf.bin /home/minimyth/.MakeMKV/sdf.bin

        /bin/rm -f /usr/bin/makemkvcon
        mm_confro_get makemkvcon /usr/bin/makemkvcon
        /bin/chmod 0755 /usr/bin/makemkvcon
        if [ ! -e /usr/bin/makemkvcon ] ; then
            "[functions/mm_reload_voip_config] failed to load makemkvcon file..."
            /bin/false
            return
        fi
    fi

    /bin/true
}

mm_redownload_theme() {
    # Re-mount MythTV theme directory.
    if [ -n "${MM_THEME_URL}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Un-mounting theme from ${MM_THEME_URL}"
        if ! mm_url_umount "${MM_THEME_URL}" "/usr/share/mythtv/themes/${MM_THEME_NAME}" ; then
            /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Can't umount theme from ${MM_THEME_URL}"
            /bin/false
            return
        fi
        /bin/sleep 3
        /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Re-mounting theme from ${MM_THEME_URL}"
        if ! mm_url_mount "${MM_THEME_URL}" "/usr/share/mythtv/themes/${MM_THEME_NAME}" ; then
            /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Can't download/re-mount theme from ${MM_THEME_URL}. Fallback to build-in ${DEFAULT_UI_THEME}..."
            mm_mythdb_settings_set "Theme" "${DEFAULT_UI_THEME}"
            /bin/false
            return
        else
            /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Theme from ${MM_THEME_URL} successfuly mounted..."
            mm_mythdb_settings_set "Theme" "${MM_THEME_NAME}"
        fi
    fi
    # Re-mount MythTV thememenu directory.
    if [ -n "${MM_THEMEMENU_URL}" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Un-mounting thememenu from ${MM_THEMEMENU_URL}"
        if ! mm_url_umount "${MM_THEMEMENU_URL}" "/usr/share/mythtv/themes/${MM_THEMEMENU_NAME}" ; then
            /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Can't umount thememenu from ${MM_THEMEMENU_URL}"
            /bin/false
            return
        fi
        /bin/sleep 3
        /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Re-mounting thememenu from ${MM_THEMEMENU_URL}"
        if ! mm_url_mount "${MM_THEMEMENU_URL}" "/usr/share/mythtv/themes/${MM_THEMEMENU_NAME}" ; then
            /usr/bin/logger -s -t minimyth -p "local0.info" "[functions/mm_redownload_theme] Can't download/re-mount thememenu from ${MM_THEMEMENU_URL}"
            /bin/false
            return
        fi
    fi
    return
}

mm_check_rss_reload_mythfrontend() {
    if [ -n "${MM_MYTHTV_RSS_FOR_RESTART}" ] ; then
        total_installed_memory=`expr $(sed -n '/^MemTotal:/ s/[^0-9]//gp' /proc/meminfo) / 1024`
        avalable_memory=`expr ${total_installed_memory} - ${MM_MYTHTV_HOME_RAMDISK}`
        if [ ${avalable_memory} -lt 512 ] ; then
            /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_check_rss_reload_mythfrontend] determined RAM is ${avalable_memory}MB and below 512MB.Exitig this function ..."
            /bin/false
            return
        else
            myth_rss=`expr $(/bin/ps --no-headers -o rss -C mythfrontend) / 1024`
            /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_check_rss_reload_mythfrontend] RAM=${avalable_memory}MB, mythfrontend RSS=${myth_rss}MB ..."
            if [ ${MM_MYTHTV_RSS_FOR_RESTART} -gt 100 ] ; then
                if [ ${myth_rss} -gt ${MM_MYTHTV_RSS_FOR_RESTART} ] ; then
                    /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_check_rss_reload_mythfrontend] RSS=${myth_rss}MB > ${MM_MYTHTV_RSS_FOR_RESTART}MB treshold! Restarting to free RSS ..."
                    /usr/bin/mm_manage _restart_mythfrontend
                    /bin/true
                    return
                else
                    /bin/false
                    return
                fi
            else
                myth_rss_percent=`expr 100 \* ${myth_rss} / ${avalable_memory}`
                if [ ${myth_rss_percent} -gt ${MM_MYTHTV_RSS_FOR_RESTART} ] ; then
                    /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_check_rss_reload_mythfrontend] RSS=${myth_rss_percent}% > ${MM_MYTHTV_RSS_FOR_RESTART}% treshold! Restarting to free RSS ..."
                    /usr/bin/mm_manage _restart_mythfrontend
                    /bin/true
                    return
                else
                    /bin/false
                    return
                fi
            fi
        fi
    fi
    /bin/false
    return
}

mm_check_uptime_reload_mythfrontend() {
    if [ -n "${MM_MYTHTV_UPTIME_FOR_RESTART}" ] ; then
        myth_uptime_hours=`expr $(ps h -o etimes -p $(pidof mythfrontend)) / 3600`
        /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_check_uptime_reload_mythfrontend] curr.uptime=${myth_uptime_hours}h. reload tresh=${MM_MYTHTV_UPTIME_FOR_RESTART}h ..."
        if [ ${myth_uptime_hours} -gt ${MM_MYTHTV_UPTIME_FOR_RESTART} ] ; then
            /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_check_uptime_reload_mythfrontend] uptime=${myth_uptime_hours}h > ${MM_MYTHTV_UPTIME_FOR_RESTART}h treshold! Restarting to free RSS ..."
            /usr/bin/mm_manage _restart_mythfrontend
            /bin/true
            return
        else
            /bin/false
            return
        fi
    fi
    /bin/false
    return
}

mm_minimize_theme_req_memory() {

    local theme_background_dir="/usr/share/mythtv/themes/Monochrome-mm2/images/Backgrounds"
    local default_background_file="/etc/splash/minimyth/images/1920x1080.png"

    if [ -e ${theme_background_dir} ] ; then
        local file_list=`ls -1 ${theme_background_dir}/*.jpg`
        rm -rf ${theme_background_dir}/Background*.jpg
        for file in ${file_list} ; do
            ln -sf ${default_background_file} ${file}
        done
    fi
}

mm_move_to_zram_ramdisk() {
# 1st para: mount point
# 2nd para: size
#
    local mount_point=$1
    local size=$2
    failed=1

    if [ ! -d "/sys/class/zram-control" ] ; then
        modprobe zram
    fi

    zram_device=$(zramctl -f | sed 's/\/dev\///' | grep -e '^zram')
    if [ "x${zram_device}" = "x" ] ; then
        /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_move_to_zram_ramdisk] No available zram devices to create ${mount_point} ... Exiting !"
        return ${failed}
    fi

    if [ "x${mount_point}" = "x" ] ; then
        /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_move_to_zram_ramdisk] No mountpoint provided ... Exiting !"
        /bin/false
        return ${failed}
    fi

    /bin/mkdir -p "${mount_point}" || return
    mv -f ${mount_point} ${mount_point}.$$ || return
    /bin/mkdir -p "${mount_point}" || return

    disksize=`echo ${size} | sed -e 's/M$/*1048576/' -e 's/K$/*1024/' | bc`
    echo -n ${disksize} > /sys/block/${zram_device}/disksize
    label=${mount_point}

    mke2fs -q -m 0 -b 4096 -O sparse_super -L ${label} /dev/${zram_device}

    mount -o relatime,noexec,nosuid /dev/${zram_device} ${mount_point}
    if [ "$?" -eq 0 ] ; then
        /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_move_to_zram_ramdisk] Mounted [${zram_device}] as [${mount_point}] labeled as ${label} with size ${size} ..."
        failed=0
    else
        /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_move_to_zram_ramdisk] Failed to mount [${zram_device}] as [${mount_point}] labeled as ${label} with size ${size} ..."
    fi

    cp -af ${mount_point}.$$/. ${mount_point}/
    rm -rf ${mount_point}.$$

    return ${failed}
}

bt_get_connection_status() {

    local mac=${1}

    if [ ! -e "/sys/class/bluetooth" ] ; then

        bt_status="no_bt_device"
        echo "No BT controller found... Exiting!"
        return
    fi

    if [ x${mac} = "x" ] ; then

        bt_status="BT_Device_Not_Configured"
        echo "No BT device MAC addr. configured... Exiting!"
        return
    fi

    connection_status=$(bluetoothctl info ${mac} | grep "Connected:" | awk '{print $2}')

    if [ -z "$connection_status" ]; then

        bt_status="cant_get_bt_status"
        echo "Can't determine status for ${mac} device... Exiting!"
        return
    fi

    if [ "$connection_status" = "yes" ]; then
        bt_status="connected"
    else
        bt_status="disconnected"
    fi

    echo "bluetoothct reports device ${mac} as: $bt_status"
}

bt_connect() {

    local mac=${1}

    echo "Connecting to ${mac}..."

    bt_status="connected"

    bluetoothctl << EOF
    connect ${mac}
EOF

}

bt_disconnect() {

    local mac=${1}

    echo "Disconnecting from ${mac}..."

    bt_status="disconnected"

    bluetoothctl << EOF
    disconnect ${mac}
EOF

}

mm_game_restore() {

    local FILE
    local REMOTE_FILE
    local LOCAL_DIR
    local LOCAL_FILE

    FILE="game.tar"
    REMOTE_FILE="${FILE}"
    LOCAL_DIR="${HOME}/tmp"
    LOCAL_FILE="${LOCAL_DIR}/${FILE}"

    /usr/bin/test -n "${LOCAL_DIR}" && /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/test -n "${LOCAL_DIR}" && /usr/bin/test ! -d "${LOCAL_DIR}" && return

    /bin/rm -f "${LOCAL_FILE}"

    mm_confrw_get "${REMOTE_FILE}" "${LOCAL_FILE}"

    if [ -n "${LOCAL_FILE}" ] ; then
        cd /home/minimyth
        /bin/tar -xf "${LOCAL_FILE}"
        /bin/rm -f "${LOCAL_FILE}"
    fi

    /bin/rm -f "${LOCAL_FILE}"
}

mm_game_save() {

    local FILE
    local REMOTE_FILE
    local LOCAL_DIR
    local LOCAL_FILE

    FILE="game.tar"
    REMOTE_FILE="${FILE}"
    LOCAL_DIR="${HOME}/tmp"
    LOCAL_FILE="${LOCAL_DIR}/${FILE}"

    /usr/bin/test -n "${LOCAL_DIR}" && /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/test -n "${LOCAL_DIR}" && /usr/bin/test ! -d "${LOCAL_DIR}" && return

    # Enumerate all the files to be saved.
    local IFS_SAVE
    local GAME_SAVE_FULL
    local GAME_SAVE_LIST
    local GAME_SAVE_ITEM
    local GAME_SAVE
    GAME_SAVE_FULL=`/bin/echo ":${MM_GAME_SAVE_LIST}" \
        | /bin/sed -e 's%:%:/home/minimyth/%g'        \
        | /bin/sed -e 's%^:%%'`
    IFS_SAVE=${IFS}
    IFS=:
    for GAME_SAVE_ITEM in ${GAME_SAVE_FULL}; do
        if [ -e "${GAME_SAVE_ITEM}" ] ; then
            GAME_SAVE=`/bin/echo "${GAME_SAVE_ITEM}" \
                | /bin/sed -e 's%^/home/minimyth/%%'`
            GAME_SAVE_LIST="${GAME_SAVE_LIST}|${GAME_SAVE}"
        fi
    done
    IFS=${IFS_SAVE}
    GAME_SAVE_LIST=`/bin/echo ${GAME_SAVE_LIST} \
        | /bin/sed -e 's%^|%%'                  \
        | /bin/sed -e 's%|%:%g'`

    /bin/rm -f "${LOCAL_FILE}"
    if [ -n "${GAME_SAVE_LIST}" ] ; then
        /bin/mkdir -p /home/minimyth
        cd /home/minimyth
        local IFS_SAVE
        IFS_SAVE=${IFS}
        IFS=:${IFS}
        /bin/tar -cf "${LOCAL_FILE}" ${GAME_SAVE_LIST} || /bin/rm -f "${LOCAL_FILE}"
        IFS=${IFS_SAVE}
        if [ ! -e "${LOCAL_FILE}" ] ; then
            /usr/bin/logger -s -t minimyth -p "local0.error" \
                "failed to create game files tarball."
            /bin/false
            return
        fi
        mm_confrw_put "${REMOTE_FILE}" "${LOCAL_FILE}"
        if [ $? -ne 0 ] ; then
            /bin/rm -f "${LOCAL_FILE}"
            /bin/false
            return
        else
            /bin/rm -f "${LOCAL_FILE}"
        fi
    fi
}

mm_extras_save() {

    if [ ! -d /usr/local ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "failed to create the extras file because the extras directory does not exist."
        /bin/false
        return
    fi
    if [ `/bin/ls -1 /usr/local | /usr/bin/wc -l` -eq 0 ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "failed to create the extras file because the extras directory is empty."
        /bin/false
        return
    fi

    local FILE
    local REMOTE_FILE
    local LOCAL_DIR
    local LOCAL_FILE

    FILE="extras.sfs"
    REMOTE_FILE="${FILE}"
    LOCAL_DIR="${HOME}/tmp"
    LOCAL_FILE="${LOCAL_DIR}/${FILE}"

    /bin/rm -f "${LOCAL_FILE}"
    /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/mksquashfs /usr/local ${LOCAL_FILE} > /dev/null 2>&1
    if [ $? -ne 0 ] ; then
        /bin/rm -f ${LOCAL_FILE}
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "failed to create the extras file because squashfs failed."
        /bin/false
        return
    fi

    mm_confrw_put "${REMOTE_FILE}" "${LOCAL_FILE}"
    if [ $? -ne 0 ] ; then
        /bin/rm -f ${LOCAL_FILE}
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "failed to save the extras file."
        /bin/false
        return
    fi

    /bin/rm -f "${LOCAL_FILE}"
    /bin/true
}

mm_themecache_save() {

    if [ ! -d /home/minimyth/.mythtv/cache/themecache ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "[functions/mm_themecache_save] failed to create the MythTV themecache file because the MythTV themecache directory does not exist!"
        /bin/false
        return
    fi
    if [ -z "`cd /home/minimyth/.mythtv/cache/themecache ; /bin/ls -A`" ] ; then
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "[functions/mm_themecache_save] failed to create the MythTV themecache file because the MythTV themecache directory seems to be empty!"
        /bin/false
        return
    fi

    local FILE
    local REMOTE_FILE
    local LOCAL_DIR
    local LOCAL_FILE

    # FILE=`cd /home/minimyth/.mythtv/cache/themecache ; /bin/ls`.sfs
    FILE="themecache.sfs"
    REMOTE_FILE="${FILE}"
    LOCAL_DIR="${HOME}/tmp"
    LOCAL_FILE="${LOCAL_DIR}/${FILE}"

    /bin/rm -f "${LOCAL_FILE}"
    /bin/mkdir -p "${LOCAL_DIR}"
    /usr/bin/mksquashfs /home/minimyth/.mythtv/cache/themecache ${LOCAL_FILE} > /dev/null 2>&1
    if [ $? -ne 0 ] ; then
        /bin/rm -f ${LOCAL_FILE}
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "[functions/mm_themecache_save] failed to create the MythTV themecache file because squashfs failed."
        /bin/false
        return
    fi

    /usr/bin/logger -t minimyth -p "local0.info" "[functions/mm_themecache_save] themecache ${LOCAL_FILE} successfuly prepared..."

    mm_confrw_put "${REMOTE_FILE}" "${LOCAL_FILE}"
    if [ $? -ne 0 ] ; then
        /bin/rm -f ${LOCAL_FILE}
        /usr/bin/logger -s -t minimyth -p "local0.error" \
            "[functions/mm_themecache_save] failed to upload the MythTV themecache file!"
        /bin/false
        return
    fi

    /bin/rm -f "${LOCAL_FILE}"
    /bin/true
}

mm_cookiejar_save() {

    if [ -d /home/minimyth/.local/share/mythfrontend/QtWebEngine/MythTV ] ; then
        mm_directory_save_to_confrw "/home/minimyth/.local/share/mythfrontend/QtWebEngine/MythTV" "mythtv-webengine-config"
    fi

    if [ -d /home/minimyth/.config/google-chrome ] ; then
        mm_directory_save_to_confrw "/home/minimyth/.config/google-chrome" "google-chrome-config"
    fi

    if [ -d /home/minimyth/.mozilla ] ; then
        mm_directory_save_to_confrw "/home/minimyth/.mozilla" "mozilla-firefox-config"
    fi

    /bin/true
    return
}

mm_bt_state_save() {

    if [ -d /var/lib/bluealsa ] ; then
        mm_directory_save_to_confrw "/var/lib/bluealsa" "bluealsa-state"
    fi
    if [ -d /var/lib/bluetooth ] ; then
        mm_directory_save_to_confrw "/var/lib/bluetooth" "bluetooth-state"
    fi
}

mm_bt_switch_audio_to_default() {

    if [ x$(readlink /etc/asound.conf) = "x/etc/asound-bt.conf" ] ; then
        if [ -e /etc/asound-hdmi.conf ] ; then
            ln -sf /etc/asound-hdmi.conf /etc/asound.conf
        fi
    fi
    return 0
}

mm_bt_state_restore() {

    mm_directory_restore_from_confrw "/var/lib/bluealsa" "bluealsa-state"
    mm_directory_restore_from_confrw "/var/lib/bluetooth" "bluetooth-state"
}

mm_kodi_settings_save() {

    if [ -d /home/minimyth/.kodi ] ; then
        mm_directory_save_to_confrw "/home/minimyth/.kodi" "kodi-settings"
    fi
}

mm_kodi_settings_restore() {

    mm_directory_restore_from_confrw "/home/minimyth/.kodi" "kodi-settings"
}
