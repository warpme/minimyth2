From 3ea013f4d7774632a94b092c384834e7900dae10 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Mon, 27 May 2013 17:13:22 +0100
Subject: [PATCH 113/333] TV: Improved caching in IsTunable

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/libs/libmythtv/channelutil.cpp |   51 +++++++++++++++++++++++++++++++++
 mythtv/libs/libmythtv/channelutil.h   |    1 +
 mythtv/libs/libmythtv/tv_play.cpp     |   44 +++++++++++++++++++---------
 mythtv/libs/libmythtv/tv_play.h       |    2 ++
 4 files changed, 85 insertions(+), 13 deletions(-)

diff --git a/mythtv/libs/libmythtv/channelutil.cpp b/mythtv/libs/libmythtv/channelutil.cpp
index 6a29295..6591775 100644
--- a/mythtv/libs/libmythtv/channelutil.cpp
+++ b/mythtv/libs/libmythtv/channelutil.cpp
@@ -11,6 +11,10 @@ using namespace std;
 #include <QFile>
 #include <QReadWriteLock>
 #include <QHash>
+#include <QMap>
+#include <QPair>
+#include <QMutex>
+#include <QMutexLocker>
 
 #include "channelutil.h"
 #include "mythdb.h"
@@ -2528,4 +2532,51 @@ ChannelInfoList ChannelUtil::LoadChannels(uint startIndex, uint count,
     return channelList;
 }
 
+//static
+bool ChannelUtil::GetMplexAndSourceID(uint &mplexid, uint &sourceid, uint chanid)
+{
+    typedef QPair< uint,uint > src_t; // mplexid, sourceid
+    typedef QMap< uint,src_t > cache_src_t;
+    static cache_src_t s_cache_src;
+    static QMutex s_mutex;
+
+    {
+        QMutexLocker locker(&s_mutex);
+        cache_src_t::const_iterator it = s_cache_src.find(chanid);
+        if (it != s_cache_src.end())
+        {
+            mplexid = it->first;
+            sourceid = it->second;
+            return true;
+        }
+    }
+
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    query.prepare(
+        "SELECT mplexid, sourceid "
+        "FROM channel "
+        "WHERE chanid = :CHANID");
+    query.bindValue(":CHANID", chanid);
+
+    if (!query.exec())
+    {
+        MythDB::DBError("GetMplexAndSourceID", query);
+        mplexid = sourceid = 0;
+        return false;
+    }
+    else if (!query.next())
+    {
+        mplexid = sourceid = 0;
+        return false;
+    }
+
+    mplexid = query.value(0).toUInt();
+    sourceid = query.value(1).toUInt();
+
+    QMutexLocker locker(&s_mutex);
+    s_cache_src[chanid] = src_t(mplexid, sourceid);
+    return true;
+}
+
 /* vim: set expandtab tabstop=4 shiftwidth=4: */
diff --git a/mythtv/libs/libmythtv/channelutil.h b/mythtv/libs/libmythtv/channelutil.h
index 59ffd85..729bedc 100644
--- a/mythtv/libs/libmythtv/channelutil.h
+++ b/mythtv/libs/libmythtv/channelutil.h
@@ -298,6 +298,7 @@ class MTV_PUBLIC ChannelUtil
     static int     GetTimeOffset(int chanid);
     static int     GetSourceID(int mplexid);
     static uint    GetSourceIDForChannel(uint chanid);
+    static bool    GetMplexAndSourceID(uint &mplexid, uint &sourceid, uint chanid);
 
     static QStringList GetCardTypes(uint chandid);
 
diff --git a/mythtv/libs/libmythtv/tv_play.cpp b/mythtv/libs/libmythtv/tv_play.cpp
index 695fa19..0cd7c39 100644
--- a/mythtv/libs/libmythtv/tv_play.cpp
+++ b/mythtv/libs/libmythtv/tv_play.cpp
@@ -8516,29 +8516,47 @@ QSet<uint> TV::IsTunableOn(TV *tv,
         return tunable_cards;
     }
 
-    uint mplexid = ChannelUtil::GetMplexID(chanid);
-    mplexid = (32767 == mplexid) ? 0 : mplexid;
+    uint mplexid = 0, sourceid = 0;
+    if (!ChannelUtil::GetMplexAndSourceID(mplexid, sourceid, chanid))
+        return tunable_cards;
+
+    if (mplexid == 32767)
+        mplexid = 0;
 
     vector<uint> excluded_cards;
     if (ctx && ctx->recorder && ctx->pseudoLiveTVState == kPseudoNormalLiveTV)
         excluded_cards.push_back(ctx->GetCardID());
 
-    uint sourceid = ChannelUtil::GetSourceIDForChannel(chanid);
-    vector<uint> connected   = RemoteRequestFreeRecorderList(excluded_cards);
-    vector<uint> interesting = CardUtil::GetCardIDs(sourceid);
-
-    // filter disconnected cards
-    vector<uint> cardids = excluded_cards;
-    for (uint i = 0; i < connected.size(); i++)
+    bool bFound = false;
+    vector<uint> cardids;
+    if (tv)
     {
-        for (uint j = 0; j < interesting.size(); j++)
+        QMutexLocker locker(&tv->is_tunable_cache_lock);
+        cache_cards_t::const_iterator it = tv->is_tunable_cache_cards.find(chanid);
+        if ((bFound = (it != tv->is_tunable_cache_cards.end())))
+            cardids = *it;
+    }
+    if (!bFound && tv)
+    {
+        cardids = excluded_cards;
+        vector<uint> connected   = RemoteRequestFreeRecorderList(excluded_cards);
+        vector<uint> interesting = CardUtil::GetCardIDs(sourceid);
+
+        // filter disconnected cards
+        for (uint i = 0; i < connected.size(); i++)
         {
-            if (connected[i] == interesting[j])
+            for (uint j = 0; j < interesting.size(); j++)
             {
-                cardids.push_back(interesting[j]);
-                break;
+                if (connected[i] == interesting[j])
+                {
+                    cardids.push_back(interesting[j]);
+                    break;
+                }
             }
         }
+
+        QMutexLocker locker(&tv->is_tunable_cache_lock);
+        tv->is_tunable_cache_cards[chanid] = cardids;
     }
 
 #if 0
diff --git a/mythtv/libs/libmythtv/tv_play.h b/mythtv/libs/libmythtv/tv_play.h
index 6626024..7a39e52 100644
--- a/mythtv/libs/libmythtv/tv_play.h
+++ b/mythtv/libs/libmythtv/tv_play.h
@@ -946,6 +946,8 @@ class MTV_PUBLIC TV : public QObject, public MenuItemDisplayer
     // IsTunable() cache, used by embedded program guide
     mutable QMutex                 is_tunable_cache_lock;
     QMap< uint,vector<InputInfo> > is_tunable_cache_inputs;
+    typedef QMap< uint,vector<uint> > cache_cards_t;
+    cache_cards_t                  is_tunable_cache_cards;
 
     // Channel group stuff
     /// \brief Lock necessary when modifying channel group variables.
-- 
1.7.9.5

