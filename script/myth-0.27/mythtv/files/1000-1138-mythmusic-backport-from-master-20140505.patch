diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/cddecoder.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/cddecoder.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/cddecoder.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/cddecoder.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -177,12 +177,7 @@
     if (output())
         output()->PauseUntilBuffered();
 
-    QFile* file = dynamic_cast< QFile* >(input()); // From QIODevice*
-    if (file)
-    {
-        setFilename(file->fileName());
-        m_tracknum = getFilename().section('.', 0, 0).toUInt();
-    }
+    m_tracknum = getFilename().section('.', 0, 0).toUInt();
 
     QMutexLocker lock(&getCdioMutex());
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/cdrip.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/cdrip.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/cdrip.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/cdrip.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -24,12 +24,14 @@
 #include <QKeyEvent>
 #include <QEvent>
 #include <QFile>
+#include <QUrl>
 
 // MythTV plugin includes
 #include <mythcontext.h>
 #include <mythdb.h>
 #include <lcddevice.h>
 #include <mythmediamonitor.h>
+#include <mythdirs.h>
 
 // MythUI
 #include <mythdialogbox.h>
@@ -40,6 +42,8 @@
 #include <mythuiprogressbar.h>
 #include <mythuibuttonlist.h>
 #include <mythsystemlegacy.h>
+#include <storagegroup.h>
+#include <remotefile.h>
 
 // MythUI headers
 #include <mythtv/libmythui/mythscreenstack.h>
@@ -88,6 +92,10 @@
     (QEvent::Type) QEvent::registerEventType();
 QEvent::Type RipStatusEvent::kOverallStartEvent =
     (QEvent::Type) QEvent::registerEventType();
+QEvent::Type RipStatusEvent::kCopyStartEvent =
+    (QEvent::Type) QEvent::registerEventType();
+QEvent::Type RipStatusEvent::kCopyEndEvent =
+    (QEvent::Type) QEvent::registerEventType();
 QEvent::Type RipStatusEvent::kFinishedEvent =
     (QEvent::Type) QEvent::registerEventType();
 QEvent::Type RipStatusEvent::kEncoderErrorEvent =
@@ -176,12 +184,18 @@
     m_CDdevice(device), m_quality(quality),
     m_tracks(tracks), m_totalSectors(0),
     m_totalSectorsDone(0), m_lastTrackPct(0),
-    m_lastOverallPct(0)
+    m_lastOverallPct(0), m_musicStorageDir("")
+
 {
 #ifdef WIN32 // libcdio needs the drive letter with no path
     if (m_CDdevice.endsWith('\\'))
         m_CDdevice.chop(1);
 #endif // WIN32
+
+    QString lastHost = gCoreContext->GetSetting("MythMusicLastRipHost", gCoreContext->GetMasterHostName());
+    QStringList dirs = StorageGroup::getGroupDirs("Music", lastHost);
+    if (dirs.count() > 0)
+        m_musicStorageDir = StorageGroup::getGroupDirs("Music", lastHost).at(0);
 }
 
 CDRipperThread::~CDRipperThread(void)
@@ -203,12 +217,26 @@
 void CDRipperThread::run(void)
 {
     RunProlog();
+
     if (!m_tracks->size() > 0)
     {
         RunEpilog();
         return;
     }
 
+    m_totalSectors = 0;
+    m_totalSectorsDone = 0;
+    for (int trackno = 0; trackno < m_tracks->size(); trackno++)
+    {
+        m_totalSectors += getSectorCount(m_CDdevice, trackno + 1);
+    }
+
+    if (!m_totalSectors)
+    {
+        RunEpilog();
+        return;
+    }
+
     MusicMetadata *track = m_tracks->at(0)->metadata;
     QString tots;
 
@@ -235,13 +263,6 @@
     QString encodertype = gCoreContext->GetSetting("EncoderType");
     bool mp3usevbr = gCoreContext->GetNumSetting("Mp3UseVBR", 0);
 
-    m_totalSectors = 0;
-    m_totalSectorsDone = 0;
-    for (int trackno = 0; trackno < m_tracks->size(); trackno++)
-    {
-        m_totalSectors += getSectorCount(m_CDdevice, trackno + 1);
-    }
-
     QApplication::postEvent(m_parent,
         new RipStatusEvent(RipStatusEvent::kOverallStartEvent, m_totalSectors));
 
@@ -255,6 +276,7 @@
     }
 
     MusicMetadata *titleTrack = NULL;
+    QString saveDir = GetConfDir() + "/MythMusic/RipTemp/";
     QString outfile;
 
     std::auto_ptr<Encoder> encoder;
@@ -296,27 +318,25 @@
                 titleTrack = track;
                 titleTrack->setLength(m_tracks->at(trackno)->length);
 
-                outfile = filenameFromMetadata(track);
-
                 if (m_quality < 3)
                 {
                     if (encodertype == "mp3")
                     {
-                        outfile += ".mp3";
-                        encoder.reset(new LameEncoder(getMusicDirectory() + outfile, m_quality,
+                        outfile = QString("track%1.mp3").arg(trackno);
+                        encoder.reset(new LameEncoder(saveDir + outfile, m_quality,
                                                       titleTrack, mp3usevbr));
                     }
                     else // ogg
                     {
-                        outfile += ".ogg";
-                        encoder.reset(new VorbisEncoder(getMusicDirectory() + outfile, m_quality,
+                        outfile = QString("track%1.ogg").arg(trackno);
+                        encoder.reset(new VorbisEncoder(saveDir + outfile, m_quality,
                                                         titleTrack));
                     }
                 }
                 else
                 {
-                    outfile += ".flac";
-                    encoder.reset(new FlacEncoder(getMusicDirectory() + outfile, m_quality,
+                    outfile = QString("track%1.flac").arg(trackno);
+                    encoder.reset(new FlacEncoder(saveDir + outfile, m_quality,
                                                   titleTrack));
                 }
 
@@ -354,12 +374,27 @@
                 return;
             }
 
-            // save the metadata to the DB
             if (m_tracks->at(trackno)->active)
             {
-                titleTrack->setFilename(outfile);
+                QString ext = QFileInfo(outfile).suffix();
+                QString destFile = filenameFromMetadata(titleTrack) + '.' + ext;
+                QUrl url(m_musicStorageDir);
+
+                // save the metadata to the DB
+                titleTrack->setFilename(destFile);
+                titleTrack->setHostname(url.host());
                 titleTrack->setFileSize((quint64)QFileInfo(outfile).size());
                 titleTrack->dumpToDatabase();
+
+                // this will delete the encoder which will write the metadata in it's dtor
+                encoder.reset();
+
+                // copy track to the BE
+                destFile = gCoreContext->GenMythURL(url.host(), 0, destFile, "Music");
+
+                QApplication::postEvent(m_parent, new RipStatusEvent(RipStatusEvent::kCopyStartEvent, 0));
+                RemoteFile::CopyFile(saveDir + outfile, destFile);
+                QApplication::postEvent(m_parent, new RipStatusEvent(RipStatusEvent::kCopyEndEvent, 0));
             }
         }
     }
@@ -500,6 +535,8 @@
 
 Ripper::Ripper(MythScreenStack *parent, QString device) :
     MythScreenType(parent, "ripcd"),
+    m_musicStorageDir(""),
+
     m_decoder(NULL),
 
     m_artistEdit(NULL),
@@ -538,10 +575,28 @@
         mon->StopMonitoring();
     }
 #endif // _WIN32
+
+    // make sure the directory where we temporarily save the rips is present
+    QDir dir;
+    dir.mkpath(GetConfDir() + "/MythMusic/RipTemp/");
+
+    // remove any ripped tracks from the temp rip directory
+    QString command = "rm -f " + GetConfDir() + "/MythMusic/RipTemp/*";
+    myth_system(command);
+
+    // get last host and directory we ripped to
+    QString lastHost = gCoreContext->GetSetting("MythMusicLastRipHost", gCoreContext->GetMasterHostName());
+    QStringList dirs = StorageGroup::getGroupDirs("Music", lastHost);
+    if (dirs.count() > 0)
+        m_musicStorageDir = StorageGroup::getGroupDirs("Music", lastHost).at(0);
 }
 
 Ripper::~Ripper(void)
 {
+    // remove any ripped tracks from the temp rip directory
+    QString command = "rm -f " + GetConfDir() + "/MythMusic/RipTemp/*";
+    myth_system(command);
+
     if (m_decoder)
         delete m_decoder;
 
@@ -636,9 +691,9 @@
         handled = true;
 
         if (action == "EDIT" || action == "INFO") // INFO purely for historical reasons
-        {
             showEditMetadataDialog(m_trackList->GetItemCurrent());
-        }
+        else if (action == "MENU")
+            ShowMenu();
         else
             handled = false;
     }
@@ -649,6 +704,83 @@
     return handled;
 }
 
+void Ripper::ShowMenu()
+{
+    if (m_tracks->empty())
+        return;
+
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+
+    MythDialogBox *menu = new MythDialogBox("", popupStack, "ripmusicmenu");
+
+    if (menu->Create())
+        popupStack->AddScreen(menu);
+    else
+    {
+        delete menu;
+        return;
+    }
+
+    menu->SetReturnEvent(this, "menu");
+    menu->AddButton(tr("Select Where To Save Tracks"), SLOT(chooseBackend()));
+    menu->AddButton(tr("Edit Track Metadata"), SLOT(showEditMetadataDialog()));
+}
+
+void Ripper::showEditMetadataDialog(void)
+{
+    showEditMetadataDialog(m_trackList->GetItemCurrent());
+}
+
+void Ripper::chooseBackend(void)
+{
+    QStringList hostList;
+
+    // get a list of hosts with a directory defined for the 'Music' storage group
+    MSqlQuery query(MSqlQuery::InitCon());
+    QString sql = "SELECT DISTINCT hostname "
+                  "FROM storagegroup "
+                  "WHERE groupname = 'Music'";
+    if (!query.exec(sql) || !query.isActive())
+        MythDB::DBError("Ripper::chooseBackend get host list", query);
+    else
+    {
+        while(query.next())
+        {
+            hostList.append(query.value(0).toString());
+        }
+    }
+
+    if (hostList.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Ripper::chooseBackend: No backends found");
+        return;
+    }
+
+    QString msg = tr("Select where to save tracks");
+
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythUISearchDialog *searchDlg = new MythUISearchDialog(popupStack, msg, hostList, false, "");
+
+    if (!searchDlg->Create())
+    {
+        delete searchDlg;
+        return;
+    }
+
+    connect(searchDlg, SIGNAL(haveResult(QString)), SLOT(setSaveHost(QString)));
+
+    popupStack->AddScreen(searchDlg);
+}
+
+void Ripper::setSaveHost(QString host)
+{
+    gCoreContext->SaveSetting("MythMusicLastRipHost", host);
+
+    QStringList dirs = StorageGroup::getGroupDirs("Music", host);
+    if (dirs.count() > 0)
+        m_musicStorageDir = StorageGroup::getGroupDirs("Music", host).at(0);
+}
+
 void Ripper::startScanCD(void)
 {
     if (m_scanThread)
@@ -823,10 +955,13 @@
     if (query.next())
     {
         int trackID = query.value(0).toInt();
-        QString filename = getMusicDirectory() + query.value(1).toString();
+        QString filename = query.value(1).toString();
+        QUrl url(m_musicStorageDir);
+        filename = gCoreContext->GenMythURL(url.host(), 0, filename, "Music");
 
         // delete file
-        if (!QFile::remove(filename))
+        // FIXME: RemoteFile::DeleteFile will only work with files on the master BE
+        if (!RemoteFile::DeleteFile(filename))
         {
             LOG(VB_GENERAL, LOG_NOTICE, QString("Ripper::deleteExistingTrack() "
                                                 "Could not delete %1")
@@ -1529,6 +1664,16 @@
         if (m_trackProgress)
             m_trackProgress->SetTotal(rse->value);
     }
+    else if (event->type() == RipStatusEvent::kCopyStartEvent)
+    {
+        if (m_trackPctText)
+            m_trackPctText->SetText(tr("Copying Track ..."));
+    }
+    else if (event->type() == RipStatusEvent::kCopyEndEvent)
+    {
+        if (m_trackPctText)
+            m_trackPctText->SetText("");
+    }
     else if (event->type() == RipStatusEvent::kOverallProgressEvent)
     {
         if (m_overallProgress)
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/cdrip.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/cdrip.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/cdrip.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/cdrip.h	2014-05-05 12:30:23.000000000 +0200
@@ -83,6 +83,9 @@
 
         int                m_lastTrackPct;
         int                m_lastOverallPct;
+
+        QString            m_musicStorageDir;
+
 };
 
 class Ripper : public MythScreenType
@@ -100,6 +103,8 @@
     void scanCD(void);
     void ejectCD(void);
 
+    virtual void ShowMenu(void);
+
   protected slots:
     void startRipper(void);
     void startScanCD(void);
@@ -122,6 +127,9 @@
     void EjectFinished(void);
     void ScanFinished(void);
     void metadataChanged(void);
+    void showEditMetadataDialog(void);
+    void chooseBackend(void);
+    void setSaveHost(QString host);
 
   signals:
     void ripFinished(void);
@@ -134,17 +142,19 @@
     void toggleTrackActive(RipTrack *);
     void ShowConflictMenu(RipTrack *);
 
-    CdDecoder           *m_decoder;
+    QString    m_musicStorageDir;
+
+    CdDecoder *m_decoder;
 
-    MythUITextEdit      *m_artistEdit;
-    MythUITextEdit      *m_albumEdit;
-    MythUITextEdit      *m_genreEdit;
-    MythUITextEdit      *m_yearEdit;
+    MythUITextEdit   *m_artistEdit;
+    MythUITextEdit   *m_albumEdit;
+    MythUITextEdit   *m_genreEdit;
+    MythUITextEdit   *m_yearEdit;
 
-    MythUICheckBox      *m_compilationCheck;
+    MythUICheckBox   *m_compilationCheck;
 
-    MythUIButtonList    *m_trackList;
-    MythUIButtonList    *m_qualityList;
+    MythUIButtonList *m_trackList;
+    MythUIButtonList *m_qualityList;
 
     MythUIButton  *m_switchTitleArtist;
     MythUIButton  *m_scanButton;
@@ -188,6 +198,8 @@
     static Type kOverallProgressEvent;
     static Type kOverallPercentEvent;
     static Type kOverallStartEvent;
+    static Type kCopyStartEvent;
+    static Type kCopyEndEvent;
     static Type kFinishedEvent;
     static Type kEncoderErrorEvent;
 };
@@ -221,8 +233,8 @@
     MythUIText        *m_statusText;
     MythUIText        *m_overallPctText;
     MythUIText        *m_trackPctText;
-    MythUIProgressBar   *m_overallProgress;
-    MythUIProgressBar   *m_trackProgress;
+    MythUIProgressBar *m_overallProgress;
+    MythUIProgressBar *m_trackProgress;
 
     CDRipperThread    *m_ripperThread;
 };
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/dbcheck.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/dbcheck.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/dbcheck.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/dbcheck.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -12,7 +12,7 @@
 
 #include "dbcheck.h"
 
-const QString currentDatabaseVersion = "1020";
+const QString currentDatabaseVersion = "1022";
 
 static bool doUpgradeMusicDatabaseSchema(QString &dbver);
 
@@ -878,5 +878,29 @@
             return false;
     }
 
+    if (dbver == "1020")
+    {
+        const QString updates[] = {
+"ALTER TABLE music_songs ADD COLUMN hostname VARCHAR(255) NOT NULL default '';",
+QString("UPDATE music_songs SET hostname = '%1';").arg(gCoreContext->GetMasterHostName()),
+""
+};
+
+        if (!performActualUpdate(updates, "1021", dbver))
+            return false;
+    }
+
+    if (dbver == "1021")
+    {
+        const QString updates[] = {
+"ALTER TABLE music_albumart ADD COLUMN hostname VARCHAR(255) NOT NULL default '';",
+QString("UPDATE music_albumart SET hostname = '%1';").arg(gCoreContext->GetMasterHostName()),
+""
+};
+
+        if (!performActualUpdate(updates, "1022", dbver))
+            return false;
+    }
+
     return true;
 }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/editmetadata.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/editmetadata.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/editmetadata.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/editmetadata.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -18,6 +18,8 @@
 #include <mythuiwebbrowser.h>
 #include <mythuifilebrowser.h>
 #include <musicutils.h>
+#include <mythprogressdialog.h>
+#include <remotefile.h>
 
 // mythmusic
 #include "musicdata.h"
@@ -37,7 +39,7 @@
 EditMetadataCommon::EditMetadataCommon(MythScreenStack *parent,
                                        MusicMetadata *source_metadata,
                                        const QString &name) :
-    MythScreenType(parent, name), m_doneButton(NULL)
+    MythScreenType(parent, name), m_albumArtChanged(false), m_doneButton(NULL)
 {
     // make a copy so we can abandon changes
     m_metadata = new MusicMetadata(*source_metadata);
@@ -48,12 +50,29 @@
 
 EditMetadataCommon::EditMetadataCommon(MythScreenStack *parent,
                                        const QString &name) :
-    MythScreenType(parent, name), m_doneButton(NULL)
+    MythScreenType(parent, name), m_albumArtChanged(false), m_doneButton(NULL)
 {
 }
 
 EditMetadataCommon::~EditMetadataCommon()
 {
+        // do we need to save anything?
+    if (m_albumArtChanged)
+    {
+        m_metadata->getAlbumArtImages()->dumpToDatabase();
+
+        // force a reload of the images for any tracks affected
+        MetadataPtrList *allMusic =  gMusicData->all_music->getAllMetadata();
+        for (int x = 0; x < allMusic->count(); x++)
+        {
+            if ((allMusic->at(x)->ID() == m_sourceMetadata->ID()) ||
+                (allMusic->at(x)->getDirectoryId() == m_sourceMetadata->getDirectoryId()))
+            {
+                allMusic->at(x)->reloadAlbumArtImages();
+                gPlayer->sendAlbumArtChangedEvent(allMusic->at(x)->ID());
+            }
+        }
+    }
 }
 
 bool EditMetadataCommon::CreateCommon(void)
@@ -200,19 +219,20 @@
 
 void EditMetadataCommon::saveAll()
 {
+    saveToDatabase();
+
+    // only write to the tag if it's enabled by the user
     if (GetMythDB()->GetNumSetting("AllowTagWriting", 0))
     {
-        MetaIO *tagger = m_metadata->getTagger();
+        QStringList strList;
+        strList << "MUSIC_TAG_UPDATE_METADATA %1 %2"
+                << m_metadata->Hostname()
+                << QString::number(m_metadata->ID());
 
-        if (tagger)
-        {
-            tagger->write(m_metadata);
-            delete tagger;
-        }
+        SendStringListThread *thread = new SendStringListThread(strList);
+        MThreadPool::globalInstance()->start(thread, "UpdateMetadata");
     }
 
-    saveToDatabase();
-
     cleanupAndClose();
 }
 
@@ -220,7 +240,7 @@
 {
     metadataOnly = true;
 
-    MythUIButton *albumartButton = dynamic_cast<MythUIButton *>(GetChild("albumart_button"));
+    MythUIButton *albumartButton = dynamic_cast<MythUIButton *>(GetChild("albumartbutton"));
     if (albumartButton)
         albumartButton->Hide();
 }
@@ -253,57 +273,14 @@
 
     QUrl url("http://www.google.co.uk/images?q=" + artist + "+" + album, QUrl::TolerantMode);
 
-    QFileInfo  fi(m_metadata->Filename());
+    m_searchType = "album";
 
-    GetMythMainWindow()->HandleMedia("WebBrowser", url.toString(), fi.canonicalPath() + '/', "front.jpg");
+    GetMythMainWindow()->HandleMedia("WebBrowser", url.toString(), GetConfDir() + "/MythMusic/", "front.jpg");
 }
 
 void EditMetadataCommon::scanForImages(void)
 {
-    // clear the original images
-    AlbumArtList *imageList = m_metadata->getAlbumArtImages()->getImageList();
-    while (!imageList->isEmpty())
-    {
-        delete imageList->back();
-        imageList->pop_back();
-    }
-
-    // scan the directory for images
-    QFileInfo fi(m_metadata->Filename());
-    QDir dir = fi.absoluteDir();
-
-    QString nameFilter = gCoreContext->GetSetting("AlbumArtFilter",
-                                                  "*.png;*.jpg;*.jpeg;*.gif;*.bmp");
-    dir.setNameFilters(nameFilter.split(";"));
-
-    QStringList files = dir.entryList();
-
-    for (int x = 0; x < files.size(); x++)
-    {
-        AlbumArtImage *image = new AlbumArtImage();
-        image->filename = dir.absolutePath() + '/' + files.at(x);
-        image->embedded = false;
-        image->imageType = AlbumArtImages::guessImageType(image->filename);
-        image->description = "";
-        m_metadata->getAlbumArtImages()->addImage(image);
-        delete image;
-    }
-
-    // scan the tracks tag for any images
-    MetaIO *tagger = m_metadata->getTagger();
-
-    if (tagger && tagger->supportsEmbeddedImages())
-    {
-        AlbumArtList art = tagger->getAlbumArtList(m_metadata->Filename());
-        for (int x = 0; x < art.count(); x++)
-        {
-            AlbumArtImage image = art.at(x);
-            m_metadata->getAlbumArtImages()->addImage(image);
-        }
-    }
-
-    if (tagger)
-        delete tagger;
+    m_metadata->getAlbumArtImages()->scanForImages();
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -507,6 +484,9 @@
 
 void EditMetadataDialog::showMenu(void )
 {
+    if (metadataOnly)
+        return;
+
     QString label = tr("Options");
 
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
@@ -599,7 +579,7 @@
 
     if (m_artistIcon)
     {
-        file = findIcon("artist", artist.toLower());
+        file = findIcon("artist", artist.toLower(), true);
         if (!file.isEmpty())
         {
             m_artistIcon->SetFilename(file);
@@ -719,7 +699,7 @@
 
     if (m_genreIcon)
     {
-        file = findIcon("genre", genre.toLower());
+        file = findIcon("genre", genre.toLower(), true);
         if (!file.isEmpty())
         {
             m_genreIcon->SetFilename(file);
@@ -753,11 +733,8 @@
 
     QUrl url("http://www.flickr.com/search/groups/?w=908425%40N22&m=pool&q=" + genre, QUrl::TolerantMode);
 
-    QString cleanName = fixFilename(m_metadata->Genre().toLower());
-    QString file = GetConfDir() + QString("/MythMusic/Icons/%1/%2.jpg").arg("genre").arg(cleanName);
-
-    QFileInfo fi(file);
-    GetMythMainWindow()->HandleMedia("WebBrowser", url.toString(), fi.absolutePath() + '/', fi.fileName());
+    m_searchType = "genre";
+    GetMythMainWindow()->HandleMedia("WebBrowser", url.toString(), GetConfDir() + "/MythMusic/", "genre.jpg");
 }
 
 /// search google for artist images
@@ -768,11 +745,8 @@
 
     QUrl url("http://www.google.co.uk/images?q=" + artist, QUrl::TolerantMode);
 
-    QString cleanName = fixFilename(m_metadata->Artist().toLower());
-    QString file = GetConfDir() + QString("/MythMusic/Icons/%1/%2.jpg").arg("artist").arg(cleanName);
-
-    QFileInfo fi(file);
-    GetMythMainWindow()->HandleMedia("WebBrowser", url.toString(), fi.absolutePath() + '/', fi.fileName());
+    m_searchType = "artist";
+    GetMythMainWindow()->HandleMedia("WebBrowser", url.toString(), GetConfDir() + "/MythMusic/", "artist.jpg");
 }
 
 void EditMetadataDialog::customEvent(QEvent *event)
@@ -810,28 +784,15 @@
             }
             else if (resulttext == tr("Check Track Length"))
             {
-                int length = calcTrackLength(m_metadata->Filename());
-
-                if (length != m_metadata->Length() / 1000)
-                {
-                    int oldLength = m_metadata->Length() / 1000;
-
-                    // save the new length to our working copy of the metadata
-                    m_metadata->setLength(length * 1000);
-
-                    // save the new length to the source copy of the metadata
-                    m_sourceMetadata->setLength(length * 1000);
-                    m_sourceMetadata->dumpToDatabase();
+                QStringList strList;
+                strList << "MUSIC_CALC_TRACK_LENGTH"
+                        << m_metadata->Hostname()
+                        << QString::number(m_metadata->ID());
 
-                    // this will update any track lengths displayed on screen
-                    gPlayer->sendMetadataChangedEvent(m_sourceMetadata->ID());
+                SendStringListThread *thread = new SendStringListThread(strList);
+                MThreadPool::globalInstance()->start(thread, "Send MUSIC_CALC_TRACK_LENGTH");
 
-                    // this will force the playlist stats to update
-                    MusicPlayerEvent me(MusicPlayerEvent::TrackChangeEvent, gPlayer->getCurrentTrackPos());
-                    gPlayer->dispatch(me);
-
-                    ShowOkPopup(QString("Updated track length to %1 seconds\nwas %2 seconds").arg(length).arg(oldLength));
-                }
+                ShowOkPopup(tr("Asked the backend to check the tracks length"));
             }
         }
     }
@@ -844,7 +805,51 @@
         {
             if (tokens[0] == "BROWSER_DOWNLOAD_FINISHED")
             {
-                scanForImages();
+                QStringList args = me->ExtraDataList();
+                QString oldFilename = args[1];
+                int fileSize  = args[2].toInt();
+                int errorCode = args[4].toInt();
+
+                if ((errorCode != 0) || (fileSize == 0))
+                    return;
+
+                QString newFilename;
+
+                if (m_searchType == "artist")
+                {
+                    QString cleanName = fixFilename(m_metadata->Artist().toLower());
+                    QString file = QString("Icons/%1/%2.jpg").arg("artist").arg(cleanName);
+                    newFilename = gCoreContext->GenMythURL(gCoreContext->GetMasterHostName(),
+                                                           0, file, "MusicArt");
+                }
+                else if (m_searchType == "genre")
+                {
+                    QString cleanName = fixFilename(m_metadata->Genre().toLower());
+                    QString file = QString("Icons/%1/%2.jpg").arg("genre").arg(cleanName);
+                    newFilename = gCoreContext->GenMythURL(gCoreContext->GetMasterHostName(),
+                                                           0, file, "MusicArt");
+                }
+                else if (m_searchType == "album")
+                {
+                    // move the image from the MythMusic config dir to the tracks
+                    // dir in the 'Music' storage group
+                    newFilename = m_metadata->Filename();
+                    newFilename = newFilename.section( '/', 0, -2);
+                    newFilename = newFilename + '/' +  oldFilename.section( '/', -1, -1);
+                }
+                else
+                {
+                    LOG(VB_GENERAL, LOG_ERR, QString("Got unknown search type '%1' "
+                                                     "in BROWSER_DOWNLOAD_FINISHED event")
+                                                     .arg(m_searchType));
+                    return;
+                }
+
+                RemoteFile::CopyFile(oldFilename, newFilename);
+                QFile::remove(oldFilename);
+
+                if (m_searchType == "album")
+                    scanForImages();
 
                 // force the icons to update
                 updateAlbumImage();
@@ -873,8 +878,7 @@
 
 EditAlbumartDialog::EditAlbumartDialog(MythScreenStack *parent)
                   : EditMetadataCommon(parent, "EditAlbumartDialog"),
-    m_albumArt(m_metadata->getAlbumArtImages()),
-    m_albumArtChanged(false),    m_metadataButton(NULL),
+    m_metadataButton(NULL),
     m_doneButton(NULL),          m_coverartImage(NULL),
     m_coverartList(NULL),        m_imagetypeText(NULL),
     m_imagefilenameText(NULL)
@@ -884,24 +888,6 @@
 
 EditAlbumartDialog::~EditAlbumartDialog()
 {
-    // do we need to save anything?
-    if (m_albumArtChanged)
-    {
-        m_albumArt->dumpToDatabase();
-
-        // force a reload of the images for any tracks affected
-        MetadataPtrList *allMusic =  gMusicData->all_music->getAllMetadata();
-        for (int x = 0; x < allMusic->count(); x++)
-        {
-            if ((allMusic->at(x)->ID() == m_sourceMetadata->ID()) ||
-                (allMusic->at(x)->getDirectoryId() == m_sourceMetadata->getDirectoryId()))
-            {
-                allMusic->at(x)->reloadAlbumArtImages();
-                gPlayer->sendAlbumArtChangedEvent(allMusic->at(x)->ID());
-            }
-        }
-    }
-
     gCoreContext->removeListener(this);
 }
 
@@ -962,7 +948,7 @@
 
 void EditAlbumartDialog::updateImageGrid(void)
 {
-    AlbumArtList *albumArtList = m_albumArt->getImageList();
+    AlbumArtList *albumArtList = m_metadata->getAlbumArtImages()->getImageList();
 
     m_coverartList->Reset();
 
@@ -1056,12 +1042,14 @@
         imageType = AlbumArtImages::guessImageType(m_imageFilename);
     }
 
-    menu->AddButton(m_albumArt->getTypeName(IT_UNKNOWN),    qVariantFromValue((int)IT_UNKNOWN),    false, (imageType == IT_UNKNOWN));
-    menu->AddButton(m_albumArt->getTypeName(IT_FRONTCOVER), qVariantFromValue((int)IT_FRONTCOVER), false, (imageType == IT_FRONTCOVER));
-    menu->AddButton(m_albumArt->getTypeName(IT_BACKCOVER),  qVariantFromValue((int)IT_BACKCOVER),  false, (imageType == IT_BACKCOVER));
-    menu->AddButton(m_albumArt->getTypeName(IT_CD),         qVariantFromValue((int)IT_CD),         false, (imageType == IT_CD));
-    menu->AddButton(m_albumArt->getTypeName(IT_INLAY),      qVariantFromValue((int)IT_INLAY),      false, (imageType == IT_INLAY));
-    menu->AddButton(m_albumArt->getTypeName(IT_ARTIST),     qVariantFromValue((int)IT_ARTIST),     false, (imageType == IT_ARTIST));
+    AlbumArtImages *albumArt = m_metadata->getAlbumArtImages();
+
+    menu->AddButton(albumArt->getTypeName(IT_UNKNOWN),    qVariantFromValue((int)IT_UNKNOWN),    false, (imageType == IT_UNKNOWN));
+    menu->AddButton(albumArt->getTypeName(IT_FRONTCOVER), qVariantFromValue((int)IT_FRONTCOVER), false, (imageType == IT_FRONTCOVER));
+    menu->AddButton(albumArt->getTypeName(IT_BACKCOVER),  qVariantFromValue((int)IT_BACKCOVER),  false, (imageType == IT_BACKCOVER));
+    menu->AddButton(albumArt->getTypeName(IT_CD),         qVariantFromValue((int)IT_CD),         false, (imageType == IT_CD));
+    menu->AddButton(albumArt->getTypeName(IT_INLAY),      qVariantFromValue((int)IT_INLAY),      false, (imageType == IT_INLAY));
+    menu->AddButton(albumArt->getTypeName(IT_ARTIST),     qVariantFromValue((int)IT_ARTIST),     false, (imageType == IT_ARTIST));
 
     popupStack->AddScreen(menu);
 }
@@ -1084,9 +1072,11 @@
 
     menu->AddButton(tr("Edit Metadata"));
     menu->AddButton(tr("Rescan For Images"));
+
+
     menu->AddButton(tr("Search Internet For Images"));
 
-    MetaIO *tagger = m_metadata->getTagger();
+    MetaIO *tagger = MetaIO::createTagger(m_metadata->Filename(false));
 
     if (m_coverartList->GetItemCurrent())
     {
@@ -1150,67 +1140,18 @@
                 MythUIButtonListItem *item = m_coverartList->GetItemCurrent();
                 if (item)
                 {
-                    item->SetText(m_albumArt->getTypeName((ImageType) type));
+                    AlbumArtImages *albumArt = m_metadata->getAlbumArtImages();
+                    item->SetText(albumArt->getTypeName((ImageType) type));
                     AlbumArtImage *image = qVariantValue<AlbumArtImage*> (item->GetData());
                     if (image)
                     {
-                        AlbumArtImage oldImage = *image;
-
-                        image->imageType = (ImageType) type;
+                        QStringList strList("MUSIC_TAG_CHANGEIMAGE");
+                        strList << m_metadata->Hostname()
+                                << QString::number(m_metadata->ID())
+                                << QString::number(image->imageType)
+                                << QString::number(type);
 
-                        if (image->imageType == oldImage.imageType)
-                            return;
-
-                        // rename any cached image to match the new type
-                        if (image->embedded)
-                        {
-                            // update the new cached image filename
-                            image->filename = QString(GetConfDir() + "/MythMusic/AlbumArt/%1-%2.jpg")
-                                                .arg(m_metadata->ID())
-                                                .arg(AlbumArtImages::getTypeFilename(image->imageType));
-
-                            if (image->filename != oldImage.filename && QFile::exists(oldImage.filename))
-                            {
-                                // remove any old cached file with the same name as the new one
-                                QFile::remove(image->filename);
-                                // rename the old cached file to the new one
-                                QFile::rename(oldImage.filename, image->filename);
-
-                                // force the theme image cache to refresh the image
-                                GetMythUI()->RemoveFromCacheByFile(image->filename);
-                            }
-
-                            // change the image type in the tag if it supports it
-                            MetaIO *tagger = m_metadata->getTagger();
-
-                            if (tagger && tagger->supportsEmbeddedImages())
-                            {
-                                if (!tagger->changeImageType(m_metadata->Filename(), &oldImage, image->imageType))
-                                    LOG(VB_GENERAL, LOG_INFO, "EditAlbumartDialog: failed to change image type");
-                            }
-
-                            if (tagger)
-                                delete tagger;
-                        }
-                        else
-                        {
-                            QFileInfo fi(oldImage.filename);
-
-                            // get the new images filename
-                            image->filename = QString(fi.absolutePath() + "/%1.jpg")
-                                    .arg(AlbumArtImages::getTypeFilename(image->imageType));
-
-                            if (image->filename != oldImage.filename && QFile::exists(oldImage.filename))
-                            {
-                                // remove any old cached file with the same name as the new one
-                                QFile::remove(image->filename);
-                                // rename the old cached file to the new one
-                                QFile::rename(oldImage.filename, image->filename);
-
-                                // force the theme image cache to refresh the image
-                                GetMythUI()->RemoveFromCacheByFile(image->filename);
-                            }
-                        }
+                        gCoreContext->SendReceiveStringList(strList);
 
                         m_albumArtChanged = true;
 
@@ -1263,6 +1204,22 @@
         {
             if (tokens[0] == "BROWSER_DOWNLOAD_FINISHED")
                 rescanForImages();
+            else if (tokens[0] == "MUSIC_ALBUMART_CHANGED")
+            {
+                if (tokens.size() >= 2)
+                {
+                    MusicMetadata::IdType songID = (MusicMetadata::IdType)tokens[1].toInt();
+
+                    if (m_metadata->ID() == songID)
+                    {
+                        // force all the image to reload
+                        for (uint x = 0; x < m_metadata->getAlbumArtImages()->getImageCount(); x++)
+                            removeCachedImage(m_metadata->getAlbumArtImages()->getImageAt(x));
+
+                        updateImageGrid();
+                    }
+                }
+            }
         }
     }
 }
@@ -1275,7 +1232,8 @@
 
     updateImageGrid();
 
-    if (m_albumArt->getImageCount() > 0)
+    AlbumArtImages *albumArt = m_metadata->getAlbumArtImages();
+    if (albumArt->getImageCount() > 0)
         m_albumArtChanged = true;
 }
 
@@ -1346,53 +1304,89 @@
         AlbumArtImage *image = qVariantValue<AlbumArtImage*> (item->GetData());
         if (image)
         {
-            MetaIO *tagger = m_metadata->getTagger();
+            // ask the backend to remove the image from the tracks tag
+            QStringList strList("MUSIC_TAG_REMOVEIMAGE");
+            strList << m_metadata->Hostname()
+                    << QString::number(m_metadata->ID())
+                    << QString::number(image->id);
 
-            if (tagger && !tagger->supportsEmbeddedImages())
-            {
-                LOG(VB_GENERAL, LOG_ERR, "EditAlbumartDialog: asked to remove an image from the tag "
-                                         "but the tagger doesn't support it!");
-                delete tagger;
-                return;
-            }
-
-            if (!tagger->removeAlbumArt(m_metadata->Filename(), image))
-                LOG(VB_GENERAL, LOG_ERR, "EditAlbumartDialog: failed to remove album art from tag");
-            else
-                LOG(VB_GENERAL, LOG_INFO, "EditAlbumartDialog: album art removed from tag");
+            gCoreContext->SendReceiveStringList(strList);
 
             removeCachedImage(image);
             rescanForImages();
-
-            if (tagger)
-                delete tagger;
         }
     }
 }
 
-void EditAlbumartDialog::doCopyImageToTag(const AlbumArtImage *image)
+class CopyImageThread: public MThread
 {
-    MetaIO *tagger = m_metadata->getTagger();
+  public:
+    CopyImageThread(QStringList strList) :
+            MThread("CopyImage"), m_strList(strList) {}
 
-    if (tagger && !tagger->supportsEmbeddedImages())
+    virtual void run()
     {
-        LOG(VB_GENERAL, LOG_ERR, "EditAlbumartDialog: asked to write album art to the tag "
-                              "but the tagger does't support it!");
-        delete tagger;
-        return;
+        RunProlog();
+        gCoreContext->SendReceiveStringList(m_strList);
+        RunEpilog();
     }
 
-    if (!tagger->writeAlbumArt(m_metadata->Filename(), image))
-        LOG(VB_GENERAL, LOG_ERR, "EditAlbumartDialog: failed to write album art to tag");
+    QStringList getResult(void) { return m_strList; }
+
+  private:
+    QStringList m_strList;
+};
+
+void EditAlbumartDialog::doCopyImageToTag(const AlbumArtImage *image)
+{
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythUIBusyDialog *busy = new MythUIBusyDialog(tr("Copying image to tag..."),
+                                                  popupStack, "copyimagebusydialog");
+
+    if (busy->Create())
+    {
+        popupStack->AddScreen(busy, false);
+    }
     else
-        LOG(VB_GENERAL, LOG_INFO, "EditAlbumartDialog: album art written to tag");
+    {
+        delete busy;
+        busy = NULL;
+    }
+
+    // copy the image to the tracks host
+    QFileInfo fi(image->filename);
+    QString saveFilename = gCoreContext->GenMythURL(m_metadata->Hostname(), 0,
+                                                    QString("AlbumArt/") + fi.fileName(),
+                                                    "MusicArt");
+
+    RemoteFile::CopyFile(image->filename, saveFilename);
+
+    // ask the backend to add the image to the tracks tag
+    QStringList strList("MUSIC_TAG_ADDIMAGE");
+    strList << m_metadata->Hostname()
+            << QString::number(m_metadata->ID())
+            << fi.fileName()
+            << QString::number(image->imageType);
+
+    CopyImageThread *copyThread = new CopyImageThread(strList);
+    copyThread->start();
+
+    while (copyThread->isRunning())
+    {
+        qApp->processEvents();
+        usleep(1000);
+    }
+
+    strList = copyThread->getResult();
+
+    delete copyThread;
+
+    if (busy)
+        busy->Close();
 
     removeCachedImage(image);
 
     rescanForImages();
-
-    if (tagger)
-        delete tagger;
 }
 
 void EditAlbumartDialog::removeCachedImage(const AlbumArtImage *image)
@@ -1400,11 +1394,5 @@
     if (!image->embedded)
         return;
 
-    QString imageFilename = QString(GetConfDir() + "/MythMusic/AlbumArt/%1-%2.jpg")
-            .arg(m_metadata->ID()).arg(AlbumArtImages::getTypeFilename(image->imageType));
-
-    if (QFile::exists(imageFilename))
-        QFile::remove(imageFilename);
-
-    GetMythUI()->RemoveFromCacheByFile(imageFilename);
+    GetMythUI()->RemoveFromCacheByFile(image->filename);
 }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/editmetadata.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/editmetadata.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/editmetadata.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/editmetadata.h	2014-05-05 12:30:23.000000000 +0200
@@ -50,7 +50,11 @@
     static bool            metadataOnly;
     static MusicMetadata  *m_metadata, *m_sourceMetadata;
 
-    MythUIButton   *m_doneButton;
+    bool m_albumArtChanged;
+
+    QString m_searchType;
+
+    MythUIButton *m_doneButton;
 };
 
 class EditMetadataDialog : public EditMetadataCommon
@@ -170,8 +174,6 @@
     void removeCachedImage(const AlbumArtImage *image);
 
     QString         m_imageFilename;
-    AlbumArtImages *m_albumArt;
-    bool            m_albumArtChanged;
 
     //
     //  GUI stuff
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/filescanner.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/filescanner.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/filescanner.cpp	2014-05-04 17:43:54.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/filescanner.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,800 +0,0 @@
-// POSIX headers
-#include <sys/stat.h>
-
-// Qt headers
-#include <QApplication>
-#include <QDir>
-
-// MythTV headers
-#include <mythdate.h>
-#include <mythdb.h>
-#include <mythcontext.h>
-#include <mythdialogs.h>
-#include <mythscreenstack.h>
-#include <mythprogressdialog.h>
-#include <musicmetadata.h>
-#include <metaio.h>
-
-// MythMusic headers
-#include "filescanner.h"
-
-FileScanner::FileScanner()
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-
-    // Cache the directory ids from the database
-    query.prepare("SELECT directory_id, path FROM music_directories");
-    if (query.exec())
-    {
-        while(query.next())
-        {
-            m_directoryid[query.value(1).toString()] = query.value(0).toInt();
-        }
-    }
-
-    // Cache the genre ids from the database
-    query.prepare("SELECT genre_id, LOWER(genre) FROM music_genres");
-    if (query.exec())
-    {
-        while(query.next())
-        {
-            m_genreid[query.value(1).toString()] = query.value(0).toInt();
-        }
-    }
-
-    // Cache the artist ids from the database
-    query.prepare("SELECT artist_id, LOWER(artist_name) FROM music_artists");
-    if (query.exec() || query.isActive())
-    {
-        while(query.next())
-        {
-            m_artistid[query.value(1).toString()] = query.value(0).toInt();
-        }
-    }
-
-    // Cache the album ids from the database
-    query.prepare("SELECT album_id, artist_id, LOWER(album_name) FROM music_albums");
-    if (query.exec())
-    {
-        while(query.next())
-        {
-            m_albumid[query.value(1).toString() + "#" + query.value(2).toString()] = query.value(0).toInt();
-        }
-    }
-}
-
-FileScanner::~FileScanner ()
-{
-
-}
-
-/*!
- * \brief Builds a list of all the files found descending recursively
- *        into the given directory
- *
- * \param directory Directory to begin search
- * \param music_files A pointer to the MusicLoadedMap to store the results
- * \param parentid The id of the parent directory in the music_directories
- *                 table. The root directory should have an id of 0
- *
- * \returns Nothing.
- */
-void FileScanner::BuildFileList(QString &directory, MusicLoadedMap &music_files, int parentid)
-{
-    QDir d(directory);
-
-    if (!d.exists())
-        return;
-
-    d.setFilter(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot);
-    QFileInfoList list = d.entryInfoList();
-    if (list.isEmpty())
-        return;
-
-    QFileInfoList::const_iterator it = list.begin();
-    const QFileInfo *fi;
-
-    /* Recursively traverse directory, calling QApplication::processEvents()
-       every now and then to ensure the UI updates */
-    int update_interval = 0;
-    int newparentid = 0;
-    while (it != list.end())
-    {
-        fi = &(*it);
-        ++it;
-        QString filename = fi->absoluteFilePath();
-        if (fi->isDir())
-        {
-
-            QString dir(filename);
-            dir.remove(0, m_startdir.length());
-
-            newparentid = m_directoryid[dir];
-
-            if (newparentid == 0)
-            {
-                int id = GetDirectoryId(dir, parentid);
-                m_directoryid[dir] = id;
-
-                if (id > 0)
-                {
-                    newparentid = id;
-                }
-                else
-                {
-                    LOG(VB_GENERAL, LOG_ERR,
-                        QString("Failed to get directory id for path %1")
-                            .arg(dir));
-                }
-            }
-
-            BuildFileList(filename, music_files, newparentid);
-
-            qApp->processEvents ();
-        }
-        else
-        {
-            if (++update_interval > 100)
-            {
-                qApp->processEvents();
-                update_interval = 0;
-            }
-
-            music_files[filename] = FileScanner::kFileSystem;
-        }
-    }
-}
-
-/*!
- * \brief Get an ID for the given directory from the database.
- *        If it doesn't already exist in the database, insert it.
- *
- * \param directory Relative path to directory, from base dir
- * \param parentid The id of the parent directory in the music_directories
- *                 table. The root directory should have an id of 0
- *
- * \returns Directory id
- */
-int FileScanner::GetDirectoryId(const QString &directory, const int &parentid)
-{
-    if (directory.isEmpty())
-        return 0;
-
-    MSqlQuery query(MSqlQuery::InitCon());
-
-    // Load the directory id or insert it and get the id
-    query.prepare("SELECT directory_id FROM music_directories "
-                "WHERE path = :DIRECTORY ;");
-    query.bindValue(":DIRECTORY", directory);
-
-    if (!query.exec())
-    {
-        MythDB::DBError("music select directory id", query);
-        return -1;
-    }
-
-    if (query.next())
-    {
-        // we have found the directory already in the DB
-        return query.value(0).toInt();
-    }
-
-    // directory is not in the DB so insert it
-    query.prepare("INSERT INTO music_directories (path, parent_id) "
-                "VALUES (:DIRECTORY, :PARENTID);");
-    query.bindValue(":DIRECTORY", directory);
-    query.bindValue(":PARENTID", parentid);
-
-    if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
-    {
-        MythDB::DBError("music insert directory", query);
-        return -1;
-    }
-
-    return query.lastInsertId().toInt();
-}
-
-/*!
- * \brief Check if file has been modified since given date/time
- *
- * \param filename File to examine
- * \param date_modified Date to use in comparison
- *
- * \returns True if file has been modified, otherwise false
- */
-bool FileScanner::HasFileChanged(
-    const QString &filename, const QString &date_modified)
-{
-    QFileInfo fi(filename);
-    QDateTime dt = fi.lastModified();
-    if (dt.isValid())
-    {
-        QDateTime old_dt = MythDate::fromString(date_modified);
-        return !old_dt.isValid() || (dt > old_dt);
-    }
-    else
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("Failed to stat file: %1")
-                .arg(filename));
-        return false;
-    }
-}
-
-/*!
- * \brief Insert file details into database.
- *        If it is an audio file, read the metadata and insert
- *        that information at the same time.
- *
- *        If it is an image file, just insert the filename and
- *        type.
- *
- * \param filename Full path to file.
- *
- * \returns Nothing.
- */
-void FileScanner::AddFileToDB(const QString &filename)
-{
-    QString extension = filename.section( '.', -1 ) ;
-    QString directory = filename;
-    directory.remove(0, m_startdir.length());
-    directory = directory.section( '/', 0, -2);
-
-    QString nameFilter = gCoreContext->GetSetting("AlbumArtFilter", "*.png;*.jpg;*.jpeg;*.gif;*.bmp");
-
-    // If this file is an image, insert the details into the music_albumart table
-    if (nameFilter.indexOf(extension.toLower()) > -1)
-    {
-        QString name = filename.section( '/', -1);
-
-        MSqlQuery query(MSqlQuery::InitCon());
-        query.prepare("INSERT INTO music_albumart SET filename = :FILE, "
-                      "directory_id = :DIRID, imagetype = :TYPE;");
-        query.bindValue(":FILE", name);
-        query.bindValue(":DIRID", m_directoryid[directory]);
-        query.bindValue(":TYPE", AlbumArtImages::guessImageType(name));
-
-        if (!query.exec() || query.numRowsAffected() <= 0)
-        {
-            MythDB::DBError("music insert artwork", query);
-        }
-        return;
-    }
-
-    LOG(VB_FILE, LOG_INFO,
-        QString("Reading metadata from %1").arg(filename));
-    MusicMetadata *data = MetaIO::readMetadata(filename);
-    if (data)
-    {
-        data->setFileSize((quint64)QFileInfo(filename).size());
-
-        QString album_cache_string;
-
-        // Set values from cache
-        int did = m_directoryid[directory];
-        if (did > 0)
-            data->setDirectoryId(did);
-
-        int aid = m_artistid[data->Artist().toLower()];
-        if (aid > 0)
-        {
-            data->setArtistId(aid);
-
-            // The album cache depends on the artist id
-            album_cache_string = data->getArtistId() + "#"
-                + data->Album().toLower();
-
-            if (m_albumid[album_cache_string] > 0)
-                data->setAlbumId(m_albumid[album_cache_string]);
-        }
-
-        int gid = m_genreid[data->Genre().toLower()];
-        if (gid > 0)
-            data->setGenreId(gid);
-
-        // Commit track info to database
-        data->dumpToDatabase();
-
-        // Update the cache
-        m_artistid[data->Artist().toLower()] =
-            data->getArtistId();
-
-        m_genreid[data->Genre().toLower()] =
-            data->getGenreId();
-
-        album_cache_string = data->getArtistId() + "#"
-            + data->Album().toLower();
-        m_albumid[album_cache_string] = data->getAlbumId();
-
-        // read any embedded images from the tag
-        MetaIO *tagger = MetaIO::createTagger(filename);
-
-        if (tagger)
-        {
-            if (tagger->supportsEmbeddedImages())
-            {
-                AlbumArtList artList = tagger->getAlbumArtList(data->Filename());
-                data->setEmbeddedAlbumArt(artList);
-                data->getAlbumArtImages()->dumpToDatabase();
-            }
-            delete tagger;
-        }
-
-        delete data;
-    }
-}
-
-/*!
- * \brief Clear orphaned entries from the genre, artist, album and albumart
- *        tables
- *
- * \returns Nothing.
- */
-void FileScanner::cleanDB()
-{
-    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-
-    QString message = tr("Cleaning music database");
-    MythUIProgressDialog *clean_progress = new MythUIProgressDialog(message,
-                                                    popupStack,
-                                                    "cleaningprogressdialog");
-
-    if (clean_progress->Create())
-    {
-        popupStack->AddScreen(clean_progress, false);
-        clean_progress->SetTotal(4);
-    }
-    else
-    {
-        delete clean_progress;
-        clean_progress = NULL;
-    }
-
-    uint counter = 0;
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    MSqlQuery deletequery(MSqlQuery::InitCon());
-
-    if (!query.exec("SELECT g.genre_id FROM music_genres g "
-                    "LEFT JOIN music_songs s ON g.genre_id=s.genre_id "
-                    "WHERE s.genre_id IS NULL;"))
-        MythDB::DBError("FileScanner::cleanDB - select music_genres", query);
-    while (query.next())
-    {
-        int genreid = query.value(0).toInt();
-        deletequery.prepare("DELETE FROM music_genres WHERE genre_id=:GENREID");
-        deletequery.bindValue(":GENREID", genreid);
-        if (!deletequery.exec())
-            MythDB::DBError("FileScanner::cleanDB - delete music_genres",
-                            deletequery);
-    }
-
-    if (clean_progress)
-        clean_progress->SetProgress(++counter);
-
-    if (!query.exec("SELECT a.album_id FROM music_albums a "
-                    "LEFT JOIN music_songs s ON a.album_id=s.album_id "
-                    "WHERE s.album_id IS NULL;"))
-        MythDB::DBError("FileScanner::cleanDB - select music_albums", query);
-    while (query.next())
-    {
-        int albumid = query.value(0).toInt();
-        deletequery.prepare("DELETE FROM music_albums WHERE album_id=:ALBUMID");
-        deletequery.bindValue(":ALBUMID", albumid);
-        if (!deletequery.exec())
-            MythDB::DBError("FileScanner::cleanDB - delete music_albums",
-                            deletequery);
-    }
-
-    if (clean_progress)
-        clean_progress->SetProgress(++counter);
-
-    if (!query.exec("SELECT a.artist_id FROM music_artists a "
-                    "LEFT JOIN music_songs s ON a.artist_id=s.artist_id "
-                    "LEFT JOIN music_albums l ON a.artist_id=l.artist_id "
-                    "WHERE s.artist_id IS NULL AND l.artist_id IS NULL"))
-        MythDB::DBError("FileScanner::cleanDB - select music_artists", query);
-    while (query.next())
-    {
-        int artistid = query.value(0).toInt();
-        deletequery.prepare("DELETE FROM music_artists WHERE artist_id=:ARTISTID");
-        deletequery.bindValue(":ARTISTID", artistid);
-        if (!deletequery.exec())
-            MythDB::DBError("FileScanner::cleanDB - delete music_artists",
-                            deletequery);
-    }
-
-    if (clean_progress)
-        clean_progress->SetProgress(++counter);
-
-    if (!query.exec("SELECT a.albumart_id FROM music_albumart a LEFT JOIN "
-                    "music_songs s ON a.song_id=s.song_id WHERE "
-                    "embedded='1' AND s.song_id IS NULL;"))
-        MythDB::DBError("FileScanner::cleanDB - select music_albumart", query);
-    while (query.next())
-    {
-        int albumartid = query.value(0).toInt();
-        deletequery.prepare("DELETE FROM music_albumart WHERE albumart_id=:ALBUMARTID");
-        deletequery.bindValue(":ALBUMARTID", albumartid);
-        if (!deletequery.exec())
-            MythDB::DBError("FileScanner::cleanDB - delete music_albumart",
-                            deletequery);
-    }
-
-    if (clean_progress)
-    {
-        clean_progress->SetProgress(++counter);
-        clean_progress->Close();
-    }
-}
-
-/*!
- * \brief Removes a file from the database.
- *
- * \param filename Full path to file.
- *
- * \returns Nothing.
- */
-void FileScanner::RemoveFileFromDB (const QString &filename)
-{
-    QString sqlfilename(filename);
-    sqlfilename.remove(0, m_startdir.length());
-    // We know that the filename will not contain :// as the SQL limits this
-    QString directory = sqlfilename.section( '/', 0, -2 ) ;
-    sqlfilename = sqlfilename.section( '/', -1 ) ;
-
-    QString extension = sqlfilename.section( '.', -1 ) ;
-
-    QString nameFilter = gCoreContext->GetSetting("AlbumArtFilter",
-                                              "*.png;*.jpg;*.jpeg;*.gif;*.bmp");
-
-    if (nameFilter.indexOf(extension) > -1)
-    {
-        MSqlQuery query(MSqlQuery::InitCon());
-        query.prepare("DELETE FROM music_albumart WHERE filename= :FILE AND "
-                      "directory_id= :DIRID;");
-        query.bindValue(":FILE", sqlfilename);
-        query.bindValue(":DIRID", m_directoryid[directory]);
-
-        if (!query.exec() || query.numRowsAffected() <= 0)
-        {
-            MythDB::DBError("music delete artwork", query);
-        }
-        return;
-    }
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("DELETE FROM music_songs WHERE filename = :NAME ;");
-    query.bindValue(":NAME", sqlfilename);
-    if (!query.exec())
-        MythDB::DBError("FileScanner::RemoveFileFromDB - deleting music_songs",
-                        query);
-}
-
-/*!
- * \brief Updates a file in the database.
- *
- * \param filename Full path to file.
- *
- * \returns Nothing.
- */
-void FileScanner::UpdateFileInDB(const QString &filename)
-{
-    QString directory = filename;
-    directory.remove(0, m_startdir.length());
-    directory = directory.section( '/', 0, -2);
-
-    MusicMetadata *db_meta   = MetaIO::getMetadata(filename);
-    MusicMetadata *disk_meta = MetaIO::readMetadata(filename);
-
-    if (db_meta && disk_meta)
-    {
-        if (db_meta->ID() <= 0)
-        {
-            LOG(VB_GENERAL, LOG_ERR, QString("Asked to update track with "
-                                                "invalid ID - %1")
-                                            .arg(db_meta->ID()));
-            delete disk_meta;
-            delete db_meta;
-            return;
-        }
-
-        disk_meta->setID(db_meta->ID());
-        disk_meta->setRating(db_meta->Rating());
-        if (db_meta->PlayCount() > disk_meta->PlayCount())
-            disk_meta->setPlaycount(db_meta->Playcount());
-
-        QString album_cache_string;
-
-        // Set values from cache
-        int did = m_directoryid[directory];
-        if (did > 0)
-            disk_meta->setDirectoryId(did);
-
-        int aid = m_artistid[disk_meta->Artist().toLower()];
-        if (aid > 0)
-        {
-            disk_meta->setArtistId(aid);
-
-            // The album cache depends on the artist id
-            album_cache_string = disk_meta->getArtistId() + "#" +
-                disk_meta->Album().toLower();
-
-            if (m_albumid[album_cache_string] > 0)
-                disk_meta->setAlbumId(m_albumid[album_cache_string]);
-        }
-
-        int gid = m_genreid[disk_meta->Genre().toLower()];
-        if (gid > 0)
-            disk_meta->setGenreId(gid);
-
-        disk_meta->setFileSize((quint64)QFileInfo(filename).size());
-
-        // Commit track info to database
-        disk_meta->dumpToDatabase();
-
-        // Update the cache
-        m_artistid[disk_meta->Artist().toLower()]
-            = disk_meta->getArtistId();
-        m_genreid[disk_meta->Genre().toLower()]
-            = disk_meta->getGenreId();
-        album_cache_string = disk_meta->getArtistId() + "#" +
-            disk_meta->Album().toLower();
-        m_albumid[album_cache_string] = disk_meta->getAlbumId();
-    }
-
-    if (disk_meta)
-        delete disk_meta;
-
-    if (db_meta)
-        delete db_meta;
-}
-
-/*!
- * \brief Scan a directory recursively for music and albumart.
- *        Inserts, updates and removes any files any files found in the
- *        database.
- *
- * \param directory Directory to scan
- *
- * \returns Nothing.
- */
-void FileScanner::SearchDir(QString &directory)
-{
-
-    m_startdir = directory;
-
-    MusicLoadedMap music_files;
-    MusicLoadedMap::Iterator iter;
-
-    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-
-    QString message = tr("Searching for music files");
-
-    MythUIBusyDialog *busy = new MythUIBusyDialog(message, popupStack,
-                                                  "musicscanbusydialog");
-
-    if (busy->Create())
-        popupStack->AddScreen(busy, false);
-    else
-        busy = NULL;
-
-    BuildFileList(m_startdir, music_files, 0);
-
-    if (busy)
-        busy->Close();
-
-    ScanMusic(music_files);
-    ScanArtwork(music_files);
-
-    message = tr("Updating music database");
-    MythUIProgressDialog *file_checking = new MythUIProgressDialog(message,
-                                                    popupStack,
-                                                    "scalingprogressdialog");
-
-    if (file_checking->Create())
-    {
-        popupStack->AddScreen(file_checking, false);
-        file_checking->SetTotal(music_files.size());
-    }
-    else
-    {
-        delete file_checking;
-        file_checking = NULL;
-    }
-
-     /*
-       This can be optimised quite a bit by consolidating all commands
-       via a lot of refactoring.
-
-       1) group all files of the same decoder type, and don't
-       create/delete a Decoder pr. AddFileToDB. Or make Decoders be
-       singletons, it should be a fairly simple change.
-
-       2) RemoveFileFromDB should group the remove into one big SQL.
-
-       3) UpdateFileInDB, same as 1.
-     */
-
-    uint counter = 0;
-    for (iter = music_files.begin(); iter != music_files.end(); iter++)
-    {
-        if (*iter == FileScanner::kFileSystem)
-            AddFileToDB(iter.key());
-        else if (*iter == FileScanner::kDatabase)
-            RemoveFileFromDB(iter.key ());
-        else if (*iter == FileScanner::kNeedUpdate)
-            UpdateFileInDB(iter.key());
-
-        if (file_checking)
-        {
-            file_checking->SetProgress(++counter);
-            qApp->processEvents();
-        }
-    }
-    if (file_checking)
-        file_checking->Close();
-
-    // Cleanup orphaned entries from the database
-    cleanDB();
-}
-
-/*!
- * \brief Check a list of files against musics files already in the database
- *
- * \param music_files MusicLoadedMap
- *
- * \returns Nothing.
- */
-void FileScanner::ScanMusic(MusicLoadedMap &music_files)
-{
-    MusicLoadedMap::Iterator iter;
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    if (!query.exec("SELECT CONCAT_WS('/', path, filename), date_modified "
-                    "FROM music_songs LEFT JOIN music_directories ON "
-                    "music_songs.directory_id=music_directories.directory_id "
-                    "WHERE filename NOT LIKE ('%://%')"))
-        MythDB::DBError("FileScanner::ScanMusic", query);
-
-    uint counter = 0;
-
-    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-
-    QString message = tr("Scanning music files");
-    MythUIProgressDialog *file_checking = new MythUIProgressDialog(message,
-                                                    popupStack,
-                                                    "scalingprogressdialog");
-
-    if (file_checking->Create())
-    {
-        popupStack->AddScreen(file_checking, false);
-        file_checking->SetTotal(query.size());
-    }
-    else
-    {
-        delete file_checking;
-        file_checking = NULL;
-    }
-
-    QString name;
-
-    if (query.isActive() && query.size() > 0)
-    {
-        while (query.next())
-        {
-            name = m_startdir + query.value(0).toString();
-
-            if (name != QString::null)
-            {
-                if ((iter = music_files.find(name)) != music_files.end())
-                {
-                    if (music_files[name] == FileScanner::kDatabase)
-                    {
-                        if (file_checking)
-                        {
-                            file_checking->SetProgress(++counter);
-                            qApp->processEvents();
-                        }
-                        continue;
-                    }
-                    else if (HasFileChanged(name, query.value(1).toString()))
-                        music_files[name] = FileScanner::kNeedUpdate;
-                    else
-                        music_files.erase(iter);
-                }
-                else
-                {
-                    music_files[name] = FileScanner::kDatabase;
-                }
-            }
-
-            if (file_checking)
-            {
-                file_checking->SetProgress(++counter);
-                qApp->processEvents();
-            }
-        }
-    }
-
-    if (file_checking)
-        file_checking->Close();
-}
-
-/*!
- * \brief Check a list of files against images already in the database
- *
- * \param music_files MusicLoadedMap
- *
- * \returns Nothing.
- */
-void FileScanner::ScanArtwork(MusicLoadedMap &music_files)
-{
-    MusicLoadedMap::Iterator iter;
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    if (!query.exec("SELECT CONCAT_WS('/', path, filename) "
-                    "FROM music_albumart LEFT JOIN music_directories ON "
-                    "music_albumart.directory_id=music_directories.directory_id"
-                    " WHERE music_albumart.embedded=0"))
-        MythDB::DBError("FileScanner::ScanArtwork", query);
-
-    uint counter = 0;
-
-    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-
-    QString message = tr("Scanning Album Artwork");
-    MythUIProgressDialog *file_checking = new MythUIProgressDialog(message,
-                                                    popupStack,
-                                                    "albumprogressdialog");
-
-    if (file_checking->Create())
-    {
-        popupStack->AddScreen(file_checking, false);
-        file_checking->SetTotal(query.size());
-    }
-    else
-    {
-        delete file_checking;
-        file_checking = NULL;
-    }
-
-    if (query.isActive() && query.size() > 0)
-    {
-        while (query.next())
-        {
-            QString name;
-
-            name = m_startdir + query.value(0).toString();
-
-            if (name != QString::null)
-            {
-                if ((iter = music_files.find(name)) != music_files.end())
-                {
-                    if (music_files[name] == FileScanner::kDatabase)
-                    {
-                        if (file_checking)
-                        {
-                            file_checking->SetProgress(++counter);
-                            qApp->processEvents();
-                        }
-                        continue;
-                    }
-                    else
-                        music_files.erase(iter);
-                }
-                else
-                {
-                    music_files[name] = FileScanner::kDatabase;
-                }
-            }
-            if (file_checking)
-            {
-                file_checking->SetProgress(++counter);
-                qApp->processEvents();
-            }
-        }
-    }
-
-    if (file_checking)
-        file_checking->Close();
-}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/filescanner.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/filescanner.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/filescanner.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/filescanner.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-#ifndef _FILESCANNER_H_
-#define _FILESCANNER_H_
-
-// Qt headers
-#include <QCoreApplication>
-
-typedef QMap<QString, int> IdCache;
-
-class FileScanner
-{
-    Q_DECLARE_TR_FUNCTIONS(FileScanner)
-
-    enum MusicFileLocation
-    {
-        kFileSystem,
-        kDatabase,
-        kNeedUpdate,
-        kBoth
-    };
-
-    typedef QMap <QString, MusicFileLocation> MusicLoadedMap;
-    public:
-        FileScanner ();
-        ~FileScanner ();
-
-        void SearchDir(QString &directory);
-
-    private:
-        void BuildFileList(QString &directory, MusicLoadedMap &music_files, int parentid);
-        int  GetDirectoryId(const QString &directory, const int &parentid);
-        bool HasFileChanged(const QString &filename, const QString &date_modified);
-        void AddFileToDB(const QString &filename);
-        void RemoveFileFromDB (const QString &filename);
-        void UpdateFileInDB(const QString &filename);
-        void ScanMusic(MusicLoadedMap &music_files);
-        void ScanArtwork(MusicLoadedMap &music_files);
-        void cleanDB();
-
-        QString  m_startdir;
-        IdCache  m_directoryid;
-        IdCache  m_artistid;
-        IdCache  m_genreid;
-        IdCache  m_albumid;
-};
-
-#endif // _FILESCANNER_H_
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/flacencoder.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/flacencoder.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/flacencoder.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/flacencoder.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -92,12 +92,7 @@
     }
 
     if (m_metadata)
-    {
-        QString filename = m_metadata->Filename();
-        m_metadata->setFilename(m_outfile);
-        MetaIOFLACVorbis().write(m_metadata);
-        m_metadata->setFilename(filename);
-    }
+        MetaIOFLACVorbis().write(m_outfile, m_metadata);
 }
 
 int FlacEncoder::addSamples(int16_t *bytes, unsigned int length)
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/generalsettings.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/generalsettings.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/generalsettings.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/generalsettings.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -4,15 +4,19 @@
 
 // MythTV
 #include <mythcorecontext.h>
+#include <mythdialogbox.h>
 
+// MythMusic
+#include "musicplayer.h"
 #include "generalsettings.h"
+#include "musicdata.h"
 
 GeneralSettings::GeneralSettings(MythScreenStack *parent, const char *name)
         : MythScreenType(parent, name),
-        m_musicLocation(NULL), m_musicAudioDevice(NULL),
+        m_musicAudioDevice(NULL),
         m_musicDefaultUpmix(NULL), m_musicCDDevice(NULL),
         m_nonID3FileNameFormat(NULL), m_ignoreID3Tags(NULL),
-        m_allowTagWriting(NULL), m_saveButton(NULL),
+        m_allowTagWriting(NULL), m_resetDBButton(NULL), m_saveButton(NULL),
         m_cancelButton(NULL)
 {
 }
@@ -30,13 +34,13 @@
     if (!LoadWindowFromXML("musicsettings-ui.xml", "generalsettings", this))
         return false;
 
-    UIUtilE::Assign(this, m_musicLocation, "musiclocation", &err);
     UIUtilE::Assign(this, m_musicAudioDevice, "musicaudiodevice", &err);
     UIUtilE::Assign(this, m_musicDefaultUpmix, "musicdefaultupmix", &err);
     UIUtilE::Assign(this, m_musicCDDevice, "musiccddevice", &err);
     UIUtilE::Assign(this, m_nonID3FileNameFormat, "nonid3filenameformat", &err);
     UIUtilE::Assign(this, m_ignoreID3Tags, "ignoreid3tags", &err);
     UIUtilE::Assign(this, m_allowTagWriting, "allowtagwriting", &err);
+    UIUtilW::Assign(this, m_resetDBButton, "resetdatabase", &err);
     UIUtilE::Assign(this, m_saveButton, "save", &err);
     UIUtilE::Assign(this, m_cancelButton, "cancel", &err);
 
@@ -46,7 +50,6 @@
         return false;
     }
 
-    m_musicLocation->SetText(gCoreContext->GetSetting("MusicLocation"));
     m_musicAudioDevice->SetText(gCoreContext->GetSetting("MusicAudioDevice"));
 
     int loadMusicDefaultUpmix = gCoreContext->GetNumSetting("MusicDefaultUpmix", 0);
@@ -65,12 +68,12 @@
     if (allowTagWriting == 1)
         m_allowTagWriting->SetCheckState(MythUIStateType::Full);
 
+    if (m_resetDBButton)
+        connect(m_resetDBButton, SIGNAL(Clicked()), this, SLOT(slotResetDB()));
+
     connect(m_saveButton, SIGNAL(Clicked()), this, SLOT(slotSave()));
     connect(m_cancelButton, SIGNAL(Clicked()), this, SLOT(Close()));
 
-    m_musicLocation->SetHelpText(tr("This directory must exist, and the user "
-                 "running MythMusic needs to have write permission "
-                 "to the directory."));
     m_musicAudioDevice->SetHelpText(tr("Audio Device used for playback. 'default' "
                  "will use the device specified in MythTV"));
     m_musicDefaultUpmix->SetHelpText(tr("MythTV can upconvert stereo tracks to 5.1 audio. "
@@ -92,30 +95,76 @@
                  "to the file and permissions must be set "
                  "accordingly. Features such as ID3 playcounts "
                  "and ratings depend on this being enabled."));
+    if (m_resetDBButton)
+        m_resetDBButton->SetHelpText(tr("This will clear all the MythMusic database tables allowing "
+                 "for a fresh start. NOTE: You may lose any manual or automatic changes made to "
+                 "a tracks metadata like rating or playcount unless you told MythMusic to "
+                 "write those to the tag."));
     m_cancelButton->SetHelpText(tr("Exit without saving settings"));
     m_saveButton->SetHelpText(tr("Save settings and Exit"));
 
     BuildFocusList();
 
-    SetFocusWidget(m_musicLocation);
+    SetFocusWidget(m_musicCDDevice);
 
     return true;
 }
 
-void GeneralSettings::slotSave(void)
+void GeneralSettings::slotResetDB(void)
 {
-    // get the starting directory from the settings and remove all multiple
-    // directory separators "/" and resolves any "." or ".." in the path.
-    QString dir = m_musicLocation->GetText();
+    ShowOkPopup(tr("Are you sure you want to reset the music database?"),
+                this, SLOT(slotDoResetDB(bool)), true);
+}
 
-    if (!dir.isEmpty())
+void GeneralSettings::slotDoResetDB(bool ok)
+{
+    if (ok)
     {
-        dir = QDir::cleanPath(dir);
-        if (!dir.endsWith("/"))
-            dir += "/";
+        gPlayer->stop(true);
+
+        MSqlQuery query(MSqlQuery::InitCon());
+
+        query.prepare("TRUNCATE music_albumart");
+        if (!query.exec())
+            MythDB::DBError("resetting music_albumart table", query);
+
+        query.prepare("TRUNCATE music_albums");
+        if (!query.exec())
+            MythDB::DBError("resetting music_albums table", query);
+
+        query.prepare("TRUNCATE music_artists");
+        if (!query.exec())
+            MythDB::DBError("resetting music_artists table", query);
+
+        query.prepare("TRUNCATE music_directories");
+        if (!query.exec())
+            MythDB::DBError("resetting music_directories table", query);
+
+        query.prepare("TRUNCATE music_genres");
+        if (!query.exec())
+            MythDB::DBError("resetting music_genres table", query);
+
+        query.prepare("TRUNCATE music_playlists");
+        if (!query.exec())
+            MythDB::DBError("resetting music_playlists table", query);
+
+        query.prepare("TRUNCATE music_songs");
+        if (!query.exec())
+            MythDB::DBError("resetting music_songs table", query);
+
+        query.prepare("TRUNCATE music_stats");
+        if (!query.exec())
+            MythDB::DBError("resetting music_stats table", query);
+
+        gMusicData->reloadMusic();
+
+        ShowOkPopup(tr("Music database has been cleared.\n"
+                       "You must now scan, rip or import some tracks."));
     }
+}
 
-    gCoreContext->SaveSetting("MusicLocation", dir);
+void GeneralSettings::slotSave(void)
+{
     gCoreContext->SaveSetting("CDDevice", m_musicCDDevice->GetText());
     gCoreContext->SaveSetting("MusicAudioDevice", m_musicAudioDevice->GetText());
     gCoreContext->SaveSetting("NonID3FileNameFormat", m_nonID3FileNameFormat->GetText());
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/generalsettings.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/generalsettings.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/generalsettings.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/generalsettings.h	2014-05-05 12:30:23.000000000 +0200
@@ -20,19 +20,21 @@
     bool Create(void);
 
   private:
-    MythUITextEdit     *m_musicLocation;
     MythUITextEdit     *m_musicAudioDevice;
     MythUICheckBox     *m_musicDefaultUpmix;
     MythUITextEdit     *m_musicCDDevice;
     MythUITextEdit     *m_nonID3FileNameFormat;
     MythUICheckBox     *m_ignoreID3Tags;
     MythUICheckBox     *m_allowTagWriting;
+    MythUIButton       *m_resetDBButton;
     MythUIButton       *m_saveButton;
     MythUIButton       *m_cancelButton;
 
   private slots:
     void slotSave(void);
 
+    void slotResetDB(void);
+    void slotDoResetDB(bool ok);
 };
 
 #endif // GENERALSETTINGS_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/importmusic.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/importmusic.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/importmusic.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/importmusic.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -6,19 +6,7 @@
 // myth
 #include <mythcontext.h>
 #include <mythdbcon.h>
-#include <audiooutput.h>
 #include <musicmetadata.h>
-
-// mythmusic
-#include "importmusic.h"
-#include "decoder.h"
-#include "genres.h"
-#include "cdrip.h"
-#include "editmetadata.h"
-#include "musicplayer.h"
-#include "metaio.h"
-#include "musicutils.h"
-
 #include <mythdialogbox.h>
 #include <mythuitext.h>
 #include <mythuiimage.h>
@@ -28,44 +16,18 @@
 #include <mythuibuttonlist.h>
 #include <mythprogressdialog.h>
 #include <mythuifilebrowser.h>
-#include "mythlogging.h"
-
-static bool copyFile(const QString &src, const QString &dst)
-{
-    const int bufferSize = 16*1024;
-
-    if (src == dst)
-    {
-        LOG(VB_GENERAL, LOG_ERR, "copyFile: Cannot copy a file to itself");
-        return false;
-    }
-
-    QFile s(src);
-    QFile d(dst);
-    char buffer[bufferSize];
-    int len;
-
-    if (!s.open(QIODevice::ReadOnly))
-        return false;
+#include <mythlogging.h>
+#include <remotefile.h>
+#include <storagegroup.h>
 
-    if (!d.open(QIODevice::WriteOnly))
-    {
-        s.close();
-        return false;
-    }
-
-    len = s.read(buffer, bufferSize);
-    do
-    {
-        d.write(buffer, len);
-        len = s.read(buffer, bufferSize);
-    } while (len > 0);
-
-    s.close();
-    d.close();
+// mythmusic
+#include "importmusic.h"
+#include "genres.h"
+#include "editmetadata.h"
+#include "musicplayer.h"
+#include "metaio.h"
+#include "musicutils.h"
 
-    return true;
-}
 
 ///////////////////////////////////////////////////////////////////////////////
 
@@ -83,10 +45,25 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 
+FileCopyThread::FileCopyThread(const QString &src, const QString &dst) :
+    MThread("FileCopy"), m_srcFile(src), m_dstFile(dst), m_result(false)
+{
+}
+
+void FileCopyThread::run()
+{
+    RunProlog();
+    m_result = RemoteFile::CopyFile(m_srcFile, m_dstFile);
+    RunEpilog();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
 
 ImportMusicDialog::ImportMusicDialog(MythScreenStack *parent) :
     MythScreenType(parent, "musicimportfiles"),
 
+    m_musicStorageDir(""),
     m_somethingWasImported(false),
     m_tracks(new vector<TrackInfo*>),
     m_currentTrack(0),
@@ -113,13 +90,16 @@
     m_addallnewButton(NULL),
     m_nextnewButton(NULL),
     m_compilationCheck(NULL),
-    m_popupMenu(NULL),
     // default metadata values
     m_defaultCompilation(false),
     m_defaultYear(0),
     m_defaultRating(0),
     m_haveDefaults(false)
 {
+    QString lastHost = gCoreContext->GetSetting("MythMusicLastImportHost", gCoreContext->GetMasterHostName());
+    QStringList dirs = StorageGroup::getGroupDirs("Music", lastHost);
+    if (dirs.count() > 0)
+        m_musicStorageDir = StorageGroup::getGroupDirs("Music", lastHost).at(0);
 }
 
 ImportMusicDialog::~ImportMusicDialog()
@@ -410,50 +390,51 @@
     // is the current track a new file?
     if (m_tracks->at(m_currentTrack)->isNewTune)
     {
-        // get the save filename - this also creates the correct directory stucture
+        // do we need to update the tags?
+        if (m_tracks->at(m_currentTrack)->metadataHasChanged)
+        {
+            MetaIO *tagger = MetaIO::createTagger(meta->Filename());
+            if (tagger)
+            {
+                tagger->write(meta->Filename(), meta);
+                delete tagger;
+            }
+        }
+
+        // get the save filename
+        QString origFilename = meta->Filename();
         QString saveFilename = filenameFromMetadata(meta);
+        QString fullFilename;
+
+        QUrl url(m_musicStorageDir);
+        fullFilename = gCoreContext->GenMythURL(url.host(), 0, saveFilename, "Music");
+
 
         // we need to manually copy the file extension
-        QFileInfo fi(meta->Filename());
+        QFileInfo fi(origFilename);
         saveFilename += "." + fi.suffix();
+        fullFilename += "." + fi.suffix();
+
+        LOG(VB_FILE, LOG_INFO, QString("Copying file from: %1").arg(origFilename));
+        LOG(VB_FILE, LOG_INFO, QString("to: ").arg(fullFilename));
 
         // copy the file to the new location
-        if (!copyFile(meta->Filename(), getMusicDirectory() + saveFilename))
+        if (!copyFile(origFilename, fullFilename))
         {
-            ShowOkPopup(tr("Copy Failed\nCould not copy file to: %1")
-                                                        .arg(getMusicDirectory() + saveFilename));
+            ShowOkPopup(tr("Copy Failed\nCould not copy file to: %1").arg(fullFilename));
             return;
         }
 
         meta->setFilename(saveFilename);
-
-        // do we need to update the tags?
-        if (m_tracks->at(m_currentTrack)->metadataHasChanged)
-        {
-            MetaIO *tagger = MetaIO::createTagger(getMusicDirectory() + saveFilename);
-            if (tagger)
-            {
-                tagger->write(meta);
-                delete tagger;
-            }
-        }
-
-        meta->setFileSize((quint64)QFileInfo(saveFilename).size());
+        meta->setHostname(url.host());
+        meta->setFileSize((quint64)QFileInfo(origFilename).size());
 
         // update the database
         meta->dumpToDatabase();
 
-        // read any embedded images from the tag
-        MetaIO *tagger = MetaIO::createTagger(meta->Filename(true));
-        if (tagger && tagger->supportsEmbeddedImages())
-        {
-            AlbumArtList artList = tagger->getAlbumArtList(meta->Filename(true));
-            meta->setEmbeddedAlbumArt(artList);
-            meta->getAlbumArtImages()->dumpToDatabase();
-        }
-
-        if (tagger)
-            delete tagger;
+        // find any albumart for this track
+        meta->getAlbumArtImages()->scanForImages();
+        meta->getAlbumArtImages()->dumpToDatabase();
 
         m_somethingWasImported = true;
 
@@ -514,6 +495,46 @@
     }
 }
 
+bool ImportMusicDialog::copyFile(const QString &src, const QString &dst)
+{
+    bool res = false;
+    QString host = QUrl(dst).host();
+
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythUIBusyDialog *busy =
+            new MythUIBusyDialog(tr("Copying music file to the 'Music' storage group on %1").arg(host),
+                                    popupStack,
+                                    "scanbusydialog");
+
+    if (busy->Create())
+    {
+        popupStack->AddScreen(busy, false);
+    }
+    else
+    {
+        delete busy;
+        busy = NULL;
+    }
+
+    FileCopyThread *copy = new FileCopyThread(src, dst);
+    copy->start();
+
+    while (!copy->isFinished())
+    {
+        usleep(500);
+        qApp->processEvents();
+    }
+
+    res = copy->GetResult();
+
+    delete copy;
+
+    if (busy)
+        busy->Close();
+
+    return res;
+}
+
 void ImportMusicDialog::startScan()
 {
     // sanity check - make sure the user isn't trying to import tracks from the music directory
@@ -521,17 +542,6 @@
     if (!location.endsWith('/'))
         location.append('/');
 
-    if (location.startsWith(getMusicDirectory()))
-    {
-        ShowOkPopup(tr("Cannot import music from the music directory. "
-                       "You probably want to use 'Scan For New Music' "
-                       "instead."));
-        m_tracks->clear();
-        m_sourceFiles.clear();
-        fillWidgets();
-        return;
-    }
-
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
     MythUIBusyDialog *busy = 
             new MythUIBusyDialog(tr("Searching for music files"),
@@ -628,7 +638,6 @@
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
 
     EditMetadataDialog *editDialog = new EditMetadataDialog(mainStack, editMeta);
-    editDialog->setSaveMetadataOnly();
 
     if (!editDialog->Create())
     {
@@ -636,6 +645,8 @@
         return;
     }
 
+    editDialog->setSaveMetadataOnly();
+
     connect(editDialog, SIGNAL(metadataChanged()), this, SLOT(metadataChanged()));
 
     mainStack->AddScreen(editDialog);
@@ -652,9 +663,6 @@
 
 void ImportMusicDialog::showMenu()
 {
-    if (m_popupMenu)
-        return;
-
     if (m_tracks->empty())
         return;
 
@@ -671,6 +679,7 @@
     }
 
     menu->SetReturnEvent(this, "menu");
+    menu->AddButton(tr("Select Where To Save Tracks"), SLOT(chooseBackend()));
     menu->AddButton(tr("Save Defaults"), SLOT(saveDefaults()));
 
     if (m_haveDefaults)
@@ -686,6 +695,57 @@
     }
 }
 
+void ImportMusicDialog::chooseBackend(void)
+{
+    QStringList hostList;
+
+    // get a list of hosts with a directory defined for the 'Music' storage group
+    MSqlQuery query(MSqlQuery::InitCon());
+    QString sql = "SELECT DISTINCT hostname "
+                  "FROM storagegroup "
+                  "WHERE groupname = 'Music'";
+    if (!query.exec(sql) || !query.isActive())
+        MythDB::DBError("ImportMusicDialog::chooseBackend get host list", query);
+    else
+    {
+        while(query.next())
+        {
+            hostList.append(query.value(0).toString());
+        }
+    }
+
+    if (hostList.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "ImportMusicDialog::chooseBackend: No backends found");
+        return;
+    }
+
+    QString msg = tr("Select where to save tracks");
+
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythUISearchDialog *searchDlg = new MythUISearchDialog(popupStack, msg, hostList, false, "");
+
+    if (!searchDlg->Create())
+    {
+        delete searchDlg;
+        return;
+    }
+
+    connect(searchDlg, SIGNAL(haveResult(QString)), SLOT(setSaveHost(QString)));
+
+    popupStack->AddScreen(searchDlg);
+}
+
+void ImportMusicDialog::setSaveHost(QString host)
+{
+    gCoreContext->SaveSetting("MythMusicLastImportHost", host);
+
+    QStringList dirs = StorageGroup::getGroupDirs("Music", host);
+    if (dirs.count() > 0)
+        m_musicStorageDir = StorageGroup::getGroupDirs("Music", host).at(0);
+
+}
+
 void ImportMusicDialog::saveDefaults(void)
 {
     MusicMetadata *data = m_tracks->at(m_currentTrack)->metadata;
@@ -863,7 +923,8 @@
 
     ImportCoverArtDialog *import = new ImportCoverArtDialog(mainStack,
                                         fi.absolutePath(),
-                                        m_tracks->at(m_currentTrack)->metadata);
+                                        m_tracks->at(m_currentTrack)->metadata,
+                                        m_musicStorageDir);
 
     if (import->Create())
         mainStack->AddScreen(import);
@@ -888,9 +949,11 @@
 
 ImportCoverArtDialog::ImportCoverArtDialog(MythScreenStack *parent,
                                            const QString &sourceDir,
-                                           MusicMetadata *metadata) :
+                                           MusicMetadata *metadata,
+                                           const QString &storageDir) :
     MythScreenType(parent, "import_coverart"),
     m_sourceDir(sourceDir),
+    m_musicStorageDir(storageDir),
     m_metadata(metadata),
     m_currentFile(0),
     //  GUI stuff
@@ -970,15 +1033,15 @@
     if (m_typeList)
     {
         new MythUIButtonListItem(m_typeList, tr("Front Cover"),
-                                 qVariantFromValue(0));
+                                 qVariantFromValue((int)IT_FRONTCOVER));
         new MythUIButtonListItem(m_typeList, tr("Back Cover"),
-                                 qVariantFromValue(1));
+                                 qVariantFromValue((int)IT_BACKCOVER));
         new MythUIButtonListItem(m_typeList, tr("CD"),
-                                 qVariantFromValue(2));
+                                 qVariantFromValue((int)IT_CD));
         new MythUIButtonListItem(m_typeList, tr("Inlay"),
-                                 qVariantFromValue(3));
+                                 qVariantFromValue((int)IT_INLAY));
         new MythUIButtonListItem(m_typeList, tr("<Unknown>"),
-                                 qVariantFromValue(4));
+                                 qVariantFromValue((int)IT_UNKNOWN));
 
         connect(m_typeList, SIGNAL(itemSelected(MythUIButtonListItem *)),
                 SLOT(selectorChanged()));
@@ -1012,14 +1075,25 @@
 {
     if (m_filelist.size() > 0)
     {
-        if (!copyFile(m_filelist[m_currentFile], m_saveFilename))
+        if (!RemoteFile::CopyFile(m_filelist[m_currentFile], m_saveFilename))
         {
             //: %1 is the filename
-            ShowOkPopup(tr("Copy CoverArt Failed.\nCopying to %1")
-                    .arg(m_saveFilename));
+            ShowOkPopup(tr("Copy CoverArt Failed.\nCopying to %1").arg(m_saveFilename));
             return;
         }
 
+        // add the file to the database
+        QString filename = m_saveFilename.section( '/', -1, -1);
+        AlbumArtImage *image = new AlbumArtImage;
+        image->description = "";
+        image->embedded = false;
+        image->filename = filename;
+        image->hostname = m_metadata->Hostname();
+        image->imageType = (ImageType)m_typeList->GetItemCurrent()->GetData().toInt();
+
+        m_metadata->getAlbumArtImages()->addImage(image);
+        m_metadata->getAlbumArtImages()->dumpToDatabase();
+
         updateStatus();
     }
 }
@@ -1093,33 +1167,41 @@
         m_coverartImage->SetFilename(m_filelist[m_currentFile]);
         m_coverartImage->Load();
 
-        QString saveFilename = getMusicDirectory() + filenameFromMetadata(m_metadata, false);
-        QFileInfo fi(saveFilename);
-        QString saveDir = fi.absolutePath();
+        QString saveFilename = filenameFromMetadata(m_metadata);
+        QString fullFilename;
+
+        QUrl url(m_musicStorageDir);
+        fullFilename = gCoreContext->GenMythURL(url.host(), 0, saveFilename, "Music");
+        QString dir = fullFilename.section( '/', 0, -2);
 
-        fi.setFile(m_filelist[m_currentFile]);
+        QFileInfo fi(m_filelist[m_currentFile]);
         switch (m_typeList->GetItemCurrent()->GetData().toInt())
         {
-            case 0:
+            case IT_FRONTCOVER:
                 saveFilename = "front." + fi.suffix();
                 break;
-            case 1:
+            case IT_BACKCOVER:
                 saveFilename = "back." + fi.suffix();
                 break;
-            case 2:
+            case IT_CD:
                 saveFilename = "cd." + fi.suffix();
                 break;
-            case 3:
+            case IT_INLAY:
                 saveFilename = "inlay." + fi.suffix();
                 break;
+            case IT_UNKNOWN:
+                saveFilename = "unknown." + fi.suffix();
+                break;
             default:
                 saveFilename = fi.fileName();
         }
 
-        m_saveFilename = saveDir + "/" + saveFilename;
+        m_saveFilename = dir + "/" + saveFilename;
         m_destinationText->SetText(m_saveFilename);
 
-        if (QFile::exists(m_saveFilename))
+        url.setUrl(m_saveFilename);
+
+        if (!RemoteFile::FindFile(url.path(), "" , "Music").isEmpty())
             m_statusText->SetText(tr("File Already Exists"));
         else
             m_statusText->SetText(tr("New File"));
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/importmusic.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/importmusic.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/importmusic.h	2014-05-04 17:43:54.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/importmusic.h	2014-05-05 12:30:23.000000000 +0200
@@ -38,6 +38,20 @@
         ImportMusicDialog *m_parent;
 };
 
+class FileCopyThread: public MThread
+{
+    public:
+        FileCopyThread(const QString &src, const QString &dst);
+        virtual void run();
+
+        bool GetResult(void) { return m_result; }
+
+    private:
+        QString m_srcFile;
+        QString m_dstFile;
+        bool m_result;
+};
+
 class ImportMusicDialog : public MythScreenType
 {
 
@@ -53,6 +67,7 @@
 
     bool somethingWasImported() { return m_somethingWasImported; }
     void doScan(void);
+    void doFileCopy(const QString &src, const QString &dst);
 
   public slots:
     void addAllNewPressed(void);
@@ -82,6 +97,8 @@
     void setTitleWordCaps(void);
     void setTitleInitialCap(void);
     void metadataChanged(void);
+    void chooseBackend(void);
+    void setSaveHost(QString host);
 
   signals:
     void importFinished(void);
@@ -90,7 +107,9 @@
     void fillWidgets();
     void scanDirectory(QString &directory, vector<TrackInfo*> *tracks);
     void showImportCoverArtDialog();
+    bool copyFile(const QString &src, const QString &dst);
 
+    QString              m_musicStorageDir;
     bool                 m_somethingWasImported;
     vector<TrackInfo*>  *m_tracks;
     QStringList          m_sourceFiles;
@@ -125,8 +144,6 @@
 
     MythUICheckBox  *m_compilationCheck;
 
-    MythDialogBox   *m_popupMenu;
-
     // default metadata values
     bool             m_defaultCompilation;
     QString          m_defaultCompArtist;
@@ -148,7 +165,7 @@
   public:
 
     ImportCoverArtDialog(MythScreenStack *parent, const QString &sourceDir,
-                         MusicMetadata *metadata);
+                         MusicMetadata *metadata, const QString &storageDir);
     ~ImportCoverArtDialog();
 
     bool Create(void);
@@ -167,6 +184,7 @@
 
     QStringList    m_filelist;
     QString        m_sourceDir;
+    QString        m_musicStorageDir;
     MusicMetadata *m_metadata;
     int            m_currentFile;
     QString        m_saveFilename;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/lameencoder.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/lameencoder.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/lameencoder.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/lameencoder.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -145,12 +145,7 @@
 
     // Now write the Metadata
     if (m_metadata)
-    {
-        QString filename = m_metadata->Filename();
-        m_metadata->setFilename(m_outfile);
-        MetaIOID3().write(m_metadata);
-        m_metadata->setFilename(filename);
-    }
+        MetaIOID3().write(m_outfile, m_metadata);
 }
 
 int LameEncoder::addSamples(int16_t * bytes, unsigned int length)
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/main.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/main.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/main.cpp	2014-05-05 12:28:39.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/main.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -24,6 +24,7 @@
 #include <lcddevice.h>
 #include <musicmetadata.h>
 #include <musicutils.h>
+#include <musicfilescanner.h>
 
 // MythMusic headers
 #include "musicdata.h"
@@ -34,7 +35,6 @@
 #include "streamview.h"
 #include "playlistcontainer.h"
 #include "dbcheck.h"
-#include "filescanner.h"
 #include "musicplayer.h"
 #include "config.h"
 #include "mainvisual.h"
@@ -64,82 +64,94 @@
     return MediaMonitor::defaultCDdevice();
 }
 
-static void loadMusic()
+/// checks we have at least one music directory in the 'Music' storage group
+static bool checkStorageGroup(void)
 {
-    // only do this once
-    if (gMusicData->initialized)
-        return;
-
-    MSqlQuery count_query(MSqlQuery::InitCon());
-
-    bool musicdata_exists = false;
-    if (count_query.exec("SELECT COUNT(*) FROM music_songs;"))
+    // get a list of hosts with a directory defined for the 'Music' storage group
+    QStringList hostList;
+    MSqlQuery query(MSqlQuery::InitCon());
+    QString sql = "SELECT DISTINCT hostname "
+                  "FROM storagegroup "
+                  "WHERE groupname = 'Music'";
+    if (!query.exec(sql) || !query.isActive())
+        MythDB::DBError("checkStorageGroup get host list", query);
+    else
     {
-        if(count_query.next() &&
-            0 != count_query.value(0).toInt())
+        while(query.next())
         {
-            musicdata_exists = true;
+            hostList.append(query.value(0).toString());
         }
     }
 
-    QString musicDir = getMusicDirectory();
+    if (hostList.isEmpty())
+    {
+        ShowOkPopup(qApp->translate("(MythMusicMain)",
+                                    "No directories found in the 'Music' storage group. "
+                                    "Please run mythtv-setup on the backend machine to add one."));
+       return false;
+    }
 
-    // Only search music files if a directory was specified & there
-    // is no data in the database yet (first run).  Otherwise, user
-    // can choose "Setup" option from the menu to force it.
-    if (!musicDir.isEmpty() && !musicdata_exists)
-    {
-        FileScanner *fscan = new FileScanner();
-        fscan->SearchDir(musicDir);
-        delete fscan;
-    }
-
-    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-    QString message = qApp->translate("(MythMusicMain)", 
-                                      "Loading Music. Please wait ...");
-
-    MythUIBusyDialog *busy = new MythUIBusyDialog(message, popupStack,
-                                                  "musicscanbusydialog");
-    if (busy->Create())
-        popupStack->AddScreen(busy, false);
+    // get a list of hosts with a directory defined for the 'MusicArt' storage group
+    hostList.clear();
+    sql = "SELECT DISTINCT hostname "
+                  "FROM storagegroup "
+                  "WHERE groupname = 'MusicArt'";
+    if (!query.exec(sql) || !query.isActive())
+        MythDB::DBError("checkStorageGroup get host list", query);
     else
-        busy = NULL;
-
-    // Set the various track formatting modes
-    MusicMetadata::setArtistAndTrackFormats();
-
-    AllMusic *all_music = new AllMusic();
-
-    //  Load all playlists into RAM (once!)
-    PlaylistContainer *all_playlists = new PlaylistContainer(all_music);
+    {
+        while(query.next())
+        {
+            hostList.append(query.value(0).toString());
+        }
+    }
 
-    gMusicData->all_music = all_music;
-    gMusicData->all_streams = new AllStream();
-    gMusicData->all_playlists = all_playlists;
+    if (hostList.isEmpty())
+    {
+        ShowOkPopup(qApp->translate("(MythMusicMain)",
+                                    "No directories found in the 'MusicArt' storage group. "
+                                    "Please run mythtv-setup on the backend machine to add one."));
+       return false;
+    }
 
-    gMusicData->initialized = true;
+    return true;
+}
 
-    while (!gMusicData->all_playlists->doneLoading() || !gMusicData->all_music->doneLoading())
+/// checks we have some tracks available
+static bool checkMusicAvailable(void)
+{
+    MSqlQuery count_query(MSqlQuery::InitCon());
+    bool foundMusic = false;
+    if (count_query.exec("SELECT COUNT(*) FROM music_songs;"))
     {
-        qApp->processEvents();
-        usleep(50000);
+        if(count_query.next() &&
+            0 != count_query.value(0).toInt())
+        {
+            foundMusic = true;
+        }
     }
 
-    gPlayer->loadStreamPlaylist();
-    gPlayer->loadPlaylist();
-
-    if (busy)
-        busy->Close();
+    if (!foundMusic)
+    {
+        ShowOkPopup(qApp->translate("(MythMusicMain)",
+                                    "No music has been found.\n"
+                                    "Please select 'Scan For New Music' "
+                                    "to perform a scan for music."));
+    }
 
+    return foundMusic;
 }
 
 static void startPlayback(void)
 {
-    loadMusic();
+    if (!checkStorageGroup() || !checkMusicAvailable())
+        return;
+
+    gMusicData->loadMusic();
 
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
 
-    PlaylistView *view = new PlaylistView(mainStack);
+    PlaylistView *view = new PlaylistView(mainStack, NULL);
 
     if (view->Create())
         mainStack->AddScreen(view);
@@ -149,11 +161,11 @@
 
 static void startStreamPlayback(void)
 {
-    loadMusic();
+    gMusicData->loadMusic();
 
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
 
-    StreamView *view = new StreamView(mainStack);
+    StreamView *view = new StreamView(mainStack, NULL);
 
     if (view->Create())
         mainStack->AddScreen(view);
@@ -163,12 +175,15 @@
 
 static void startDatabaseTree(void)
 {
-    loadMusic();
+    if (!checkStorageGroup() || !checkMusicAvailable())
+        return;
+
+    gMusicData->loadMusic();
 
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
 
     QString lastView = gCoreContext->GetSetting("MusicPlaylistEditorView", "tree");
-    PlaylistEditorView *view = new PlaylistEditorView(mainStack, lastView);
+    PlaylistEditorView *view = new PlaylistEditorView(mainStack, NULL, lastView);
 
     if (view->Create())
         mainStack->AddScreen(view);
@@ -179,7 +194,10 @@
 static void startRipper(void)
 {
 #if defined HAVE_CDIO
-    loadMusic();
+    if (!checkStorageGroup())
+        return;
+
+    gMusicData->loadMusic();
 
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
 
@@ -204,54 +222,20 @@
 
 static void runScan(void)
 {
-    // if we don't have a valid start dir warn the user and give up
-    if (getMusicDirectory().isEmpty())
-    {
-        ShowOkPopup(qApp->translate("(MythMusicMain)",
-                                    "You need to tell me where to find your "
-                                    "music on the 'General Settings' page of "
-                                    "MythMusic's settings pages."));
-       return;
-    }
-
-    if (!QFile::exists(getMusicDirectory()))
-    {
-        ShowOkPopup(qApp->translate("(MythMusicMain)",
-                                    "Can't find your music directory. Have "
-                                    "you set it correctly on the 'General "
-                                    "Settings' page of MythMusic's settings "
-                                    "pages?"));
-       return;
-    }
-
-    LOG(VB_GENERAL, LOG_INFO, QString("Scanning '%1' for music files").arg(getMusicDirectory()));
-
-    FileScanner *fscan = new FileScanner();
-    QString musicDir = getMusicDirectory();
-    fscan->SearchDir(musicDir);
-
-    // save anything that may have changed
-    if (gMusicData->all_music && gMusicData->all_music->cleanOutThreads())
-        gMusicData->all_music->save();
-
-    if (gMusicData->all_playlists && gMusicData->all_playlists->cleanOutThreads())
-    {
-        gMusicData->all_playlists->save();
-    }
-
-    // force a complete reload of the tracks and playlists
-    gPlayer->stop(true);
-    delete gMusicData;
+    if (!checkStorageGroup())
+        return;
 
-    gMusicData = new MusicData;
-    loadMusic();
+    LOG(VB_GENERAL, LOG_INFO, "Scanning for music files");
 
-    delete fscan;
+    gMusicData->scanMusic();
 }
 
 static void startImport(void)
 {
-    loadMusic();
+    if (!checkStorageGroup())
+        return;
+
+    gMusicData->loadMusic();
 
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
 
@@ -396,7 +380,7 @@
 
 static void runRipCD(void)
 {
-    loadMusic();
+    gMusicData->loadMusic();
 
 #if defined HAVE_CDIO
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
@@ -487,7 +471,7 @@
     }
 
     if (!gMusicData->initialized)
-        loadMusic();
+        gMusicData->loadMusic();
 
     // remove any existing CD tracks
     if (gMusicData->all_music)
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/miniplayer.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/miniplayer.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/miniplayer.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/miniplayer.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -8,7 +8,7 @@
 #include "decoder.h"
 
 MiniPlayer::MiniPlayer(MythScreenStack *parent)
-          : MusicCommon(parent, "music_miniplayer")
+          : MusicCommon(parent, NULL, "music_miniplayer")
 {
     m_currentView = MV_MINIPLAYER;
     m_displayTimer = new QTimer(this);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musiccommon.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musiccommon.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musiccommon.cpp	2014-05-05 12:28:39.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musiccommon.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -43,8 +43,10 @@
 #include "visualizerview.h"
 #include "searchview.h"
 
-MusicCommon::MusicCommon(MythScreenStack *parent, const QString &name)
+MusicCommon::MusicCommon(MythScreenStack *parent, MythScreenType *parentScreen,
+                         const QString &name)
             : MythScreenType(parent, name),
+    m_parentScreen(parentScreen),
     m_currentView(),            m_mainvisual(NULL),
     m_fullscreenBlank(false),   m_randomVisualizer(false),
     m_currentVisual(0),         m_moveTrackMode(false),
@@ -165,39 +167,63 @@
     if (m_nextButton)
         connect(m_nextButton, SIGNAL(Clicked()), this, SLOT(next()));
 
-    gPlayer->addListener(this);
-
-    if (!gPlayer->isPlaying())
+    if (m_currentPlaylist)
     {
-        bool isRadioView = (m_currentView == MV_RADIO);
-        if (isRadioView)
-            gPlayer->setPlayMode(MusicPlayer::PLAYMODE_RADIO);
-        else
-            gPlayer->setPlayMode(MusicPlayer::PLAYMODE_TRACKS);
+        connect(m_currentPlaylist, SIGNAL(itemClicked(MythUIButtonListItem*)),
+                this, SLOT(playlistItemClicked(MythUIButtonListItem*)));
+        connect(m_currentPlaylist, SIGNAL(itemVisible(MythUIButtonListItem*)),
+                this, SLOT(playlistItemVisible(MythUIButtonListItem*)));
 
-        gPlayer->restorePosition();
+        m_currentPlaylist->SetSearchFields("**search**");
     }
-    else
+
+    init();
+
+    return err;
+}
+
+void MusicCommon::init(bool startPlayback)
+{
+    gPlayer->addListener(this);
+
+    if (startPlayback)
     {
-        // if we are playing but we are switching to a view from a different playmode
-        // we need to restart playback in the new mode
-        if (m_currentView == MV_VISUALIZER || m_currentView == MV_MINIPLAYER)
-        {
-            // this view can be used in both play modes
-        }
-        else if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_RADIO && m_currentView != MV_RADIO)
+        if (!gPlayer->isPlaying())
         {
-            //gPlayer->savePosition();
-            gPlayer->stop(true);
-            gPlayer->setPlayMode(MusicPlayer::PLAYMODE_TRACKS);
+            if (m_currentView == MV_RADIO)
+                gPlayer->setPlayMode(MusicPlayer::PLAYMODE_RADIO);
+            else if (m_currentView == MV_PLAYLISTEDITORGALLERY || m_currentView == MV_PLAYLISTEDITORTREE)
+                gPlayer->setPlayMode(MusicPlayer::PLAYMODE_TRACKSEDITOR);
+            else
+                gPlayer->setPlayMode(MusicPlayer::PLAYMODE_TRACKSPLAYLIST);
+
             gPlayer->restorePosition();
         }
-        else if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_TRACKS && m_currentView == MV_RADIO)
+        else
         {
-            //gPlayer->savePosition();
-            gPlayer->stop(true);
-            gPlayer->setPlayMode(MusicPlayer::PLAYMODE_RADIO);
-            gPlayer->restorePosition();
+            // if we are playing but we are switching to a view from a different playmode
+            // we need to restart playback in the new mode
+            if (m_currentView == MV_VISUALIZER || m_currentView == MV_MINIPLAYER)
+            {
+                // these views can be used in both play modes
+            }
+            else if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_RADIO && m_currentView != MV_RADIO)
+            {
+                gPlayer->stop(true);
+
+                if (m_currentView == MV_PLAYLISTEDITORGALLERY || m_currentView == MV_PLAYLISTEDITORTREE)
+                    gPlayer->setPlayMode(MusicPlayer::PLAYMODE_TRACKSEDITOR);
+                else
+                    gPlayer->setPlayMode(MusicPlayer::PLAYMODE_TRACKSPLAYLIST);
+
+                gPlayer->restorePosition();
+            }
+            else if (gPlayer->getPlayMode() != MusicPlayer::PLAYMODE_RADIO && m_currentView == MV_RADIO)
+            {
+                gPlayer->stop(true);
+                gPlayer->setPlayMode(MusicPlayer::PLAYMODE_RADIO);
+                gPlayer->restorePosition();
+            }
         }
     }
 
@@ -210,21 +236,12 @@
     updateProgressBar();
 
     if (m_currentPlaylist)
-    {
-        connect(m_currentPlaylist, SIGNAL(itemClicked(MythUIButtonListItem*)),
-                this, SLOT(playlistItemClicked(MythUIButtonListItem*)));
-        connect(m_currentPlaylist, SIGNAL(itemVisible(MythUIButtonListItem*)),
-                this, SLOT(playlistItemVisible(MythUIButtonListItem*)));
-
-        m_currentPlaylist->SetSearchFields("**search**");
-
         updateUIPlaylist();
-    }
 
     if (m_visualizerVideo)
     {
-        // Warm up the visualizer
         m_mainvisual = new MainVisual(m_visualizerVideo);
+
         m_visualModes = m_mainvisual->getVisualizations();
 
         m_fullscreenBlank = false;
@@ -284,7 +301,7 @@
 
     updatePlaylistStats();
 
-    return err;
+    updateUIPlayedList();
 }
 
 void MusicCommon::updateRepeatMode(void)
@@ -379,6 +396,54 @@
 
 void MusicCommon::switchView(MusicView view)
 {
+    // can we switch to this view from the current view?
+    switch (m_currentView)
+    {
+        case MV_PLAYLIST:
+        {
+            if (view != MV_PLAYLISTEDITORTREE && view != MV_PLAYLISTEDITORGALLERY &&
+                    view != MV_SEARCH && view != MV_VISUALIZER)
+                return;
+            break;
+        }
+
+        case MV_PLAYLISTEDITORTREE:
+        {
+            if (view != MV_PLAYLISTEDITORGALLERY && view != MV_SEARCH && view != MV_VISUALIZER)
+                return;
+            break;
+        }
+
+        case MV_PLAYLISTEDITORGALLERY:
+        {
+            if (view != MV_PLAYLISTEDITORTREE && view != MV_SEARCH && view != MV_VISUALIZER)
+                return;
+            break;
+        }
+
+        case MV_SEARCH:
+        {
+            if (view != MV_VISUALIZER)
+                return;
+            break;
+        }
+
+        case MV_VISUALIZER:
+        {
+            return;
+        }
+
+        case MV_RADIO:
+        {
+            if (view != MV_VISUALIZER)
+                return;
+            break;
+        }
+
+        default:
+            return;
+    }
+
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
 
     stopVisualizer();
@@ -396,13 +461,15 @@
     {
         case MV_PLAYLIST:
         {
-            PlaylistView *view = new PlaylistView(mainStack);
+            PlaylistView *view = new PlaylistView(mainStack, this);
 
             if (view->Create())
                 mainStack->AddScreen(view);
             else
                 delete view;
 
+            connect(view, SIGNAL(Exiting()), this, SLOT(viewExited()));
+
             break;
         }
 
@@ -415,13 +482,23 @@
             if (oldView)
                 oldView->saveTreePosition();
 
-            PlaylistEditorView *view = new PlaylistEditorView(mainStack, "tree", restorePos);
+            MythScreenType *parentScreen = (oldView != NULL ? m_parentScreen : this);
+
+            PlaylistEditorView *view = new PlaylistEditorView(mainStack, parentScreen, "tree", restorePos);
 
             if (view->Create())
                 mainStack->AddScreen(view);
             else
                 delete view;
 
+            connect(view, SIGNAL(Exiting()), this, SLOT(viewExited()));
+
+            if (oldView)
+            {
+                disconnect(this , SIGNAL(Exiting()));
+                Close();
+            }
+
             break;
         }
 
@@ -434,49 +511,65 @@
             if (oldView)
                 oldView->saveTreePosition();
 
-            PlaylistEditorView *view = new PlaylistEditorView(mainStack, "gallery", restorePos);
+            MythScreenType *parentScreen = (oldView != NULL ? m_parentScreen : this);
+
+            PlaylistEditorView *view = new PlaylistEditorView(mainStack, parentScreen, "gallery", restorePos);
 
             if (view->Create())
                 mainStack->AddScreen(view);
             else
                 delete view;
 
+            connect(view, SIGNAL(Exiting()), this, SLOT(viewExited()));
+
+            if (oldView)
+            {
+                disconnect(this , SIGNAL(Exiting()));
+                Close();
+            }
+
             break;
         }
 
         case MV_SEARCH:
         {
-            SearchView *view = new SearchView(mainStack);
+            SearchView *view = new SearchView(mainStack, this);
 
             if (view->Create())
                 mainStack->AddScreen(view);
             else
                 delete view;
 
+            connect(view, SIGNAL(Exiting()), this, SLOT(viewExited()));
+
             break;
         }
 
         case MV_VISUALIZER:
         {
-            VisualizerView *view = new VisualizerView(mainStack);
+            VisualizerView *view = new VisualizerView(mainStack, this);
 
             if (view->Create())
                 mainStack->AddScreen(view);
             else
                 delete view;
 
+            connect(view, SIGNAL(Exiting()), this, SLOT(viewExited()));
+
             break;
         }
 
         case MV_RADIO:
         {
-            StreamView *view = new StreamView(mainStack);
+            StreamView *view = new StreamView(mainStack, this);
 
             if (view->Create())
                 mainStack->AddScreen(view);
             else
                 delete view;
 
+            connect(view, SIGNAL(Exiting()), this, SLOT(viewExited()));
+
             break;
         }
 
@@ -484,11 +577,14 @@
             return;
     }
 
-    Close();
-
     gPlayer->setAllowRestorePos(true);
 }
 
+void MusicCommon::viewExited(void)
+{
+    init(false);
+}
+
 bool MusicCommon::keyPressEvent(QKeyEvent *e)
 {
     bool handled = false;
@@ -542,26 +638,35 @@
 
         if (action == "ESCAPE")
         {
-            QString exit_action = gCoreContext->GetSetting("MusicExitAction", "prompt");
-
-            if (!gPlayer->isPlaying() || GetMythMainWindow()->IsExitingToMain())
+            // if we was started from another music view screen return to it
+            if (m_parentScreen || GetMythMainWindow()->IsExitingToMain())
             {
-                gPlayer->savePosition();
-                stopAll();
-                Close();
+                handled = false;
             }
             else
             {
-                if (exit_action == "stop")
+                // this is the top music view screen so prompt to continue playing
+                QString exit_action = gCoreContext->GetSetting("MusicExitAction", "prompt");
+
+                if (!gPlayer->isPlaying())
                 {
                     gPlayer->savePosition();
                     stopAll();
                     Close();
                 }
-                else if (exit_action == "play")
-                    Close();
                 else
-                    showExitMenu();
+                {
+                    if (exit_action == "stop")
+                    {
+                        gPlayer->savePosition();
+                        stopAll();
+                        Close();
+                    }
+                    else if (exit_action == "play")
+                        Close();
+                    else
+                        showExitMenu();
+                }
             }
         }
         else if (action == "THMBUP")
@@ -584,7 +689,7 @@
         }
         else if (action == "FFWD")
         {
-            if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_TRACKS)
+            if (gPlayer->getPlayMode() != MusicPlayer::PLAYMODE_RADIO)
             {
                 if (m_ffButton)
                     m_ffButton->Push();
@@ -594,7 +699,7 @@
         }
         else if (action == "RWND")
         {
-            if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_TRACKS)
+            if (gPlayer->getPlayMode() != MusicPlayer::PLAYMODE_RADIO)
             {
                 if (m_rewButton)
                     m_rewButton->Push();
@@ -775,7 +880,7 @@
 
 void MusicCommon::changeSpeed(bool up)
 {
-    if (gPlayer->getOutput() && gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_TRACKS)
+    if (gPlayer->getOutput() && gPlayer->getPlayMode() != MusicPlayer::PLAYMODE_RADIO)
     {
         if (up)
             gPlayer->incSpeed();
@@ -1237,20 +1342,29 @@
 
         QString resultid   = dce->GetId();
         QString resulttext = dce->GetResultText();
-        if (resultid == "viewmenu")
+
+        if (resultid == "mainmenu")
         {
-            if (dce->GetResult() >= 0)
+            if (resulttext == tr("Fullscreen Visualizer"))
+                switchView(MV_VISUALIZER);
+            else if (resulttext == tr("Playlist Editor"))
             {
-                MusicView view = (MusicView)dce->GetData().toInt();
-                switchView(view);
+                if (gCoreContext->GetSetting("MusicPlaylistEditorView", "tree") ==  "tree")
+                    switchView(MV_PLAYLISTEDITORTREE);
+                else
+                    switchView(MV_PLAYLISTEDITORGALLERY);
             }
+            else if (resulttext == tr("Search for Music"))
+                switchView(MV_SEARCH);
+            else if (resulttext == tr("Switch To Gallery View"))
+                switchView(MV_PLAYLISTEDITORGALLERY);
+            else if (resulttext == tr("Switch To Tree View"))
+                switchView(MV_PLAYLISTEDITORTREE);
         }
-        else if (resultid == "actionmenu")
+        else if (resultid == "submenu")
         {
             if (resulttext == tr("Search List..."))
-            {
                 searchButtonList();
-            }
         }
         else if (resultid == "playlistmenu")
         {
@@ -1706,6 +1820,29 @@
         if (gPlayer->getCurrentMetadata() && trackID == gPlayer->getCurrentMetadata()->ID())
             updateTrackInfo(gPlayer->getCurrentMetadata());
     }
+    else if (event->type() == MusicPlayerEvent::TrackUnavailableEvent)
+    {
+        MusicPlayerEvent *mpe = dynamic_cast<MusicPlayerEvent *>(event);
+
+        if (!mpe)
+            return;
+
+        uint trackID = mpe->TrackID;
+
+        if (m_currentPlaylist)
+        {
+            for (int x = 0; x < m_currentPlaylist->GetCount(); x++)
+            {
+                MythUIButtonListItem *item = m_currentPlaylist->GetItemAt(x);
+                MusicMetadata *mdata = qVariantValue<MusicMetadata*> (item->GetData());
+                if (mdata && mdata->ID() == trackID)
+                {
+                    item->SetFontState("disabled");
+                    item->DisplayState("unavailable", "playstate");
+                }
+            }
+        }
+    }
 }
 
 void MusicCommon::updateVolume(void)
@@ -1860,7 +1997,7 @@
         return;
 
     MusicMetadata *mdata = qVariantValue<MusicMetadata*> (item->GetData());
-    if (mdata)
+    if (mdata && item->GetText() == " ")
     {
         if (item->GetImageFilename().isEmpty())
         {
@@ -1877,14 +2014,11 @@
             }
         }
 
-        if (item->GetText() == " ")
-        {
-            InfoMap metadataMap;
-            mdata->toMap(metadataMap);
-            item->SetText("");
-            item->SetTextFromMap(metadataMap);
-            item->DisplayState(QString("%1").arg(mdata->Rating()), "ratingstate");
-        }
+        InfoMap metadataMap;
+        mdata->toMap(metadataMap);
+        item->SetText("");
+        item->SetTextFromMap(metadataMap);
+        item->DisplayState(QString("%1").arg(mdata->Rating()), "ratingstate");
     }
 }
 
@@ -2072,17 +2206,36 @@
 
 MythMenu* MusicCommon::createMainMenu(void)
 {
+    QString label = tr("View Actions");
+
+    MythMenu *menu = new MythMenu(label, this, "mainmenu");
+
+    if (m_currentView == MV_PLAYLISTEDITORTREE)
+        menu->AddItem(tr("Switch To Gallery View"));
+    else if (m_currentView == MV_PLAYLISTEDITORGALLERY)
+        menu->AddItem(tr("Switch To Tree View"));
+    else if (m_currentView == MV_PLAYLIST)
+        menu->AddItem(MusicCommon::tr("Playlist Editor"));
+
+    menu->AddItem(tr("Search for Music"));
+    menu->AddItem(tr("Fullscreen Visualizer"));
+
+    menu->AddItem(tr("More Options"), NULL, createSubMenu());
+
+    return menu;
+}
+
+MythMenu* MusicCommon::createSubMenu(void)
+{
     QString label = tr("Actions");
 
-    MythMenu *menu = new MythMenu(label, this, "actionmenu");
+    MythMenu *menu = new MythMenu(label, this, "submenu");
 
     if (GetFocusWidget() && (GetFocusWidget()->inherits("MythUIButtonList") ||
                              GetFocusWidget()->inherits("MythUIButtonTree")))
         menu->AddItem(tr("Search List..."));
 
-    menu->AddItem(tr("Switch View"),      NULL, createViewMenu());
-
-    if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_TRACKS)
+    if (gPlayer->getPlayMode() != MusicPlayer::PLAYMODE_RADIO)
     {
         menu->AddItem(tr("Playlist Options"), NULL, createPlaylistMenu());
         menu->AddItem(tr("Set Shuffle Mode"), NULL, createShuffleMenu());
@@ -2091,7 +2244,7 @@
 
     menu->AddItem(tr("Player Options"),   NULL, createPlayerMenu());
 
-    if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_TRACKS)
+    if (gPlayer->getPlayMode() != MusicPlayer::PLAYMODE_RADIO)
         menu->AddItem(tr("Quick Playlists"),  NULL, createQuickPlaylistsMenu());
 
     if (m_visualizerVideo)
@@ -2100,28 +2253,6 @@
     return menu;
 }
 
-MythMenu* MusicCommon::createViewMenu(void)
-{
-    QString label = tr("Switch View");
-
-    MythMenu *menu = new MythMenu(label, this, "viewmenu");
-
-    if (m_currentView != MV_PLAYLIST)
-        menu->AddItem(tr("Current Playlist"), qVariantFromValue((int)MV_PLAYLIST));
-    if (m_currentView != MV_PLAYLISTEDITORTREE)
-        menu->AddItem(tr("Playlist Editor - Tree"), qVariantFromValue((int)MV_PLAYLISTEDITORTREE));
-    if (m_currentView != MV_PLAYLISTEDITORGALLERY)
-        menu->AddItem(tr("Playlist Editor - Gallery"), qVariantFromValue((int)MV_PLAYLISTEDITORGALLERY));
-    if (m_currentView != MV_SEARCH)
-        menu->AddItem(tr("Search for Music"), qVariantFromValue((int)MV_SEARCH));
-    if (m_currentView != MV_RADIO)
-        menu->AddItem(tr("Play Radio Stream"), qVariantFromValue((int)MV_RADIO));
-    if (m_currentView != MV_VISUALIZER)
-        menu->AddItem(tr("Fullscreen Visualizer"), qVariantFromValue((int)MV_VISUALIZER));
-
-    return menu;
-}
-
 MythMenu* MusicCommon::createPlaylistMenu(void)
 {
     QString label = tr("Playlist Options");
@@ -2185,7 +2316,7 @@
     menu->AddItem(tr("Previous Track"));
     menu->AddItem(tr("Next Track"));
 
-    if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_TRACKS)
+    if (gPlayer->getPlayMode() != MusicPlayer::PLAYMODE_RADIO)
     {
         menu->AddItem(tr("Jump Back"));
         menu->AddItem(tr("Jump Forward"));
@@ -2194,7 +2325,7 @@
     menu->AddItem(tr("Play"));
     menu->AddItem(tr("Stop"));
 
-    if (gPlayer->getPlayMode() == MusicPlayer::PLAYMODE_TRACKS)
+    if (gPlayer->getPlayMode() != MusicPlayer::PLAYMODE_RADIO)
         menu->AddItem(tr("Pause"));
 
     return menu;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musiccommon.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musiccommon.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musiccommon.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musiccommon.h	2014-05-05 12:30:23.000000000 +0200
@@ -50,7 +50,8 @@
 
   protected:
 
-    MusicCommon(MythScreenStack *parent, const QString &name);
+    MusicCommon(MythScreenStack *parent, MythScreenType *parentScreen,
+                const QString &name);
     ~MusicCommon(void);
 
     bool CreateCommon(void);
@@ -63,6 +64,7 @@
     virtual void ShowMenu(void);
 
   protected slots:
+    void viewExited(void);
 
     void play(void);
     void stop(void);
@@ -77,7 +79,7 @@
 
     void searchButtonList(void);
     MythMenu* createMainMenu(void);
-    MythMenu* createViewMenu(void);
+    MythMenu* createSubMenu(void);
     MythMenu* createPlaylistMenu(void);
     MythMenu* createPlayerMenu(void);
     MythMenu* createQuickPlaylistsMenu(void);
@@ -103,6 +105,7 @@
     void showPlaylistOptionsMenu(bool addMainMenu = false);
 
   protected:
+    void init(bool startPlayback = true);
     QString getTimeString(int exTime, int maxTime);
     void updateProgressBar(void);
     void setTrackOnLCD(MusicMetadata *mdata);
@@ -132,6 +135,7 @@
     void playFirstTrack();
     bool restorePosition(int trackID);
 
+    MythScreenType        *m_parentScreen;
     MusicView              m_currentView;
 
     // visualiser stuff
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musicdata.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musicdata.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musicdata.cpp	2014-05-04 17:43:54.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musicdata.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -6,13 +6,20 @@
 #include <mythmainwindow.h>
 #include <mythprogressdialog.h>
 #include <musicmetadata.h>
+#include <musicfilescanner.h>
+#include <musicutils.h>
 
 // mythmusic
 #include "musicdata.h"
+#include "musicplayer.h"
 
 // this is the global MusicData object shared thoughout MythMusic
 MusicData  *gMusicData = NULL;
 
+
+///////////////////////////////////////////////////////////////////////////////
+
+
 MusicData::MusicData(void)
 {
     all_playlists = NULL;
@@ -42,6 +49,15 @@
     }
 }
 
+void MusicData::scanMusic (void)
+{
+    QStringList strList("SCAN_MUSIC");
+    SendStringListThread *thread = new SendStringListThread(strList);
+    MThreadPool::globalInstance()->start(thread, "Send SCAN_MUSIC");
+
+    LOG(VB_GENERAL, LOG_INFO, "Requested a music file scan");
+}
+
 /// reload music after a scan, rip or import
 void MusicData::reloadMusic(void)
 {
@@ -59,6 +75,16 @@
     else
         busy = NULL;
 
+    // TODO make it so the player isn't interupted
+    // for the moment stop playing and try to resume after reloading
+    bool wasPlaying = false;
+    if (gPlayer->isPlaying())
+    {
+        gPlayer->savePosition();
+        gPlayer->stop(true);
+        wasPlaying = true;
+    }
+
     all_music->startLoading();
     while (!all_music->doneLoading())
     {
@@ -66,6 +92,55 @@
         usleep(50000);
     }
 
+    all_playlists->resync();
+
+    if (busy)
+        busy->Close();
+
+    if (wasPlaying)
+        gPlayer->restorePosition();
+}
+
+void MusicData::loadMusic(void)
+{
+    // only do this once
+    if (initialized)
+        return;
+
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    QString message = qApp->translate("(MythMusicMain)",
+                                      "Loading Music. Please wait ...");
+
+    MythUIBusyDialog *busy = new MythUIBusyDialog(message, popupStack,
+                                                  "musicscanbusydialog");
+    if (busy->Create())
+        popupStack->AddScreen(busy, false);
+    else
+        busy = NULL;
+
+    // Set the various track formatting modes
+    MusicMetadata::setArtistAndTrackFormats();
+
+    AllMusic *all_music = new AllMusic();
+
+    //  Load all playlists into RAM (once!)
+    PlaylistContainer *all_playlists = new PlaylistContainer(all_music);
+
+    gMusicData->all_music = all_music;
+    gMusicData->all_streams = new AllStream();
+    gMusicData->all_playlists = all_playlists;
+
+    gMusicData->initialized = true;
+
+    while (!gMusicData->all_playlists->doneLoading() || !gMusicData->all_music->doneLoading())
+    {
+        qApp->processEvents();
+        usleep(50000);
+    }
+
+    gPlayer->loadStreamPlaylist();
+    gPlayer->loadPlaylist();
+
     if (busy)
         busy->Close();
 }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musicdata.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musicdata.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musicdata.h	2014-05-04 17:43:54.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musicdata.h	2014-05-05 12:30:23.000000000 +0200
@@ -1,15 +1,39 @@
 #ifndef MUSICDATA_H_
 #define MUSICDATA_H_
 
-//#include <musicmetadata.h>
+
+// qt
+#include <QRunnable>
+
+// myth
 #include <mythexp.h>
+#include <mythcorecontext.h>
 
+// mythmusic
 #include "playlistcontainer.h"
 
 class PlaylistContainer;
 class AllMusic;
 class AllStream;
 
+/// send a message to the master BE without blocking the UI thread
+class SendStringListThread : public QRunnable
+{
+  public:
+    SendStringListThread(const QStringList &strList)
+    {
+        m_strList = strList;
+    }
+
+    void run()
+    {
+        gCoreContext->SendReceiveStringList(m_strList);
+    }
+
+  private:
+    QStringList m_strList;
+};
+
 //----------------------------------------------------------------------------
 
 class MusicData : public QObject
@@ -21,11 +45,13 @@
     MusicData();
     ~MusicData();
 
+    void scanMusic(void);
+    void loadMusic(void);
+
   public slots:
     void reloadMusic(void);
 
   public:
-    //QString             musicDir;
     PlaylistContainer  *all_playlists;
     AllMusic           *all_music;
     AllStream          *all_streams;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musicplayer.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musicplayer.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musicplayer.cpp	2014-05-05 12:28:39.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musicplayer.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -42,6 +42,7 @@
 QEvent::Type MusicPlayerEvent::VolumeChangeEvent = (QEvent::Type) QEvent::registerEventType();
 QEvent::Type MusicPlayerEvent::TrackAddedEvent = (QEvent::Type) QEvent::registerEventType();
 QEvent::Type MusicPlayerEvent::TrackRemovedEvent = (QEvent::Type) QEvent::registerEventType();
+QEvent::Type MusicPlayerEvent::TrackUnavailableEvent = (QEvent::Type) QEvent::registerEventType();
 QEvent::Type MusicPlayerEvent::AllTracksRemovedEvent = (QEvent::Type) QEvent::registerEventType();
 QEvent::Type MusicPlayerEvent::MetadataChangedEvent = (QEvent::Type) QEvent::registerEventType();
 QEvent::Type MusicPlayerEvent::TrackStatsChangedEvent = (QEvent::Type) QEvent::registerEventType();
@@ -69,7 +70,7 @@
 
     m_isAutoplay = false;
     m_isPlaying = false;
-    m_playMode = PLAYMODE_TRACKS;
+    m_playMode = PLAYMODE_TRACKSPLAYLIST;
     m_canShowPlayer = true;
     m_wasPlaying = false;
     m_updatedLastplay = false;
@@ -77,6 +78,8 @@
 
     m_playSpeed = 1.0;
 
+    m_showScannerNotifications = true;
+
     m_errorCount = 0;
 
     QString playmode = gCoreContext->GetSetting("PlayMode", "none");
@@ -115,6 +118,12 @@
     gCoreContext->removeListener(this);
     gCoreContext->UnregisterForPlayback(this);
 
+    QMap<QString, int>::Iterator i;
+    for (i = m_notificationMap.begin(); i != m_notificationMap.end(); i++)
+        GetNotificationCenter()->UnRegister(this, (*i));
+
+    m_notificationMap.clear();
+
     stop(true);
 
     if (m_decoderHandler)
@@ -218,20 +227,23 @@
     }
 }
 
-void MusicPlayer::loadSettings(void )
+MusicPlayer::ResumeMode MusicPlayer::getResumeMode(void)
 {
-    QString resumestring = gCoreContext->GetSetting("ResumeMode", "off");
-    if (resumestring.toLower() == "off")
-        m_resumeMode = RESUME_OFF;
-    else if (resumestring.toLower() == "first")
-        m_resumeMode = RESUME_FIRST;
-    else if (resumestring.toLower() == "track")
-        m_resumeMode = RESUME_TRACK;
+    if (m_playMode == PLAYMODE_RADIO)
+        return m_resumeModeRadio;
+    else if (m_playMode == PLAYMODE_TRACKSEDITOR)
+        return m_resumeModeEditor;
     else
-        m_resumeMode = RESUME_EXACT;
+        return m_resumeModePlayback;
+}
 
-    m_lastplayDelay = gCoreContext->GetNumSetting("MusicLastPlayDelay", LASTPLAY_DELAY);
+void MusicPlayer::loadSettings(void)
+{
+    m_resumeModePlayback = (ResumeMode) gCoreContext->GetNumSetting("ResumeModePlayback", (ResumeMode) MusicPlayer::RESUME_EXACT);
+    m_resumeModeEditor = (ResumeMode) gCoreContext->GetNumSetting("ResumeModeEditor", (ResumeMode) MusicPlayer::RESUME_OFF);
+    m_resumeModeRadio = (ResumeMode) gCoreContext->GetNumSetting("ResumeModeRadio", (ResumeMode) MusicPlayer::RESUME_TRACK);
 
+    m_lastplayDelay = gCoreContext->GetNumSetting("MusicLastPlayDelay", LASTPLAY_DELAY);
     m_autoShowPlayer = (gCoreContext->GetNumSetting("MusicAutoShowPlayer", 1) > 0);
 }
 
@@ -315,11 +327,35 @@
 
 void MusicPlayer::play(void)
 {
+    stopDecoder();
+
     MusicMetadata *meta = getCurrentMetadata();
     if (!meta)
         return;
 
-    stopDecoder();
+    if (meta->Filename() == METADATA_INVALID_FILENAME)
+    {
+        // put an upper limit on the number of consecutive track unavailable errors
+        if (m_errorCount >= 1000)
+        {
+            ShowOkPopup(tr("Got to many track unavailable errors. Maybe the host with the music on is off-line?"));
+            stop(true);
+            m_errorCount = 0;
+            return;
+        }
+
+        if (m_errorCount < 5)
+        {
+            MythErrorNotification n(tr("Track Unavailable"), tr("MythMusic"), QString("Cannot find file '%1'").arg(meta->Filename(false)));
+            GetNotificationCenter()->Queue(n);
+        }
+
+        m_errorCount++;
+
+        sendTrackUnavailableEvent(meta->ID());
+        next();
+        return;
+    }
 
     // Notify others that we are about to play
     gCoreContext->WantingPlayback(this);
@@ -688,13 +724,6 @@
         }
         else if (me->Message().startsWith("MUSIC_SETTINGS_CHANGED"))
         {
-            QString startdir = gCoreContext->GetSetting("MusicLocation");
-            startdir = QDir::cleanPath(startdir);
-            if (!startdir.isEmpty() && !startdir.endsWith("/"))
-                startdir += "/";
-
-            setMusicDirectory(startdir);
-
             loadSettings();
         }
         else if (me->Message().startsWith("MUSIC_METADATA_CHANGED"))
@@ -717,6 +746,60 @@
                 }
             }
         }
+        else if (me->Message().startsWith("MUSIC_SCANNER_STARTED"))
+        {
+            QStringList list = me->Message().simplified().split(' ');
+            if (list.size() == 2)
+            {
+                QString host = list[1];
+                int id = getNotificationID(host);
+                sendNotification(id,
+                                 tr("A music file scan has started on %1").arg(host),
+                                 tr("Music File Scanner"),
+                                 tr("This may take a while I'll give a shout when finished"));
+            }
+        }
+        else if (me->Message().startsWith("MUSIC_SCANNER_FINISHED"))
+        {
+            QStringList list = me->Message().simplified().split(' ');
+            if (list.size() == 6)
+            {
+                QString host = list[1];
+                int id = getNotificationID(host);
+                int totalTracks = list[2].toInt();
+                int newTracks = list[3].toInt();
+                int totalCoverart = list[4].toInt();
+                int newCoverart = list[5].toInt();
+
+                QString summary = QString("Total Tracks: %2, new tracks: %3,\nTotal Coverart: %4, New CoverArt %5")
+                                          .arg(totalTracks).arg(newTracks).arg(totalCoverart).arg(newCoverart);
+                sendNotification(id,
+                                 tr("A music file scan has finished on %1").arg(host),
+                                 tr("Music File Scanner"), summary);
+
+                gMusicData->reloadMusic();
+            }
+        }
+        else if (me->Message().startsWith("MUSIC_SCANNER_ERROR"))
+        {
+            QStringList list = me->Message().simplified().split(' ');
+            if (list.size() == 3)
+            {
+                QString host = list[1];
+                QString error = list[2];
+                int id = getNotificationID(host);
+
+                if (error == "Already_Running")
+                    sendNotification(id, tr(""),
+                                     tr("Music File Scanner"),
+                                     tr("Can't run the music file scanner because it is already running on %1").arg(host));
+                else if (error == "Stalled")
+                    sendNotification(id, tr(""),
+                                     tr("Music File Scanner"),
+                                     tr("The music file scanner has been running for more than 60 minutes on %1.\nResetting and trying again")
+                                         .arg(host));
+            }
+        }
     }
 
     if (event->type() == OutputEvent::Error)
@@ -792,12 +875,12 @@
         if (!oe)
             return;
 
-        if (m_playMode == PLAYMODE_TRACKS)
+        if (m_playMode != PLAYMODE_RADIO)
             m_currentTime = oe->elapsedSeconds();
         else
             m_currentTime = oe->elapsedSeconds() - m_lastTrackStart;
 
-        if (m_playMode == PLAYMODE_TRACKS && !m_updatedLastplay)
+        if (m_playMode != PLAYMODE_RADIO && !m_updatedLastplay)
         {
             // we update the lastplay and playcount after playing
             // for m_lastplayDelay seconds or half the total track time
@@ -830,7 +913,7 @@
         }
         else
         {
-            if (m_playMode == PLAYMODE_TRACKS && getCurrentMetadata() &&
+            if (m_playMode != PLAYMODE_RADIO && getCurrentMetadata() &&
                 m_currentTime != getCurrentMetadata()->Length() / 1000)
             {
                 LOG(VB_GENERAL, LOG_NOTICE, QString("MusicPlayer: Updating track length was %1s, should be %2s")
@@ -1015,7 +1098,7 @@
         if (gPlayer->getResumeMode() > MusicPlayer::RESUME_OFF)
             play();
 
-        if (gPlayer->getResumeMode() == MusicPlayer::RESUME_EXACT && m_playMode == PLAYMODE_TRACKS)
+        if (gPlayer->getResumeMode() == MusicPlayer::RESUME_EXACT && m_playMode != PLAYMODE_RADIO)
             seek(gCoreContext->GetNumSetting("MusicBookmarkPosition", 0));
     }
 }
@@ -1169,7 +1252,7 @@
         curTrackID = getCurrentMetadata()->ID();
 
     // only save the mode if we are playing tracks
-    if (m_playMode == PLAYMODE_TRACKS)
+    if (m_playMode != PLAYMODE_RADIO)
         m_shuffleMode = mode;
 
     if (!getCurrentPlaylist())
@@ -1193,7 +1276,7 @@
 
 void MusicPlayer::updateLastplay()
 {
-    if (m_playMode == PLAYMODE_TRACKS && getCurrentMetadata())
+    if (m_playMode != PLAYMODE_RADIO && getCurrentMetadata())
     {
         getCurrentMetadata()->incPlayCount();
         getCurrentMetadata()->setLastPlay();
@@ -1204,22 +1287,24 @@
 
 void MusicPlayer::updateVolatileMetadata(void)
 {
-    if (m_playMode == PLAYMODE_TRACKS && getCurrentMetadata() && getDecoder())
+    if (m_playMode != PLAYMODE_RADIO && getCurrentMetadata() && getDecoder())
     {
         if (getCurrentMetadata()->hasChanged())
         {
             getCurrentMetadata()->persist();
 
-            // only write the playcount & rating to the tag if it's enabled by the user
+            // only write the last played, playcount & rating to the tag if it's enabled by the user
             if (GetMythDB()->GetNumSetting("AllowTagWriting", 0) == 1)
             {
-                MetaIO *tagger = MetaIO::createTagger(getCurrentMetadata()->Filename(true));
-
-                if (tagger)
-                {
-                    tagger->writeVolatileMetadata(getCurrentMetadata());
-                    delete tagger;
-                }
+                QStringList strList;
+                strList << QString("MUSIC_TAG_UPDATE_VOLATILE")
+                        << getCurrentMetadata()->Hostname()
+                        << QString::number(getCurrentMetadata()->ID())
+                        << QString::number(getCurrentMetadata()->Rating())
+                        << QString::number(getCurrentMetadata()->Playcount())
+                        << getCurrentMetadata()->LastPlay().toString(Qt::ISODate);
+                SendStringListThread *thread = new SendStringListThread(strList);
+                MThreadPool::globalInstance()->start(thread, "UpdateVolatile");
             }
 
             sendTrackStatsChangedEvent(getCurrentMetadata()->ID());
@@ -1272,6 +1357,12 @@
     dispatch(me);
 }
 
+void MusicPlayer::sendTrackUnavailableEvent(int trackID)
+{
+    MusicPlayerEvent me(MusicPlayerEvent::TrackUnavailableEvent, trackID);
+    dispatch(me);
+}
+
 void MusicPlayer::sendCDChangedEvent(void)
 {
     MusicPlayerEvent me(MusicPlayerEvent::CDChangedEvent, -1);
@@ -1424,6 +1515,9 @@
 
 void MusicPlayer::decoderHandlerReady(void)
 {
+    if (!getDecoder())
+        return;
+
     LOG(VB_PLAYBACK, LOG_INFO, QString ("decoder handler is ready, decoding %1")
             .arg(getDecoder()->getFilename()));
 
@@ -1472,7 +1566,7 @@
 
         getDecoder()->start();
 
-        if (!m_oneshotMetadata && m_resumeMode == RESUME_EXACT &&
+        if (!m_oneshotMetadata && getResumeMode() == RESUME_EXACT &&
             gCoreContext->GetNumSetting("MusicBookmarkPosition", 0) > 0)
         {
             seek(gCoreContext->GetNumSetting("MusicBookmarkPosition", 0));
@@ -1533,3 +1627,32 @@
 {
     return gMusicData->all_streams->getStreams();
 }
+
+int MusicPlayer::getNotificationID (const QString& hostname)
+{
+    if (m_notificationMap.find(hostname) == m_notificationMap.end())
+        m_notificationMap.insert(hostname, GetNotificationCenter()->Register(this));
+
+    return m_notificationMap[hostname];
+}
+
+void MusicPlayer::sendNotification(int notificationID, const QString &title, const QString &author, const QString &desc)
+{
+    QString image = "musicscanner.png";
+    if (!GetMythUI()->FindThemeFile(image))
+        LOG(VB_GENERAL, LOG_ERR, "MusicPlayer: sendNotification failed to find the 'musicscanner.png' image");
+
+    DMAP map;
+    map["asar"] = title;
+    map["minm"] = author;
+    map["asal"] = desc;
+
+    MythImageNotification *n = new MythImageNotification(MythNotification::Info, image, map);
+
+    n->SetId(notificationID);
+    n->SetParent(this);
+    n->SetDuration(5);
+    n->SetFullScreen(false);
+    GetNotificationCenter()->Queue(*n);
+    delete n;
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musicplayer.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musicplayer.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/musicplayer.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/musicplayer.h	2014-05-05 12:30:23.000000000 +0200
@@ -38,6 +38,7 @@
         static Type VolumeChangeEvent;
         static Type TrackAddedEvent;
         static Type TrackRemovedEvent;
+        static Type TrackUnavailableEvent;
         static Type AllTracksRemovedEvent;
         static Type MetadataChangedEvent;
         static Type TrackStatsChangedEvent;
@@ -57,7 +58,8 @@
 
     enum PlayMode
     {
-      PLAYMODE_TRACKS = 0,
+      PLAYMODE_TRACKSPLAYLIST = 0,
+      PLAYMODE_TRACKSEDITOR,
       PLAYMODE_RADIO,
     };
 
@@ -141,6 +143,7 @@
     void         sendMetadataChangedEvent(int trackID);
     void         sendTrackStatsChangedEvent(int trackID);
     void         sendAlbumArtChangedEvent(int trackID);
+    void         sendTrackUnavailableEvent(int trackID);
     void         sendCDChangedEvent(void);
 
     void         toMap(InfoMap &infoMap);
@@ -177,7 +180,7 @@
     void        setShuffleMode(ShuffleMode mode);
     ShuffleMode toggleShuffleMode(void);
 
-    ResumeMode  getResumeMode(void) { return m_resumeMode; }
+    ResumeMode  getResumeMode(void);
 
     void getBufferStatus(int *bufferAvailable, int *bufferSize);
 
@@ -195,6 +198,8 @@
     void updateLastplay(void);
     void updateVolatileMetadata(void);
     void sendVolumeChangedEvent(void);
+    int  getNotificationID(const QString &hostname);
+    void sendNotification(int notificationID, const QString &title, const QString &author, const QString &desc);
 
     void setupDecoderHandler(void);
     void decoderHandlerReady(void);
@@ -222,10 +227,16 @@
 
     ShuffleMode  m_shuffleMode;
     RepeatMode   m_repeatMode;
-    ResumeMode   m_resumeMode;
+    ResumeMode   m_resumeModePlayback;
+    ResumeMode   m_resumeModeEditor;
+    ResumeMode   m_resumeModeRadio;
 
     float        m_playSpeed;
 
+    // notification
+    bool m_showScannerNotifications;
+    QMap<QString, int>  m_notificationMap;
+
     // radio stuff
     QList<MusicMetadata*>  m_playedList;
     int               m_lastTrackStart;
@@ -235,6 +246,7 @@
     int               m_errorCount;
 };
 
+Q_DECLARE_METATYPE(MusicPlayer::ResumeMode);
 Q_DECLARE_METATYPE(MusicPlayer::RepeatMode);
 Q_DECLARE_METATYPE(MusicPlayer::ShuffleMode);
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/mythmusic.pro mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/mythmusic.pro
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/mythmusic.pro	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/mythmusic.pro	2014-05-05 12:30:23.000000000 +0200
@@ -36,7 +36,7 @@
 HEADERS += goom/ifs.h goom/lines.h goom/mythgoom.h goom/drawmethods.h
 HEADERS += goom/mmx.h goom/mathtools.h goom/tentacle3d.h goom/v3d.h
 HEADERS += editmetadata.h smartplaylist.h genres.h
-HEADERS += filescanner.h musicplayer.h miniplayer.h
+HEADERS += musicplayer.h miniplayer.h
 HEADERS += playlistcontainer.h musicdata.h
 HEADERS += musiccommon.h decoderhandler.h pls.h shoutcast.h
 HEADERS += playlistview.h playlisteditorview.h 
@@ -55,7 +55,7 @@
 SOURCES += goom/ifs.c goom/ifs_display.c goom/lines.c goom/surf3d.c
 SOURCES += goom/zoom_filter_mmx.c goom/zoom_filter_xmmx.c goom/mythgoom.cpp
 SOURCES += avfdecoder.cpp editmetadata.cpp smartplaylist.cpp
-SOURCES += filescanner.cpp musicplayer.cpp miniplayer.cpp
+SOURCES += musicplayer.cpp miniplayer.cpp
 SOURCES += playlistcontainer.cpp musicdata.cpp
 SOURCES += musiccommon.cpp decoderhandler.cpp pls.cpp shoutcast.cpp
 SOURCES += playlistview.cpp playlisteditorview.cpp 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playersettings.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playersettings.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playersettings.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playersettings.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -5,10 +5,13 @@
 #include <mythcorecontext.h>
 
 #include "playersettings.h"
+#include "musicplayer.h"
 
 PlayerSettings::PlayerSettings(MythScreenStack *parent, const char *name)
         : MythScreenType(parent, name),
         m_resumeMode(NULL),
+        m_resumeModeEditor(),
+        m_resumeModeRadio(),
         m_exitAction(NULL),
         m_autoLookupCD(NULL),
         m_autoPlayCD(NULL),
@@ -31,6 +34,8 @@
         return false;
 
     UIUtilE::Assign(this, m_resumeMode, "resumemode", &err);
+    UIUtilE::Assign(this, m_resumeModeEditor, "resumemodeeditor", &err);
+    UIUtilE::Assign(this, m_resumeModeRadio, "resumemoderadio", &err);
     UIUtilE::Assign(this, m_exitAction, "exitaction", &err);
     UIUtilE::Assign(this, m_autoLookupCD, "autolookupcd", &err);
     UIUtilE::Assign(this, m_autoPlayCD, "autoplaycd", &err);
@@ -43,11 +48,21 @@
         return false;
     }
 
-    new MythUIButtonListItem(m_resumeMode, tr("Off"), qVariantFromValue(QString("off")));
-    new MythUIButtonListItem(m_resumeMode, tr("First"), qVariantFromValue(QString("first")));
-    new MythUIButtonListItem(m_resumeMode, tr("Track"), qVariantFromValue(QString("track")));
-    new MythUIButtonListItem(m_resumeMode, tr("Exact"), qVariantFromValue(QString("exact")));
-    m_resumeMode->SetValueByData(gCoreContext->GetSetting("ResumeMode"));
+    new MythUIButtonListItem(m_resumeMode, tr("Off"),   qVariantFromValue((int)MusicPlayer::RESUME_OFF));
+    new MythUIButtonListItem(m_resumeMode, tr("First"), qVariantFromValue((int)MusicPlayer::RESUME_FIRST));
+    new MythUIButtonListItem(m_resumeMode, tr("Track"), qVariantFromValue((int)MusicPlayer::RESUME_TRACK));
+    new MythUIButtonListItem(m_resumeMode, tr("Exact"), qVariantFromValue((int)MusicPlayer::RESUME_EXACT));
+    m_resumeMode->SetValueByData(gCoreContext->GetNumSetting("ResumeModePlayback", MusicPlayer::RESUME_EXACT));
+
+    new MythUIButtonListItem(m_resumeModeEditor, tr("Off"),   qVariantFromValue((int)MusicPlayer::RESUME_OFF));
+    new MythUIButtonListItem(m_resumeModeEditor, tr("First"), qVariantFromValue((int)MusicPlayer::RESUME_FIRST));
+    new MythUIButtonListItem(m_resumeModeEditor, tr("Track"), qVariantFromValue((int)MusicPlayer::RESUME_TRACK));
+    new MythUIButtonListItem(m_resumeModeEditor, tr("Exact"), qVariantFromValue((int)MusicPlayer::RESUME_EXACT));
+    m_resumeModeEditor->SetValueByData(gCoreContext->GetNumSetting("ResumeModeEditor", MusicPlayer::RESUME_OFF));
+
+    new MythUIButtonListItem(m_resumeModeRadio, tr("Off"), qVariantFromValue((int)MusicPlayer::RESUME_OFF));
+    new MythUIButtonListItem(m_resumeModeRadio, tr("On"),  qVariantFromValue((int)MusicPlayer::RESUME_TRACK));
+    m_resumeModeRadio->SetValueByData(gCoreContext->GetNumSetting("ResumeModeRadio", MusicPlayer::RESUME_TRACK));
 
     new MythUIButtonListItem(m_exitAction, tr("Prompt"), qVariantFromValue(QString("prompt")));
     new MythUIButtonListItem(m_exitAction, tr("Stop playing"), qVariantFromValue(QString("stop")));
@@ -61,9 +76,13 @@
     if (loadAutoPlayCD == 1)
         m_autoPlayCD->SetCheckState(MythUIStateType::Full);
 
-    m_resumeMode->SetHelpText(tr("Resume playback at either the beginning of the "
-                 "active play queue, the beginning of the last track, "
-                 "or an exact point within the last track."));
+    m_resumeMode->SetHelpText(tr("Playback screen - Resume playback at either the beginning of the "
+                 "active play queue, the beginning of the last track played, "
+                 "or an exact point within the last track played or not at all."));
+    m_resumeModeEditor->SetHelpText(tr("Playlist Editor screen - Resume playback at either the beginning of the "
+                 "active play queue, the beginning of the last track played, "
+                 "or an exact point within the last track played or not at all."));
+    m_resumeModeRadio->SetHelpText(tr("Radio screen - Resume playback at the previous station or not at all"));
     m_exitAction->SetHelpText(tr("Specify what action to take when exiting MythMusic plugin."));
     m_autoLookupCD->SetHelpText(tr("Automatically lookup an audio CD if it is "
                  "present and show its information in the "
@@ -83,7 +102,9 @@
 
 void PlayerSettings::slotSave(void)
 {
-    gCoreContext->SaveSetting("ResumeMode", m_resumeMode->GetDataValue().toString());
+    gCoreContext->SaveSetting("ResumeModePlayback", m_resumeMode->GetDataValue().toInt());
+    gCoreContext->SaveSetting("ResumeModeEditor", m_resumeModeEditor->GetDataValue().toInt());
+    gCoreContext->SaveSetting("ResumeModeRadio", m_resumeModeRadio->GetDataValue().toInt());
     gCoreContext->SaveSetting("MusicExitAction", m_exitAction->GetDataValue().toString());
 
     int saveAutoLookupCD = (m_autoLookupCD->GetCheckState() == MythUIStateType::Full) ? 1 : 0;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playersettings.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playersettings.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playersettings.h	2014-05-04 17:43:54.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playersettings.h	2014-05-05 12:30:23.000000000 +0200
@@ -6,7 +6,6 @@
 #include <libmythui/mythuibuttonlist.h>
 #include <libmythui/mythuicheckbox.h>
 
-
 class PlayerSettings : public MythScreenType
 {
     Q_OBJECT
@@ -18,6 +17,8 @@
 
 private:
     MythUIButtonList   *m_resumeMode;
+    MythUIButtonList   *m_resumeModeEditor;
+    MythUIButtonList   *m_resumeModeRadio;
     MythUIButtonList   *m_exitAction;
     MythUICheckBox     *m_autoLookupCD;
     MythUICheckBox     *m_autoPlayCD;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlist.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlist.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlist.cpp	2014-05-05 12:28:39.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlist.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -81,7 +81,7 @@
 
         changed();
 
-        if (update_display)
+        if (update_display && isActivePlaylist())
             gPlayer->activePlaylistChanged(trackID, false);
     }
     else
@@ -125,7 +125,8 @@
 
     changed();
 
-    gPlayer->activePlaylistChanged(trackID, true);
+    if (isActivePlaylist())
+        gPlayer->activePlaylistChanged(trackID, true);
 }
 
 void Playlist::moveTrackUpDown(bool flag, int where_its_at)
@@ -607,6 +608,35 @@
     fillSongsFromSonglist(rawSonglist);
 }
 
+/// make sure all tracks are still valid after a scan
+void Playlist::resync(void)
+{
+    bool needUpdate = false;
+
+    for (int x = 0; x < m_songs.count(); x++)
+    {
+        MusicMetadata::IdType id = m_songs.at(x);
+        MusicMetadata *mdata = getRawSongAt(x);
+        if (!mdata)
+        {
+            m_songs.removeAll(id);
+            m_shuffledSongs.removeAll(id);
+            needUpdate = true;
+        }
+    }
+
+    if (needUpdate)
+    {
+        changed();
+
+        gPlayer->playlistChanged(m_playlistid);
+
+        // TODO check we actually need this
+        if (isActivePlaylist())
+            gPlayer->activePlaylistChanged(-1, false);
+    }
+}
+
 void Playlist::fillSongsFromSonglist(QString songList)
 {
     MusicMetadata::IdType id;
@@ -650,7 +680,8 @@
     if (badTrack)
         changed();
 
-    gPlayer->activePlaylistChanged(-1, false);
+    if (isActivePlaylist())
+        gPlayer->activePlaylistChanged(-1, false);
 }
 
 void Playlist::fillSonglistFromQuery(QString whereClause,
@@ -822,7 +853,7 @@
 
 QString Playlist::toRawSonglist(bool shuffled, bool tracksOnly)
 {
-    QString rawList;
+    QString rawList = "";
 
     if (shuffled)
     {
@@ -1082,7 +1113,6 @@
     return mdata;
 }
 
-
 // Here begins CD Writing things. ComputeSize, CreateCDMP3 & CreateCDAudio
 // FIXME non of this is currently used
 
@@ -1110,10 +1140,7 @@
                 LOG(VB_GENERAL, LOG_ERR, "Computing track lengths. "
                                          "One track <=0");
 
-            // Check tmpdata->Filename
-            QFileInfo finfo(mdata->Filename());
-
-            size_in_MB += finfo.size() / 1000000;
+            size_in_MB += mdata->FileSize() / 1000000;
         }
     }
 }
@@ -1202,6 +1229,7 @@
     m_procExitVal = retval;
 }
 
+// FIXME: this needs updating to work with storage groups
 int Playlist::CreateCDMP3(void)
 {
     // Check & get global settings
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlist.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlist.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlist.h	2014-05-05 12:28:39.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlist.h	2014-05-05 12:30:23.000000000 +0200
@@ -9,6 +9,7 @@
 #include <musicmetadata.h>
 
 // mythmusic
+#include "playlistcontainer.h"
 #include "musicplayer.h"
 
 class PlaylistContainer;
@@ -102,10 +103,14 @@
     QString getName(void) { return m_name; } 
     void    setName(QString a_name) { m_name = a_name; }
 
-    int     getID(void) { return m_playlistid; }
-    void    setID(int x) { m_playlistid = x; }
+    bool isActivePlaylist(void) { return m_name == DEFAULT_PLAYLIST_NAME; }
 
-    void    getStats(uint *trackCount, uint *totalLength, uint currentTrack = 0, uint *playedLength = NULL) const;
+    int  getID(void) { return m_playlistid; }
+    void setID(int x) { m_playlistid = x; }
+
+    void getStats(uint *trackCount, uint *totalLength, uint currentTrack = 0, uint *playedLength = NULL) const;
+
+    void resync(void);
 
     void computeSize(double &size_in_MB, double &size_in_sec);
     int CreateCDMP3(void);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -1,9 +1,13 @@
+// MythTV
 #include <mythcontext.h>
 #include <mythdb.h>
 #include <compat.h>
+#include <mythlogging.h>
 
+// mythmusic
+#include "playlist.h"
 #include "playlistcontainer.h"
-#include "mythlogging.h"
+
 
 PlaylistLoadingThread::PlaylistLoadingThread(PlaylistContainer *parent_ptr,
                                              AllMusic *all_music_ptr) :
@@ -82,9 +86,9 @@
 
     m_allPlaylists = new QList<Playlist*>;
 
-    m_activePlaylist->loadPlaylist("default_playlist_storage", m_myHost);
+    m_activePlaylist->loadPlaylist(DEFAULT_PLAYLIST_NAME, m_myHost);
 
-    m_streamPlaylist->loadPlaylist("stream_playlist", m_myHost);
+    m_streamPlaylist->loadPlaylist(DEFAULT_STREAMLIST_NAME, m_myHost);
 
     MSqlQuery query(MSqlQuery::InitCon());
     query.prepare("SELECT playlist_id FROM music_playlists "
@@ -93,9 +97,9 @@
                   " AND playlist_name != :STREAM "
                   " AND (hostname = '' OR hostname = :HOST) "
                   "ORDER BY playlist_name;");
-    query.bindValue(":DEFAULT", "default_playlist_storage");
+    query.bindValue(":DEFAULT", DEFAULT_PLAYLIST_NAME);
     query.bindValue(":BACKUP", "backup_playlist_storage");
-    query.bindValue(":STREAM", "stream_playlist");
+    query.bindValue(":STREAM", DEFAULT_STREAMLIST_NAME);
     query.bindValue(":HOST", m_myHost);
 
     if (!query.exec())
@@ -118,6 +122,18 @@
     m_doneLoading = true;
 }
 
+// resync all the playlists after a rescan just in case some tracks were removed
+void PlaylistContainer::resync(void)
+{
+    QList<Playlist*>::const_iterator it = m_allPlaylists->begin();
+    for (; it != m_allPlaylists->end(); ++it)
+    {
+        (*it)->resync();
+    }
+
+    m_activePlaylist->resync();
+}
+
 void PlaylistContainer::describeYourself(void) const
 {
     //    Debugging
@@ -174,8 +190,8 @@
             (*it)->savePlaylist((*it)->getName(), m_myHost);
     }
 
-    m_activePlaylist->savePlaylist("default_playlist_storage", m_myHost);
-    m_streamPlaylist->savePlaylist("stream_playlist", m_myHost);
+    m_activePlaylist->savePlaylist(DEFAULT_PLAYLIST_NAME, m_myHost);
+    m_streamPlaylist->savePlaylist(DEFAULT_STREAMLIST_NAME, m_myHost);
 }
 
 void PlaylistContainer::createNewPlaylist(QString name)
@@ -274,7 +290,7 @@
 
 bool PlaylistContainer::nameIsUnique(QString a_name, int which_id)
 {
-    if (a_name == "default_playlist_storage")
+    if (a_name == DEFAULT_PLAYLIST_NAME)
         return false;
 
     QList<Playlist*>::iterator it = m_allPlaylists->begin();
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlistcontainer.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlistcontainer.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlistcontainer.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlistcontainer.h	2014-05-05 12:30:23.000000000 +0200
@@ -1,11 +1,19 @@
 #ifndef _PLAYLIST_CONTAINER_H_
 #define _PLAYLIST_CONTAINER_H_
 
+// qt
 #include <QCoreApplication>
 
+// MythTV
 #include "mthread.h"
 
-#include "playlist.h"
+
+#define DEFAULT_PLAYLIST_NAME     "default_playlist_storage"
+#define DEFAULT_STREAMLIST_NAME   "stream_playlist"
+
+class PlaylistContainer;
+class Playlist;
+class AllMusic;
 
 class PlaylistLoadingThread : public MThread
 {
@@ -28,6 +36,7 @@
    ~PlaylistContainer();
 
     void            load();
+    void            resync(void);
     void            describeYourself(void) const;    // debugging
 
     Playlist*       getActive(void) { return m_activePlaylist; }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlisteditorview.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlisteditorview.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlisteditorview.cpp	2014-05-05 12:28:39.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlisteditorview.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -90,17 +90,21 @@
 #define LOC_WARN QString("PlaylistEditorView, Warning: ")
 #define LOC_ERR  QString("PlaylistEditorView, Error: ")
 
-PlaylistEditorView::PlaylistEditorView(MythScreenStack *parent, const QString &layout, bool restorePosition)
-         :MusicCommon(parent, "playlisteditorview"),
+PlaylistEditorView::PlaylistEditorView(MythScreenStack *parent, MythScreenType *parentScreen,
+                                       const QString &layout, bool restorePosition)
+         :MusicCommon(parent, parentScreen, "playlisteditorview"),
             m_layout(layout), m_restorePosition(restorePosition),
             m_rootNode(NULL), m_playlistTree(NULL), m_breadcrumbsText(NULL),
             m_positionText(NULL)
 {
+    gCoreContext->addListener(this);
     gCoreContext->SaveSetting("MusicPlaylistEditorView", layout);
 }
 
 PlaylistEditorView::~PlaylistEditorView()
 {
+    gCoreContext->removeListener(this);
+
     saveTreePosition();
 
     for (int x = 0; x < m_deleteList.count(); x++)
@@ -168,8 +172,10 @@
             this, SLOT(treeItemClicked(MythUIButtonListItem*)));
     connect(m_playlistTree, SIGNAL(nodeChanged(MythGenericTree*)),
             this, SLOT(treeNodeChanged(MythGenericTree*)));
-    connect(m_playlistTree, SIGNAL(itemVisible(MythUIButtonListItem*)),
-            this, SLOT(treeItemVisible(MythUIButtonListItem*)));
+
+    if (m_currentView == MV_PLAYLISTEDITORGALLERY)
+        connect(m_playlistTree, SIGNAL(itemVisible(MythUIButtonListItem*)),
+                this, SLOT(treeItemVisible(MythUIButtonListItem*)));
 
     BuildFocusList();
 
@@ -210,6 +216,28 @@
         //TODO should just update the cd node
         reloadTree();
     }
+    else if (event->type() == MythEvent::MythEventMessage)
+    {
+        MythEvent *me = dynamic_cast<MythEvent*>(event);
+
+        if (!me)
+            return;
+
+        if (me->Message().startsWith("MUSIC_RESYNC_FINISHED"))
+        {
+            QStringList list = me->Message().simplified().split(' ');
+            if (list.size() == 4)
+            {
+                int added = list[1].toInt();
+                int removed = list[2].toInt();
+                int changed = list[3].toInt();
+
+                // if something changed reload the tree
+                if (added || removed || changed)
+                    reloadTree();
+            }
+        }
+    }
     else if (event->type() == DialogCompletionEvent::kEventType)
     {
         DialogCompletionEvent *dce = static_cast<DialogCompletionEvent*>(event);
@@ -658,12 +686,6 @@
         MythMenu *menu = NULL;
         MusicGenericTree *mnode = dynamic_cast<MusicGenericTree*>(m_playlistTree->GetCurrentNode());
 
-        if (!mnode)
-        {
-            MusicCommon::ShowMenu();
-            return;
-        }
-
         if (mnode->getAction() == "smartplaylists" ||
             mnode->getAction() == "smartplaylistcategory" ||
             mnode->getAction() == "smartplaylist")
@@ -868,8 +890,10 @@
     if (!mnode)
         return;
 
-    if (item->GetImageFilename().isEmpty())
+    if (item->GetText("*").isEmpty())
     {
+        item->SetText(" ", "*");
+
         QString artFile;
 
         if (mnode->getAction() == "trackid")
@@ -897,6 +921,15 @@
         {
             artFile = findIcon("artist", mnode->GetText().toLower());
         }
+        else if (mnode->getAction() == "all tracks" || mnode->getAction() == "genres" ||
+                 mnode->getAction() == "albums"     || mnode->getAction() == "artists" ||
+                 mnode->getAction() == "compartists"|| mnode->getAction() == "ratings" ||
+                 mnode->getAction() == "years"      || mnode->getAction() == "compilations" ||
+                 mnode->getAction() == "cd"         || mnode->getAction() == "directory" ||
+                 mnode->getAction() == "playlists"  || mnode->getAction() == "smartplaylists")
+        {
+            artFile = "blank.png";
+        }
         else
         {
             artFile = findIcon(mnode->getAction(), mnode->GetText().toLower());
@@ -905,65 +938,29 @@
         QString state = "default";
 
         if (mnode->getAction() == "all tracks")
-        {
             state = "alltracks";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "genres")
-        {
             state = "genres";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "albums")
-        {
             state = "albums";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "artists")
-        {
             state = "artists";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "compartists")
-        {
             state = "compartists";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "ratings")
-        {
             state = "ratings";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "years")
-        {
             state = "years";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "compilations")
-        {
             state = "compilations";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "cd")
-        {
             state = "cd";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "directory")
-        {
             state = "directory";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "playlists")
-        {
             state = "playlists";
-            artFile="blank.png";
-        }
         else if (mnode->getAction() == "smartplaylists")
-        {
             state = "smartplaylists";
-            artFile="blank.png";
-        }
 
         item->DisplayState(state, "nodetype");
 
@@ -1055,7 +1052,6 @@
                     if (mdata->Track() < 10)
                         key.prepend("0");
                 }
-
                 map.insertMulti(key, mdata->ID());
             }
         }
@@ -1647,16 +1643,19 @@
 {
     Playlist *playlist = gMusicData->all_playlists->getPlaylist(playlistID);
 
-    for (int x = 0; x < playlist->getTrackCount(); x++)
+    if (playlist)
     {
-        MusicMetadata *mdata = playlist->getSongAt(x);
-        if (mdata)
+        for (int x = 0; x < playlist->getTrackCount(); x++)
         {
-            MusicGenericTree *newnode = new MusicGenericTree(node, mdata->Title(), "trackid");
-            newnode->setInt(mdata->ID());
-            newnode->setDrawArrow(false);
-            bool hasTrack = gPlayer->getCurrentPlaylist() ? gPlayer->getCurrentPlaylist()->checkTrack(mdata->ID()) : false;
-            newnode->setCheck(hasTrack ? MythUIButtonListItem::FullChecked : MythUIButtonListItem::NotChecked);
+            MusicMetadata *mdata = playlist->getSongAt(x);
+            if (mdata)
+            {
+                MusicGenericTree *newnode = new MusicGenericTree(node, mdata->Title(), "trackid");
+                newnode->setInt(mdata->ID());
+                newnode->setDrawArrow(false);
+                bool hasTrack = gPlayer->getCurrentPlaylist() ? gPlayer->getCurrentPlaylist()->checkTrack(mdata->ID()) : false;
+                newnode->setCheck(hasTrack ? MythUIButtonListItem::FullChecked : MythUIButtonListItem::NotChecked);
+            }
         }
     }
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlisteditorview.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlisteditorview.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlisteditorview.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlisteditorview.h	2014-05-05 12:30:23.000000000 +0200
@@ -63,7 +63,8 @@
 {
     Q_OBJECT
   public:
-    PlaylistEditorView(MythScreenStack *parent, const QString &layout, bool restorePosition = false);
+    PlaylistEditorView(MythScreenStack *parent, MythScreenType *parentScreen,
+                       const QString &layout, bool restorePosition = false);
     ~PlaylistEditorView(void);
 
     bool Create(void);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlistview.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlistview.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlistview.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlistview.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -10,8 +10,8 @@
 #include "musiccommon.h"
 #include "playlistview.h"
 
-PlaylistView::PlaylistView(MythScreenStack *parent)
-         :MusicCommon(parent, "playlistview")
+PlaylistView::PlaylistView(MythScreenStack *parent, MythScreenType *parentScreen)
+         :MusicCommon(parent, parentScreen, "playlistview")
 {
     m_currentView = MV_PLAYLIST;
 }
@@ -46,52 +46,17 @@
 
 void PlaylistView::customEvent(QEvent *event)
 {
-    bool handled = false;
-
-#if 0
-    if (event->type() == DialogCompletionEvent::kEventType)
-    {
-        DialogCompletionEvent *dce = (DialogCompletionEvent*)(event);
-
-        QString resultid   = dce->GetId();
-        QString resulttext = dce->GetResultText();
-        //TODO::
-        if (resultid == "menu")
-        {
-        }
-    }
-#endif
-
-    if (!handled)
-        MusicCommon::customEvent(event);
+    MusicCommon::customEvent(event);
 }
 
-
 bool PlaylistView::keyPressEvent(QKeyEvent *event)
 {
     if (!m_moveTrackMode && GetFocusWidget() && GetFocusWidget()->keyPressEvent(event))
         return true;
 
     bool handled = false;
-    QStringList actions;
-    handled = GetMythMainWindow()->TranslateKeyPress("Music", event, actions);
-
-#if 0
-    for (int i = 0; i < actions.size() && !handled; i++)
-    {
-        QString action = actions[i];
-        handled = true;
-
-        if (action == "MENU")
-        {
-            showMenu();
-        }
-        else
-            handled = false;
-    }
-#endif
 
-    if (!handled && MusicCommon::keyPressEvent(event))
+    if (MusicCommon::keyPressEvent(event))
         handled = true;
 
     if (!handled && MythScreenType::keyPressEvent(event))
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlistview.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlistview.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/playlistview.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/playlistview.h	2014-05-05 12:30:23.000000000 +0200
@@ -18,7 +18,7 @@
 {
     Q_OBJECT
   public:
-    PlaylistView(MythScreenStack *parent);
+    PlaylistView(MythScreenStack *parent, MythScreenType *parentScreen);
     ~PlaylistView(void);
 
     bool Create(void);
@@ -26,9 +26,6 @@
 
   protected:
     void customEvent(QEvent *event);
-
-  private:
-//    void showMenu(void);
 };
 
 #endif
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/searchview.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/searchview.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/searchview.cpp	2014-05-04 17:43:54.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/searchview.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -15,8 +15,8 @@
 #include "musiccommon.h"
 #include "searchview.h"
 
-SearchView::SearchView(MythScreenStack *parent)
-         :MusicCommon(parent, "searchview"),
+SearchView::SearchView(MythScreenStack *parent, MythScreenType *parentScreen)
+         :MusicCommon(parent, parentScreen,"searchview"),
             m_playTrack(false), m_fieldList(NULL), m_criteriaEdit(NULL),
             m_matchesText(NULL), m_tracksList(NULL)
 {
@@ -293,7 +293,7 @@
         if (GetFocusWidget() == m_tracksList || GetFocusWidget() == m_currentPlaylist)
             menu->AddItem(tr("Search List..."));
 
-        menu->AddItem(tr("More Options"), NULL, createMainMenu());
+        menu->AddItem(tr("More Options"), NULL, createSubMenu());
 
         MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/searchview.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/searchview.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/searchview.h	2014-05-04 17:43:54.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/searchview.h	2014-05-05 12:30:23.000000000 +0200
@@ -19,7 +19,7 @@
 {
     Q_OBJECT
   public:
-    SearchView(MythScreenStack *parent);
+    SearchView(MythScreenStack *parent, MythScreenType *parentScreen);
     ~SearchView(void);
 
     bool Create(void);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/streamview.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/streamview.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/streamview.cpp	2014-05-05 12:28:39.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/streamview.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -29,8 +29,8 @@
 
 using namespace std;
 
-StreamView::StreamView(MythScreenStack *parent)
-           :MusicCommon(parent, "streamview"),
+StreamView::StreamView(MythScreenStack *parent, MythScreenType *parentScreen)
+           :MusicCommon(parent, parentScreen, "streamview"),
             m_streamList(NULL), m_noStreams(NULL), m_bufferStatus(NULL),
             m_bufferProgress(NULL)
 {
@@ -85,7 +85,7 @@
 {
     MythMenu *menu = NULL;
 
-    menu = new MythMenu(tr("Stream Actions"), this, "streammenu");
+    menu = new MythMenu(tr("Stream Actions"), this, "mainmenu");
     menu->AddItem(tr("Add Stream"));
 
     if (m_streamList->GetItemCurrent())
@@ -94,7 +94,9 @@
         menu->AddItem(tr("Remove Stream"));
     }
 
-    menu->AddItem(tr("More Options"), NULL, createMainMenu());
+    menu->AddItem(MusicCommon::tr("Fullscreen Visualizer"), qVariantFromValue((int)MV_VISUALIZER));
+
+    menu->AddItem(tr("More Options"), NULL, createSubMenu());
 
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
 
@@ -292,7 +294,7 @@
         QString resultid   = dce->GetId();
         QString resulttext = dce->GetResultText();
 
-        if (resultid == "streammenu")
+        if (resultid == "mainmenu")
         {
             if (resulttext == tr("Add Stream"))
             {
@@ -312,6 +314,8 @@
             {
                 editStream();
             }
+            else
+                handled = false;
         }
         else
             handled = false;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/streamview.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/streamview.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/streamview.h	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/streamview.h	2014-05-05 12:30:23.000000000 +0200
@@ -20,7 +20,7 @@
   Q_OBJECT
 
   public:
-    StreamView(MythScreenStack *parent);
+    StreamView(MythScreenStack *parent, MythScreenType *parentScreen);
     ~StreamView(void);
 
     bool Create(void);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/visualize.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/visualize.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/visualize.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/visualize.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -1416,7 +1416,8 @@
     AlbumArtImages *albumArt = gPlayer->getCurrentMetadata()->getAlbumArtImages();
     int newType = m_currImageType;
 
-    if (albumArt->getImageCount() > 0)
+    // If we only have one image there is nothing to cycle
+    if (albumArt->getImageCount() > 1)
     {
         do
         {
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/visualizerview.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/visualizerview.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/visualizerview.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/visualizerview.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -19,8 +19,8 @@
 #include "musiccommon.h"
 #include "visualizerview.h"
 
-VisualizerView::VisualizerView(MythScreenStack *parent)
-         :MusicCommon(parent, "visualizerview")
+VisualizerView::VisualizerView(MythScreenStack *parent, MythScreenType *parentScreen)
+         :MusicCommon(parent, parentScreen, "visualizerview")
 {
     m_currentView = MV_VISUALIZER;
 }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/visualizerview.h mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/visualizerview.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/visualizerview.h	2014-05-04 17:43:54.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/visualizerview.h	2014-05-05 12:30:23.000000000 +0200
@@ -17,7 +17,7 @@
 {
     Q_OBJECT
   public:
-    VisualizerView(MythScreenStack *parent);
+    VisualizerView(MythScreenStack *parent, MythScreenType *parentScreen);
     ~VisualizerView(void);
 
     bool Create(void);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/vorbisencoder.cpp mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/vorbisencoder.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/mythmusic/vorbisencoder.cpp	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/mythmusic/vorbisencoder.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -104,12 +104,7 @@
 
     // Now write the Metadata
     if (m_metadata)
-    {
-        QString filename = m_metadata->Filename();
-        m_metadata->setFilename(m_outfile);
-        MetaIOOggVorbis().write(m_metadata);
-        m_metadata->setFilename(filename);
-    }
+        MetaIOOggVorbis().write(m_outfile, m_metadata);
 }
 
 int VorbisEncoder::addSamples(int16_t * bytes, unsigned int length)
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/theme/default/music-base.xml mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/theme/default/music-base.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/theme/default/music-base.xml	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/theme/default/music-base.xml	2014-05-05 12:30:23.000000000 +0200
@@ -53,6 +53,13 @@
                             <filename>mm_stopicon.png</filename>
                         </imagetype>
                     </state>
+                    <state name="unavailable">
+                        <imagetype name="animation">
+                            <position>0,0</position>
+                            <filename>schedule_disabled.png</filename>
+                        </imagetype>
+                    </state>
+
                 </statetype>
 
                 <statetype name="movestate">
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/theme/default/musicsettings-ui.xml mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/theme/default/musicsettings-ui.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/theme/default/musicsettings-ui.xml	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/theme/default/musicsettings-ui.xml	2014-05-05 12:30:23.000000000 +0200
@@ -11,15 +11,6 @@
             <value>General Settings</value>
         </textarea>
 
-        <textarea name="musiclocation_label" from="basetextarea">
-            <area>20,40,380,50</area>
-            <align>right,vcenter</align>
-            <value>Directory to hold music:</value>
-        </textarea> 
-        <textedit name="musiclocation" from="basetextedit">
-            <position>410,40</position>
-        </textedit>
-
         <textarea name="musiccddevice_label" from="basetextarea">
             <area>20,100,380,50</area>
             <align>right,vcenter</align>
@@ -68,12 +59,17 @@
         <textarea name="allowtagwriting_label" from="basetextarea">
             <area>20,360,380,40</area>
             <align>right,vcenter</align>
-            <value>Allow metadata to be written to tags:</value>
+            <value>Allow writing metadata to tags:</value>
         </textarea>
         <checkbox name="allowtagwriting" from="basecheckbox">
             <position>410,365</position>
         </checkbox>
 
+        <button name="resetdatabase" from="basewidebutton">
+            <position>410,410</position>
+            <value>Reset Database</value>
+        </button>
+
         <textarea name="helptext" from="basetextarea">
             <area>10,445,780,100</area>
             <cutdown>yes</cutdown>
@@ -100,39 +96,57 @@
         </textarea>
 
         <textarea name="resumemode_label" from="basetextarea">
-            <area>20,140,380,40</area>
+            <area>20,60,380,40</area>
             <align>right,vcenter</align>
-            <value>Resume mode:</value>
+            <value>Resume mode (Playlist):</value>
         </textarea>
         <buttonlist name="resumemode" from="baseselector">
-            <position>410,140</position>
+            <position>410,60</position>
+        </buttonlist>
+
+        <textarea name="resumemodeeditor_label" from="basetextarea">
+            <area>20,110,380,40</area>
+            <align>right,vcenter</align>
+            <value>Resume mode (Playlist Editor):</value>
+        </textarea>
+        <buttonlist name="resumemodeeditor" from="baseselector">
+            <position>410,110</position>
+        </buttonlist>
+
+        <textarea name="resumemoderadio_label" from="basetextarea">
+            <area>20,160,380,40</area>
+            <align>right,vcenter</align>
+            <value>Resume mode (Radio):</value>
+        </textarea>
+        <buttonlist name="resumemoderadio" from="baseselector">
+            <position>410,160</position>
         </buttonlist>
 
         <textarea name="exitaction_label" from="basetextarea">
-            <area>20,190,380,40</area>
+            <area>20,210,380,40</area>
             <align>right,vcenter</align>
             <value>Action on exit:</value>
         </textarea>
         <buttonlist name="exitaction" from="baseselector">
-            <position>410,190</position>
+            <position>410,210</position>
         </buttonlist>
 
         <textarea name="autolookupcd_label" from="basetextarea">
-            <area>20,255,380,40</area>
+            <area>20,275,380,40</area>
             <align>right,vcenter</align>
             <value>Automatically lookup CDs:</value>
         </textarea>
         <checkbox name="autolookupcd" from="basecheckbox">
-            <position>410,260</position>
+            <position>410,280</position>
         </checkbox>
 
         <textarea name="autoplaycd_label" from="basetextarea">
-            <area>20,305,380,40</area>
+            <area>20,325,380,40</area>
             <align>right,vcenter</align>
             <value>Automatically Play CDs:</value>
         </textarea>
         <checkbox name="autoplaycd" from="basecheckbox">
-            <position>410,310</position>
+            <position>410,330</position>
         </checkbox>
 
         <textarea name="helptext" from="basetextarea">
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/theme/default-wide/music-base.xml mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/theme/default-wide/music-base.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/theme/default-wide/music-base.xml	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/theme/default-wide/music-base.xml	2014-05-05 12:30:23.000000000 +0200
@@ -210,7 +210,14 @@
                             <position>5,5</position>
                             <filename>mm_stopicon.png</filename>
                         </imagetype>
-                    </state> 
+                    </state>
+                    <state name="unavailable">
+                        <imagetype name="animation">
+                            <position>0,0</position>
+                            <filename>schedule_disabled.png</filename>
+                        </imagetype>
+                    </state>
+
                 </statetype>
 
                 <statetype name="movestate" from="basemovingtracksstate">
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/theme/default-wide/musicsettings-ui.xml mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/theme/default-wide/musicsettings-ui.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/mythmusic/theme/default-wide/musicsettings-ui.xml	2014-05-04 17:43:55.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/mythmusic/theme/default-wide/musicsettings-ui.xml	2014-05-05 12:30:23.000000000 +0200
@@ -11,15 +11,6 @@
             <value>General Settings</value>
         </textarea>
 
-        <textarea name="musiclocation_label" from="basetextarea">
-            <area>140,100,500,50</area>
-            <align>right,vcenter</align>
-            <value>Directory to hold music:</value>
-        </textarea> 
-        <textedit name="musiclocation" from="basetextedit">
-            <area>650,100,550,50</area>
-        </textedit>
-
         <textarea name="musiccddevice_label" from="basetextarea">
             <area>140,160,500,50</area>
             <align>right,vcenter</align>
@@ -74,6 +65,11 @@
             <position>650,425</position>
         </checkbox>
 
+        <button name="resetdatabase" from="basewidebutton">
+            <position>650,470</position>
+            <value>Reset music database</value>
+        </button>
+
         <textarea name="helptext" from="basetextarea">
             <area>100,540,1080,100</area>
             <cutdown>yes</cutdown>
@@ -100,11 +96,29 @@
         </textarea>
 
         <textarea name="resumemode_label" from="basetextarea">
-            <area>240,220,400,40</area>
+            <area>240,120,400,40</area>
             <align>right,vcenter</align>
-            <value>Resume mode:</value>
+            <value>Resume mode (Playlist):</value>
         </textarea>
         <buttonlist name="resumemode" from="basemediumselector">
+            <position>650,120</position>
+        </buttonlist>
+
+        <textarea name="resumemodeeditor_label" from="basetextarea">
+            <area>240,170,400,40</area>
+            <align>right,vcenter</align>
+            <value>Resume mode (Playlist Editor):</value>
+        </textarea>
+        <buttonlist name="resumemodeeditor" from="basemediumselector">
+            <position>650,170</position>
+        </buttonlist>
+
+        <textarea name="resumemoderadio_label" from="basetextarea">
+            <area>240,220,400,40</area>
+            <align>right,vcenter</align>
+            <value>Resume mode (Radio):</value>
+        </textarea>
+        <buttonlist name="resumemoderadio" from="basemediumselector">
             <position>650,220</position>
         </buttonlist>
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/mythsingledownload.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/mythsingledownload.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/mythsingledownload.h	2014-05-04 17:43:16.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/mythsingledownload.h	2014-05-05 12:30:23.000000000 +0200
@@ -25,11 +25,10 @@
    Q_OBJECT
 
   public:
-   MythSingleDownload(void) : m_reply(NULL) { ; }
+   MythSingleDownload(void) : m_reply(NULL), m_errorcode(QNetworkReply::NoError) { ; }
    ~MythSingleDownload(void) { ; }
 
-   bool DownloadURL(const QString &url, QByteArray *buffer,
-		    uint timeout = 30000);
+   bool DownloadURL(const QString &url, QByteArray *buffer, uint timeout = 30000);
    void Cancel(void);
    QString ErrorString(void) const { return m_errorstring; }
    QNetworkReply::NetworkError ErrorCode(void) const { return m_errorcode; }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/remotefile.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/remotefile.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/remotefile.cpp	2014-05-05 12:28:43.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/remotefile.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -32,6 +32,7 @@
 #include "mythdate.h"
 #include "mythmiscutil.h"
 #include "threadedfilewriter.h"
+#include "storagegroup.h"
 
 #define MAX_FILE_CHECK 500  // in ms
 
@@ -424,30 +425,51 @@
 bool RemoteFile::Exists(const QString &url, struct stat *fileinfo)
 {
     if (isLocal(url))
+        return false;
+
+    QUrl qurl(url);
+    QString filename = qurl.path();
+    QString sgroup   = qurl.userName();
+    QString host     = qurl.host();
+
+    if (isLocal(url) || (gCoreContext->IsMasterBackend() &&
+        host == gCoreContext->GetMasterHostName()))
     {
        LOG(VB_FILE, LOG_INFO,
            QString("RemoteFile::Exists(): looking for local file: %1").arg(url));
 
-        QFileInfo info(url);
-        if (info.exists())
+        bool fileExists = false;
+        QString fullFilePath = "";
+
+        if (url.startsWith("myth:"))
         {
-            if (stat(url.toLocal8Bit().constData(), fileinfo) == -1)
+            StorageGroup sGroup(sgroup, host);
+            fullFilePath = sGroup.FindFile(filename);
+            if (!fullFilePath.isEmpty())
+                fileExists = true;
+        }
+        else
+        {
+            QFileInfo info(url);
+            fileExists = info.exists() && info.isFile();
+            fullFilePath = url;
+        }
+
+        if (fileExists)
+        {
+            if (stat(fullFilePath.toLocal8Bit().constData(), fileinfo) == -1)
             {
                 LOG(VB_FILE, LOG_ERR,
-                    QString("RemoteFile::Exists(): failed to stat file: %1").arg(url) + ENO);
+                    QString("RemoteFile::Exists(): failed to stat file: %1").arg(fullFilePath) + ENO);
             }
         }
 
-        return info.exists() && info.isFile();
+        return fileExists;
     }
 
     LOG(VB_FILE, LOG_INFO,
         QString("RemoteFile::Exists(): looking for remote file: %1").arg(url));
 
-    QUrl qurl(url);
-    QString filename = qurl.path();
-    QString sgroup   = qurl.userName();
-
     if (!qurl.fragment().isEmpty() || url.endsWith("#"))
         filename = filename + "#" + qurl.fragment();
 
@@ -530,6 +552,66 @@
     return result;
 }
 
+bool RemoteFile::CopyFile (const QString& src, const QString& dst)
+{
+    // sanity check
+    if (src == dst)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "RemoteFile::CopyFile: Cannot copy a file to itself");
+        return false;
+    }
+
+    const int readSize = 2 * 1024 * 1024;
+    char *buf = new char[readSize];
+    if (!buf)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "RemoteFile::CopyFile: ERROR, unable to allocate copy buffer");
+        return false;
+    }
+
+    RemoteFile srcFile(src, false);
+    if (!srcFile.isOpen())
+    {
+         LOG(VB_GENERAL, LOG_ERR,
+             QString("RemoteFile::CopyFile: Failed to open file (%1) for reading.").arg(src));
+         delete[] buf;
+         return false;
+    }
+
+    RemoteFile dstFile(dst, true);
+    if (!dstFile.isOpen())
+    {
+         LOG(VB_GENERAL, LOG_ERR,
+             QString("RemoteFile::CopyFile: Failed to open file (%1) for writing.").arg(dst));
+         srcFile.Close();
+         delete[] buf;
+         return false;
+    }
+
+    int srcLen, dstLen;
+
+    while ((srcLen = srcFile.Read(buf, readSize)) > 0)
+    {
+        dstLen = dstFile.Write(buf, srcLen);
+
+        if (dstLen == -1 || srcLen != dstLen)
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                "RemoteFile::CopyFile:: Error while trying to write to destination file.");
+            srcFile.Close();
+            dstFile.Close();
+            delete[] buf;
+            return false;
+        }
+    }
+
+    srcFile.Close();
+    dstFile.Close();
+    delete[] buf;
+
+    return true;
+}
+
 void RemoteFile::Reset(void)
 {
     if (isLocal())
@@ -1055,13 +1137,23 @@
     if (hostName.isEmpty())
         hostName = gCoreContext->GetMasterHostName();
 
-    // first check the given host
-    strList << "QUERY_SG_FILEQUERY" << hostName << storageGroup << filename;
-    if (gCoreContext->SendReceiveStringList(strList))
+    if (gCoreContext->IsMasterBackend() &&
+        hostName == gCoreContext->GetMasterHostName())
     {
-        if (strList.size() > 0 && strList[0] != "EMPTY LIST")
+        StorageGroup sGroup(storageGroup, hostName);
+        if (!sGroup.FindFile(filename).isEmpty())
             return gCoreContext->GenMythURL(hostName, 0, filename, storageGroup);
     }
+    else
+    {
+        // first check the given host
+        strList << "QUERY_SG_FILEQUERY" << hostName << storageGroup << filename << 0;
+        if (gCoreContext->SendReceiveStringList(strList))
+        {
+            if (strList.size() > 0 && strList[0] != "EMPTY LIST" && !strList[0].startsWith("SLAVE UNREACHABLE"))
+                return gCoreContext->GenMythURL(hostName, 0, filename, storageGroup);
+        }
+    }
 
     // not found so search all hosts that has a directory defined for the give storage group
 
@@ -1086,12 +1178,22 @@
     {
         hostName = query.value(0).toString();
 
+        if (gCoreContext->IsMasterBackend() &&
+            hostName == gCoreContext->GetMasterHostName())
+        {
+            StorageGroup sGroup(storageGroup, hostName);
+            if (!sGroup.FindFile(filename).isEmpty())
+                return gCoreContext->GenMythURL(hostName, 0, filename, storageGroup);
+            else
+                continue;
+        }
+
         strList.clear();
-        strList << "QUERY_SG_FILEQUERY" << hostName << storageGroup << filename;
+        strList << "QUERY_SG_FILEQUERY" << hostName << storageGroup << filename << 0;
 
         if (gCoreContext->SendReceiveStringList(strList))
         {
-            if (strList.size() > 0 && strList[0] != "EMPTY LIST")
+            if (strList.size() > 0 && strList[0] != "EMPTY LIST" && !strList[0].startsWith("SLAVE UNREACHABLE"))
                 return gCoreContext->GenMythURL(hostName, 0, filename, storageGroup);
         }
     }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/remotefile.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/remotefile.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/remotefile.h	2014-05-05 12:28:43.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/remotefile.h	2014-05-05 12:30:23.000000000 +0200
@@ -34,6 +34,7 @@
     static QString GetFileHash(const QString &url);
     static QDateTime LastModified(const QString &url);
     static QString FindFile(const QString &filename, const QString &host, const QString &storageGroup);
+    static bool CopyFile(const QString &src, const QString &dest);
 
     int Write(const void *data, int size);
     int Read(void *data, int size);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/storagegroup.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/storagegroup.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/storagegroup.cpp	2014-05-04 17:43:17.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/storagegroup.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -30,6 +30,8 @@
     <<  QT_TRANSLATE_NOOP("(StorageGroups)", "Fanart")
     <<  QT_TRANSLATE_NOOP("(StorageGroups)", "Screenshots")
     <<  QT_TRANSLATE_NOOP("(StorageGroups)", "Banners")
+    <<  QT_TRANSLATE_NOOP("(StorageGroups)", "Music")
+    <<  QT_TRANSLATE_NOOP("(StorageGroups)", "MusicArt")
     ;
 
 /****************************************************************************/
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/libmythmetadata.pro mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/libmythmetadata.pro
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/libmythmetadata.pro	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/libmythmetadata.pro	2014-05-05 12:30:23.000000000 +0200
@@ -24,7 +24,7 @@
 HEADERS += mythuiimageresults.h
 HEADERS += musicmetadata.h musicutils.h metaio.h metaiotaglib.h
 HEADERS += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
-HEADERS += metaiowavpack.h metaioid3.h metaiooggvorbis.h
+HEADERS += metaiowavpack.h metaioid3.h metaiooggvorbis.h musicfilescanner.h
 
 SOURCES += cleanup.cpp  dbaccess.cpp  dirscan.cpp  globals.cpp
 SOURCES += parentalcontrols.cpp  videoscan.cpp  videoutils.cpp
@@ -34,7 +34,7 @@
 SOURCES += mythuiimageresults.cpp
 SOURCES += musicmetadata.cpp musicutils.cpp metaio.cpp metaiotaglib.cpp
 SOURCES += metaioflacvorbis.cpp metaioavfcomment.cpp metaiomp4.cpp
-SOURCES += metaiowavpack.cpp metaioid3.cpp metaiooggvorbis.cpp
+SOURCES += metaiowavpack.cpp metaioid3.cpp metaiooggvorbis.cpp musicfilescanner.cpp
 
 INCLUDEPATH += ../libmythbase ../libmythtv
 INCLUDEPATH += ../.. ../ ./ ../libmythupnp ../libmythui
@@ -85,7 +85,7 @@
 inc.files += musicmetadata.h musicutils.h
 inc.files += metaio.h metaiotaglib.h
 inc.files += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
-inc.files += metaiowavpack.h metaioid3.h metaiooggvorbis.h
+inc.files += metaiowavpack.h metaioid3.h metaiooggvorbis.h musicfilescanner.h
 
 INSTALLS += inc
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaio.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaio.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaio.cpp	2014-05-04 17:43:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaio.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -1,3 +1,7 @@
+
+// POSIX C headers
+#include <utime.h>
+
 // Qt
 #include <QFileInfo>
 
@@ -21,7 +25,8 @@
  */
 MetaIO::MetaIO()
 {
-    mFilenameFormat = gCoreContext->GetSetting("NonID3FileNameFormat").toUpper();
+    m_filenameFormat = gCoreContext->GetSetting("NonID3FileNameFormat").toUpper();
+    memset(&m_fileinfo, 0, sizeof(m_fileinfo));
 }
 
 /*!
@@ -49,13 +54,13 @@
         return new MetaIOOggVorbis;
     else if (extension == "flac")
     {
-        MetaIOID3 *tagger = new MetaIOID3;
+        MetaIOFLACVorbis *tagger = new MetaIOFLACVorbis;
         if (tagger->TagExists(filename))
             return tagger;
         else
         {
             delete tagger;
-            return new MetaIOFLACVorbis;
+            return new MetaIOID3;
         }
     }
     else if (extension == "m4a")
@@ -97,7 +102,8 @@
 // static
 MusicMetadata* MetaIO::getMetadata(const QString &filename)
 {
-
+    //FIXME: we need a relative path for createFromFilename()
+    //       but readMetadata() needs an absolute path
     MusicMetadata *mdata = MusicMetadata::createFromFilename(filename);
     if (mdata)
         return mdata;
@@ -121,7 +127,7 @@
     // Replace 
     lfilename.replace('_', ' ');
     lfilename = lfilename.section('.', 0, -2);
-    QStringList fmt_list = mFilenameFormat.split("/");
+    QStringList fmt_list = m_filenameFormat.split("/");
     QStringList::iterator fmt_it = fmt_list.begin();
 
     // go through loop once to get minimum part number
@@ -197,25 +203,48 @@
     QString artist, album, title, genre;
     int tracknum = 0;
 
-    const QString filename = metadata->Filename();
+    const QString filename = metadata->Filename(false);
 
     if (filename.isEmpty())
         return;
-    
+
     readFromFilename(filename, artist, album, title, genre, tracknum);
 
     if (metadata->Artist().isEmpty())
         metadata->setArtist(artist);
-    
+
     if (metadata->Album().isEmpty())
         metadata->setAlbum(album);
-    
+
     if (metadata->Title().isEmpty())
         metadata->setTitle(title);
-    
+
     if (metadata->Genre().isEmpty())
         metadata->setGenre(genre);
-    
+
     if (metadata->Track() <= 0)
         metadata->setTrack(tracknum);
 }
+
+void MetaIO::saveTimeStamps(void)
+{
+    if (stat(m_filename.toLocal8Bit().constData(), &m_fileinfo) == -1)
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("MetaIO::saveTimeStamps: failed to stat file: %1").arg(m_filename) + ENO);
+    }
+}
+
+void MetaIO::restoreTimeStamps(void)
+{
+    struct utimbuf new_times;
+
+    new_times.actime = m_fileinfo.st_atime;
+    new_times.modtime = m_fileinfo.st_mtime;
+
+    if (utime(m_filename.toLocal8Bit().constData(), &new_times) < 0)
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("MetaIO::restoreTimeStamps: failed to utime file: %1").arg(m_filename) + ENO);
+    }
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaio.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaio.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaio.h	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaio.h	2014-05-05 12:30:23.000000000 +0200
@@ -1,6 +1,11 @@
 #ifndef METAIO_H_
 #define METAIO_H_
 
+// POSIX C headers
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
 // QT
 #include <QString>
 
@@ -18,20 +23,20 @@
     /*!
     * \brief Writes all metadata back to a file
     *
+    * \param filename The filename to write metadata to
     * \param mdata A pointer to a MusicMetadata object
     * \returns Boolean to indicate success/failure.
     */
-    virtual bool write(const MusicMetadata* mdata) = 0;
+    virtual bool write(const QString &filename, MusicMetadata* mdata) = 0;
 
     /*!
     * \brief Writes rating and playcount back to a file
-    *
+    * \param filename The filename to write metadata to
     * \param mdata A pointer to a MusicMetadata object
     * \returns Boolean to indicate success/failure.
     */
-    virtual bool writeVolatileMetadata(const MusicMetadata* mdata)
+    virtual bool writeVolatileMetadata(const QString & /*filename*/, MusicMetadata* /*mdata*/)
     {
-        (void)mdata;
         return false;
     }
 
@@ -159,12 +164,15 @@
     static const QString ValidFileExtensions;
 
   protected:
+    void saveTimeStamps(void);
+    void restoreTimeStamps(void);
 
-  private:
     virtual int getTrackLength(const QString &filename) = 0;
 
-    QString mFilename;
-    QString mFilenameFormat;
+    QString m_filename;
+    QString m_filenameFormat;
+
+    struct stat m_fileinfo;
 };
 
 #endif
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioavfcomment.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioavfcomment.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioavfcomment.cpp	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioavfcomment.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -26,7 +26,7 @@
 /*!
  * \copydoc MetaIO::write()
  */
-bool MetaIOAVFComment::write(const MusicMetadata* /*mdata*/)
+bool MetaIOAVFComment::write(const QString & /*filename*/, MusicMetadata* /*mdata*/)
 {
     // Wont implement....
     return false;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioavfcomment.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioavfcomment.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioavfcomment.h	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioavfcomment.h	2014-05-05 12:30:23.000000000 +0200
@@ -22,7 +22,7 @@
     MetaIOAVFComment(void);
     virtual ~MetaIOAVFComment(void);
 
-    bool write(const MusicMetadata* mdata);
+    bool write(const QString &filename, MusicMetadata* mdata);
     MusicMetadata* read(const QString &filename);
 
 private:
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioflacvorbis.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioflacvorbis.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioflacvorbis.cpp	2014-05-04 17:43:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioflacvorbis.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -2,6 +2,9 @@
 // Libmyth
 #include <mythcontext.h>
 
+// qt
+#include <QBuffer>
+
 // Taglib
 #include <xiphcomment.h>
 
@@ -44,12 +47,17 @@
 /*!
  * \copydoc MetaIO::write()
  */
-bool MetaIOFLACVorbis::write(const MusicMetadata* mdata)
+bool MetaIOFLACVorbis::write(const QString &filename, MusicMetadata* mdata)
 {
     if (!mdata)
         return false;
 
-    TagLib::FLAC::File *flacfile = OpenFile(mdata->Filename());
+    if (filename.isEmpty())
+        return false;
+
+    m_filename = filename;
+
+    TagLib::FLAC::File *flacfile = OpenFile(m_filename);
 
     if (!flacfile)
         return false;
@@ -84,7 +92,9 @@
         tag->removeField("COMPILATION_ARTIST");
     }
 
+    saveTimeStamps();
     bool result = flacfile->save();
+    restoreTimeStamps();
 
     if (flacfile)
         delete flacfile;
@@ -145,6 +155,354 @@
     return metadata;
 }
 
+/*!
+ * \brief Read the albumart image from the file
+ *
+ * \param filename The filename for which we want to find the albumart.
+ * \param type The type of image we want - front/back etc
+ * \returns A pointer to a QImage owned by the caller or NULL if not found.
+ */
+QImage* MetaIOFLACVorbis::getAlbumArt(const QString &filename, ImageType type)
+{
+    QImage *picture = new QImage();
+    TagLib::FLAC::File * flacfile = OpenFile(filename);
+
+    if (flacfile)
+    {
+        TagLib::FLAC::Picture* pic = getPictureFromFile(flacfile, type);
+        if (pic)
+        {
+            picture->loadFromData((const uchar *)pic->data().data(),
+                                  pic->data().size());
+        }
+        else
+        {
+            delete picture;
+            return NULL;
+        }
+
+        delete flacfile;
+    }
+
+    return picture;
+}
+
+TagLib::FLAC::Picture *MetaIOFLACVorbis::getPictureFromFile(
+                                        TagLib::FLAC::File *flacfile,
+                                        ImageType type)
+{
+    using TagLib::FLAC::Picture;
+
+    Picture *pic = NULL;
+
+    if (flacfile)
+    {
+        Picture::Type artType = PictureTypeFromImageType(type);
+
+        // From what I can tell, FLAC::File maintains ownership of the Picture pointers, so no need to delete
+        const TagLib::List<Picture *>& picList = flacfile->pictureList();
+
+        for (TagLib::List<Picture *>::ConstIterator it = picList.begin();
+                it != picList.end(); it++)
+        {
+            pic = *it;
+            if (pic->type() == artType)
+            {
+                //found the type we were looking for
+                break;
+            }
+        }
+    }
+
+    return pic;
+}
+
+TagLib::FLAC::Picture::Type MetaIOFLACVorbis::PictureTypeFromImageType(
+                                                ImageType itype) {
+    using TagLib::FLAC::Picture;
+    Picture::Type artType = Picture::Other;
+    switch (itype)
+    {
+        case IT_UNKNOWN :
+            artType = Picture::Other;
+            break;
+        case IT_FRONTCOVER :
+            artType = Picture::FrontCover;
+            break;
+        case IT_BACKCOVER :
+            artType = Picture::BackCover;
+            break;
+        case IT_CD :
+            artType = Picture::Media;
+            break;
+        case IT_INLAY :
+            artType = Picture::LeafletPage;
+            break;
+        case IT_ARTIST :
+            artType = Picture::Artist;
+            break;
+        default:
+            return Picture::Other;
+    }
+
+    return artType;
+}
+
+/*!
+ * \brief Read the albumart images from the file
+ *
+ * \param filename The filename for which we want to find the images.
+ */
+AlbumArtList MetaIOFLACVorbis::getAlbumArtList(const QString &filename)
+{
+    using TagLib::FLAC::Picture;
+    AlbumArtList artlist;
+    TagLib::FLAC::File * flacfile = OpenFile(filename);
+
+    if (flacfile)
+    {
+        const TagLib::List<Picture *>& picList = flacfile->pictureList();
+
+        for(TagLib::List<Picture *>::ConstIterator it = picList.begin();
+            it != picList.end(); it++)
+        {
+            Picture* pic = *it;
+            // Assume a valid image would have at least
+            // 100 bytes of data (1x1 indexed gif is 35 bytes)
+            if (pic->data().size() < 100)
+            {
+                LOG(VB_GENERAL, LOG_NOTICE,
+                    "Music Scanner - Discarding picture "
+                    "with size less than 100 bytes");
+                continue;
+            }
+
+            AlbumArtImage *art = new AlbumArtImage();
+
+            if (pic->description().isEmpty())
+                art->description.clear();
+            else
+                art->description = TStringToQString(pic->description());
+
+            art->embedded = true;
+            art->hostname = gCoreContext->GetHostName();
+
+            QString ext = getExtFromMimeType(
+                                TStringToQString(pic->mimeType()).toLower());
+
+            switch (pic->type())
+            {
+                case Picture::FrontCover :
+                    art->imageType = IT_FRONTCOVER;
+                    art->filename = QString("front") + ext;
+                    break;
+                case Picture::BackCover :
+                    art->imageType = IT_BACKCOVER;
+                    art->filename = QString("back") + ext;
+                    break;
+                case Picture::Media :
+                    art->imageType = IT_CD;
+                    art->filename = QString("cd") + ext;
+                    break;
+                case Picture::LeafletPage :
+                    art->imageType = IT_INLAY;
+                    art->filename = QString("inlay") + ext;
+                    break;
+                case Picture::Artist :
+                    art->imageType = IT_ARTIST;
+                    art->filename = QString("artist") + ext;
+                    break;
+                case Picture::Other :
+                    art->imageType = IT_UNKNOWN;
+                    art->filename = QString("unknown") + ext;
+                    break;
+                default:
+                    LOG(VB_GENERAL, LOG_ERR, "Music Scanner - picture found "
+                                             "with unsupported type");
+                    delete art;
+                    continue;
+            }
+
+            artlist.append(art);
+        }
+    }
+
+    delete flacfile;
+    return artlist;
+}
+
+/*!
+ * \brief Write the albumart image to the file
+ *
+ * \param filename The music file to add the albumart
+ * \param albumart The Album Art image to write
+ * \returns True if successful
+ *
+ * \Note We always save the image in JPEG format
+ */
+bool MetaIOFLACVorbis::writeAlbumArt(const QString &filename,
+                              const AlbumArtImage *albumart)
+{
+#if TAGLIB_MAJOR_VERSION == 1 && TAGLIB_MINOR_VERSION >= 8
+    using TagLib::FLAC::Picture;
+    if (filename.isEmpty() || !albumart)
+        return false;
+
+    m_filename = filename;
+
+    bool retval = false;
+
+    // load the image into a QByteArray
+    QImage image(albumart->filename);
+    QByteArray imageData;
+    QBuffer buffer(&imageData);
+    buffer.open(QIODevice::WriteOnly);
+    // Write the image data to a file
+    image.save(&buffer, "JPEG");
+
+    TagLib::FLAC::File * flacfile = OpenFile(filename);
+
+    // This presumes that there is only one art item of each type
+    if (flacfile)
+    {
+        // Now see if the art is in the FLAC file
+        Picture *pic = getPictureFromFile(flacfile, albumart->imageType);
+
+        if (pic)
+        {
+            // Remove the embedded image of the matching type
+            flacfile->removePicture(pic, false);
+        }
+        else
+        {
+            // Create a new image of the correct type
+            pic = new Picture();
+            pic->setType(PictureTypeFromImageType(albumart->imageType));
+        }
+
+        TagLib::ByteVector bytevector;
+        bytevector.setData(imageData.data(), imageData.size());
+
+        pic->setData(bytevector);
+        QString mimetype = "image/jpeg";
+
+        pic->setMimeType(QStringToTString(mimetype));
+        pic->setDescription(QStringToTString(albumart->description));
+
+        flacfile->addPicture(pic);
+
+        saveTimeStamps();
+        retval = flacfile->save();
+        restoreTimeStamps();
+
+        delete flacfile;
+    }
+    else
+    {
+        retval = false;
+    }
+
+    return retval;
+#else
+    LOG(VB_GENERAL, LOG_WARNING,
+        "TagLib 1.8.0 or later is required to write albumart to flac xiphComment tags");
+    return false;
+#endif
+}
+
+/*!
+ * \brief Remove the albumart image from the file
+ *
+ * \param filename The music file to remove the albumart
+ * \param albumart The Album Art image to remove
+ * \returns True if successful
+ */
+bool MetaIOFLACVorbis::removeAlbumArt(const QString &filename,
+                               const AlbumArtImage *albumart)
+{
+#if TAGLIB_MAJOR_VERSION == 1 && TAGLIB_MINOR_VERSION >= 8
+
+    if (filename.isEmpty() || !albumart)
+        return false;
+
+    bool retval = false;
+
+    TagLib::FLAC::File * flacfile = OpenFile(filename);
+
+    // This presumes that there is only one art item of each type
+    if (flacfile)
+    {
+        // Now see if the art is in the FLAC file
+        TagLib::FLAC::Picture *pic = getPictureFromFile(flacfile, albumart->imageType);
+
+        if (pic)
+        {
+            // Remove the embedded image of the matching type
+            flacfile->removePicture(pic, false);
+            flacfile->save();
+            retval = true;
+        }
+        else
+        {
+            retval = false;
+        }
+
+        delete flacfile;
+    }
+    else
+    {
+        retval = false;
+    }
+
+    return retval;
+#else
+    LOG(VB_GENERAL, LOG_WARNING,
+        "TagLib 1.8.0 or later is required to remove albumart from flac xiphComment tags");
+    return false;
+#endif
+}
+
+bool MetaIOFLACVorbis::changeImageType(const QString &filename,
+                                const AlbumArtImage* albumart,
+                                ImageType newType)
+{
+    if (filename.isEmpty() || !albumart)
+        return false;
+
+    if (albumart->imageType == newType)
+        return true;
+
+    bool retval = false;
+
+    TagLib::FLAC::File * flacfile = OpenFile(filename);
+
+    // This presumes that there is only one art item of each type
+    if (flacfile)
+    {
+        // Now see if the art is in the FLAC file
+        TagLib::FLAC::Picture *pic = getPictureFromFile(flacfile, albumart->imageType);
+
+        if (pic)
+        {
+            pic->setType(PictureTypeFromImageType(newType));
+            flacfile->save();
+            retval = true;
+        }
+        else
+        {
+            retval = false;
+        }
+
+        delete flacfile;
+    }
+    else
+    {
+        retval = false;
+    }
+
+    return retval;
+}
+
 bool MetaIOFLACVorbis::TagExists(const QString &filename)
 {
     TagLib::FLAC::File *flacfile = OpenFile(filename);
@@ -162,3 +520,20 @@
 
     return retval;
 }
+
+QString MetaIOFLACVorbis::getExtFromMimeType(const QString &mimeType)
+{
+    if (mimeType == "image/png")
+        return QString(".png");
+    else if (mimeType == "image/jpeg" || mimeType == "image/jpg")
+        return QString(".jpg");
+    else if (mimeType == "image/gif")
+        return QString(".gif");
+    else if (mimeType == "image/bmp")
+        return QString(".bmp");
+
+    LOG(VB_GENERAL, LOG_ERR,
+        "Music Scanner - Unknown image mimetype found - " + mimeType);
+
+    return QString();
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioflacvorbis.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioflacvorbis.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioflacvorbis.h	2014-05-04 17:43:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioflacvorbis.h	2014-05-05 12:30:23.000000000 +0200
@@ -24,13 +24,27 @@
     MetaIOFLACVorbis(void);
     virtual ~MetaIOFLACVorbis(void);
 
-    bool write(const MusicMetadata* mdata);
+    bool write(const QString &filename, MusicMetadata* mdata);
+    bool writeAlbumArt(const QString &filename, const AlbumArtImage *albumart);
+    bool removeAlbumArt(const QString &filename, const AlbumArtImage *albumart);
+
     MusicMetadata* read(const QString &filename);
+    AlbumArtList getAlbumArtList(const QString &filename);
+    QImage *getAlbumArt(const QString &filename, ImageType type);
+
+    bool supportsEmbeddedImages(void) { return true; }
+
+    bool changeImageType(const QString &filename, const AlbumArtImage *albumart,
+                         ImageType newType);
 
     virtual bool TagExists(const QString &filename);
 
 private:
     TagLib::FLAC::File *OpenFile(const QString &filename);
+    TagLib::FLAC::Picture *getPictureFromFile(TagLib::FLAC::File *flacfile,
+                                              ImageType type);
+    TagLib::FLAC::Picture::Type PictureTypeFromImageType(ImageType itype);
+    QString getExtFromMimeType(const QString &mimeType);
 };
 
 #endif
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioid3.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioid3.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioid3.cpp	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioid3.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -5,6 +5,7 @@
 
 // Libmythbase
 #include <mythlogging.h>
+#include <mythcorecontext.h>
 
 // Taglib
 #include <flacfile.h>
@@ -60,7 +61,7 @@
 
     if (extension.toLower() == "flac")
         m_fileType = kFLAC;
-    else if (extension.toLower() == "mp3")
+    else if (extension.toLower() == "mp3" || extension.toLower() == "mp2")
         m_fileType = kMPEG;
     else
         return false;
@@ -99,7 +100,9 @@
     if (!m_file)
         return false;
 
+    saveTimeStamps();
     bool retval = m_file->save();
+    restoreTimeStamps();
 
     return retval;
 }
@@ -154,9 +157,12 @@
 /*!
  * \copydoc MetaIO::write()
  */
-bool MetaIOID3::write(const MusicMetadata* mdata)
+bool MetaIOID3::write(const QString &filename, MusicMetadata* mdata)
 {
-    if (!OpenFile(mdata->Filename(), true))
+    if (filename.isEmpty())
+        return false;
+
+    if (!OpenFile(filename, true))
         return false;
 
     TagLib::ID3v2::Tag *tag = GetID3v2Tag();
@@ -483,6 +489,7 @@
                 art->description = TStringToQString(frame->description());
 
             art->embedded = true;
+            art->hostname = gCoreContext->GetHostName();
 
             QString ext = getExtFromMimeType(
                                 TStringToQString(frame->mimeType()).toLower());
@@ -840,9 +847,11 @@
     return true;
 }
 
-bool MetaIOID3::writeVolatileMetadata(const MusicMetadata* mdata)
+bool MetaIOID3::writeVolatileMetadata(const QString &filename, MusicMetadata* mdata)
 {
-    QString filename = mdata->Filename();
+    if (filename.isEmpty())
+        return false;
+
     int rating = mdata->Rating();
     int playcount = mdata->PlayCount();
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioid3.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioid3.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaioid3.h	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaioid3.h	2014-05-05 12:30:23.000000000 +0200
@@ -36,8 +36,8 @@
     MetaIOID3(void);
     virtual ~MetaIOID3(void);
 
-    virtual bool write(const MusicMetadata* mdata);
-    bool writeVolatileMetadata(const MusicMetadata* mdata);
+    virtual bool write(const QString &filename, MusicMetadata* mdata);
+    bool writeVolatileMetadata(const QString &filename, MusicMetadata* mdata);
 
     bool writeAlbumArt(const QString &filename, const AlbumArtImage *albumart);
     bool removeAlbumArt(const QString &filename, const AlbumArtImage *albumart);
@@ -74,7 +74,6 @@
     QString getExtFromMimeType(const QString &mimeType);
 
     TagLib::File *m_file;
-    QString m_filename;
 
     typedef enum { kMPEG, kFLAC } TagType;
     TagType m_fileType;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiomp4.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiomp4.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiomp4.cpp	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiomp4.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -27,11 +27,14 @@
 /*!
  * \copydoc MetaIO::write()
  */
-bool MetaIOMP4::write(const MusicMetadata* mdata)
+bool MetaIOMP4::write(const QString &filename, MusicMetadata* mdata)
 {
     if (!mdata)
         return false;
 
+    if (filename.isEmpty())
+        return false;
+
 // Disabled because it doesn't actually work. Better implemented with Taglib
 // when we formally move to 1.6
 
@@ -39,8 +42,6 @@
 //     AVFormatParameters* p_params = NULL;
 //     AVInputFormat* p_inputformat = NULL;
 //
-//     QString filename = mdata->Filename();
-//
 //     QByteArray local8bit = filename.toLocal8Bit();
 //     if ((av_open_input_file(&p_context, local8bit.constData(),
 //                             p_inputformat, 0, p_params) < 0))
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiomp4.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiomp4.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiomp4.h	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiomp4.h	2014-05-05 12:30:23.000000000 +0200
@@ -19,7 +19,7 @@
     MetaIOMP4(void);
     virtual ~MetaIOMP4(void);
 
-    bool write(const MusicMetadata* mdata);
+    bool write(const QString &filename, MusicMetadata* mdata);
     MusicMetadata* read(const QString &filename);
 
   private:
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiooggvorbis.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiooggvorbis.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiooggvorbis.cpp	2014-05-04 17:43:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiooggvorbis.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -41,12 +41,17 @@
 /*!
  * \copydoc MetaIO::write()
  */
-bool MetaIOOggVorbis::write(const MusicMetadata* mdata)
+bool MetaIOOggVorbis::write(const QString &filename, MusicMetadata* mdata)
 {
     if (!mdata)
         return false;
 
-    TagLib::Ogg::Vorbis::File *oggfile = OpenFile(mdata->Filename());
+    m_filename = filename;
+
+    if (m_filename.isEmpty())
+        return false;
+
+    TagLib::Ogg::Vorbis::File *oggfile = OpenFile(m_filename);
 
     if (!oggfile)
         return false;
@@ -81,7 +86,9 @@
         tag->removeField("COMPILATION_ARTIST");
     }
 
+    saveTimeStamps();
     bool result = oggfile->save();
+    restoreTimeStamps();
 
     if (oggfile)
         delete oggfile;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiooggvorbis.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiooggvorbis.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiooggvorbis.h	2014-05-04 17:43:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiooggvorbis.h	2014-05-05 12:30:23.000000000 +0200
@@ -24,7 +24,7 @@
     MetaIOOggVorbis(void);
     ~MetaIOOggVorbis(void);
 
-    bool write(const MusicMetadata* mdata);
+    bool write(const QString &filename, MusicMetadata* mdata);
     MusicMetadata* read(const QString &filename);
 
   private:
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiotaglib.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiotaglib.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiotaglib.cpp	2014-05-04 17:43:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiotaglib.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -85,7 +85,7 @@
     {
         LOG(VB_GENERAL, LOG_ERR,
             QString("MetaIOTagLib: Failed to read metadata from '%1'")
-                .arg(metadata->Filename()));
+                .arg(metadata->Filename(false)));
     }
 }
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiotaglib.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiotaglib.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiotaglib.h	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiotaglib.h	2014-05-05 12:30:23.000000000 +0200
@@ -23,7 +23,7 @@
     MetaIOTagLib(void);
     virtual ~MetaIOTagLib(void);
 
-    virtual bool write(const MusicMetadata* mdata) = 0;
+    virtual bool write(const QString &filename, MusicMetadata* mdata) = 0;
     virtual MusicMetadata* read(const QString &filename) = 0;
 
   protected:
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiowavpack.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiowavpack.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiowavpack.cpp	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiowavpack.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -43,12 +43,17 @@
 /*!
 * \copydoc MetaIO::write()
 */
-bool MetaIOWavPack::write(const MusicMetadata* mdata)
+bool MetaIOWavPack::write(const QString &filename, MusicMetadata* mdata)
 {
     if (!mdata)
         return false;
 
-    TagLib::WavPack::File *wpfile = OpenFile(mdata->Filename());
+    if (filename.isEmpty())
+        return false;
+
+    m_filename = filename;
+
+    TagLib::WavPack::File *wpfile = OpenFile(m_filename);
 
     if (!wpfile)
         return false;
@@ -74,7 +79,9 @@
     else
         tag->removeItem("Album artist");
 
+    saveTimeStamps();
     bool result = wpfile->save();
+    restoreTimeStamps();
 
     if (wpfile)
         delete wpfile;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiowavpack.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiowavpack.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/metaiowavpack.h	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/metaiowavpack.h	2014-05-05 12:30:23.000000000 +0200
@@ -26,7 +26,7 @@
     MetaIOWavPack(void);
     virtual ~MetaIOWavPack(void);
 
-    bool write(const MusicMetadata* mdata);
+    bool write(const QString &filename, MusicMetadata* mdata);
     MusicMetadata* read(const QString &filename);
 
 private:
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicfilescanner.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicfilescanner.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicfilescanner.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicfilescanner.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -0,0 +1,909 @@
+// POSIX headers
+#include <sys/stat.h>
+#include <unistd.h>
+
+// Qt headers
+#include <QDir>
+
+// MythTV headers
+#include <mythdate.h>
+#include <mythdb.h>
+#include <mythcontext.h>
+#include <musicmetadata.h>
+#include <metaio.h>
+#include <musicfilescanner.h>
+
+MusicFileScanner::MusicFileScanner():
+    m_tracksTotal(0), m_tracksUnchanged(0), m_tracksAdded (0), m_tracksRemoved(0),
+    m_tracksUpdated(0), m_coverartTotal(0), m_coverartUnchanged(0), m_coverartAdded(0),
+    m_coverartRemoved(0), m_coverartUpdated(0)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    // Cache the directory ids from the database
+    query.prepare("SELECT directory_id, path FROM music_directories");
+    if (query.exec())
+    {
+        while(query.next())
+        {
+            m_directoryid[query.value(1).toString()] = query.value(0).toInt();
+        }
+    }
+
+    // Cache the genre ids from the database
+    query.prepare("SELECT genre_id, LOWER(genre) FROM music_genres");
+    if (query.exec())
+    {
+        while(query.next())
+        {
+            m_genreid[query.value(1).toString()] = query.value(0).toInt();
+        }
+    }
+
+    // Cache the artist ids from the database
+    query.prepare("SELECT artist_id, LOWER(artist_name) FROM music_artists");
+    if (query.exec() || query.isActive())
+    {
+        while(query.next())
+        {
+            m_artistid[query.value(1).toString()] = query.value(0).toInt();
+        }
+    }
+
+    // Cache the album ids from the database
+    query.prepare("SELECT album_id, artist_id, LOWER(album_name) FROM music_albums");
+    if (query.exec())
+    {
+        while(query.next())
+        {
+            m_albumid[query.value(1).toString() + "#" + query.value(2).toString()] = query.value(0).toInt();
+        }
+    }
+}
+
+MusicFileScanner::~MusicFileScanner ()
+{
+
+}
+
+/*!
+ * \brief Builds a list of all the files found descending recursively
+ *        into the given directory
+ *
+ * \param directory Directory to begin search
+ * \param music_files A pointer to the MusicLoadedMap to store the results
+ * \param parentid The id of the parent directory in the music_directories
+ *                 table. The root directory should have an id of 0
+ *
+ * \returns Nothing.
+ */
+void MusicFileScanner::BuildFileList(QString &directory, MusicLoadedMap &music_files, MusicLoadedMap &art_files, int parentid)
+{
+    QDir d(directory);
+
+    if (!d.exists())
+        return;
+
+    d.setFilter(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot);
+
+    QFileInfoList list = d.entryInfoList();
+    if (list.isEmpty())
+        return;
+
+    QFileInfoList::const_iterator it = list.begin();
+    const QFileInfo *fi;
+
+    // Recursively traverse directory
+    int newparentid = 0;
+    while (it != list.end())
+    {
+        fi = &(*it);
+        ++it;
+        QString filename = fi->absoluteFilePath();
+        if (fi->isDir())
+        {
+
+            QString dir(filename);
+            dir.remove(0, m_startDirs.last().length());
+
+            newparentid = m_directoryid[dir];
+
+            if (newparentid == 0)
+            {
+                int id = GetDirectoryId(dir, parentid);
+                m_directoryid[dir] = id;
+
+                if (id > 0)
+                {
+                    newparentid = id;
+                }
+                else
+                {
+                    LOG(VB_GENERAL, LOG_ERR,
+                        QString("Failed to get directory id for path %1")
+                            .arg(dir));
+                }
+            }
+
+            BuildFileList(filename, music_files, art_files, newparentid);
+        }
+        else
+        {
+            if (IsArtFile(filename))
+            {
+                MusicFileData fdata;
+                fdata.startDir = m_startDirs.last();
+                fdata.location = MusicFileScanner::kFileSystem;
+                art_files[filename] = fdata;
+            }
+            else if (IsMusicFile(filename))
+            {
+                MusicFileData fdata;
+                fdata.startDir = m_startDirs.last();
+                fdata.location = MusicFileScanner::kFileSystem;
+                music_files[filename] = fdata;
+            }
+            else
+                LOG(VB_GENERAL, LOG_INFO,
+                        QString("Found file with unsupported extension %1")
+                            .arg(filename));
+        }
+    }
+}
+
+bool MusicFileScanner::IsArtFile(const QString &filename)
+{
+    QFileInfo fi(filename);
+    QString extension = fi.suffix().toLower();
+    QString nameFilter = gCoreContext->GetSetting("AlbumArtFilter", "*.png;*.jpg;*.jpeg;*.gif;*.bmp");
+
+
+    if (!extension.isEmpty() && nameFilter.indexOf(extension.toLower()) > -1)
+        return true;
+
+    return false;
+}
+
+bool MusicFileScanner::IsMusicFile(const QString &filename)
+{
+    QFileInfo fi(filename);
+    QString extension = fi.suffix().toLower();
+    QString nameFilter = MetaIO::ValidFileExtensions;
+
+    if (!extension.isEmpty() && nameFilter.indexOf(extension.toLower()) > -1)
+        return true;
+
+    return false;
+}
+
+/*!
+ * \brief Get an ID for the given directory from the database.
+ *        If it doesn't already exist in the database, insert it.
+ *
+ * \param directory Relative path to directory, from base dir
+ * \param parentid The id of the parent directory in the music_directories
+ *                 table. The root directory should have an id of 0
+ *
+ * \returns Directory id
+ */
+int MusicFileScanner::GetDirectoryId(const QString &directory, const int &parentid)
+{
+    if (directory.isEmpty())
+        return 0;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    // Load the directory id or insert it and get the id
+    query.prepare("SELECT directory_id FROM music_directories "
+                "WHERE path = :DIRECTORY ;");
+    query.bindValue(":DIRECTORY", directory);
+
+    if (!query.exec())
+    {
+        MythDB::DBError("music select directory id", query);
+        return -1;
+    }
+
+    if (query.next())
+    {
+        // we have found the directory already in the DB
+        return query.value(0).toInt();
+    }
+
+    // directory is not in the DB so insert it
+    query.prepare("INSERT INTO music_directories (path, parent_id) "
+                "VALUES (:DIRECTORY, :PARENTID);");
+    query.bindValue(":DIRECTORY", directory);
+    query.bindValue(":PARENTID", parentid);
+
+    if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
+    {
+        MythDB::DBError("music insert directory", query);
+        return -1;
+    }
+
+    return query.lastInsertId().toInt();
+}
+
+/*!
+ * \brief Check if file has been modified since given date/time
+ *
+ * \param filename File to examine
+ * \param date_modified Date to use in comparison
+ *
+ * \returns True if file has been modified, otherwise false
+ */
+bool MusicFileScanner::HasFileChanged(
+    const QString &filename, const QString &date_modified)
+{
+    QFileInfo fi(filename);
+    QDateTime dt = fi.lastModified();
+    if (dt.isValid())
+    {
+        QDateTime old_dt = MythDate::fromString(date_modified);
+        return !old_dt.isValid() || (dt > old_dt);
+    }
+    else
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Failed to stat file: %1")
+                .arg(filename));
+        return false;
+    }
+}
+
+/*!
+ * \brief Insert file details into database.
+ *        If it is an audio file, read the metadata and insert
+ *        that information at the same time.
+ *
+ *        If it is an image file, just insert the filename and
+ *        type.
+ *
+ * \param filename Full path to file.
+ *
+ * \returns Nothing.
+ */
+void MusicFileScanner::AddFileToDB(const QString &filename, const QString &startDir)
+{
+    QString extension = filename.section( '.', -1 ) ;
+    QString directory = filename;
+    directory.remove(0, startDir.length());
+    directory = directory.section( '/', 0, -2);
+
+    QString nameFilter = gCoreContext->GetSetting("AlbumArtFilter", "*.png;*.jpg;*.jpeg;*.gif;*.bmp");
+
+    // If this file is an image, insert the details into the music_albumart table
+    if (nameFilter.indexOf(extension.toLower()) > -1)
+    {
+        QString name = filename.section( '/', -1);
+
+        MSqlQuery query(MSqlQuery::InitCon());
+        query.prepare("INSERT INTO music_albumart "
+                       "SET filename = :FILE, directory_id = :DIRID, "
+                       "imagetype = :TYPE, hostname = :HOSTNAME;");
+
+        query.bindValue(":FILE", name);
+        query.bindValue(":DIRID", m_directoryid[directory]);
+        query.bindValue(":TYPE", AlbumArtImages::guessImageType(name));
+        query.bindValue(":HOSTNAME", gCoreContext->GetHostName());
+
+        if (!query.exec() || query.numRowsAffected() <= 0)
+        {
+            MythDB::DBError("music insert artwork", query);
+        }
+
+        ++m_coverartAdded;
+
+        return;
+    }
+
+    if (extension.isEmpty() || !MetaIO::ValidFileExtensions.contains(extension.toLower()))
+    {
+        LOG(VB_GENERAL, LOG_WARNING, QString("Ignoring filename with unsupported filename: '%1'").arg(filename));
+        return;
+    }
+
+    LOG(VB_FILE, LOG_INFO, QString("Reading metadata from %1").arg(filename));
+    MusicMetadata *data = MetaIO::readMetadata(filename);
+    if (data)
+    {
+        data->setFileSize((quint64)QFileInfo(filename).size());
+        data->setHostname(gCoreContext->GetHostName());
+
+        QString album_cache_string;
+
+        // Set values from cache
+        int did = m_directoryid[directory];
+        if (did > 0)
+            data->setDirectoryId(did);
+
+        int aid = m_artistid[data->Artist().toLower()];
+        if (aid > 0)
+        {
+            data->setArtistId(aid);
+
+            // The album cache depends on the artist id
+            album_cache_string = data->getArtistId() + "#"
+                + data->Album().toLower();
+
+            if (m_albumid[album_cache_string] > 0)
+                data->setAlbumId(m_albumid[album_cache_string]);
+        }
+
+        int gid = m_genreid[data->Genre().toLower()];
+        if (gid > 0)
+            data->setGenreId(gid);
+
+        // Commit track info to database
+        data->dumpToDatabase();
+
+        // Update the cache
+        m_artistid[data->Artist().toLower()] =
+            data->getArtistId();
+
+        m_genreid[data->Genre().toLower()] =
+            data->getGenreId();
+
+        album_cache_string = data->getArtistId() + "#"
+            + data->Album().toLower();
+        m_albumid[album_cache_string] = data->getAlbumId();
+
+        // read any embedded images from the tag
+        MetaIO *tagger = MetaIO::createTagger(filename);
+
+        if (tagger)
+        {
+            if (tagger->supportsEmbeddedImages())
+            {
+                AlbumArtList artList = tagger->getAlbumArtList(data->Filename());
+                data->setEmbeddedAlbumArt(artList);
+                data->getAlbumArtImages()->dumpToDatabase();
+            }
+            delete tagger;
+        }
+
+        delete data;
+
+        ++m_tracksAdded;
+    }
+}
+
+/*!
+ * \brief Clear orphaned entries from the genre, artist, album and albumart
+ *        tables
+ *
+ * \returns Nothing.
+ */
+void MusicFileScanner::cleanDB()
+{
+    LOG(VB_GENERAL, LOG_INFO, "Cleaning old entries from music database");
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    MSqlQuery deletequery(MSqlQuery::InitCon());
+
+    // delete unused genre_ids from music_genres
+    if (!query.exec("SELECT g.genre_id FROM music_genres g "
+                    "LEFT JOIN music_songs s ON g.genre_id=s.genre_id "
+                    "WHERE s.genre_id IS NULL;"))
+        MythDB::DBError("MusicFileScanner::cleanDB - select music_genres", query);
+
+    deletequery.prepare("DELETE FROM music_genres WHERE genre_id=:GENREID");
+    while (query.next())
+    {
+        int genreid = query.value(0).toInt();
+        deletequery.bindValue(":GENREID", genreid);
+        if (!deletequery.exec())
+            MythDB::DBError("MusicFileScanner::cleanDB - delete music_genres",
+                            deletequery);
+    }
+
+    // delete unused album_ids from music_albums
+    if (!query.exec("SELECT a.album_id FROM music_albums a "
+                    "LEFT JOIN music_songs s ON a.album_id=s.album_id "
+                    "WHERE s.album_id IS NULL;"))
+        MythDB::DBError("MusicFileScanner::cleanDB - select music_albums", query);
+
+    deletequery.prepare("DELETE FROM music_albums WHERE album_id=:ALBUMID");
+    while (query.next())
+    {
+        int albumid = query.value(0).toInt();
+        deletequery.bindValue(":ALBUMID", albumid);
+        if (!deletequery.exec())
+            MythDB::DBError("MusicFileScanner::cleanDB - delete music_albums",
+                            deletequery);
+    }
+
+    // delete unused artist_ids from music_artists
+    if (!query.exec("SELECT a.artist_id FROM music_artists a "
+                    "LEFT JOIN music_songs s ON a.artist_id=s.artist_id "
+                    "LEFT JOIN music_albums l ON a.artist_id=l.artist_id "
+                    "WHERE s.artist_id IS NULL AND l.artist_id IS NULL"))
+        MythDB::DBError("MusicFileScanner::cleanDB - select music_artists", query);
+
+
+    deletequery.prepare("DELETE FROM music_artists WHERE artist_id=:ARTISTID");
+    while (query.next())
+    {
+        int artistid = query.value(0).toInt();
+        deletequery.bindValue(":ARTISTID", artistid);
+        if (!deletequery.exec())
+            MythDB::DBError("MusicFileScanner::cleanDB - delete music_artists",
+                            deletequery);
+    }
+
+    // delete unused directory_ids from music_directories
+    // get a list of directory_ids not referenced in music_songs
+    if (!query.exec("SELECT d.directory_id, d.parent_id FROM music_directories d "
+                    "LEFT JOIN music_songs s ON d.directory_id=s.directory_id "
+                    "WHERE s.directory_id IS NULL ORDER BY directory_id DESC;"))
+        MythDB::DBError("MusicFileScanner::cleanDB - select music_directories", query);
+
+    deletequery.prepare("DELETE FROM music_directories WHERE directory_id=:DIRECTORYID");
+
+    MSqlQuery parentquery(MSqlQuery::InitCon());
+    parentquery.prepare("SELECT COUNT(*) FROM music_directories "
+                        "WHERE parent_id=:DIRECTORYID ");
+
+    int deletedCount;
+
+    do
+    {
+        deletedCount = 0;
+
+        if (!query.first())
+            break;
+
+        // loop through the list of unused directory_ids deleting any which
+        // aren't referenced by any other directories parent_id
+        do
+        {
+            int directoryid = query.value(0).toInt();
+
+            // have we still got references to this directory_id from other directories
+            parentquery.bindValue(":DIRECTORYID", directoryid);
+            if (!parentquery.exec())
+                MythDB::DBError("MusicFileScanner::cleanDB - get parent directory count",
+                                parentquery);
+
+            if (parentquery.next())
+            {
+                int parentCount = parentquery.value(0).toInt();
+
+                if (parentCount == 0)
+                {
+                    deletequery.bindValue(":DIRECTORYID", directoryid);
+                    if (!deletequery.exec())
+                        MythDB::DBError("MusicFileScanner::cleanDB - delete music_directories",
+                                        deletequery);
+
+                    deletedCount += deletequery.numRowsAffected();
+                }
+            }
+
+        } while (query.next());
+
+    } while (deletedCount);
+
+    // delete unused albumart_ids from music_albumart (embedded images)
+    if (!query.exec("SELECT a.albumart_id FROM music_albumart a LEFT JOIN "
+                    "music_songs s ON a.song_id=s.song_id WHERE "
+                    "embedded='1' AND s.song_id IS NULL;"))
+        MythDB::DBError("MusicFileScanner::cleanDB - select music_albumart", query);
+
+    deletequery.prepare("DELETE FROM music_albumart WHERE albumart_id=:ALBUMARTID");
+    while (query.next())
+    {
+        int albumartid = query.value(0).toInt();
+        deletequery.bindValue(":ALBUMARTID", albumartid);
+        if (!deletequery.exec())
+            MythDB::DBError("MusicFileScanner::cleanDB - delete music_albumart",
+                            deletequery);
+    }
+}
+
+/*!
+ * \brief Removes a file from the database.
+ *
+ * \param filename Full path to file.
+ *
+ * \returns Nothing.
+ */
+void MusicFileScanner::RemoveFileFromDB(const QString &filename, const QString &startDir)
+{
+    QString sqlfilename(filename);
+    sqlfilename.remove(0, startDir.length());
+    // We know that the filename will not contain :// as the SQL limits this
+    QString directory = sqlfilename.section( '/', 0, -2 ) ;
+    sqlfilename = sqlfilename.section( '/', -1 ) ;
+
+    QString extension = sqlfilename.section( '.', -1 ) ;
+
+    QString nameFilter = gCoreContext->GetSetting("AlbumArtFilter",
+                                              "*.png;*.jpg;*.jpeg;*.gif;*.bmp");
+
+    if (nameFilter.indexOf(extension.toLower()) > -1)
+    {
+        MSqlQuery query(MSqlQuery::InitCon());
+        query.prepare("DELETE FROM music_albumart WHERE filename= :FILE AND "
+                      "directory_id= :DIRID;");
+        query.bindValue(":FILE", sqlfilename);
+        query.bindValue(":DIRID", m_directoryid[directory]);
+
+        if (!query.exec() || query.numRowsAffected() <= 0)
+        {
+            MythDB::DBError("music delete artwork", query);
+        }
+
+        ++m_coverartRemoved;
+
+        return;
+    }
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("DELETE FROM music_songs WHERE filename = :NAME ;");
+    query.bindValue(":NAME", sqlfilename);
+    if (!query.exec())
+        MythDB::DBError("MusicFileScanner::RemoveFileFromDB - deleting music_songs",
+                        query);
+
+    ++m_tracksRemoved;
+}
+
+/*!
+ * \brief Updates a file in the database.
+ *
+ * \param filename Full path to file.
+ *
+ * \returns Nothing.
+ */
+void MusicFileScanner::UpdateFileInDB(const QString &filename, const QString &startDir)
+{
+    QString dbFilename = filename;
+    dbFilename.remove(0, startDir.length());
+
+    QString directory = filename;
+    directory.remove(0, startDir.length());
+    directory = directory.section( '/', 0, -2);
+
+    MusicMetadata *db_meta   = MetaIO::getMetadata(dbFilename);
+    MusicMetadata *disk_meta = MetaIO::readMetadata(filename);
+
+    if (db_meta && disk_meta)
+    {
+        if (db_meta->ID() <= 0)
+        {
+            LOG(VB_GENERAL, LOG_ERR, QString("Asked to update track with "
+                                                "invalid ID - %1")
+                                            .arg(db_meta->ID()));
+            delete disk_meta;
+            delete db_meta;
+            return;
+        }
+
+        disk_meta->setID(db_meta->ID());
+        disk_meta->setRating(db_meta->Rating());
+        if (db_meta->PlayCount() > disk_meta->PlayCount())
+            disk_meta->setPlaycount(db_meta->Playcount());
+
+        QString album_cache_string;
+
+        // Set values from cache
+        int did = m_directoryid[directory];
+        if (did > 0)
+            disk_meta->setDirectoryId(did);
+
+        int aid = m_artistid[disk_meta->Artist().toLower()];
+        if (aid > 0)
+        {
+            disk_meta->setArtistId(aid);
+
+            // The album cache depends on the artist id
+            album_cache_string = disk_meta->getArtistId() + "#" +
+                disk_meta->Album().toLower();
+
+            if (m_albumid[album_cache_string] > 0)
+                disk_meta->setAlbumId(m_albumid[album_cache_string]);
+        }
+
+        int gid = m_genreid[disk_meta->Genre().toLower()];
+        if (gid > 0)
+            disk_meta->setGenreId(gid);
+
+        disk_meta->setFileSize((quint64)QFileInfo(filename).size());
+
+        disk_meta->setHostname(gCoreContext->GetHostName());
+
+        // Commit track info to database
+        disk_meta->dumpToDatabase();
+
+        // Update the cache
+        m_artistid[disk_meta->Artist().toLower()]
+            = disk_meta->getArtistId();
+        m_genreid[disk_meta->Genre().toLower()]
+            = disk_meta->getGenreId();
+        album_cache_string = disk_meta->getArtistId() + "#" +
+            disk_meta->Album().toLower();
+        m_albumid[album_cache_string] = disk_meta->getAlbumId();
+    }
+
+    if (disk_meta)
+        delete disk_meta;
+
+    if (db_meta)
+        delete db_meta;
+}
+
+/*!
+ * \brief Scan a list of directories recursively for music and albumart.
+ *        Inserts, updates and removes any files any files found in the
+ *        database.
+ *
+ * \param dirList List of directories to scan
+ *
+ * \returns Nothing.
+ */
+void MusicFileScanner::SearchDirs(const QStringList &dirList)
+{
+    QString host = gCoreContext->GetHostName();
+
+    if (IsRunning())
+    {
+        // check how long the scanner has been running
+        // if it's more than 60 minutes assume something went wrong
+        QString lastRun =  gCoreContext->GetSetting("MusicScannerLastRunStart", "");
+        if (!lastRun.isEmpty())
+        {
+            QDateTime dtLastRun = QDateTime::fromString(lastRun, Qt::ISODate);
+            if (dtLastRun.isValid())
+            {
+                if (MythDate::current() > dtLastRun.addSecs(60*1))
+                {
+                    LOG(VB_GENERAL, LOG_INFO, "Music file scanner has been running for more than 60 minutes. Lets reset and try again");
+                    gCoreContext->SendMessage(QString("MUSIC_SCANNER_ERROR %1 %2").arg(host).arg("Stalled"));
+
+                    // give the user time to read the notification before restarting the scan
+                    sleep(5);
+                }
+                else
+                {
+                    LOG(VB_GENERAL, LOG_INFO, "Music file scanner is already running");
+                    gCoreContext->SendMessage(QString("MUSIC_SCANNER_ERROR %1 %2").arg(host).arg("Already_Running"));
+                    return;
+                }
+            }
+        }
+    }
+
+    //TODO: could sanity check the directory exists and is readable here?
+
+    LOG(VB_GENERAL, LOG_INFO, "Music file scanner started");
+    gCoreContext->SendMessage(QString("MUSIC_SCANNER_STARTED %1").arg(host));
+
+    updateLastRunStart();
+    QString status = QString("running");
+    updateLastRunStatus(status);
+
+    m_tracksTotal = m_tracksAdded = m_tracksUnchanged = m_tracksRemoved = m_tracksUpdated = 0;
+    m_coverartTotal = m_coverartAdded = m_coverartUnchanged = m_coverartRemoved = m_coverartUpdated = 0;
+
+    MusicLoadedMap music_files;
+    MusicLoadedMap art_files;
+    MusicLoadedMap::Iterator iter;
+
+    for (int x = 0; x < dirList.count(); x++)
+    {
+        QString startDir = dirList[x];
+        m_startDirs.append(startDir + '/');
+        LOG(VB_GENERAL, LOG_INFO, QString("Searching '%1' for music files").arg(startDir));
+
+        BuildFileList(startDir, music_files, art_files, 0);
+    }
+
+    m_tracksTotal = music_files.count();
+    m_coverartTotal = art_files.count();
+
+    ScanMusic(music_files);
+    ScanArtwork(art_files);
+
+    LOG(VB_GENERAL, LOG_INFO, "Updating database");
+
+        /*
+        This can be optimised quite a bit by consolidating all commands
+        via a lot of refactoring.
+
+        1) group all files of the same decoder type, and don't
+        create/delete a Decoder pr. AddFileToDB. Or make Decoders be
+        singletons, it should be a fairly simple change.
+
+        2) RemoveFileFromDB should group the remove into one big SQL.
+
+        3) UpdateFileInDB, same as 1.
+        */
+
+    for (iter = music_files.begin(); iter != music_files.end(); iter++)
+    {
+        if ((*iter).location == MusicFileScanner::kFileSystem)
+            AddFileToDB(iter.key(), (*iter).startDir);
+        else if ((*iter).location == MusicFileScanner::kDatabase)
+            RemoveFileFromDB(iter.key(), (*iter).startDir);
+        else if ((*iter).location == MusicFileScanner::kNeedUpdate)
+        {
+            UpdateFileInDB(iter.key(), (*iter).startDir);
+            ++m_tracksUpdated;
+        }
+    }
+
+    for (iter = art_files.begin(); iter != art_files.end(); iter++)
+    {
+        if ((*iter).location == MusicFileScanner::kFileSystem)
+            AddFileToDB(iter.key(), (*iter).startDir);
+        else if ((*iter).location == MusicFileScanner::kDatabase)
+            RemoveFileFromDB(iter.key(), (*iter).startDir);
+        else if ((*iter).location == MusicFileScanner::kNeedUpdate)
+        {
+            UpdateFileInDB(iter.key(), (*iter).startDir);
+            ++m_coverartUpdated;
+        }
+    }
+
+    // Cleanup orphaned entries from the database
+    cleanDB();
+
+    QString trackStatus = QString("total tracks found: %1 (unchanged: %2, added: %3, removed: %4, updated %5)")
+                                  .arg(m_tracksTotal).arg(m_tracksUnchanged).arg(m_tracksAdded)
+                                  .arg(m_tracksRemoved).arg(m_tracksUpdated);
+    QString coverartStatus = QString("total coverart found: %1 (unchanged: %2, added: %3, removed: %4, updated %5)")
+                                     .arg(m_coverartTotal).arg(m_coverartUnchanged).arg(m_coverartAdded)
+                                     .arg(m_coverartRemoved).arg(m_coverartUpdated);
+
+
+    LOG(VB_GENERAL, LOG_INFO, "Music file scanner finished ");
+    LOG(VB_GENERAL, LOG_INFO, trackStatus);
+    LOG(VB_GENERAL, LOG_INFO, coverartStatus);
+
+    gCoreContext->SendMessage(QString("MUSIC_SCANNER_FINISHED %1 %2 %3 %4 %5")
+                                      .arg(host).arg(m_tracksTotal).arg(m_tracksAdded)
+                                      .arg(m_coverartTotal).arg(m_coverartAdded));
+
+    updateLastRunEnd();
+    status = QString("success - %1 - %2").arg(trackStatus).arg(coverartStatus);
+    updateLastRunStatus(status);
+}
+
+/*!
+ * \brief Check a list of files against musics files already in the database
+ *
+ * \param music_files MusicLoadedMap
+ *
+ * \returns Nothing.
+ */
+void MusicFileScanner::ScanMusic(MusicLoadedMap &music_files)
+{
+    MusicLoadedMap::Iterator iter;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT CONCAT_WS('/', path, filename), date_modified "
+                  "FROM music_songs LEFT JOIN music_directories ON "
+                  "music_songs.directory_id=music_directories.directory_id "
+                  "WHERE filename NOT LIKE ('%://%') "
+                  "AND hostname = :HOSTNAME");
+
+    query.bindValue(":HOSTNAME", gCoreContext->GetHostName());
+
+    if (!query.exec())
+        MythDB::DBError("MusicFileScanner::ScanMusic", query);
+
+    LOG(VB_GENERAL, LOG_INFO, "Checking tracks");
+
+    QString name;
+
+    if (query.isActive() && query.size() > 0)
+    {
+        while (query.next())
+        {
+            for (int x = 0; x < m_startDirs.count(); x++)
+            {
+                name = m_startDirs[x] + query.value(0).toString();
+                if ((iter = music_files.find(name)) != music_files.end())
+                    break;
+            }
+
+            if (iter != music_files.end())
+            {
+                if (music_files[name].location == MusicFileScanner::kDatabase)
+                    continue;
+                else if (HasFileChanged(name, query.value(1).toString()))
+                    music_files[name].location = MusicFileScanner::kNeedUpdate;
+                else
+                {
+                    ++m_tracksUnchanged;
+                    music_files.erase(iter);
+                }
+            }
+            else
+                music_files[name].location = MusicFileScanner::kDatabase;
+        }
+    }
+}
+
+/*!
+ * \brief Check a list of files against images already in the database
+ *
+ * \param music_files MusicLoadedMap
+ *
+ * \returns Nothing.
+ */
+void MusicFileScanner::ScanArtwork(MusicLoadedMap &music_files)
+{
+    MusicLoadedMap::Iterator iter;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT CONCAT_WS('/', path, filename) "
+                  "FROM music_albumart "
+                  "LEFT JOIN music_directories ON music_albumart.directory_id=music_directories.directory_id "
+                  "WHERE music_albumart.embedded = 0 "
+                  "AND music_albumart.hostname = :HOSTNAME");
+
+    query.bindValue(":HOSTNAME", gCoreContext->GetHostName());
+
+    if (!query.exec())
+        MythDB::DBError("MusicFileScanner::ScanArtwork", query);
+
+    LOG(VB_GENERAL, LOG_INFO, "Checking artwork");
+
+    QString name;
+
+    if (query.isActive() && query.size() > 0)
+    {
+        while (query.next())
+        {
+            for (int x = 0; x < m_startDirs.count(); x++)
+            {
+                name = m_startDirs[x] + query.value(0).toString();
+                if ((iter = music_files.find(name)) != music_files.end())
+                    break;
+            }
+
+            if (iter != music_files.end())
+            {
+                if (music_files[name].location == MusicFileScanner::kDatabase)
+                    continue;
+                else
+                {
+                    ++m_coverartUnchanged;
+                    music_files.erase(iter);
+                }
+            }
+            else
+            {
+                music_files[name].location = MusicFileScanner::kDatabase;
+            }
+        }
+    }
+}
+
+// static
+bool MusicFileScanner::IsRunning(void)
+{
+   if (gCoreContext->GetSetting("MusicScannerLastRunStatus", "") == "running")
+       return true;
+
+   return false;
+}
+
+void MusicFileScanner::updateLastRunEnd(void)
+{
+    QDateTime qdtNow = MythDate::current();
+    gCoreContext->SaveSetting("MusicScannerLastRunEnd", qdtNow.toString(Qt::ISODate));
+}
+
+void MusicFileScanner::updateLastRunStart(void)
+{
+    QDateTime qdtNow = MythDate::current();
+    gCoreContext->SaveSetting("MusicScannerLastRunStart", qdtNow.toString(Qt::ISODate));
+}
+
+void MusicFileScanner::updateLastRunStatus(QString &status)
+{
+    gCoreContext->SaveSetting("MusicScannerLastRunStatus", status);
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicfilescanner.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicfilescanner.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicfilescanner.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicfilescanner.h	2014-05-05 12:30:23.000000000 +0200
@@ -0,0 +1,66 @@
+#ifndef _MUSICFILESCANNER_H_
+#define _MUSICFILESCANNER_H_
+
+// MythTV
+#include "mythmetaexp.h"
+
+// Qt headers
+#include <QCoreApplication>
+
+typedef QMap<QString, int> IdCache;
+
+class META_PUBLIC MusicFileScanner
+{
+    Q_DECLARE_TR_FUNCTIONS(MusicFileScanner)
+
+    enum MusicFileLocation
+    {
+        kFileSystem,
+        kDatabase,
+        kNeedUpdate,
+        kBoth
+    };
+
+    struct MusicFileData
+    {
+        QString startDir;
+        MusicFileLocation location;
+    };
+
+    typedef QMap <QString, MusicFileData> MusicLoadedMap;
+    public:
+        MusicFileScanner(void);
+        ~MusicFileScanner(void);
+
+        void SearchDirs(const QStringList &directory);
+
+        static bool IsRunning(void);
+
+    private:
+        void BuildFileList(QString &directory, MusicLoadedMap &music_files, MusicLoadedMap &art_files, int parentid);
+        int  GetDirectoryId(const QString &directory, const int &parentid);
+        bool HasFileChanged(const QString &filename, const QString &date_modified);
+        void AddFileToDB(const QString &filename, const QString &startDir);
+        void RemoveFileFromDB (const QString &filename, const QString &startDir);
+        void UpdateFileInDB(const QString &filename, const QString &startDir);
+        void ScanMusic(MusicLoadedMap &music_files);
+        void ScanArtwork(MusicLoadedMap &music_files);
+        void cleanDB();
+        bool IsArtFile(const QString &filename);
+        bool IsMusicFile(const QString &filename);
+
+        void updateLastRunEnd(void);
+        void updateLastRunStart(void);
+        void updateLastRunStatus(QString &status);
+
+        QStringList  m_startDirs;
+        IdCache  m_directoryid;
+        IdCache  m_artistid;
+        IdCache  m_genreid;
+        IdCache  m_albumid;
+
+        uint m_tracksTotal, m_tracksUnchanged, m_tracksAdded, m_tracksRemoved, m_tracksUpdated;
+        uint m_coverartTotal, m_coverartUnchanged, m_coverartAdded, m_coverartRemoved, m_coverartUpdated;
+};
+
+#endif // _MUSICFILESCANNER_H_
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicmetadata.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicmetadata.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicmetadata.cpp	2014-05-04 17:43:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicmetadata.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -3,6 +3,7 @@
 #include <QRegExp>
 #include <QDateTime>
 #include <QDir>
+#include <QScopedPointer>
 
 // mythtv
 #include <mythcontext.h>
@@ -15,6 +16,8 @@
 #include <mythlogging.h>
 #include <mythdate.h>
 #include <remotefile.h>
+#include <storagegroup.h>
+#include <mythsystem.h>
 
 // libmythmetadata
 #include "musicmetadata.h"
@@ -29,14 +32,14 @@
 
 static QString thePrefix = "the ";
 
-bool operator==(const MusicMetadata& a, const MusicMetadata& b)
+bool operator==(MusicMetadata& a, MusicMetadata& b)
 {
     if (a.Filename() == b.Filename())
         return true;
     return false;
 }
 
-bool operator!=(const MusicMetadata& a, const MusicMetadata& b)
+bool operator!=(MusicMetadata& a, MusicMetadata& b)
 {
     if (a.Filename() != b.Filename())
         return true;
@@ -44,7 +47,7 @@
 }
 
 // this ctor is for radio streams
-MusicMetadata::MusicMetadata(int lid, QString lstation, QString lchannel, QString lurl, 
+MusicMetadata::MusicMetadata(int lid, QString lstation, QString lchannel, QString lurl,
                    QString llogourl, QString lgenre, QString lmetaformat, QString lformat)
          :  m_artist(""),
             m_compilation_artist(""),
@@ -73,6 +76,7 @@
             m_albumArt(NULL),
             m_id(lid),
             m_filename(lurl),
+            m_hostname(""),
             m_fileSize(0),
             m_changed(false),
             m_station(lstation),
@@ -115,6 +119,8 @@
     m_compilation = rhs.m_compilation;
     m_id = rhs.m_id;
     m_filename = rhs.m_filename;
+    m_actualFilename = rhs.m_actualFilename;
+    m_hostname = rhs.m_hostname;
     m_directoryid = rhs.m_directoryid;
     m_artistid = rhs.m_artistid;
     m_compartistid = rhs.m_compartistid;
@@ -132,6 +138,33 @@
     return *this;
 }
 
+// return true if this == mdata
+bool MusicMetadata::compare(MusicMetadata *mdata) const
+{
+    return (
+        m_artist == mdata->m_artist &&
+        m_compilation_artist == mdata->m_compilation_artist &&
+        m_album == mdata->m_album &&
+        m_title == mdata->m_title &&
+        m_year == mdata->m_year &&
+        m_tracknum == mdata->m_tracknum &&
+        m_trackCount == mdata->m_trackCount &&
+        //m_length == mdata->m_length &&
+        m_rating == mdata->m_rating &&
+        m_lastplay == mdata->m_lastplay &&
+        m_playcount == mdata->m_playcount &&
+        m_compilation == mdata->m_compilation &&
+        m_filename == mdata->m_filename &&
+        m_directoryid == mdata->m_directoryid &&
+        m_artistid == mdata->m_artistid &&
+        m_compartistid == mdata->m_compartistid &&
+        m_albumid == mdata->m_albumid &&
+        m_genreid == mdata->m_genreid &&
+        m_format == mdata->m_format &&
+        m_fileSize == mdata->m_fileSize
+    );
+}
+
 void MusicMetadata::persist()
 {
     if (m_id < 1)
@@ -160,48 +193,19 @@
     m_changed = false;
 }
 
-
-void MusicMetadata::UpdateModTime() const
+void MusicMetadata::saveHostname(void)
 {
     if (m_id < 1)
         return;
 
     MSqlQuery query(MSqlQuery::InitCon());
-
-    query.prepare("UPDATE music_songs SET date_modified = :DATE_MOD "
-                  "WHERE song_id= :ID ;");
-
-    query.bindValue(":DATE_MOD", MythDate::current());
+    query.prepare("UPDATE music_songs SET hostname = :HOSTNAME "
+                  "WHERE song_id = :ID ;");
+    query.bindValue(":HOSTNAME", m_hostname);
     query.bindValue(":ID", m_id);
 
     if (!query.exec())
-        MythDB::DBError("MusicMetadata::UpdateModTime",
-                        query);
-}
-
-int MusicMetadata::compare(const MusicMetadata *other) const
-{
-    if (m_format == "cast")
-    {
-        int artist_cmp = Artist().toLower().localeAwareCompare(
-            other->Artist().toLower());
-
-        if (artist_cmp == 0)
-            return Title().toLower().localeAwareCompare(
-                other->Title().toLower());
-
-        return artist_cmp;
-    }
-    else
-    {
-        int track_cmp = Track() - other->Track();
-
-        if (track_cmp == 0)
-            return Title().toLower().localeAwareCompare(
-                other->Title().toLower());
-
-        return track_cmp;
-    }
+        MythDB::DBError("music save hostname", query);
 }
 
 // static
@@ -210,10 +214,6 @@
     // find the trackid for this filename
     QString sqldir = filename.section('/', 0, -2);
 
-    // Filename is the absolute path, we want the relative path
-    if (sqldir.startsWith(getMusicDirectory()))
-        sqldir.remove(0, getMusicDirectory().length());
-
     QString sqlfilename = filename.section('/', -1);
 
     MSqlQuery query(MSqlQuery::InitCon());
@@ -237,7 +237,6 @@
             QString("MusicMetadata::createFromFilename: Could not find '%1'")
                 .arg(filename));
         return NULL;
-
     }
 
     int songID = query.value(0).toInt();
@@ -256,7 +255,8 @@
     "music_songs.song_id, music_songs.rating, music_songs.numplays, "
     "music_songs.lastplay, music_albums.compilation, music_songs.format, "
     "music_songs.track_count, music_songs.size, music_songs.date_entered, "
-    "CONCAT_WS('/', music_directories.path, music_songs.filename) AS filename "
+    "CONCAT_WS('/', music_directories.path, music_songs.filename) AS filename, "
+    "music_songs.hostname "
     "FROM music_songs "
     "LEFT JOIN music_directories ON music_songs.directory_id=music_directories.directory_id "
     "LEFT JOIN music_artists ON music_songs.artist_id=music_artists.artist_id "
@@ -287,6 +287,7 @@
         mdata->m_fileSize = (quint64)query.value(15).toULongLong();
         mdata->m_dateadded = query.value(16).toDateTime();
         mdata->m_filename = query.value(17).toString();
+        mdata->m_hostname = query.value(18).toString();
 
         return mdata;
     }
@@ -317,51 +318,61 @@
     m_genreid = -1;
 }
 
-void MusicMetadata::dumpToDatabase()
+int MusicMetadata::getDirectoryId()
 {
-    QString sqldir = m_filename.section('/', 0, -2);
-    QString sqlfilename = m_filename.section('/', -1);
-
-    checkEmptyFields();
+    if (m_directoryid < 0)
+    {
+        QString sqldir = m_filename.section('/', 0, -2);
+        QString sqlfilename = m_filename.section('/', -1);
 
-    MSqlQuery query(MSqlQuery::InitCon());
+        checkEmptyFields();
 
-    if (sqldir.isEmpty())
-    {
-        m_directoryid = 0;
-    }
-    else if (m_directoryid < 0)
-    {
-        // Load the directory id
-        query.prepare("SELECT directory_id FROM music_directories "
-                    "WHERE path = :DIRECTORY ;");
-        query.bindValue(":DIRECTORY", sqldir);
+        MSqlQuery query(MSqlQuery::InitCon());
 
-        if (!query.exec() || !query.isActive())
-        {
-            MythDB::DBError("music select directory id", query);
-            return;
-        }
-        if (query.next())
+        if (sqldir.isEmpty())
         {
-            m_directoryid = query.value(0).toInt();
+            m_directoryid = 0;
         }
-        else
+        else if (m_directoryid < 0)
         {
-            query.prepare("INSERT INTO music_directories (path) VALUES (:DIRECTORY);");
+            // Load the directory id
+            query.prepare("SELECT directory_id FROM music_directories "
+                        "WHERE path = :DIRECTORY ;");
             query.bindValue(":DIRECTORY", sqldir);
 
-            if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
+            if (!query.exec() || !query.isActive())
             {
-                MythDB::DBError("music insert directory", query);
-                return;
+                MythDB::DBError("music select directory id", query);
+                return -1;
+            }
+            if (query.next())
+            {
+                m_directoryid = query.value(0).toInt();
+            }
+            else
+            {
+                query.prepare("INSERT INTO music_directories (path) VALUES (:DIRECTORY);");
+                query.bindValue(":DIRECTORY", sqldir);
+
+                if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
+                {
+                    MythDB::DBError("music insert directory", query);
+                    return -1;
+                }
+                m_directoryid = query.lastInsertId().toInt();
             }
-            m_directoryid = query.lastInsertId().toInt();
         }
     }
 
+    return m_directoryid;
+}
+
+int MusicMetadata::getArtistId()
+{
     if (m_artistid < 0)
     {
+        MSqlQuery query(MSqlQuery::InitCon());
+
         // Load the artist id
         query.prepare("SELECT artist_id FROM music_artists "
                     "WHERE artist_name = :ARTIST ;");
@@ -370,7 +381,7 @@
         if (!query.exec() || !query.isActive())
         {
             MythDB::DBError("music select artist id", query);
-            return;
+            return -1;
         }
         if (query.next())
         {
@@ -384,48 +395,54 @@
             if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
             {
                 MythDB::DBError("music insert artist", query);
-                return;
+                return -1;
             }
             m_artistid = query.lastInsertId().toInt();
         }
-    }
 
-    // Compilation Artist
-    if (m_artist == m_compilation_artist)
-    {
-        m_compartistid = m_artistid;
-    }
-    else
-    {
-        query.prepare("SELECT artist_id FROM music_artists "
-                    "WHERE artist_name = :ARTIST ;");
-        query.bindValue(":ARTIST", m_compilation_artist);
-        if (!query.exec() || !query.isActive())
+        // Compilation Artist
+        if (m_artist == m_compilation_artist)
         {
-            MythDB::DBError("music select compilation artist id", query);
-            return;
-        }
-        if (query.next())
-        {
-            m_compartistid = query.value(0).toInt();
+            m_compartistid = m_artistid;
         }
         else
         {
-            query.prepare("INSERT INTO music_artists (artist_name) VALUES (:ARTIST);");
+            query.prepare("SELECT artist_id FROM music_artists "
+                        "WHERE artist_name = :ARTIST ;");
             query.bindValue(":ARTIST", m_compilation_artist);
-
-            if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
+            if (!query.exec() || !query.isActive())
+            {
+                MythDB::DBError("music select compilation artist id", query);
+                return -1;
+            }
+            if (query.next())
             {
-                MythDB::DBError("music insert compilation artist", query);
-                return;
+                m_compartistid = query.value(0).toInt();
+            }
+            else
+            {
+                query.prepare("INSERT INTO music_artists (artist_name) VALUES (:ARTIST);");
+                query.bindValue(":ARTIST", m_compilation_artist);
+
+                if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
+                {
+                    MythDB::DBError("music insert compilation artist", query);
+                    return -1 ;
+                }
+                m_compartistid = query.lastInsertId().toInt();
             }
-            m_compartistid = query.lastInsertId().toInt();
         }
     }
 
-    // Album
+    return m_artistid;
+}
+
+int MusicMetadata::getAlbumId()
+{
     if (m_albumid < 0)
     {
+        MSqlQuery query(MSqlQuery::InitCon());
+
         query.prepare("SELECT album_id FROM music_albums "
                     "WHERE artist_id = :COMP_ARTIST_ID "
                     " AND album_name = :ALBUM ;");
@@ -434,7 +451,7 @@
         if (!query.exec() || !query.isActive())
         {
             MythDB::DBError("music select album id", query);
-            return;
+            return -1;
         }
         if (query.next())
         {
@@ -442,7 +459,8 @@
         }
         else
         {
-            query.prepare("INSERT INTO music_albums (artist_id, album_name, compilation, year) VALUES (:COMP_ARTIST_ID, :ALBUM, :COMPILATION, :YEAR);");
+            query.prepare("INSERT INTO music_albums (artist_id, album_name, compilation, year) "
+                          "VALUES (:COMP_ARTIST_ID, :ALBUM, :COMPILATION, :YEAR);");
             query.bindValue(":COMP_ARTIST_ID", m_compartistid);
             query.bindValue(":ALBUM", m_album);
             query.bindValue(":COMPILATION", m_compilation);
@@ -451,22 +469,28 @@
             if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
             {
                 MythDB::DBError("music insert album", query);
-                return;
+                return -1;
             }
             m_albumid = query.lastInsertId().toInt();
         }
     }
 
+    return m_albumid;
+}
+
+int MusicMetadata::getGenreId()
+{
     if (m_genreid < 0)
     {
-        // Genres
+        MSqlQuery query(MSqlQuery::InitCon());
+
         query.prepare("SELECT genre_id FROM music_genres "
                     "WHERE genre = :GENRE ;");
         query.bindValue(":GENRE", m_genre);
         if (!query.exec() || !query.isActive())
         {
             MythDB::DBError("music select genre id", query);
-            return;
+            return -1;
         }
         if (query.next())
         {
@@ -480,12 +504,29 @@
             if (!query.exec() || !query.isActive() || query.numRowsAffected() <= 0)
             {
                 MythDB::DBError("music insert genre", query);
-                return;
+                return -1;
             }
             m_genreid = query.lastInsertId().toInt();
         }
     }
 
+    return m_genreid;
+}
+
+void MusicMetadata::dumpToDatabase()
+{
+    if (m_directoryid < 0)
+        getDirectoryId();
+
+    if (m_artistid < 0)
+        getArtistId();
+
+    if (m_albumid < 0)
+        getAlbumId();
+
+    if (m_genreid < 0)
+        getGenreId();
+
     // We have all the id's now. We can insert it.
     QString strQuery;
     if (m_id < 1)
@@ -494,13 +535,13 @@
                    " artist_id, album_id,    name,         genre_id,"
                    " year,      track,       length,       filename,"
                    " rating,    format,      date_entered, date_modified,"
-                   " numplays,  track_count, size) "
+                   " numplays,  track_count, size,         hostname) "
                    "VALUES ( "
                    " :DIRECTORY, "
                    " :ARTIST,   :ALBUM,      :TITLE,       :GENRE,"
                    " :YEAR,     :TRACKNUM,   :LENGTH,      :FILENAME,"
                    " :RATING,   :FORMAT,     :DATE_ADD,    :DATE_MOD,"
-                   " :PLAYCOUNT,:TRACKCOUNT, :SIZE );";
+                   " :PLAYCOUNT,:TRACKCOUNT, :SIZE,        :HOSTNAME );";
     }
     else
     {
@@ -520,9 +561,15 @@
                    ", numplays = :PLAYCOUNT "
                    ", track_count = :TRACKCOUNT "
                    ", size = :SIZE "
+                   ", hostname = :HOSTNAME "
                    "WHERE song_id= :ID ;";
     }
 
+    QString sqldir = m_filename.section('/', 0, -2);
+    QString sqlfilename = m_filename.section('/', -1);
+
+    MSqlQuery query(MSqlQuery::InitCon());
+
     query.prepare(strQuery);
 
     query.bindValue(":DIRECTORY", m_directoryid);
@@ -546,6 +593,7 @@
 
     query.bindValue(":TRACKCOUNT", m_trackCount);
     query.bindValue(":SIZE", (quint64)m_fileSize);
+    query.bindValue(":HOSTNAME", m_hostname);
 
     if (!query.exec())
         MythDB::DBError("MusicMetadata::dumpToDatabase - updating music_songs",
@@ -712,40 +760,77 @@
     return m_formattedtitle;
 }
 
-QString MusicMetadata::Filename(bool find) const
+void MusicMetadata::setFilename(const QString& lfilename)
+{
+    m_filename = lfilename;
+    m_actualFilename.clear();
+}
+
+QString MusicMetadata::Filename(bool find)
 {
     // if not asked to find the file just return the raw filename from the DB
     if (find == false)
         return m_filename;
 
+    if (!m_actualFilename.isEmpty())
+        return m_actualFilename;
+
     // check for a cd track
     if (m_filename.endsWith(".cda"))
+    {
+        m_actualFilename = m_filename;
         return m_filename;
+    }
 
     // check for http urls etc
     if (m_filename.contains("://"))
+    {
+        m_actualFilename = m_filename;
         return m_filename;
+    }
 
     // first check to see if the filename is complete
     if (QFile::exists(m_filename))
+    {
+        m_actualFilename = m_filename;
         return m_filename;
-
-    // next try appending the start directory
-    if (QFile::exists(getMusicDirectory() + m_filename))
-        return getMusicDirectory() + m_filename;
+    }
 
     // maybe it's in our 'Music' storage group
-    //FIXME: this is just looking on the master BE
-    QString filename = gCoreContext->GenMythURL(gCoreContext->GetSetting("MasterServerIP"),
-                                                gCoreContext->GetNumSetting("MasterServerPort"),
-                                                m_filename, "Music");
-    if (RemoteFile::Exists(filename))
-        return filename;
+    QString mythUrl = RemoteFile::FindFile(m_filename, m_hostname, "Music");
+    if (!mythUrl.isEmpty())
+    {
+        m_actualFilename = mythUrl;
+
+        QUrl url(mythUrl);
+        if (url.host() != m_hostname)
+        {
+            m_hostname = url.host();
+            saveHostname();
+        }
+
+        return mythUrl;
+    }
 
     // not found
     LOG(VB_GENERAL, LOG_ERR, QString("MusicMetadata: Asked to get the filename for a track but no file found: %1")
                                      .arg(m_filename));
-    return QString();
+
+    m_actualFilename = METADATA_INVALID_FILENAME;
+
+    return m_actualFilename;
+}
+
+/// try to find the track on the local file system
+QString MusicMetadata::getLocalFilename(void)
+{
+    // try the file name as is first
+    if (QFile::exists(m_filename))
+        return m_filename;
+
+    // not found so now try to find the file in the local 'Music' storage group
+    StorageGroup storageGroup("Music", gCoreContext->GetHostName(), false);
+    return storageGroup.FindFile(m_filename);
 }
 
 void MusicMetadata::setField(const QString &field, const QString &data)
@@ -902,10 +987,12 @@
     // add the images found in the tag to the ones we got from the DB
 
     if (!m_albumArt)
-        m_albumArt = new AlbumArtImages(this);
+        m_albumArt = new AlbumArtImages(this, false);
 
     for (int x = 0; x < albumart.size(); x++)
     {
+        AlbumArtImage *image = albumart.at(x);
+        image->filename = QString("%1-%2").arg(m_id).arg(image->filename);
         m_albumArt->addImage(albumart.at(x));
     }
 
@@ -1000,52 +1087,43 @@
         }
         else
         {
-            if (res.startsWith("myth://"))
+            // check for the image in the storage group
+            QUrl url(res);
+
+            if (url.path().isEmpty() || url.host().isEmpty() || url.userName().isEmpty())
             {
-                // check for the image in the storage group
-                if (!RemoteFile::Exists(res))
-                {
-                    if (albumart_image->embedded)
-                    {
-                        // image is embedded try to extract it from the tag and cache it for latter
-                        //TODO need to update this to work with storage groups
+                return QString("");
+            }
 
-                        return QString("");
-                    }
+            QString sUrl = RemoteFile::FindFile(url.path(), url.host(), url.userName());
 
-                    // image couldn't be found!
-                    m_albumArt->getImageList()->removeAll(albumart_image);
-                    return QString("");
-                }
-            }
-            else
+            if (sUrl.isEmpty())
             {
-                // check for the image in the local filesystem
-                if (!QFile::exists(res))
+                if (albumart_image->embedded)
                 {
-                    if (albumart_image->embedded)
+                    if (gCoreContext->IsMasterBackend() &&
+                        url.host() == gCoreContext->GetMasterHostName())
                     {
-                        // image is embedded try to extract it from the tag and cache it for latter
-                        MetaIO *tagger = getTagger();
-                        if (tagger && tagger->supportsEmbeddedImages())
-                        {
-                            QImage *image = tagger->getAlbumArt(Filename(), albumart_image->imageType);
-                            if (image)
-                            {
-                                image->save(res);
-                                delete image;
-                                delete tagger;
-                                return res;
-                            }
-                        }
-
-                        if (tagger)
-                            delete tagger;
+                        QStringList paramList;
+                        paramList.append(QString("--songid='%1'").arg(ID()));
+                        paramList.append(QString("--imagetype='%1'").arg(albumart_image->imageType));
+
+                        QString command = "mythutil --extractimage " + paramList.join(" ");
+
+                        QScopedPointer<MythSystem> cmd(MythSystem::Create(command,
+                                                    kMSAutoCleanup | kMSRunBackground |
+                                                    kMSDontDisableDrawing | kMSProcessEvents |
+                                                    kMSDontBlockInputDevs));
+                    }
+                    else
+                    {
+                        QStringList slist;
+                        slist << "MUSIC_TAG_GETIMAGE"
+                            << Hostname()
+                            << QString::number(ID())
+                            << QString::number(albumart_image->imageType);
+                        gCoreContext->SendReceiveStringList(slist);
                     }
-
-                    // image couldn't be found!
-                    m_albumArt->getImageList()->removeAll(albumart_image);
-                    return QString("");
                 }
             }
         }
@@ -1087,7 +1165,19 @@
 // NOTE the caller is responsible for deleting it
 MetaIO* MusicMetadata::getTagger(void)
 {
-    return MetaIO::createTagger(Filename(true));
+    // the taggers require direct file access so try to find
+    // the file on the local filesystem
+
+    QString filename = getLocalFilename();
+
+    if (!filename.isEmpty())
+    {
+        LOG(VB_FILE, LOG_INFO, QString("MusicMetadata::getTagger - creating tagger for %1").arg(filename));
+        return MetaIO::createTagger(filename);
+    }
+
+    LOG(VB_GENERAL, LOG_ERR, QString("MusicMetadata::getTagger - failed to find %1 on the local filesystem").arg(Filename(false)));
+    return NULL;
 }
 
 //--------------------------------------------------------------------------
@@ -1184,10 +1274,11 @@
     return true;
 }
 
-// NOTE we don't clear the existing tracks just load any new ones found in the DB
-// maybe we should also check for any removed tracks?
+/// resync our cache with the database
 void AllMusic::resync()
 {
+    uint added = 0, removed = 0, changed = 0;
+
     m_done_loading = false;
 
     QString aquery = "SELECT music_songs.song_id, music_artists.artist_id, music_artists.artist_name, "
@@ -1197,7 +1288,7 @@
                      "CONCAT_WS('/', music_directories.path, music_songs.filename) AS filename, "
                      "music_songs.rating, music_songs.numplays, music_songs.lastplay, music_songs.date_entered, "
                      "music_albums.compilation, music_songs.format, music_songs.track_count, "
-                     "music_songs.size "
+                     "music_songs.size, music_songs.hostname "
                      "FROM music_songs "
                      "LEFT JOIN music_directories ON music_songs.directory_id=music_directories.directory_id "
                      "LEFT JOIN music_artists ON music_songs.artist_id=music_artists.artist_id "
@@ -1214,45 +1305,65 @@
 
     m_numPcs = query.size() * 2;
     m_numLoaded = 0;
+    QList<MusicMetadata::IdType> idList;
 
     if (query.isActive() && query.size() > 0)
     {
         while (query.next())
         {
-            int id = query.value(0).toInt();
+            MusicMetadata::IdType id = query.value(0).toInt();
+
+            idList.append(id);
+
+            MusicMetadata *dbMeta = new MusicMetadata(
+                query.value(12).toString(),    // filename
+                query.value(2).toString(),     // artist
+                query.value(3).toString(),     // compilation artist
+                query.value(5).toString(),     // album
+                query.value(6).toString(),     // title
+                query.value(7).toString(),     // genre
+                query.value(8).toInt(),        // year
+                query.value(9).toInt(),        // track no.
+                query.value(10).toInt(),       // length
+                query.value(0).toInt(),        // id
+                query.value(13).toInt(),       // rating
+                query.value(14).toInt(),       // playcount
+                query.value(15).toDateTime(),  // lastplay
+                query.value(16).toDateTime(),  // date_entered
+                (query.value(17).toInt() > 0), // compilation
+                query.value(18).toString());   // format
+
+            dbMeta->setDirectoryId(query.value(11).toInt());
+            dbMeta->setArtistId(query.value(1).toInt());
+            dbMeta->setAlbumId(query.value(4).toInt());
+            dbMeta->setTrackCount(query.value(19).toInt());
+            dbMeta->setFileSize((quint64)query.value(20).toULongLong());
+            dbMeta->setHostname(query.value(21).toString());
 
             if (!music_map.contains(id))
             {
-                filename = query.value(12).toString();
+                // new track
 
-                MusicMetadata *mdata = new MusicMetadata(
-                    filename,
-                    query.value(2).toString(),     // artist
-                    query.value(3).toString(),     // compilation artist
-                    query.value(5).toString(),     // album
-                    query.value(6).toString(),     // title
-                    query.value(7).toString(),     // genre
-                    query.value(8).toInt(),        // year
-                    query.value(9).toInt(),        // track no.
-                    query.value(10).toInt(),       // length
-                    query.value(0).toInt(),        // id
-                    query.value(13).toInt(),       // rating
-                    query.value(14).toInt(),       // playcount
-                    query.value(15).toDateTime(),  // lastplay
-                    query.value(16).toDateTime(),  // date_entered
-                    (query.value(17).toInt() > 0), // compilation
-                    query.value(18).toString());   // format
-
-                mdata->setDirectoryId(query.value(11).toInt());
-                mdata->setArtistId(query.value(1).toInt());
-                mdata->setAlbumId(query.value(4).toInt());
-                mdata->setTrackCount(query.value(19).toInt());
-                mdata->setFileSize((quint64)query.value(20).toULongLong());
+                //  Don't delete dbMeta, as the MetadataPtrList now owns it
+                m_all_music.append(dbMeta);
 
-                //  Don't delete mdata, as PtrList now owns it
-                m_all_music.append(mdata);
+                music_map[id] = dbMeta;
 
-                music_map[id] = mdata;
+                added++;
+            }
+            else
+            {
+                // existing track, check for any changes
+                MusicMetadata *cacheMeta = music_map[id];
+
+                if (cacheMeta && !cacheMeta->compare(dbMeta))
+                {
+                    cacheMeta->reloadMetadata();
+                    changed++;
+                }
+
+                // we already have this track in the cache so don't need dbMeta anymore
+                delete dbMeta;
             }
 
             // compute max/min playcount,lastplay for all music
@@ -1277,10 +1388,35 @@
     }
     else
     {
-         LOG(VB_GENERAL, LOG_ERR, "MythMusic hasn't found any tracks! "
-                                  "That's ok with me if it's ok with you.");
+         LOG(VB_GENERAL, LOG_ERR, "MythMusic hasn't found any tracks!");
+    }
+
+    // get a list of tracks in our cache that's now not in the database
+    QList<MusicMetadata::IdType> deleteList;
+    for (int x = 0; x < m_all_music.size(); x++)
+    {
+        if (!idList.contains(m_all_music.at(x)->ID()))
+        {
+            deleteList.append(m_all_music.at(x)->ID());
+        }
+    }
+
+    // remove the no longer available tracks
+    for (int x = 0; x < deleteList.size(); x++)
+    {
+        MusicMetadata::IdType id = deleteList.at(x);
+        MusicMetadata *mdata = music_map[id];
+        m_all_music.removeAll(mdata);
+        music_map.remove(id);
+        removed++;
+        delete mdata;
     }
 
+    // tell any listeners a resync has just finished and they may need to reload/resync
+    LOG(VB_GENERAL, LOG_DEBUG, QString("AllMusic::resync sending MUSIC_RESYNC_FINISHED added: %1, removed: %2, changed: %3")
+                                      .arg(added).arg(removed).arg(changed));
+    gCoreContext->SendMessage(QString("MUSIC_RESYNC_FINISHED %1 %2 %3").arg(added).arg(removed).arg(changed));
+
     m_done_loading = true;
 }
 
@@ -1542,10 +1678,11 @@
 
 /**************************************************************************/
 
-AlbumArtImages::AlbumArtImages(MusicMetadata *metadata)
+AlbumArtImages::AlbumArtImages(MusicMetadata *metadata, bool loadFromDB)
     : m_parent(metadata)
 {
-    findImages();
+    if (loadFromDB)
+        findImages();
 }
 
 AlbumArtImages::~AlbumArtImages()
@@ -1587,7 +1724,7 @@
                 image->filename = logoUrl;
                 image->imageType = IT_FRONTCOVER;
                 image->embedded = false;
-
+                image->hostname = "";
                 m_imageList.push_back(image);
             }
         }
@@ -1603,7 +1740,7 @@
         MSqlQuery query(MSqlQuery::InitCon());
         query.prepare("SELECT albumart_id, CONCAT_WS('/', music_directories.path, "
                 "music_albumart.filename), music_albumart.filename, music_albumart.imagetype, "
-                "music_albumart.embedded "
+                "music_albumart.embedded, music_albumart.hostname "
                 "FROM music_albumart "
                 "LEFT JOIN music_directories ON "
                 "music_directories.directory_id = music_albumart.directory_id "
@@ -1629,7 +1766,7 @@
                                                                    QString("AlbumArt/") + query.value(1).toString(),
                                                                    "MusicArt");
                     else
-                        image->filename = GetConfDir() + "/MythMusic/AlbumArt/" + query.value(1).toString();
+                        image->filename = query.value(1).toString();
                 }
                 else
                 {
@@ -1638,11 +1775,12 @@
                                                                     query.value(1).toString(),
                                                                     "Music");
                     else
-                        image->filename = getMusicDirectory() + query.value(1).toString();
+                        image->filename = query.value(1).toString();
                 }
 
                 image->imageType = (ImageType) query.value(3).toInt();
                 image->embedded = embedded;
+                image->hostname = query.value(5).toString();
 
                 m_imageList.push_back(image);
             }
@@ -1663,6 +1801,88 @@
     }
 }
 
+void AlbumArtImages::scanForImages()
+{
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythUIBusyDialog *busy = new MythUIBusyDialog(tr("Scanning for music album art..."),
+                                                  popupStack, "scanbusydialog");
+
+    if (busy->Create())
+    {
+        popupStack->AddScreen(busy, false);
+    }
+    else
+    {
+        delete busy;
+        busy = NULL;
+    }
+
+    QStringList strList;
+    strList << "MUSIC_FIND_ALBUMART"
+            << m_parent->Hostname()
+            << QString::number(m_parent->ID())
+            << "1";
+
+    AlbumArtScannerThread *scanThread = new AlbumArtScannerThread(strList);
+    scanThread->start();
+
+    while (scanThread->isRunning())
+    {
+        qApp->processEvents();
+        usleep(1000);
+    }
+
+    strList = scanThread->getResult();
+
+    delete scanThread;
+
+    if (busy)
+        busy->Close();
+
+    while (!m_imageList.empty())
+    {
+        delete m_imageList.back();
+        m_imageList.pop_back();
+    }
+
+    for (int x = 2; x < strList.count(); x += 6)
+    {
+        AlbumArtImage *image = new AlbumArtImage;
+        image->id = strList[x].toInt();
+        image->imageType = (ImageType) strList[x + 1].toInt();
+        image->embedded = (strList[x + 2].toInt() == 1);
+        image->description = strList[x + 3];
+
+        if (image->embedded)
+        {
+            image->filename = gCoreContext->GenMythURL(m_parent->Hostname(), 0,
+                                                       QString("AlbumArt/") + strList[x + 4],
+                                                       "MusicArt");
+        }
+        else
+        {
+            image->filename =  gCoreContext->GenMythURL(m_parent->Hostname(), 0,
+                                                        strList[x + 4],
+                                                        "Music");
+        }
+
+        image->hostname = strList[x + 5];
+
+        LOG(VB_FILE, LOG_INFO, "AlbumArtImages::scanForImages found image");
+        LOG(VB_FILE, LOG_INFO, QString("ID: %1").arg(image->id));
+        LOG(VB_FILE, LOG_INFO, QString("ImageType: %1").arg(image->imageType));
+        LOG(VB_FILE, LOG_INFO, QString("Embedded: %1").arg(image->embedded));
+        LOG(VB_FILE, LOG_INFO, QString("Description: %1").arg(image->description));
+        LOG(VB_FILE, LOG_INFO, QString("Filename: %1").arg(image->filename));
+        LOG(VB_FILE, LOG_INFO, QString("Hostname: %1").arg(image->hostname));
+        LOG(VB_FILE, LOG_INFO, "-------------------------------");
+
+        addImage(image);
+
+        delete image;
+    }
+}
+
 AlbumArtImage *AlbumArtImages::getImage(ImageType type)
 {
     AlbumArtList::iterator it = m_imageList.begin();
@@ -1675,6 +1895,18 @@
     return NULL;
 }
 
+AlbumArtImage *AlbumArtImages::getImageByID(int imageID)
+{
+    AlbumArtList::iterator it = m_imageList.begin();
+    for (; it != m_imageList.end(); ++it)
+    {
+        if ((*it)->id == imageID)
+            return *it;
+    }
+
+    return NULL;
+}
+
 QStringList AlbumArtImages::getImageFilenames(void) const
 {
     QStringList paths;
@@ -1752,6 +1984,27 @@
     return type;
 }
 
+// static method to get image type from the type name
+ImageType AlbumArtImages::getImageTypeFromName(const QString &name)
+{
+    ImageType type = IT_UNKNOWN;
+
+    if (name.toLower() == "front")
+        type = IT_FRONTCOVER;
+    else if (name.toLower() == "back")
+        type = IT_BACKCOVER;
+    else if (name.toLower() == "inlay")
+        type = IT_INLAY;
+    else if (name.toLower() == "cd")
+        type = IT_CD;
+    else if (name.toLower() == "artist")
+        type = IT_ARTIST;
+    else if (name.toLower() == "unknown")
+        type = IT_UNKNOWN;
+
+    return type;
+}
+
 void AlbumArtImages::addImage(const AlbumArtImage &newImage)
 {
     // do we already have an image of this type?
@@ -1780,36 +2033,7 @@
         image->imageType = newImage.imageType;
         image->embedded = newImage.embedded;
         image->description = newImage.description;
-    }
-
-    // if this is an embedded image copy it to disc to speed up its display
-    MetaIO *tagger = m_parent->getTagger();
-
-    if (tagger)
-    {
-        if (image->embedded && tagger->supportsEmbeddedImages())
-        {
-            QString path = GetConfDir() + "/MythMusic/AlbumArt/";
-            QDir dir(path);
-
-            QString filename = QString("%1-%2.jpg").arg(m_parent->ID()).arg(AlbumArtImages::getTypeFilename(image->imageType));
-            if (!QFile::exists(path + filename))
-            {
-                if (!dir.exists())
-                    dir.mkpath(path);
-
-                QImage *saveImage = tagger->getAlbumArt(m_parent->Filename(), image->imageType);
-                if (saveImage)
-                {
-                    saveImage->save(path + filename, "JPEG");
-                    delete saveImage;
-                }
-            }
-
-            image->filename = path + filename;
-        }
-
-        delete tagger;
+        image->hostname = newImage.hostname;
     }
 }
 
@@ -1857,15 +2081,15 @@
         {
             // re-use the same id this image had before
             query.prepare("INSERT INTO music_albumart ( albumart_id, "
-                          "filename, imagetype, song_id, directory_id, embedded ) "
-                          "VALUES ( :ID, :FILENAME, :TYPE, :SONGID, :DIRECTORYID, :EMBED );");
+                          "filename, imagetype, song_id, directory_id, embedded, hostname ) "
+                          "VALUES ( :ID, :FILENAME, :TYPE, :SONGID, :DIRECTORYID, :EMBED, :HOSTNAME );");
             query.bindValue(":ID", image->id);
         }
         else
         {
             query.prepare("INSERT INTO music_albumart ( filename, "
-                        "imagetype, song_id, directory_id, embedded ) VALUES ( "
-                        ":FILENAME, :TYPE, :SONGID, :DIRECTORYID, :EMBED );");
+                        "imagetype, song_id, directory_id, embedded, hostname ) VALUES ( "
+                        ":FILENAME, :TYPE, :SONGID, :DIRECTORYID, :EMBED, :HOSTNAME );");
         }
 
         QFileInfo fi(image->filename);
@@ -1875,9 +2099,15 @@
         query.bindValue(":SONGID", image->embedded ? trackID : 0);
         query.bindValue(":DIRECTORYID", image->embedded ? 0 : directoryID);
         query.bindValue(":EMBED", image->embedded);
+        query.bindValue(":HOSTNAME", image->hostname);
 
         if (!query.exec())
             MythDB::DBError("AlbumArtImages::dumpToDatabase - "
                             "add/update music_albumart", query);
+        else
+        {
+            if (image->id <= 0)
+                image->id = query.lastInsertId().toInt();
+        }
     }
 }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicmetadata.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicmetadata.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicmetadata.h	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicmetadata.h	2014-05-05 12:30:23.000000000 +0200
@@ -18,7 +18,8 @@
 // mythtv
 #include "mythtypes.h"
 #include "mythmetaexp.h"
-#include <mthread.h>
+#include "mthread.h"
+#include "mythcorecontext.h"
 
 class AllMusic;
 class AlbumArtImages;
@@ -39,13 +40,14 @@
 {
   public:
     AlbumArtImage(void) :
-            id(0), filename(""), imageType(IT_UNKNOWN),
+            id(0), filename(""), hostname(""), imageType(IT_UNKNOWN),
             description(""), embedded(false) {}
     AlbumArtImage(AlbumArtImage *image) :
-            id(image->id), filename(image->filename), imageType(image->imageType),
+            id(image->id), filename(image->filename), hostname(image->hostname), imageType(image->imageType),
             description(image->description), embedded(image->embedded) {}
      int       id;
      QString   filename;
+     QString   hostname;
      ImageType imageType;
      QString   description;
      bool      embedded;
@@ -68,6 +70,8 @@
 #define ID_TO_ID(x) x & METADATA_ID_MASK;
 #define ID_TO_REPO(x)  x >> METADATA_REPO_SHIFT
 
+#define METADATA_INVALID_FILENAME "**NOT FOUND**"
+
 class META_PUBLIC MusicMetadata
 {
     Q_DECLARE_TR_FUNCTIONS(MusicMetadata)
@@ -161,16 +165,16 @@
     void setGenre(const QString &lgenre) { m_genre = lgenre; }
 
     void setDirectoryId(int ldirectoryid) { m_directoryid = ldirectoryid; }
-    int getDirectoryId() const { return m_directoryid; }
+    int getDirectoryId();
 
     void setArtistId(int lartistid) { m_artistid = lartistid; }
-    int getArtistId() const { return m_artistid; }
+    int getArtistId();
 
     void setAlbumId(int lalbumid) { m_albumid = lalbumid; }
-    int getAlbumId() const { return m_albumid; }
+    int getAlbumId();
 
     void setGenreId(int lgenreid) { m_genreid = lgenreid; }
-    int getGenreId() const { return m_genreid; }
+    int getGenreId();
 
     int Year() const { return m_year; }
     void setYear(int lyear) { m_year = lyear; }
@@ -195,10 +199,14 @@
     bool isDBTrack(void) const { return ID_TO_REPO(m_id) == RT_Database; }
     bool isRadio(void) const { return ID_TO_REPO(m_id) == RT_Radio; }
 
-    QString Filename(bool find = true) const;
-    void setFilename(const QString &lfilename) { m_filename = lfilename; }
+    QString Filename(bool find = true);
+    void setFilename(const QString &lfilename);
+    QString getLocalFilename(void);
+
+    QString Hostname(void) { return m_hostname; }
+    void setHostname(const QString &host) { m_hostname = host; }
 
-    uint64_t FileSize() const;
+    uint64_t FileSize() const { return m_fileSize; }
     void setFileSize(uint64_t lfilesize) { m_fileSize = lfilesize; }
 
     QString Format() const { return m_format; }
@@ -250,9 +258,10 @@
     void toMap(InfoMap &metadataMap, const QString &prefix = "");
 
     void persist(void);
-    void UpdateModTime(void) const;
-    bool hasChanged() const { return m_changed; }
-    int  compare(const MusicMetadata *other) const;
+
+    bool hasChanged(void) const { return m_changed; }
+
+    bool compare(MusicMetadata *mdata) const;
 
     // static functions
     static MusicMetadata *createFromFilename(const QString &filename);
@@ -274,6 +283,7 @@
     void setCompilationFormatting(bool cd = false);
     QString formatReplaceSymbols(const QString &format);
     void checkEmptyFields(void);
+    void saveHostname(void);
 
     QString m_artist;
     QString m_compilation_artist;
@@ -303,7 +313,9 @@
     AlbumArtImages *m_albumArt;
 
     IdType   m_id;
-    QString  m_filename;
+    QString  m_filename;       // file name as stored in the DB
+    QString  m_hostname;       // host where file is located as stored in the DB
+    QString  m_actualFilename; // actual URL of the file if found
     uint64_t m_fileSize;
     bool     m_changed;
 
@@ -325,13 +337,14 @@
     static QString m_formatcompilationcdtrack;
 };
 
-bool operator==(const MusicMetadata& a, const MusicMetadata& b);
-bool operator!=(const MusicMetadata& a, const MusicMetadata& b);
+bool operator==(MusicMetadata& a, MusicMetadata& b);
+bool operator!=(MusicMetadata& a, MusicMetadata& b);
 
 Q_DECLARE_METATYPE(MusicMetadata *)
 
 typedef QList<MusicMetadata*> MetadataPtrList;
 Q_DECLARE_METATYPE(MetadataPtrList *)
+Q_DECLARE_METATYPE(ImageType)
 
 //---------------------------------------------------------------------------
 
@@ -434,18 +447,38 @@
 
 //----------------------------------------------------------------------------
 
+class AlbumArtScannerThread: public MThread
+{
+  public:
+    AlbumArtScannerThread(QStringList strList) :
+            MThread("AlbumArtScanner"), m_strList(strList) {}
+
+    virtual void run()
+    {
+        RunProlog();
+        gCoreContext->SendReceiveStringList(m_strList);
+        RunEpilog();
+    }
+
+    QStringList getResult(void) { return m_strList; }
+
+  private:
+    QStringList m_strList;
+};
 
 class META_PUBLIC AlbumArtImages
 {
     Q_DECLARE_TR_FUNCTIONS(AlbumArtImages)
 
   public:
-    AlbumArtImages(MusicMetadata *metadata);
+    AlbumArtImages(MusicMetadata *metadata, bool loadFromDB = true);
     ~AlbumArtImages();
 
+    void           scanForImages(void);
     void           addImage(const AlbumArtImage &newImage);
     uint           getImageCount() { return m_imageList.size(); }
     AlbumArtImage *getImage(ImageType type);
+    AlbumArtImage *getImageByID(int imageID);
     QStringList    getImageFilenames(void) const;
     AlbumArtList  *getImageList(void) { return &m_imageList; }
     AlbumArtImage *getImageAt(uint index);
@@ -455,6 +488,7 @@
     static ImageType guessImageType(const QString &filename);
     static QString   getTypeName(ImageType type);
     static QString   getTypeFilename(ImageType type);
+    static ImageType getImageTypeFromName(const QString &name);
 
   private:
     void findImages(void);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicutils.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicutils.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicutils.cpp	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicutils.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -21,26 +21,6 @@
 #include "musicmetadata.h"
 #include "musicutils.h"
 
-static QString musicDirectory;
-
-QString getMusicDirectory(void)
-{
-    if (musicDirectory.isEmpty())
-    {
-        musicDirectory = gCoreContext->GetSetting("MusicLocation");
-        musicDirectory = QDir::cleanPath(musicDirectory);
-        if (!musicDirectory.isEmpty() && !musicDirectory.endsWith("/"))
-            musicDirectory += "/";
-    }
-
-    return musicDirectory;
-}
-
-void setMusicDirectory(const QString &musicDir)
-{
-    musicDirectory = musicDir;
-}
-
 static QRegExp badChars = QRegExp("(/|\\\\|:|\'|\"|\\?|\\|)");
 
 QString fixFilename(const QString &filename)
@@ -50,128 +30,43 @@
     return ret;
 }
 
-QString findIcon(const QString &type, const QString &name)
-{
-    QString cleanName = fixFilename(name);
-    QString file = QString("Icons/%1/%2").arg(type).arg(cleanName);
-
-    // first look in the 'MusicArt' storage group
-    QString filename = gCoreContext->GenMythURL(gCoreContext->GetSetting("MasterServerIP"),
-                                                gCoreContext->GetNumSetting("MasterServerPort"),
-                                                file, "MusicArt");
-
-    if (RemoteFile::Exists(filename + ".jpg"))
-        return filename + ".jpg";
-
-    if (RemoteFile::Exists(filename + ".jpeg"))
-        return filename + ".jpeg";
-
-    if (RemoteFile::Exists(filename + ".png"))
-        return filename + ".png";
-
-    if (RemoteFile::Exists(filename + ".gif"))
-        return filename + ".gif";
-
-    // not found so try the local config directory
-    file = GetConfDir() + "MythMusic/" + file;
-
-    if (QFile::exists(file + ".jpg"))
-        return file + ".jpg";
-
-    if (QFile::exists(file + ".jpeg"))
-        return file + ".jpeg";
-
-    if (QFile::exists(file + ".png"))
-        return file + ".png";
-
-    if (QFile::exists(file + ".gif"))
-        return file + ".gif";
-
-    LOG(VB_FILE, LOG_INFO, QString("findicon: not found for type: %1, name: %2").arg(type).arg(name));
-
-    return QString();
-}
-
-//TODO this needs updating to also use storage groups
-uint calcTrackLength(const QString &musicFile)
+static QMap<QString, QString> iconMap;
+QString findIcon(const QString &type, const QString &name, bool ignoreCache)
 {
-//    const char *type = NULL;
+    LOG(VB_FILE, LOG_INFO, QString("findicon: looking for type: %1, name: %2").arg(type).arg(name));
 
-    AVFormatContext *inputFC = NULL;
-    AVInputFormat *fmt = NULL;
-
-//     if (type)
-//         fmt = av_find_input_format(type);
-
-    // Open recording
-    LOG(VB_GENERAL, LOG_DEBUG, QString("calcTrackLength: Opening '%1'")
-            .arg(musicFile));
-
-    QByteArray inFileBA = musicFile.toLocal8Bit();
-
-    int ret = avformat_open_input(&inputFC, inFileBA.constData(), fmt, NULL);
-
-    if (ret)
-    {
-        LOG(VB_GENERAL, LOG_ERR, "calcTrackLength: Couldn't open input file" +
-                                  ENO);
-        return 0;
-    }
-
-    // Getting stream information
-    ret = avformat_find_stream_info(inputFC, NULL);
-
-    if (ret < 0)
+    if (!ignoreCache)
     {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("calcTrackLength: Couldn't get stream info, error #%1").arg(ret));
-        avformat_close_input(&inputFC);
-        inputFC = NULL;
-        return 0;
+        QMap<QString, QString>::iterator i = iconMap.find(type + name);
+        if (i != iconMap.end())
+        {
+            LOG(VB_FILE, LOG_INFO, QString("findicon: found in cache %1").arg(i.value()));
+            return i.value();
+        }
     }
 
-    uint duration = 0;
-    long long time = 0;
+    QString cleanName = fixFilename(name);
+    QString file = QString("Icons/%1/%2").arg(type).arg(cleanName);
+    QStringList imageExtensions = QStringList() << ".jpg" << ".jpeg" << ".png" << ".gif";
+    QString filename;
 
-    for (uint i = 0; i < inputFC->nb_streams; i++)
+    // TODO also look on any slave BEs?
+    for (int x = 0; x < imageExtensions.count(); x++)
     {
-        AVStream *st = inputFC->streams[i];
-        char buf[256];
-
-        avcodec_string(buf, sizeof(buf), st->codec, false);
-
-        switch (inputFC->streams[i]->codec->codec_type)
+        filename = RemoteFile::FindFile(file + imageExtensions[x], gCoreContext->GetMasterHostName(), "MusicArt");
+        if (!filename.isEmpty())
         {
-            case AVMEDIA_TYPE_AUDIO:
-            {
-                AVPacket pkt;
-                av_init_packet(&pkt);
-
-                while (av_read_frame(inputFC, &pkt) >= 0)
-                {
-                    if (pkt.stream_index == (int)i)
-                        time = time + pkt.duration;
-
-                    av_free_packet(&pkt);
-                }
-
-                duration = time * av_q2d(inputFC->streams[i]->time_base);
-                break;
-            }
-
-            default:
-                LOG(VB_GENERAL, LOG_ERR,
-                    QString("Skipping unsupported codec %1 on stream %2")
-                        .arg(inputFC->streams[i]->codec->codec_type).arg(i));
-                break;
+            LOG(VB_FILE, LOG_INFO, QString("findicon: found at %1").arg(filename));
+            iconMap.insert(type + name, filename);
+            return filename;
         }
     }
 
-    // Close input file
-    avformat_close_input(&inputFC);
-    inputFC = NULL;
+    iconMap.insert(type + name, QString());
+
+    LOG(VB_FILE, LOG_INFO, QString("findicon: not found type: %1, name: %2").arg(type).arg(name));
 
-    return duration;
+    return QString();
 }
 
 inline QString fixFileToken_sl(QString token)
@@ -182,9 +77,8 @@
     return token;
 }
 
-QString filenameFromMetadata(MusicMetadata *track, bool createDir)
+QString filenameFromMetadata(MusicMetadata *track)
 {
-    QDir directoryQD(getMusicDirectory());
     QString filename;
     QString fntempl = gCoreContext->GetSetting("FilenameTemplate");
     bool no_ws = gCoreContext->GetNumSetting("NoWhitespace", 0);
@@ -242,14 +136,6 @@
         LOG(VB_GENERAL, LOG_ERR, "Invalid file storage definition.");
     }
 
-    if (createDir)
-    {
-        QFileInfo fi(filename);
-        if (!directoryQD.mkpath(getMusicDirectory() + fi.path()))
-            LOG(VB_GENERAL, LOG_ERR,
-                QString("filenameFromMetadata: Failed to create directory path: '%1'").arg(getMusicDirectory() + filename));
-    }
-
     return filename;
 }
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicutils.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicutils.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/musicutils.h	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/musicutils.h	2014-05-05 12:30:23.000000000 +0200
@@ -12,23 +12,14 @@
 #undef TStringToQString
 #define TStringToQString(s) QString::fromUtf8(s.toCString(true))
 
-/// get music directory for this host
-META_PUBLIC QString getMusicDirectory(void);
-
-// get music directory for this host
-META_PUBLIC void setMusicDirectory(const QString &musicDir);
-
 /// remove any bad filename characters
 META_PUBLIC QString fixFilename(const QString &filename);
 
 /// find an image for a artist or genre
-META_PUBLIC QString findIcon(const QString &type, const QString &name);
-
-/// calculate a tracks length by parsing the frames
-META_PUBLIC uint calcTrackLength(const QString &musicFile);
+META_PUBLIC QString findIcon(const QString &type, const QString &name, bool ignoreCache = false);
 
 /// create a filename using the template in the settings and a MusicMetadata object
-META_PUBLIC QString filenameFromMetadata(MusicMetadata *track, bool createDir = true);
+META_PUBLIC QString filenameFromMetadata(MusicMetadata *track);
 
 /// try to find a track in the db using the given artist, album and title
 META_PUBLIC bool isNewTune(const QString &artist, const QString &album, const QString &title);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythimage.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythimage.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythimage.cpp	2014-05-04 17:43:16.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythimage.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -256,18 +256,22 @@
     return false;
 }
 
-// FIXME: Get rid of LoadScaleImage
-bool MythImage::Load(const QString &filename, bool scale)
+bool MythImage::Load(const QString &filename)
 {
+    if (filename.isEmpty())
+        return false;
+
     QImage *im = NULL;
-    if (scale)
-        im = GetMythUI()->LoadScaleImage(filename);
-    else
+    if (filename.startsWith("myth://"))
     {
-        if (filename.startsWith("myth://"))
+        // Attempting a file transfer on a file that doesn't exist throws
+        // a lot of noisy warnings on the backend and frontend, so to avoid
+        // that first check it's there
+        QUrl url(filename);
+        QString mythUrl = RemoteFile::FindFile(url.path(), url.host(), url.userName());
+        if (!mythUrl.isEmpty())
         {
-            im = new QImage();
-            RemoteFile *rf = new RemoteFile(filename, false, false, 0);
+            RemoteFile *rf = new RemoteFile(mythUrl, false, false, 0);
 
             QByteArray data;
             bool ret = rf->SaveAs(data);
@@ -275,29 +279,43 @@
             delete rf;
 
             if (ret)
+            {
+                im = new QImage();
                 im->loadFromData(data);
+            }
+        }
 #if 0
-            else
-                LOG(VB_GENERAL, LOG_ERR,
-                    QString("MythImage::Load failed to load remote image %1")
-                        .arg(filename));
+        else
+            LOG(VB_GENERAL, LOG_ERR,
+                QString("MythImage::Load failed to load remote image %1")
+                    .arg(filename));
 #endif
 
-        }
-        else if ((filename.startsWith("http://")) ||
-                 (filename.startsWith("https://")) ||
-                 (filename.startsWith("ftp://")))
+    }
+    else if ((filename.startsWith("http://")) ||
+                (filename.startsWith("https://")) ||
+                (filename.startsWith("ftp://")))
+    {
+        QByteArray data;
+        if (GetMythDownloadManager()->download(filename, &data))
         {
             im = new QImage();
-            QByteArray data;
-            if (GetMythDownloadManager()->download(filename, &data))
-                im->loadFromData(data);
-        }
-        else
-        {
-            im = new QImage(filename);
+            im->loadFromData(data);
         }
     }
+    else
+    {
+        QString absoluteUrl = filename;
+        if (!absoluteUrl.startsWith('/'))
+            GetMythUI()->FindThemeFile(absoluteUrl);
+        im = new QImage(absoluteUrl);
+    }
+
+    if (im && im->isNull())
+    {
+        delete im;
+        im = NULL;
+    }
 
     SetFileName(filename);
     if (im)
@@ -306,6 +324,8 @@
         delete im;
         return true;
     }
+    else
+        LOG(VB_GUI, LOG_WARNING, QString("MythImage::Load(%1) failed").arg(filename));
 
     return false;
 }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythimage.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythimage.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythimage.h	2014-05-04 17:43:16.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythimage.h	2014-05-05 12:30:23.000000000 +0200
@@ -53,7 +53,7 @@
     void Assign(const QPixmap &pix);
 
     bool Load(MythImageReader *reader);
-    bool Load(const QString &filename, bool scale = true);
+    bool Load(const QString &filename);
 
     void Resize(const QSize &newSize, bool preserveAspect = false);
     void Reflect(ReflectAxis axis, int shear, int scale, int length,
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuihelper.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuihelper.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuihelper.cpp	2014-05-04 17:43:16.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuihelper.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -1522,6 +1522,11 @@
         QString cachefilepath = GetThemeCacheDir() + '/' + label;
         QFileInfo cacheFileInfo(cachefilepath);
 
+        // If the file isn't in the disk cache, then we don't want to bother
+        // checking the last modified times of the original
+        if (!cacheFileInfo.exists())
+            return NULL;
+
         // Now compare the time on the source versus our cached copy
         QDateTime srcLastModified;
 
@@ -1571,7 +1576,7 @@
                     ret = painter->GetFormatImage();
 
                 // Load file from disk cache to memory cache
-                if (ret && ret->Load(cachefilepath, false))
+                if (ret && ret->Load(cachefilepath))
                 {
                     // Add to ram cache, and skip saving to disk since that is
                     // where we found this in the first place.
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuiimage.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuiimage.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuiimage.cpp	2014-05-04 17:43:16.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuiimage.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -71,6 +71,7 @@
     reflectLength = 100;
     reflectShear = 0;
     reflectSpacing = 0,
+    isThemeImage = false;
     maskImage = NULL;
 }
 
@@ -93,6 +94,8 @@
     reflectShear = other.reflectShear;
     reflectSpacing = other.reflectSpacing;
 
+    isThemeImage = other.isThemeImage;
+
     SetMaskImage(other.maskImage);
 }
 
@@ -228,7 +231,7 @@
         QString filename = imProps.filename;
         MythImage *image = NULL;
 
-        bool bForceResize = false;
+        bool bResize = false;
         bool bFoundInCache = false;
 
         int w = -1;
@@ -242,7 +245,7 @@
             if (imProps.forceSize.height() != -1)
                 h = imProps.forceSize.height();
 
-            bForceResize = true;
+            bResize = true;
         }
 
         if (!imageReader)
@@ -301,7 +304,23 @@
 
         if (image && !bFoundInCache)
         {
-            if (bForceResize)
+            // Even if an explicit size wasn't defined this image may still need
+            // to be scaled because of a difference between the theme resolution
+            // and the screen resolution. We want to avoid scaling twice.
+            if (!bResize && imProps.isThemeImage)
+            {
+                float wmult; // Width multipler
+                float hmult; // Height multipler
+                GetMythUI()->GetScreenSettings(wmult, hmult);
+                if (wmult != 1.0f || hmult != 1.0f)
+                {
+                    w = image->size().width() * wmult;
+                    h = image->size().height() * hmult;
+                    bResize = true;
+                }
+            }
+
+            if (bResize)
                 image->Resize(QSize(w, h), imProps.preserveAspect);
 
             if (imProps.isMasked)
@@ -617,6 +636,7 @@
 
     if (m_imageProperties.filename != m_OrigFilename)
     {
+        m_imageProperties.isThemeImage = true;
         m_imageProperties.filename = m_OrigFilename;
 
         if (m_animatedImage)
@@ -659,6 +679,7 @@
 void MythUIImage::SetFilename(const QString &filename)
 {
     QWriteLocker updateLocker(&d->m_UpdateLock);
+    m_imageProperties.isThemeImage = false;
     m_imageProperties.filename = filename;
     if (filename == m_OrigFilename)
         emit DependChanged(true);
@@ -674,6 +695,7 @@
                                  int high)
 {
     QWriteLocker updateLocker(&d->m_UpdateLock);
+    m_imageProperties.isThemeImage = false;
     m_imageProperties.filename = filepattern;
     m_LowNum = low;
     m_HighNum = high;
@@ -738,6 +760,7 @@
         return;
     }
 
+    m_imageProperties.isThemeImage = false;
     m_imageProperties.filename = img->GetFileName();
 
     img->IncrRef();
@@ -790,6 +813,8 @@
     QWriteLocker updateLocker(&d->m_UpdateLock);
     QSize aSize = GetFullArea().size();
 
+    m_imageProperties.isThemeImage = false;
+
     QVector<MythImage *>::iterator it;
 
     for (it = images->begin(); it != images->end(); ++it)
@@ -1238,6 +1263,7 @@
 
     if (element.tagName() == "filename")
     {
+        m_imageProperties.isThemeImage = true; // This is an image distributed with the them
         m_OrigFilename = m_imageProperties.filename = getFirstText(element);
 
         if (m_imageProperties.filename.endsWith('/'))
@@ -1274,6 +1300,7 @@
     }
     else if (element.tagName() == "filepattern")
     {
+        m_imageProperties.isThemeImage = true; // This is an image distributed with the theme
         m_OrigFilename = m_imageProperties.filename = getFirstText(element);
         QString tmp = element.attribute("low");
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuiimage.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuiimage.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuiimage.h	2014-05-04 17:43:16.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuiimage.h	2014-05-05 12:30:23.000000000 +0200
@@ -63,6 +63,8 @@
     int reflectShear;
     int reflectSpacing;
 
+    bool isThemeImage;
+
   private:
     void Init(void);
     void Copy(const ImageProperties &other);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/mainserver.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/mainserver.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/mainserver.cpp	2014-05-05 12:28:42.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/mainserver.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -71,6 +71,8 @@
 #include "videoutils.h"
 #include "mythlogging.h"
 #include "filesysteminfo.h"
+#include "metaio.h"
+#include "musicmetadata.h"
 
 /** Milliseconds to wait for an existing thread from
  *  process request thread pool.
@@ -809,6 +811,66 @@
     {
         HandleScanVideos(pbs);
     }
+    else if (command == "SCAN_MUSIC")
+    {
+        HandleScanMusic(tokens, pbs);
+    }
+    else if (command == "MUSIC_TAG_UPDATE_VOLATILE")
+    {
+        if (listline.size() != 6)
+            LOG(VB_GENERAL, LOG_ERR, "Bad MUSIC_TAG_UPDATE_VOLATILE");
+        else
+            HandleMusicTagUpdateVolatile(listline, pbs);
+    }
+    else if (command == "MUSIC_CALC_TRACK_LENGTH")
+    {
+        if (listline.size() != 3)
+            LOG(VB_GENERAL, LOG_ERR, "Bad MUSIC_CALC_TRACK_LENGTH");
+        else
+            HandleMusicCalcTrackLen(listline, pbs);
+    }
+    else if (command == "MUSIC_TAG_UPDATE_METADATA")
+    {
+        if (listline.size() != 3)
+            LOG(VB_GENERAL, LOG_ERR, "Bad MUSIC_TAG_UPDATE_METADATA");
+        else
+            HandleMusicTagUpdateMetadata(listline, pbs);
+    }
+    else if (command == "MUSIC_FIND_ALBUMART")
+    {
+        if (listline.size() != 4)
+            LOG(VB_GENERAL, LOG_ERR, "Bad MUSIC_FIND_ALBUMART");
+        else
+            HandleMusicFindAlbumArt(listline, pbs);
+    }
+    else if (command == "MUSIC_TAG_GETIMAGE")
+    {
+        if (listline.size() < 4)
+            LOG(VB_GENERAL, LOG_ERR, "Bad MUSIC_TAG_GETIMAGE");
+        else
+            HandleMusicTagGetImage(listline, pbs);
+    }
+    else if (command == "MUSIC_TAG_ADDIMAGE")
+    {
+        if (listline.size() < 5)
+            LOG(VB_GENERAL, LOG_ERR, LOC + "Bad MUSIC_TAG_ADDIMAGE");
+        else
+            HandleMusicTagAddImage(listline, pbs);
+    }
+    else if (command == "MUSIC_TAG_REMOVEIMAGE")
+    {
+        if (listline.size() < 4)
+            LOG(VB_GENERAL, LOG_ERR, LOC + "Bad MUSIC_TAG_REMOVEIMAGE");
+        else
+            HandleMusicTagRemoveImage(listline, pbs);
+    }
+    else if (command == "MUSIC_TAG_CHANGEIMAGE")
+    {
+        if (listline.size() < 5)
+            LOG(VB_GENERAL, LOG_ERR, LOC + "Bad MUSIC_TAG_CHANGEIMAGE");
+        else
+            HandleMusicTagChangeImage(listline, pbs);
+    }
     else if (command == "ALLOW_SHUTDOWN")
     {
         if (tokens.size() != 1)
@@ -3402,10 +3464,12 @@
 void MainServer::HandleSGFileQuery(QStringList &sList,
                                      PlaybackSock *pbs)
 {
+//format: QUERY_SG_FILEQUERY <host> <storagegroup> <filename> <allowfallback (optional)>
+
     MythSocket *pbssock = pbs->getSocket();
     QStringList strList;
 
-    if (sList.size() != 4)
+    if (sList.size() < 4)
     {
         LOG(VB_GENERAL, LOG_ERR,
             QString("HandleSGFileQuery: Invalid Request. %1")
@@ -3419,6 +3483,11 @@
     QString groupname = sList.at(2);
     QString filename = sList.at(3);
 
+    bool allowFallback = true;
+    if (sList.size() >= 5)
+        allowFallback = (sList.at(4).toInt() > 0);
+    LOG(VB_FILE, LOG_ERR, QString("HandleSGFileQuery - allowFallback: %1").arg(allowFallback));
+
     bool slaveUnreachable = false;
 
     LOG(VB_FILE, LOG_INFO, QString("HandleSGFileQuery: %1")
@@ -3429,7 +3498,7 @@
         (wantHost == gCoreContext->GetSetting("BackendServerIP6")))
     {
         LOG(VB_FILE, LOG_INFO, "HandleSGFileQuery: Getting local info");
-        StorageGroup sg(groupname, gCoreContext->GetHostName());
+        StorageGroup sg(groupname, gCoreContext->GetHostName(), allowFallback);
         strList = sg.GetFileInfo(filename);
     }
     else
@@ -5129,6 +5198,952 @@
         SendResponse(pbssock, retlist);
 }
 
+void MainServer::HandleScanMusic(const QStringList &slist, PlaybackSock *pbs)
+{
+    MythSocket *pbssock = pbs->getSocket();
+
+    QStringList strlist;
+
+    if (ismaster)
+    {
+        // get a list of hosts with a directory defined for the 'Music' storage group
+        MSqlQuery query(MSqlQuery::InitCon());
+        QString sql = "SELECT DISTINCT hostname "
+                      "FROM storagegroup "
+                      "WHERE groupname = 'Music'";
+        if (!query.exec(sql) || !query.isActive())
+            MythDB::DBError("MainServer::HandleScanMusic get host list", query);
+        else
+        {
+            while(query.next())
+            {
+                QString hostname = query.value(0).toString();
+
+                if (hostname == gCoreContext->GetHostName())
+                {
+                    // this is the master BE with a music storage group directory defined so run the file scanner
+                    LOG(VB_GENERAL, LOG_INFO, QString("HandleScanMusic: running filescanner on master BE '%1'").arg(hostname));
+                    QScopedPointer<MythSystem> cmd(MythSystem::Create("mythutil --scanmusic",
+                                                                      kMSAutoCleanup | kMSRunBackground |
+                                                                      kMSDontDisableDrawing | kMSProcessEvents |
+                                                                      kMSDontBlockInputDevs));
+                }
+                else
+                {
+                    // found a slave BE so ask it to run the file scanner
+                    PlaybackSock *slave = GetMediaServerByHostname(hostname);
+                    if (slave)
+                    {
+                        LOG(VB_GENERAL, LOG_INFO, QString("HandleScanMusic: asking slave '%1' to run file scanner").arg(hostname));
+                        slave->ForwardRequest(slist);
+                        slave->DecrRef();
+                    }
+                    else
+                    {
+                        LOG(VB_GENERAL, LOG_INFO,
+                            QString("HandleScanMusic: Failed to grab slave socket on '%1'").arg(hostname));
+                    }
+                }
+            }
+        }
+    }
+    else
+    {
+        // must be a slave with a music storage group directory defined so run the file scanner
+        LOG(VB_GENERAL, LOG_INFO, QString("HandleScanMusic: running filescanner on slave BE '%1'").arg(gCoreContext->GetHostName()));
+        QScopedPointer<MythSystem> cmd(MythSystem::Create("mythutil --scanmusic",
+                                                          kMSAutoCleanup | kMSRunBackground |
+                                                          kMSDontDisableDrawing | kMSProcessEvents |
+                                                          kMSDontBlockInputDevs));
+    }
+
+    strlist << "OK";
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
+void MainServer::HandleMusicTagUpdateVolatile(const QStringList &slist, PlaybackSock *pbs)
+{
+// format: MUSIC_TAG_UPDATE_VOLATILE <hostname> <songid> <rating> <playcount> <lastplayed>
+
+    QStringList strlist;
+
+    MythSocket *pbssock = pbs->getSocket();
+
+    QString hostname = slist[1];
+
+    if (ismaster && hostname != gCoreContext->GetHostName())
+    {
+        // forward the request to the slave BE
+        PlaybackSock *slave = GetMediaServerByHostname(hostname);
+        if (slave)
+        {
+            LOG(VB_GENERAL, LOG_INFO, QString("HandleMusicTagUpdateVolatile: asking slave '%1' to update the metadata").arg(hostname));
+            strlist = slave->ForwardRequest(slist);
+            slave->DecrRef();
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_INFO,
+                QString("HandleMusicTagUpdateVolatile: Failed to grab slave socket on '%1'").arg(hostname));
+
+            strlist << "ERROR: slave not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+    }
+    else
+    {
+        //  run mythutil to update the metadata
+        QStringList paramList;
+        paramList.append(QString("--songid='%1'").arg(slist[2]));
+        paramList.append(QString("--rating='%1'").arg(slist[3]));
+        paramList.append(QString("--playcount='%1'").arg(slist[4]));
+        paramList.append(QString("--lastplayed='%1'").arg(slist[5]));
+
+        QString command = "mythutil --updatemeta " + paramList.join(" ");
+
+        LOG(VB_GENERAL, LOG_INFO, QString("HandleMusicTagUpdateVolatile: running %1'").arg(command));
+        QScopedPointer<MythSystem> cmd(MythSystem::Create(command,
+                                                          kMSAutoCleanup | kMSRunBackground |
+                                                          kMSDontDisableDrawing | kMSProcessEvents |
+                                                          kMSDontBlockInputDevs));
+    }
+
+    strlist << "OK";
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
+void MainServer::HandleMusicCalcTrackLen(const QStringList &slist, PlaybackSock *pbs)
+{
+// format: MUSIC_CALC_TRACK_LENGTH <hostname> <songid>
+
+    QStringList strlist;
+
+    MythSocket *pbssock = pbs->getSocket();
+
+    QString hostname = slist[1];
+
+    if (ismaster && hostname != gCoreContext->GetHostName())
+    {
+        // forward the request to the slave BE
+        PlaybackSock *slave = GetMediaServerByHostname(hostname);
+        if (slave)
+        {
+            LOG(VB_GENERAL, LOG_INFO, QString("HandleMusicCalcTrackLen: asking slave '%1' to update the track length").arg(hostname));
+            strlist = slave->ForwardRequest(slist);
+            slave->DecrRef();
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_INFO,
+                QString("HandleMusicCalcTrackLen: Failed to grab slave socket on '%1'").arg(hostname));
+
+            strlist << "ERROR: slave not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+    }
+    else
+    {
+        //  run mythutil to calc the tracks length
+        QStringList paramList;
+        paramList.append(QString("--songid='%1'").arg(slist[2]));
+
+        QString command = "mythutil --calctracklen " + paramList.join(" ");
+
+        LOG(VB_GENERAL, LOG_INFO, QString("HandleMusicCalcTrackLen: running %1'").arg(command));
+        QScopedPointer<MythSystem> cmd(MythSystem::Create(command,
+                                                          kMSAutoCleanup | kMSRunBackground |
+                                                          kMSDontDisableDrawing | kMSProcessEvents |
+                                                          kMSDontBlockInputDevs));
+    }
+
+    strlist << "OK";
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
+void MainServer::HandleMusicTagUpdateMetadata(const QStringList &slist, PlaybackSock *pbs)
+{
+// format: MUSIC_TAG_UPDATE_METADATA <hostname> <songid>
+// this assumes the new metadata has already been saved to the database for this track
+
+    QStringList strlist;
+
+    MythSocket *pbssock = pbs->getSocket();
+
+    QString hostname = slist[1];
+
+    if (ismaster && hostname != gCoreContext->GetHostName())
+    {
+        // forward the request to the slave BE
+        PlaybackSock *slave = GetMediaServerByHostname(hostname);
+        if (slave)
+        {
+            LOG(VB_GENERAL, LOG_INFO, QString("HandleMusicTagUpdateMetadata: asking slave '%1' "
+                                              "to update the metadata").arg(hostname));
+            strlist = slave->ForwardRequest(slist);
+            slave->DecrRef();
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_INFO, QString("HandleMusicTagUpdateMetadata: Failed to grab "
+                                              "slave socket on '%1'").arg(hostname));
+
+            strlist << "ERROR: slave not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+    }
+    else
+    {
+        // load the new metadata from the database
+        int songID = slist[2].toInt();
+
+        MusicMetadata *mdata = MusicMetadata::createFromID(songID);
+
+        if (!mdata)
+        {
+            LOG(VB_GENERAL, LOG_ERR, QString("HandleMusicTagUpdateMetadata: "
+                                             "Cannot find metadata for trackid: %1")
+                                             .arg(songID));
+
+            strlist << "ERROR: track not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+
+        MetaIO *tagger = mdata->getTagger();
+        if (tagger)
+        {
+            if (!tagger->write(mdata->getLocalFilename(), mdata))
+            {
+                LOG(VB_GENERAL, LOG_ERR, QString("HandleMusicTagUpdateMetadata: "
+                                                 "Failed to write to tag for trackid: %1")
+                                                 .arg(songID));
+
+                strlist << "ERROR: write to tag failed";
+
+                if (pbssock)
+                    SendResponse(pbssock, strlist);
+
+                return;
+            }
+        }
+    }
+
+    strlist << "OK";
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
+
+void MainServer::HandleMusicFindAlbumArt(const QStringList &slist, PlaybackSock *pbs)
+{
+// format: MUSIC_FIND_ALBUMART <hostname> <songid> <update_database>
+
+    QStringList strlist;
+
+    MythSocket *pbssock = pbs->getSocket();
+
+    QString hostname = slist[1];
+
+    if (ismaster && hostname != gCoreContext->GetHostName())
+    {
+        // forward the request to the slave BE
+        PlaybackSock *slave = GetMediaServerByHostname(hostname);
+        if (slave)
+        {
+            LOG(VB_GENERAL, LOG_INFO, QString("HandleMusicFindAlbumArt: asking slave '%1' "
+                                              "to update the albumart").arg(hostname));
+            strlist = slave->ForwardRequest(slist);
+            slave->DecrRef();
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_INFO, QString("HandleMusicFindAlbumArt: Failed to grab "
+                                              "slave socket on '%1'").arg(hostname));
+
+            strlist << "ERROR: slave not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+    }
+    else
+    {
+        // find the track in the database
+        int songID = slist[2].toInt();
+        bool updateDatabase = (slist[3].toInt() == 1);
+
+        MusicMetadata *mdata = MusicMetadata::createFromID(songID);
+
+        if (!mdata)
+        {
+            LOG(VB_GENERAL, LOG_ERR, QString("HandleMusicFindAlbumArt: "
+                                             "Cannot find metadata for trackid: %1")
+                                             .arg(songID));
+
+            strlist << "ERROR: track not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+
+        // find any directory images
+        QFileInfo fi(mdata->getLocalFilename());
+        QDir dir = fi.absoluteDir();
+
+        QString nameFilter = gCoreContext->GetSetting("AlbumArtFilter",
+                                                    "*.png;*.jpg;*.jpeg;*.gif;*.bmp");
+        dir.setNameFilters(nameFilter.split(";"));
+
+        QStringList files = dir.entryList();
+
+        // create an empty image list
+        AlbumArtImages *images = new AlbumArtImages(mdata, false);
+
+        fi.setFile(mdata->Filename(false));
+        QString startDir = fi.path();
+
+        for (int x = 0; x < files.size(); x++)
+        {
+            fi.setFile(files.at(x));
+            AlbumArtImage *image = new AlbumArtImage();
+            image->filename = startDir + '/' + fi.fileName();
+            image->hostname = gCoreContext->GetHostName();
+            image->embedded = false;
+            image->imageType = AlbumArtImages::guessImageType(image->filename);
+            image->description = "";
+            images->addImage(image);
+            delete image;
+        }
+
+        // find any embedded albumart in the tracks tag
+        MetaIO *tagger = mdata->getTagger();
+        if (tagger)
+        {
+            if (tagger->supportsEmbeddedImages())
+            {
+                AlbumArtList artList = tagger->getAlbumArtList(mdata->getLocalFilename());
+
+                for (int x = 0; x < artList.count(); x++)
+                {
+                    AlbumArtImage *image = artList.at(x);
+                    image->filename = QString("%1-%2").arg(mdata->ID()).arg(image->filename);
+                    images->addImage(image);
+                }
+            }
+
+            delete tagger;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_ERR, QString("HandleMusicFindAlbumArt: "
+                                             "Failed to find a tagger for trackid: %1")
+                                             .arg(songID));
+        }
+
+        // finally save the result to the database
+        if (updateDatabase)
+            images->dumpToDatabase();
+
+        strlist << "OK";
+        strlist.append(QString("%1").arg(images->getImageCount()));
+
+        for (uint x = 0; x < images->getImageCount(); x++)
+        {
+            AlbumArtImage *image = images->getImageAt(x);
+            strlist.append(QString("%1").arg(image->id));
+            strlist.append(QString("%1").arg((int)image->imageType));
+            strlist.append(QString("%1").arg(image->embedded));
+            strlist.append(image->description);
+            strlist.append(image->filename);
+            strlist.append(image->hostname);
+
+            // if this is an embedded image update the cached image
+            if (image->embedded)
+            {
+                QStringList paramList;
+                paramList.append(QString("--songid='%1'").arg(mdata->ID()));
+                paramList.append(QString("--imagetype='%1'").arg(image->imageType));
+
+                QString command = "mythutil --extractimage " + paramList.join(" ");
+                QScopedPointer<MythSystem> cmd(MythSystem::Create(command,
+                                                    kMSAutoCleanup | kMSRunBackground |
+                                                    kMSDontDisableDrawing | kMSProcessEvents |
+                                                    kMSDontBlockInputDevs));
+            }
+        }
+
+        delete images;
+    }
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
+void MainServer::HandleMusicTagGetImage(const QStringList &slist, PlaybackSock *pbs)
+{
+// format: MUSIC_TAG_GETIMAGE <hostname> <songid> <imagetype>
+
+    QStringList strlist;
+
+    MythSocket *pbssock = pbs->getSocket();
+
+    QString hostname = slist[1];
+    QString songid = slist[2];
+    QString imagetype = slist[3];
+
+    if (ismaster && hostname != gCoreContext->GetHostName())
+    {
+
+        // forward the request to the slave BE
+        PlaybackSock *slave = GetMediaServerByHostname(hostname);
+        if (slave)
+        {
+            LOG(VB_GENERAL, LOG_INFO, LOC +
+                QString("HandleMusicTagGetImage: asking slave '%1' to "
+                        "extract the image").arg(hostname));
+            strlist = slave->ForwardRequest(slist);
+            slave->DecrRef();
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_INFO, LOC +
+                QString("HandleMusicTagGetImage: Failed to grab slave "
+                        "socket on '%1'").arg(hostname));
+        }
+    }
+    else
+    {
+        QStringList paramList;
+        paramList.append(QString("--songid='%1'").arg(songid));
+        paramList.append(QString("--imagetype='%1'").arg(imagetype));
+
+        QString command = "mythutil --extractimage " + paramList.join(" ");
+
+        QScopedPointer<MythSystem> cmd(MythSystem::Create(command,
+                                        kMSAutoCleanup | kMSRunBackground |
+                                        kMSDontDisableDrawing | kMSProcessEvents |
+                                        kMSDontBlockInputDevs));
+    }
+
+    strlist << "OK";
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
+void MainServer::HandleMusicTagChangeImage(const QStringList &slist, PlaybackSock *pbs)
+{
+// format: MUSIC_TAG_CHANGEIMAGE <hostname> <songid> <oldtype> <newtype>
+
+    QStringList strlist;
+
+    MythSocket *pbssock = pbs->getSocket();
+
+    QString hostname = slist[1];
+
+    if (ismaster && hostname != gCoreContext->GetHostName())
+    {
+        // forward the request to the slave BE
+        PlaybackSock *slave = GetMediaServerByHostname(hostname);
+        if (slave)
+        {
+            LOG(VB_GENERAL, LOG_INFO, LOC +
+                QString("HandleMusicTagChangeImage: asking slave '%1' "
+                        "to update the metadata").arg(hostname));
+            strlist = slave->ForwardRequest(slist);
+            slave->DecrRef();
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_INFO, LOC +
+                QString("HandleMusicTagChangeImage: Failed to grab "
+                        "slave socket on '%1'").arg(hostname));
+
+            strlist << "ERROR: slave not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+    }
+    else
+    {
+        int songID = slist[2].toInt();
+        ImageType oldType = (ImageType)slist[3].toInt();
+        ImageType newType = (ImageType)slist[4].toInt();
+
+        // load the metadata from the database
+        MusicMetadata *mdata = MusicMetadata::createFromID(songID);
+
+        if (!mdata)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("HandleMusicTagChangeImage: "
+                        "Cannot find metadata for trackid: %1")
+                    .arg(songID));
+
+            strlist << "ERROR: track not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+
+        mdata->setFilename(mdata->getLocalFilename());
+
+        AlbumArtImages *albumArt = mdata->getAlbumArtImages();
+        AlbumArtImage *image = albumArt->getImage(oldType);
+        if (image)
+        {
+            AlbumArtImage oldImage = *image;
+
+            image->imageType = (ImageType) newType;
+
+            if (image->imageType == oldImage.imageType)
+            {
+                // nothing to change
+                strlist << "OK";
+
+                if (pbssock)
+                    SendResponse(pbssock, strlist);
+
+                delete mdata;
+
+                return;
+            }
+
+            // rename any cached image to match the new type
+            if (image->embedded)
+            {
+                // change the image type in the tag if it supports it
+                MetaIO *tagger = mdata->getTagger();
+
+                if (tagger && tagger->supportsEmbeddedImages())
+                {
+                    if (!tagger->changeImageType(mdata->getLocalFilename(), &oldImage, image->imageType))
+                    {
+                        LOG(VB_GENERAL, LOG_ERR, "HandleMusicTagChangeImage: failed to change image type");
+
+                        strlist << "ERROR: failed to change image type";
+
+                        if (pbssock)
+                            SendResponse(pbssock, strlist);
+
+                        delete mdata;
+                        delete tagger;
+
+                        return;
+                    }
+                }
+
+                if (tagger)
+                    delete tagger;
+
+                // update the new cached image filename
+                StorageGroup artGroup("MusicArt", gCoreContext->GetHostName(), false);
+                oldImage.filename = artGroup.FindFile("AlbumArt/" + image->filename);
+
+                QFileInfo fi(oldImage.filename);
+                image->filename = QString(fi.path() + "/%1-%2.jpg")
+                                          .arg(mdata->ID())
+                                          .arg(AlbumArtImages::getTypeFilename(image->imageType));
+
+                // remove any old cached file with the same name as the new one
+                if (QFile::exists(image->filename))
+                    QFile::remove(image->filename);
+
+                // rename the old cached file to the new one
+                if (image->filename != oldImage.filename && QFile::exists(oldImage.filename))
+                    QFile::rename(oldImage.filename, image->filename);
+                else
+                {
+                    // extract the image from the tag and cache it
+                    QStringList paramList;
+                    paramList.append(QString("--songid='%1'").arg(mdata->ID()));
+                    paramList.append(QString("--imagetype='%1'").arg(image->imageType));
+
+                    QString command = "mythutil --extractimage " + paramList.join(" ");
+
+                    QScopedPointer<MythSystem> cmd(MythSystem::Create(command,
+                                                   kMSAutoCleanup | kMSRunBackground |
+                                                   kMSDontDisableDrawing | kMSProcessEvents |
+                                                   kMSDontBlockInputDevs));
+                }
+            }
+            else
+            {
+                QFileInfo fi(oldImage.filename);
+
+                // get the new images filename
+                image->filename = QString(fi.absolutePath() + "/%1.jpg")
+                        .arg(AlbumArtImages::getTypeFilename(image->imageType));
+
+                if (image->filename != oldImage.filename && QFile::exists(oldImage.filename))
+                {
+                    // remove any old cached file with the same name as the new one
+                    QFile::remove(image->filename);
+                    // rename the old cached file to the new one
+                    QFile::rename(oldImage.filename, image->filename);
+                }
+            }
+        }
+
+        delete mdata;
+    }
+
+    strlist << "OK";
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
+void MainServer::HandleMusicTagAddImage(const QStringList& slist, PlaybackSock* pbs)
+{
+// format: MUSIC_TAG_ADDIMAGE <hostname> <songid> <filename> <imagetype>
+
+    QStringList strlist;
+
+    MythSocket *pbssock = pbs->getSocket();
+
+    QString hostname = slist[1];
+
+    if (ismaster && hostname != gCoreContext->GetHostName())
+    {
+        // forward the request to the slave BE
+        PlaybackSock *slave = GetMediaServerByHostname(hostname);
+        if (slave)
+        {
+            LOG(VB_GENERAL, LOG_INFO, LOC +
+                QString("HandleMusicTagAddImage: asking slave '%1' "
+                        "to add the image").arg(hostname));
+            strlist = slave->ForwardRequest(slist);
+            slave->DecrRef();
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_INFO, LOC +
+                QString("HandleMusicTagAddImage: Failed to grab "
+                        "slave socket on '%1'").arg(hostname));
+
+            strlist << "ERROR: slave not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+    }
+    else
+    {
+        // load the metadata from the database
+        int songID = slist[2].toInt();
+        QString filename = slist[3];
+        ImageType imageType = (ImageType) slist[4].toInt();
+
+        MusicMetadata *mdata = MusicMetadata::createFromID(songID);
+
+        if (!mdata)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("HandleMusicTagAddImage: Cannot find metadata for trackid: %1")
+                        .arg(songID));
+
+            strlist << "ERROR: track not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+
+        MetaIO *tagger = mdata->getTagger();
+
+        if (!tagger)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                "HandleMusicTagAddImage: failed to find a tagger for track");
+
+            strlist << "ERROR: tagger not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            delete mdata;
+            return;
+        }
+
+        if (!tagger->supportsEmbeddedImages())
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                "HandleMusicTagAddImage: asked to write album art to the tag "
+                "but the tagger doesn't support it!");
+
+            strlist << "ERROR: embedded images not supported by tag";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            delete tagger;
+            delete mdata;
+            return;
+        }
+
+        // is the image in the 'MusicArt' storage group
+        bool isDirectoryImage = false;
+        StorageGroup storageGroup("MusicArt", gCoreContext->GetHostName(), false);
+        QString imageFilename = storageGroup.FindFile("AlbumArt/" + filename);
+        if (imageFilename.isEmpty())
+        {
+            // not found there so look in the tracks directory
+            QFileInfo fi(mdata->getLocalFilename());
+            imageFilename = fi.absolutePath() + '/' + filename;
+            isDirectoryImage = true;
+        }
+
+        if (!QFile::exists(imageFilename))
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("HandleMusicTagAddImage: cannot find image file %1").arg(filename));
+
+            strlist << "ERROR: failed to find image file";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            delete tagger;
+            delete mdata;
+            return;
+        }
+
+        AlbumArtImage image;
+        image.filename = imageFilename;
+        image.imageType = imageType;
+
+        if (!tagger->writeAlbumArt(mdata->getLocalFilename(), &image))
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC + "HandleMusicTagAddImage: failed to write album art to tag");
+
+            strlist << "ERROR: failed to write album art to tag";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            if (!isDirectoryImage)
+                QFile::remove(imageFilename);
+
+            delete tagger;
+            delete mdata;
+            return;
+        }
+
+        // only remove the image if we temporarily saved one to the 'AlbumArt' storage group
+        if (!isDirectoryImage)
+            QFile::remove(imageFilename);
+
+        delete tagger;
+        delete mdata;
+    }
+
+
+    strlist << "OK";
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
+void MainServer::HandleMusicTagRemoveImage(const QStringList& slist, PlaybackSock* pbs)
+{
+// format: MUSIC_TAG_REMOVEIMAGE <hostname> <songid> <imageid>
+
+    QStringList strlist;
+
+    MythSocket *pbssock = pbs->getSocket();
+
+    QString hostname = slist[1];
+
+    if (ismaster && hostname != gCoreContext->GetHostName())
+    {
+        // forward the request to the slave BE
+        PlaybackSock *slave = GetMediaServerByHostname(hostname);
+        if (slave)
+        {
+            LOG(VB_GENERAL, LOG_INFO, LOC +
+                QString("HandleMusicTagRemoveImage: asking slave '%1' "
+                        "to remove the image").arg(hostname));
+            strlist = slave->ForwardRequest(slist);
+            slave->DecrRef();
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_INFO, LOC +
+                QString("HandleMusicTagRemoveImage: Failed to grab "
+                        "slave socket on '%1'").arg(hostname));
+
+            strlist << "ERROR: slave not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+    }
+    else
+    {
+        int songID = slist[2].toInt();
+        int imageID = slist[3].toInt();
+
+        // load the metadata from the database
+        MusicMetadata *mdata = MusicMetadata::createFromID(songID);
+
+        if (!mdata)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("HandleMusicTagRemoveImage: Cannot find metadata for trackid: %1")
+                        .arg(songID));
+
+            strlist << "ERROR: track not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+
+        MetaIO *tagger = mdata->getTagger();
+
+        if (!tagger)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                "HandleMusicTagRemoveImage: failed to find a tagger for track");
+
+            strlist << "ERROR: tagger not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            delete mdata;
+            return;
+        }
+
+        if (!tagger->supportsEmbeddedImages())
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC + "HandleMusicTagRemoveImage: asked to remove album art "
+                                           "from the tag but the tagger doesn't support it!");
+
+            strlist << "ERROR: embedded images not supported by tag";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            delete mdata;
+            delete tagger;
+            return;
+        }
+
+        AlbumArtImage *image = mdata->getAlbumArtImages()->getImageByID(imageID);
+        if (!image)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("HandleMusicTagRemoveImage: Cannot find image for imageid: %1")
+                        .arg(imageID));
+
+            strlist << "ERROR: image not found";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            delete mdata;
+            delete tagger;
+            return;
+        }
+
+        if (!tagger->removeAlbumArt(mdata->getLocalFilename(), image))
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC + "HandleMusicTagRemoveImage: failed to remove album art from tag");
+
+            strlist << "ERROR: failed to remove album art from tag";
+
+            if (pbssock)
+                SendResponse(pbssock, strlist);
+
+            return;
+        }
+    }
+
+    strlist << "OK";
+
+    if (pbssock)
+        SendResponse(pbssock, strlist);
+}
+
 void MainServer::HandleFileTransferQuery(QStringList &slist,
                                          QStringList &commands,
                                          PlaybackSock *pbs)
@@ -6218,7 +7233,7 @@
             else
             {
                 LOG(VB_GENERAL, LOG_ERR, QString("ERROR: LocalFilePath "
-                    "unable to find local path for '%1'.") .arg(opath));
+                    "unable to find local path for '%1'.") .arg(url.toString()));
                 lpath = "";
             }
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/mainserver.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/mainserver.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/mainserver.h	2014-05-04 17:43:46.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/mainserver.h	2014-05-05 12:30:23.000000000 +0200
@@ -216,6 +216,15 @@
     void HandleSettingQuery(QStringList &tokens, PlaybackSock *pbs);
     void HandleSetSetting(QStringList &tokens, PlaybackSock *pbs);
     void HandleScanVideos(PlaybackSock *pbs);
+    void HandleScanMusic(const QStringList &slist, PlaybackSock *pbs);
+    void HandleMusicTagUpdateVolatile(const QStringList &slist, PlaybackSock *pbs);
+    void HandleMusicTagUpdateMetadata(const QStringList &slist, PlaybackSock *pbs);
+    void HandleMusicFindAlbumArt(const QStringList &slist, PlaybackSock *pbs);
+    void HandleMusicTagGetImage(const QStringList &slist, PlaybackSock *pbs);
+    void HandleMusicTagAddImage(const QStringList &slist, PlaybackSock *pbs);
+    void HandleMusicTagRemoveImage(const QStringList &slist, PlaybackSock *pbs);
+    void HandleMusicTagChangeImage(const QStringList &slist, PlaybackSock *pbs);
+    void HandleMusicCalcTrackLen(const QStringList &slist, PlaybackSock *pbs);
     void HandleVersion(MythSocket *socket, const QStringList &slist);
     void HandleBackendRefresh(MythSocket *socket);
     void HandleQueryLoad(PlaybackSock *pbs);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/content.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/content.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/content.cpp	2014-05-05 12:28:41.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/content.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -673,8 +673,8 @@
     // check to see if the file exists
     // ----------------------------------------------------------------------
 
-    if (QFile::exists( sFileName ))
-        return QFileInfo( sFileName );
+    if (!QFile::exists( sFileName ))
+        return GetFile( "Music", sFileName );
 
     return QFileInfo();
 }
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/upnpcdsmusic.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/upnpcdsmusic.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/upnpcdsmusic.cpp	2014-05-04 17:43:46.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/upnpcdsmusic.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -12,6 +12,7 @@
 
 #include <QFileInfo>
 
+#include "storagegroup.h"
 #include "upnpcdsmusic.h"
 #include "httprequest.h"
 #include "mythcorecontext.h"
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/commandlineparser.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/commandlineparser.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/commandlineparser.cpp	2014-05-05 12:28:38.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/commandlineparser.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -149,6 +149,20 @@
         << add("--print-notification-template", "printntemplate", false,
                 "Print the template to be sent to the frontend", "")
                 ->SetGroup("Messaging")
+
+        // musicmetautils.cpp
+        << add("--scanmusic", "scanmusic", false,
+                "Scan the 'Music' Storage Group for music files", "")
+                ->SetGroup("Music Scanning")
+        << add("--updatemeta", "updatemeta", false,
+                "Update a music tracks database record and tag with new metadata", "")
+                ->SetGroup("Metadata Reading/Writing")
+        << add("--extractimage", "extractimage", false,
+                "Extract an embedded image from a tracks tag and cache it in the AlbumArt storage group", "")
+                ->SetGroup("Metadata Reading/Writing")
+        << add("--calctracklen", "calctracklen", false,
+                "Decode a track to determine its exact length", "")
+                ->SetGroup("Metadata Reading/Writing")
         );
 
     // mpegutils.cpp
@@ -203,6 +217,34 @@
     add("--fixseektable", "fixseektable", false, "(optional) fix the seektable if missing for a recording", "")
         ->SetChildOf("checkrecordings");
 
+    // musicmetautils.cpp
+    add("--songid", "songid", "", "ID of track to update", "")
+            ->SetChildOf("updatemeta");
+    add("--title", "title", "", "(optional) Title of track", "")
+            ->SetChildOf("updatemeta");
+    add("--artist", "artist", "", "(optional) Artist of track", "")
+            ->SetChildOf("updatemeta");
+    add("--album", "album", "", "(optional) Album of track", "")
+            ->SetChildOf("updatemeta");
+    add("--genre", "genre", "", "(optional) Genre of track", "")
+            ->SetChildOf("updatemeta");
+    add("--trackno", "trackno", "", "(optional) Track No. of track", "")
+            ->SetChildOf("updatemeta");
+    add("--year", "year", "", "(optional) Year of track", "")
+            ->SetChildOf("updatemeta");
+    add("--rating", "rating", "", "(optional) Rating of track", "")
+            ->SetChildOf("updatemeta");
+    add("--playcount", "playcount", "", "(optional) Playcount of track", "")
+            ->SetChildOf("updatemeta");
+    add("--lastplayed", "lastplayed", "", "(optional) Last played of track", "")
+            ->SetChildOf("updatemeta");
+    add("--songid", "songid", "", "ID of track from which to get the image", "")
+            ->SetChildOf("extractimage");
+    add("--imagetype", "imagetype", "", "Type of image to extract (front, back, cd, inlay, unknown)", "")
+            ->SetChildOf("extractimage");
+    add("--songid", "songid", "", "ID of track to determine the length", "")
+            ->SetChildOf("calctracklen");
+
     // Generic Options used by more than one utility
     addRecording();
     addInFile(true);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/main.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/main.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/main.cpp	2014-05-05 12:28:38.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/main.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -22,6 +22,7 @@
 #include "markuputils.h"
 #include "messageutils.h"
 #include "recordingutils.h"
+#include "musicmetautils.h"
 #include "signalhandling.h"
 
 
@@ -107,6 +108,7 @@
     registerMarkupUtils(utilMap);
     registerMessageUtils(utilMap);
     registerRecordingUtils(utilMap);
+    registerMusicUtils(utilMap);
 
     bool cmdFound = false;
     int cmdResult = GENERIC_EXIT_OK;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/musicmetautils.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/musicmetautils.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/musicmetautils.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/musicmetautils.cpp	2014-05-05 12:30:23.000000000 +0200
@@ -0,0 +1,320 @@
+// qt
+#include <QDir>
+
+// libmyth* headers
+#include "exitcodes.h"
+#include "mythlogging.h"
+#include "storagegroup.h"
+#include "musicmetadata.h"
+#include "metaio.h"
+#include "mythcontext.h"
+#include "musicfilescanner.h"
+#include "musicutils.h"
+
+extern "C" {
+#include <libavformat/avformat.h>
+#include <libavcodec/avcodec.h>
+}
+
+// mythutils headers
+#include "commandlineparser.h"
+#include "musicmetautils.h"
+
+static int UpdateMeta(const MythUtilCommandLineParser &cmdline)
+{
+    bool ok = true;
+    int result = GENERIC_EXIT_OK;
+
+    if (cmdline.toString("songid").isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Missing --songid option");
+        return GENERIC_EXIT_INVALID_CMDLINE;
+    }
+    int songID = cmdline.toInt("songid");
+
+    MusicMetadata *mdata = MusicMetadata::createFromID(songID);
+    if (!mdata)
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Cannot find metadata for trackid: %1").arg(songID));
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+    if (!cmdline.toString("title").isEmpty())
+        mdata->setTitle(cmdline.toString("title"));
+
+    if (!cmdline.toString("artist").isEmpty())
+        mdata->setArtist(cmdline.toString("artist"));
+
+    if (!cmdline.toString("album").isEmpty())
+        mdata->setAlbum(cmdline.toString("album"));
+
+    if (!cmdline.toString("genre").isEmpty())
+        mdata->setGenre(cmdline.toString("genre"));
+
+    if (!cmdline.toString("trackno").isEmpty())
+        mdata->setTrack(cmdline.toInt("trackno"));
+
+    if (!cmdline.toString("year").isEmpty())
+        mdata->setYear(cmdline.toInt("year"));
+
+    if (!cmdline.toString("rating").isEmpty())
+        mdata->setRating(cmdline.toInt("rating"));
+
+    if (!cmdline.toString("playcount").isEmpty())
+        mdata->setPlaycount(cmdline.toInt("playcount"));
+
+    if (!cmdline.toString("lastplayed").isEmpty())
+        mdata->setLastPlay(cmdline.toDateTime("lastplayed"));
+
+    mdata->dumpToDatabase();
+
+    MetaIO *tagger = mdata->getTagger();
+    if (tagger)
+    {
+        ok = tagger->write(mdata->getLocalFilename(), mdata);
+
+        if (!ok)
+            LOG(VB_GENERAL, LOG_ERR, QString("Failed to write to tag for trackid: %1").arg(songID));
+    }
+
+    // tell any clients that the metadata for this track has changed
+    gCoreContext->SendMessage(QString("MUSIC_METADATA_CHANGED %1").arg(songID));
+
+    if (!ok)
+        result = GENERIC_EXIT_NOT_OK;
+
+    return result;
+}
+
+static int ExtractImage(const MythUtilCommandLineParser &cmdline)
+{
+    if (cmdline.toString("songid").isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Missing --songid option");
+        return GENERIC_EXIT_INVALID_CMDLINE;
+    }
+
+    if (cmdline.toString("imagetype").isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Missing --imagetype option");
+        return GENERIC_EXIT_INVALID_CMDLINE;
+    }
+
+    int songID = cmdline.toInt("songid");
+    ImageType type = (ImageType)cmdline.toInt("imagetype");
+
+    MusicMetadata *mdata = MusicMetadata::createFromID(songID);
+    if (!mdata)
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Cannot find metadata for trackid: %1").arg(songID));
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+    AlbumArtImage *image = mdata->getAlbumArtImages()->getImage(type);
+    if (!image)
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Cannot find image of type: %1").arg(type));
+        //return GENERIC_EXIT_NOT_OK;
+    }
+
+    MetaIO *tagger = mdata->getTagger();
+    if (!tagger)
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Cannot find a tagger for this file: %1").arg(mdata->Filename(false)));
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+
+    if (!image->embedded || !tagger->supportsEmbeddedImages())
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Either the image isn't embedded or the tagger doesn't support embedded images"));
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+    // find the tracks actual filename
+    StorageGroup musicGroup("Music", gCoreContext->GetHostName(), false);
+    QString trackFilename =  musicGroup.FindFile(mdata->Filename(false));
+
+    // where are we going to save the image
+    QString path;
+    StorageGroup artGroup("MusicArt", gCoreContext->GetHostName(), false);
+    QStringList dirList = artGroup.GetDirList();
+    if (dirList.size())
+        path = artGroup.FindNextDirMostFree();
+
+    if (!QDir(path).exists())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Cannot find a directory in the 'MusicArt' storage group to save to");
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+    path += "/AlbumArt/";
+    QDir dir(path);
+
+    QString filename = QString("%1-%2.jpg").arg(mdata->ID()).arg(AlbumArtImages::getTypeFilename(image->imageType));
+
+    if (QFile::exists(path + filename))
+        QFile::remove(path + filename);
+
+    if (!dir.exists())
+        dir.mkpath(path);
+
+    QImage *saveImage = tagger->getAlbumArt(trackFilename, image->imageType);
+    if (saveImage)
+    {
+        saveImage->save(path + filename, "JPEG");
+        delete saveImage;
+    }
+
+    delete tagger;
+
+    // tell any clients that the albumart for this track has changed
+    gCoreContext->SendMessage(QString("MUSIC_ALBUMART_CHANGED %1 %2").arg(songID).arg(type));
+
+    return GENERIC_EXIT_OK;
+}
+
+static int ScanMusic(const MythUtilCommandLineParser &cmdline)
+{
+    MusicFileScanner *fscan = new MusicFileScanner();
+    QStringList dirList;
+
+    if (!StorageGroup::FindDirs("Music", gCoreContext->GetHostName(), &dirList))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Failed to find any directories in the 'Music' storage group");
+        delete fscan;
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+    fscan->SearchDirs(dirList);
+    delete fscan;
+
+    return GENERIC_EXIT_OK;
+}
+
+static int CalcTrackLength(const MythUtilCommandLineParser &cmdline)
+{
+    if (cmdline.toString("songid").isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Missing --songid option");
+        return GENERIC_EXIT_INVALID_CMDLINE;
+    }
+
+    int songID = cmdline.toInt("songid");
+
+    MusicMetadata *mdata = MusicMetadata::createFromID(songID);
+    if (!mdata)
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Cannot find metadata for trackid: %1").arg(songID));
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+    QString musicFile = mdata->getLocalFilename();
+
+    if (musicFile.isEmpty() || !QFile::exists(musicFile))
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Cannot find file for trackid: %1").arg(songID));
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+    av_register_all();
+
+    AVFormatContext *inputFC = NULL;
+    AVInputFormat *fmt = NULL;
+
+    // Open track
+    LOG(VB_GENERAL, LOG_DEBUG, QString("CalcTrackLength: Opening '%1'")
+            .arg(musicFile));
+
+    QByteArray inFileBA = musicFile.toLocal8Bit();
+
+    int ret = avformat_open_input(&inputFC, inFileBA.constData(), fmt, NULL);
+
+    if (ret)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "CalcTrackLength: Couldn't open input file" +
+                                  ENO);
+        return GENERIC_EXIT_NOT_OK;
+    }
+
+    // Getting stream information
+    ret = avformat_find_stream_info(inputFC, NULL);
+
+    if (ret < 0)
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("CalcTrackLength: Couldn't get stream info, error #%1").arg(ret));
+        avformat_close_input(&inputFC);
+        inputFC = NULL;
+        return GENERIC_EXIT_NOT_OK;;
+    }
+
+    int duration = 0;
+    long long time = 0;
+
+    for (uint i = 0; i < inputFC->nb_streams; i++)
+    {
+        AVStream *st = inputFC->streams[i];
+        char buf[256];
+
+        avcodec_string(buf, sizeof(buf), st->codec, false);
+
+        switch (inputFC->streams[i]->codec->codec_type)
+        {
+            case AVMEDIA_TYPE_AUDIO:
+            {
+                AVPacket pkt;
+                av_init_packet(&pkt);
+
+                while (av_read_frame(inputFC, &pkt) >= 0)
+                {
+                    if (pkt.stream_index == (int)i)
+                        time = time + pkt.duration;
+
+                    av_free_packet(&pkt);
+                }
+
+                duration = time * av_q2d(inputFC->streams[i]->time_base);
+                break;
+            }
+
+            default:
+                LOG(VB_GENERAL, LOG_ERR,
+                    QString("Skipping unsupported codec %1 on stream %2")
+                        .arg(inputFC->streams[i]->codec->codec_type).arg(i));
+                break;
+        }
+    }
+
+    // Close input file
+    avformat_close_input(&inputFC);
+    inputFC = NULL;
+
+    if (mdata->Length() / 1000 != duration)
+    {
+        LOG(VB_GENERAL, LOG_INFO, QString("The length of this track in the database was %1s "
+                                          "it is now %2s").arg(mdata->Length() / 1000).arg(duration));
+
+        // update the track length in the database
+        mdata->setLength(duration * 1000);
+        mdata->dumpToDatabase();
+
+        // tell any clients that the metadata for this track has changed
+        gCoreContext->SendMessage(QString("MUSIC_METADATA_CHANGED %1").arg(songID));
+    }
+    else
+    {
+        LOG(VB_GENERAL, LOG_INFO, QString("The length of this track is unchanged %1s")
+                                          .arg(mdata->Length() / 1000));
+    }
+
+    return GENERIC_EXIT_OK;
+}
+
+void registerMusicUtils(UtilMap &utilMap)
+{
+    utilMap["updatemeta"] = &UpdateMeta;
+    utilMap["extractimage"] = &ExtractImage;
+    utilMap["scanmusic"] = &ScanMusic;
+    utilMap["calctracklen"] = &CalcTrackLength;
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/musicmetautils.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/musicmetautils.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/musicmetautils.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/musicmetautils.h	2014-05-05 12:30:23.000000000 +0200
@@ -0,0 +1,3 @@
+#include "mythutil.h"
+
+void registerMusicUtils(UtilMap &utilMap);
\ No newline at end of file
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/mythutil.pro mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/mythutil.pro
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythutil/mythutil.pro	2014-05-05 12:28:38.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythutil/mythutil.pro	2014-05-05 12:30:23.000000000 +0200
@@ -21,9 +21,9 @@
 # Input
 HEADERS += mythutil.h commandlineparser.h
 HEADERS += backendutils.h fileutils.h jobutils.h markuputils.h
-HEADERS += messageutils.h mpegutils.h recordingutils.h
+HEADERS += messageutils.h mpegutils.h recordingutils.h musicmetautils.h
 SOURCES += main.cpp mythutil.cpp commandlineparser.cpp
 SOURCES += backendutils.cpp fileutils.cpp jobutils.cpp markuputils.cpp
-SOURCES += messageutils.cpp mpegutils.cpp recordingutils.cpp
+SOURCES += messageutils.cpp mpegutils.cpp recordingutils.cpp musicmetautils.cpp
 
 mingw: LIBS += -lwinmm -lws2_32
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/MythCenter-wide/music-base.xml mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/MythCenter-wide/music-base.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/MythCenter-wide/music-base.xml	2014-05-04 17:43:22.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/MythCenter-wide/music-base.xml	2014-05-05 12:30:23.000000000 +0200
@@ -211,6 +211,12 @@
                             <filename>mm_stopicon.png</filename>
                         </imagetype>
                     </state>
+                    <state name="unavailable">
+                        <imagetype name="animation">
+                            <position>0,0</position>
+                            <filename>schedule_disabled.png</filename>
+                        </imagetype>
+                    </state>
                 </statetype>
 
                 <statetype name="movestate" from="basemovingtracksstate">
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/Terra/musicsettings-ui.xml mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/Terra/musicsettings-ui.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/Terra/musicsettings-ui.xml	2014-05-04 17:43:19.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/Terra/musicsettings-ui.xml	2014-05-05 12:30:23.000000000 +0200
@@ -10,15 +10,6 @@
             <value>General Settings</value>
         </textarea>
 
-        <textarea name="musiclocation_label" from="basetextarea">
-            <area>140,100,500,50</area>
-            <align>right,vcenter</align>
-            <value>Directory to hold music:</value>
-        </textarea> 
-        <textedit name="musiclocation" from="basetextedit">
-            <area>650,100,550,50</area>
-        </textedit>
-
         <textarea name="musiccddevice_label" from="basetextarea">
             <area>140,160,500,50</area>
             <align>right,vcenter</align>
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/default/musicscanner.png mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/default/musicscanner.png
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/default/musicscanner.png	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/default/musicscanner.png	2014-05-05 12:30:23.000000000 +0200
@@ -0,0 +1,92 @@
+PNG
+
+   IHDR         X   bKGD       IDATxw|$G#r6wms6&	Gqrq6wLkz$9kbw4j^N55POU,f1Yb,f1Yb,f1Yb,f1Yb,f1Yb8H-[,,GJ766^}w4&?XQ$0?'"xefr'b #?XGIX7 mB'q)Qm,84al2?HB|xe3~f^E)mQa3 8	X|j,;8O7Afz/>{A2:@v7;cG/@A(d9#kE[5C::wr'> ~@F"W.=  G??6d~ZslX7v';0/@[g7EspN~Ypnk*7(PZ&m8piH`.Y.2+ }{By_8qii@0Q: d>Yrt<~^/&f
+PRcw8p|>i<b Wp +.]+ !.CV>YS 9Xh8k ||<wKxtx##>3RV*9+EZ8~V.4/c} 8DO{w:A)nKH<To-G.fq4 olt\BF	d%/+/P.Ku&FXiH-6,h,N|a{=$k*VqJ?pKwrcxS?GfqbA Jh 0sr$#pjyVdpXRMf}YL !
+(yiup8? ebg+g%p 80bD})/<Wi9Fw87A J>	R?@aE177+U#y8bkjJ7iOMg60};@@w^:jDuJG6([[duf8xBQmbEp6*
+zhqLs%JS h%\P/ bQ3W5:pI}x$UTEiv;q  mCQmXLH"\FlR4 1'n"/7hh,#81Jeu@! }{,ULJ_Re9z mEA((KTaX>;'M(q6 *le$gk-WMv(U,Sp0Huv3err;p]e~\[D\el;t/tZYU461CA*
+GP :,(T
+XJ9&a Kv%Hn.3`I&AF	Pf*Q}x'N T8K )OI[6A"mFzXh?
+:A !sB||=:'/N,TDr:[%WLHt	ds|NnA6Y[|0![!@EAa6mEQ*#X Zp67-f J/J^F6BoBX8992c?qXS` emsA	>%+-EA(`=lvEF>
+707oUWi864Gzt)z:'@KV)<>Q c*kvG%V".+7eeiScVVVzm6 0
+lqsr^P1Y6N< nL'uAw^@`` [|Yd+f:s<ZAK!GUY"N MTx T\"u!j!>	+e(qf0<k581 VM&
+{cc&NL"!NA 
+8x{3$)Qp)(6acs-;} rAhrzpr;Em W:/*_x#}Kx" F)r{::K YMF,+]S,9Ae| ,Sf-RAZ|5rml'BKP[(Bacs<mF4Xoh5Gi}q  s=9 T!FK9qPi;K6^s@aijMy\5b?,Rd-mt-m:SEOB*Q8g1}G|~{~ND3XOW4X5XDrs-k+VI2/y_sN?1+-L#Q&V+V[d_y;:"$1!}X;y].Nl lB]/:C\4*g:jN ahJ%lrm`sN1.&"Z~	#Qm24.\G%b[-C!e\J d5"GdE
+Y'Zx/&I@yDD?6Dw;'^2yXAX ((,v4zV`)i`? <bEda"W
+)X!\r	H{Lc-}1Fq9?y RR
+!I.g'A*svDxq%Az??*2$>Ot|	c
+xq^qKs|}J\5yE5J6;~G{;L`Sytc-oYs-}t<]"WJ(Nw;i44{Bz{0S8	pF+ lQ/W\<WG=?fo'|1M$F
+8UN|`c[<5?|gE8o[{ T^jJk2XC[$rO$jV`w)l"Z` -	Mx}sAwLd! n_?JU6((H$oG=?\3v4u8 |TiYApJ<j<YK5Oe_&xDam,/vT9RdLigNar
+V8)(wkb83,0N32GwV/i;}wKC"B>OA.J>$$C|wzK9q'AA^hc-sg:G8\Jxun+mNx4?-?jCWJi\%uZ}jT.tS"[I
+9qwe;yv|4o  [AD%[l=7~ *<_y`OQ/4^2nT.Agp!s g\*
+
+N37rZ%5^+Y1k|m%| /(W,plELf`M}]Oo -TE1iJQ0h#<pCcoD|}{z8yrF#>s8oobV$Pw'nc
+t4Y&\J\
+\	,&Cr;Y+B(a~gFuo9st}+H*XqFOf9OB! 4?GkYtxE 9~[U-XQX3x<}xGBcX !W2u<fdp (UQN]7#P)}(c) oF. K%!8MYgP,cnmA	?Agt].Wd[9\]MYd'h(FF`xFGP(QSH1!Jd7wM1M"ok~4pbR4_V*<KVPO/[46004 \$*+GU~e2V|07&y<XKn?K\_}CCIdIb+*+7Ode/~W d<qO~y8!@MV2.WU*W%Zya5d/&#{WHhiU/"D*3_kUv\,[F$%:}};'&uP4./r
+'p(]]{l&%D'{*1#:IST|+[y839NxxiI80b#^UoXKl`4y/"B+	([c82i*_^v|f=^!B~cYZZ`` FxDH
+	&#t!`RDzibUQ.(g<;P	\[(0e5M	q5SSc/sQx|=<k=o`FZ)(Z(*V)UA-DkuTzzLs)pMAO;/d<^z`@O"QPs`a-Ux>^kWG*PQK=/b6rsjv^vSy4CT~T-Ntt%K%n"
+\>U;R+9]GIEkQ
+#c- TeT0 LRs!mfNFV.V?B?~Tl\:mA-d3rdbo_46`I)gURI?p_"$QYv.{b}2+b 9$$@vpP WDL7wx7Rfa=jk?@ Sl/V-[7A\R?#d@t\{H00$G<IclV%/f9K'B.!uZ'`az&^55laY3.s/Mkq7!pDOqq9}<.kc^FnWA*}oz*jfM&idp*#G:lv*|>I#-|}[uj?YE HKJ,aL]Z,88^;!O1EXh!`y|%-p =_J]Z_@e^VEeXB8WKi&MGgB%b2rP(Ep5<X=]uB}12NN`ECZd
+UZ`envr9V]c[vqD* `|jV%Fg'wS\>wKw`W4TJ#A9&*>Ixdxd|y~%6aQU+5Pc@aB<%ty})\Z0k<}>T6S~hl!imqs>eg9fViC}{!B:&De*#L$m&+Qi\SiibiTeW#Z|sbIufytP7xF1#Z12;8|FS-JHl9@KNwd-fb?`t4nlB!J D
+aFHq8pJ`lKSC?{5 	/?n[O^~_(9r`4}t3
+qNX! g<wy8o?[fV${k%qs#-3Ya2@<aI@`xS_#^g<VONxy	,t{r a7C7E,)$*!G<H).Uoa).|5+"9vO.,5m+a{.s*	}+1&2 G*}4/';?}1mMxm>	rv.]Q0OYY*u	w[` ${wr%F+XUysDj2q&NA
+9"ett?r'Q\d_qJ'7A 0G7Qx.
+9Bc">V|x]B(Zooc08 b1r""LL&EJ.]QQ9=lCXtuIrDLR6?1Oen<-y}4)hI"59efljy#* %tJ6	vxfU>;=um4mx_J3S"Nw:78[b$"&,J '&lm'2V'^xs;*ig&1"i	f#}8nGocRmL39#NI"Nta8|LAz){dp U,+0cVx|N5DXS+L_Z};jJ4$|t$DxQ.|>sfe<.fI>rYI5{ O7!' pPE:Q Pt{\!&7uE6\"}WO_"uFFX,
+:8m%Y	\GW/d;4u$aj  e61USK$
+-?$sd~T|)%G	OLKzXWrE)XSIKiE.wd!9^n)a#BF 0 AH`SNiv &\
+FLI  J/=\9rv2&DIHGS-Ob`cll_ F#u%O@Tl-&_i2(LsAxy #9T$OY^u~(yxS$
+`>!K>P]^r:HdKWl"-EMokD~C"-`'nXirRu'w=l#tJgj%p/AOcM,+kIG    IDATtvf%^)kDQgHEJr*`qT0[c B,nDHW	CHG.nI).KB0GNTn5b<'Z+ +/%:OD$=z" x0tv0$	[g R&M4d=M*jz
+JU	(AT 7+T0I'$t%Zv{j!?VUS1fB;lvV[*';A>dk_E|b6	muVz%zNgP-u_S$Zc"RZ+7:I]4]/D]`r`\jsDQS(Ht:4t!l2C3@\;2%ztIen~TG	3Du)u?)k8a	k,P\s>tk'& ^n3YR1s@13/?2vt&2Cp4qf^p;:v^>'A -w\
+~M\ towyF%5XOE`^<,"jfKdAwhtNN<eq~g>DX-VF$W8UAk/-4v1oO(N_VQ!snPTmZuFO
+`NO7re+sT%:WH}I:,IEM$A*):\"L%j<R&H{'_nK0]'3d2`eDU"A^oJ IV<
+*D4C9>Icu9SqU[q8bf3Tr:I:U<'2wH@\&f*#ZCHnI6Q=]N&EER}&'Sd)`q,hHw?2!|OB[%xl"(-5KA@VaNrbnfs$CJ5phiJMQWI-	 B?@VFYlOYX=$62qHW:!:ZA,n["(sQ	FTe%Dm626yFt#OM&!oh804tc>OLb\)$O#(2Hc\MH4B{qc,Id:4:C$q
++a}y\-2Y ZMQU"#cLHc"TkMzm!G0q"X7;zx	A!u)2<n>"Z(Q(M%ixd39{jv	qE1-D+&RU,^tN9GG$H$ik"^c	g/9 {0O/>CZ6m%G+r#]=[B,w?SO`dUT0gNbvRnL~:CT*c{jsN_6s0|]E2/?MaF-Dg_2Zp9\K>=@(@|hNS9Uc~s6XPP,4Q!z|A~B:wflVv+.Utp4Gf?#^vX .RDZ#y*_z<fS}-1*'0;2Y`-__'V^VyZt"PG!1]qo2aAyzxOIQ?}} dd8),|/ilrh#df&k0dnbj		rXX6KU]"s#!:|+#,i=*U7, TZP(,[;>9B!>jk^FF|ic<8x6Bq6QX9*;A"Rc/(a,8NrgT 'PRyJRETUFRukQj[Oh@|<90oBA;=DGG?{FF|7_OW(vwwhHm&9\HY~[fQTc?h0E"vBpkH>?vkA)'vmLl6P>Wv}ochh4*GS_?&
+A#Ldwb%:O=g:w)AnwuhRyH,hJUpT2<E=v+XHuX(j(~(,UOW5KTu({6sPO#Min!H*Lf%c:Z'^{?3|b+	qr+<LQS,O8W1hj_ee+cf%hJFjskws k
+K[hh?Qe2kJa^zpye1^II(HKuO{$BHnq.1?);.::!F^|@x%esqfs$D.[v%U?Dj`,:Ta^nzZ"C<*fTvLx E:cI]$,}da#uV	AFK~lC5hzji]&;[wB5rJ*(*GUZL^Gp+0jf)<~n7yinN+zEQp\vl6VEQ0MNn5?Hk^/ega`4t8q$d64AC%C34W^8C@4DRn+2`AR<MkZ_?mo4IkkIKOBvvnNxqDQ^)3Et}'GrXfZkm4[11H8{sgLxM?]o5q,HIp,5<)%vSXEaa6SOp2~9`LK:\>dOJii~$ iWp	rcJeupA-<@
+va.]ILh ;ZE
+^zq46vb$0t:<(`"iNR0OIrX,PZ;$SKiG -|@""C$iu4C)wmo#"-g<T  [\&t|OhAW:s vm27@(9kjOv+df\({hoK|u*0qwkH9$_|@oZQ!f`|=hunyvHS9HWmb+"3
+BYKGBHF|qRa
+v@Y'h>h5,EgCCw+Wr(*(E_h|m RBaU=8,*~!H5`KKcm^dg}}@&A&L$G5$+/qON	rwIm,1s(>D jD
+#p`&d!	b1L-D&aT(@F5OKUU3hGmZZ/cfcG\1njC[;KI869;?x&>$?I>_qJ8BJ~@VtGmQ>O)'Xy>~D)$rX,2j*d	Q$(x0Vm%|{!/.U+l_h^h
+53gjzp*nw"	ay *+>]_en6]C)IUUJc*uE`sh"{aU}L
+G FbBr2@%zt&^\( UHw	P5\rNTOPz	)@Ere	-KIYf0H(6KPm;`jr3	+,4z;.O[I)8<6~fE`   E3Rx^M0=wp\i#'0t1I8b"X	yeOV
+XN("#3(>EB7vhP1,L>^La:swQ]]|m>puSS/,`*JKKAsk3!H}tBRFFbBya\qC*fn8/=F(9rKA:p#D["@D{WxwKO[2zbepN&XEH`Y!cnTT$AE@+m:ujv	Gssb4J nR,uwwa0(>'a;\SKsvSK#fe 3.EL0!&Q[(%@}2IL8z<O?Mv8q/k7-bW!0c/@a Vt3D^bvHcT&Ud ?A4BH M4e0_]!9-&A|sjK>XbK.0.obd(k"#PY";y%c*6`U 9oGHu$E{u4|1/>F'Y80mb%t+~/:,968'*aiBK3YQ	"*CDx%]sHD#F]kQmcbL$8)Jh~{n?M~*kXjW|g+(p8|) OK{hA?hIT)!ei\Wx:}zL`F	r}@~=fK)%lo;8y` ,8uX	 DEC	/FaNGIY$J 2D[p15Bk1O g^3S?l"b;kYfMy}^gxnX-NwkX&cLttOdet/	0
+P5o>p|!L	nkf O	1qd
+W\d=P9zq\2=h(.C(X"-aM'BQoyMdb%"Hg%.3	RYG]G=kvg1g7p}7Ng&:dI'?9r_Y9zI?^"NF#A>uZ!vRx1jjN:[w7}=Ql(^,OS#
+c*BTXPP<cZ$H`X	0I8Mhz
+!EBvEO~wa"A:f,FE`\A*e0zHE`GA5,\=otM,UU*NIg+3T:bK4Oq>=>vo$F:vUZS{Ef"FW10&*lay'ZYe
+
+B(W#.
+&)L*&I0IE?GH'MZgCH^H^!7)B(|j;^v91@D\eoYIaDF7@CC{St,EklA?V`	7?pFo_%F#ph$`F4n6\orii9]@5a`ACbH$2G6#Zb%GvG 58;h+rC xvx^\XjG!_F"(,Zqe~~!**H;fqfEzF'$@k91GgMO@kd[Jb\o.wN.cf3yD 73t("c:&H4CR"$1==F	AVwB-!/}V<+5xeiB\'z((MZ<(TW
+'q%L	=@OWbGiK78&HfPoGV+|?!K|?D
+F
+-DJCTqN{L!e(_#8cD"Aq/o2 `a/OaZ[{Z7s"9NVd~_G}raVLbMLRtpXl_lK)$~IP/z7+P`
+6a
+kA=S+t#yA	P4j5|<7F:?p1q1g.pZgfnt1>::&\$.s=t4ln(Rg?eLt(0Y &C_>I3"jLHY{
+n_	>i><J0VTB2R% 1	F"Zzyl``IeVZkL6>^H7]Lv)ahh/de,L23=Rb1`h``	<t_N;_	F}IfLc1mDC
+Kif^{oBH	rC9i:aC!PD	y7wD_S'IWu+:e)T(T%(fjKPU :w46/~u#haJL #B0t+Ts!v	kiX(_$[XXh%<(W"= N`5lv$`F0j8{Ef*B_
+R4  IDAT=`Q?^?p8lS8vMMoz"+H4`,	i']pCVX]V| `M@Sc>UL )92j~m;) T {(N{:]CrY!W
+kxPn~y8&q`S09!MT9]~&ZZ&}% otCXD\aq`@qqpGEEg|uPt|A!Y8!H !{I^kUWu{.]U]<99{;[-\Hi#vx}04.Q~7^p18Q|A> 8V
+|~KVU>II_-qHi+hC5h^<xHeI`4''1Nt\,>6BK	**.no(,>MIEEv7tIHsKZa:A<FSJ=*to?#+HJ,tX
+]BJ+deUS"9c+hn;]k>yEG#?k#Tst!}s%E{xlS%CY/Oe.(Z=jL7_XqbMuNJrF&cS;&- ,Fj
+a	5k?]LZt_IviuDP2A2zRjRf/wMR3A%^q;NvR2`B:2 dfKG'Coqs3FOcc?e	yO'$r 2)'
+E~gH\|p`H5E SWWE}}\-m4nry6+UsNuc60"2PI{u1V_T6J":bF gaVBHNWr"WZ!s@b*x<pJbW'Tq.5*lVB|rjYFO8$$F+5VKE4k*Gly\ik k"Ti~G BB+J)F4%:P7ecacsYFw"q ,sTk8c>RI!=D,iC")HX([K< cpuW1.L7YH&euk'(nTTXlnnrs+|sOAg@5!*%D*m'D"'[M2a8	q]He`,9*ksybHRRVef|*O+y2]0|>?{$rlHbGU'"&Uv Xr)'p	KK1CMS"WZB[B^A. _W^^'TBy6W|yB[RO*"7xa :d<L]Hr @j`~,>ax,4EK"s]P~W~<#ii+ t7BPXnUdBMr%qMw
+TqwS{hH<Ab7NrmVLPgOD[>^a>&(RIA\taVR;O<|M+O&C.aReeL8].C> `Rzyzm#b9PP bbGZiANP][ea 	!1	!u"WZk]m?$s71D(X|em"4MCRW(|I?,UPmy.=ZGq8J	ipE7JaR>`Wd5ie5[|o+K:R~ 14~w??L&c)n!O&sh	#qo DTax]Hsj/cPk]= u	rs9sy&8zPi`u0|wWU*6j2 	vf%IB ykmD"c{xnG\ly*e6J^@Pc"\q^TS|g9]u]&g<
+6?i=-*]9Af*fS@tC-7o^Ia?vq\8kwv Xvs>j@I"2I^o777A:L{&sJ8q>/"IkksVtBjrK;j4A8,.4_5G=I34{3V_+R9fm6`9PHihL@XsMC;~-4lM4k(rs[r~sLT*:w_>ySVvs>U{"T)TBb
+^$"-|:h&I?(YSW=PA`6 I9sKd^g-t5,3%ZQa9<rLQih#V>|i$u
+[?x9R4"bbKxzU2m4"fYC= c	\St6BIhCK6Bd::gVP+Vs5-eSRYMrIWUIP&x<7?xNxr&h\q{KAQ*R{`ic	YKQn5D~=];'/j$o9XBJs#E2]
+BHO<$*_y;.)~54ek]PUmQ8pB+\DAP9O{N:d#&xs9m2sA,'W;_y@E!O"k?wM4*'Qi	k#n+4x
+&QcD<:d9Gl`9QA 5Zec'aWUa'+W3]O4ZRj/,hL{s(apD<['/[.W{,G"{_;M`-('Ahbx|g[hRqP4AwjxW_?][h&
+ _Y{{z6,	SPLh?m<I]O@tFc0kC>?Mkn%f Zryas$Afj"H+PI7HwzC  &~KNo=Uim2V!>|>Gc}OR|nhPMkn/,r$:v)Kr(moW/})AWFo 7i">bQ\V9zow_OEwX2>zIp9W<\}5\jPW7y8LTz!Uc#?P&yRLsxN*&_UiiFYHxrC*d%@'UWy1fB4*1Srx<PS#z?|xa>k /c-n{h_{2!c{t7?PWZ]6Ir<	hD]fmhkf)Yb.^Yp7
++cOSF(C!Jf
+$tN*6RB*?K`)+c<GHDN:D%DQcCj	i'5ik0yi4\9*OE_n&!7w}]JH{H2t"U}[uREKamJZ ;_LiupX*K-eYRGb D3J!q)=C|ppRtZQ(e]sBQ;:af!`|L,3/A2,9r/Q6F&#I4:7=YM^p5v'oX -Tndj~9!>h>RM4w#R55+o;[tvDlh/d:=nv2H[Saf	4~,<i-"l/"A!5)&Ihf6nzkA<v>H>1mCMU9v BBjGXGVVi4]"JTI"a~.[f 6`<g~d
+q\kRMy %dE|@@@#>r/X
+ZCn}'e6cDt6*^n,L  ~BK.7>S'<>fJ&L BUr.3[D*ZUW%Nw+K v$:Wq;TGY5c{=}D:NS+.
+8N/}s4 *r'--6o_n=?W;u {c.co9(@Cg^J{\I'S)9fZazR65V952nn#cDALGvF*F7^rcj\? NvJ<i}tZ9|GS
+hd+uxG[y]`35("F9:S)1] 4z=WC<7kOOV!>,SHr(Hc<c~XV2iRYR1Vx3E;qT6ya&'zy*AZ*5|_/o|>#eGw{'l}pCC#,]~9:8<1 T@>ixBm*iJ46AWV* ;^^IrI/vFC)A@Z=,_/S0r'nj(Y-HBR(6U&(Hk_-DG6R0<i#*@/o^8z4QhH_{oOUCjqqmx>(rf%n\0(Izh2z'#C4[wB0X8t4Pl Mu8nk>Z>,/n\(i4]%y=
+FV^^X=oH{"REw|w9Q.t$wy?qEgS+Z
+>S{DR!:ra?d'/=`"J8)bS!$
+T5H##<qsOWZ]oxkwaEmZcO\)$^|>+$!
+{{7_}l]#H8"X2"{7Az9g(7A@lBho<{e.
+jxu8j.s/E})q	^*.Iw0_g>:ZfSA\tFQ*ys{GAF3#P	N6i4+ZS8J,lct0E[#naZn*'[Fq#`s97Qld?I$@PbQ.]t_HVzm%X<@ 'iZRA 5b$qw{0NWCtw=S8!,L\Fa@~dEcIUj f  =\ j^wsZdU%O!kJ"hxPU`WIgHgE22Sq;aHTd#>ciFPAH5j<iOkwx}bKNY2;2/D}Q3Dx`$$AHRm*3*}kh8{IU9-R+F=JW|M&AV$E,NWl\tbXLNrx9/$EQARW1A(UPi-\Zs]Pkku!a9#M$$J$9L8Q:$#	q[$ CrG 
+>,q#$R^JmImU~j>*2#&@dYAZdId2b,&1O''DXVnHA~fB'9TPEDHokCG%dA3Qa~[!`D\'6!$1HA) J-bhW8b$R *faC+ i[lW+H0=eIE;AX
+1 vrS s a7"Xas09as09as01E    IENDB`
\ No newline at end of file
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/themes.pro mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/themes.pro
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/themes.pro	2014-05-04 17:43:22.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/themes.pro	2014-05-05 12:30:23.000000000 +0200
@@ -1,5 +1,5 @@
 include ( ../settings.pro )
- 
+
 QMAKE_STRIP = echo
 
 TEMPLATE = app
