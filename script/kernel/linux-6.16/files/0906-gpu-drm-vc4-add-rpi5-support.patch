diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/dma/bcm2835-dma.c linux-6.16-rc2/drivers/dma/bcm2835-dma.c
--- linux-6.16-rc2/drivers/dma/bcm2835-dma.c	2025-06-16 17:44:52.118346032 +0200
+++ linux-6.16-rc2/drivers/dma/bcm2835-dma.c	2025-06-16 17:40:50.788351389 +0200
@@ -18,6 +18,7 @@
  *	Copyright 2012 Marvell International Ltd.
  */
 #include <linux/dmaengine.h>
+#include <linux/dma-direct.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmapool.h>
 #include <linux/err.h>
@@ -77,6 +78,16 @@
 	u32 pad;
 };
 
+struct bcm2712_lite_scb {
+	u32 info;
+	u32 src;
+	u32 dst;
+	u32 length;
+	u32 addr_high;
+	u32 next;
+	u32 pad[2];
+};
+
 struct bcm2835_cb_entry {
 	struct bcm_dma_cb *cb;
 	dma_addr_t paddr;
@@ -134,6 +145,8 @@
 				enum dma_transfer_direction);
 
 	u64 dma_mask;
+
+	bool bcm2712_hack;
 };
 
 struct bcm2835_desc {
@@ -672,6 +685,65 @@
 	       chan_base + BCM2711_DMA40_DEBUG);
 }
 
+/* BCM2712 Lite channels */
+
+static dma_addr_t
+bcm2712_lite_dma_cb_get_addr(void *data, enum dma_transfer_direction direction)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	if (direction == DMA_DEV_TO_MEM)
+		return (((dma_addr_t)cb->addr_high & 0xff00) << 24ULL) + cb->dst;
+
+	return (((dma_addr_t)cb->addr_high & 0xff) << 32ULL) + cb->src;
+}
+
+static void
+bcm2712_lite_dma_cb_init(void *data, struct bcm2835_chan *c,
+			 enum dma_transfer_direction direction, dma_addr_t src,
+			 dma_addr_t dst, bool zero_page)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	cb->info = bcm2835_dma_prepare_cb_info(c, direction, zero_page);
+	cb->src = lower_32_bits(src);
+	cb->dst = lower_32_bits(dst);
+	cb->addr_high = (upper_32_bits(src) & 0xff) |
+			((upper_32_bits(dst) & 0xff) << 8);
+	cb->next = 0;
+}
+
+static void
+bcm2712_lite_dma_cb_set_src(void *data, enum dma_transfer_direction direction,
+			    dma_addr_t src)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	cb->src = src;
+	cb->addr_high &= 0xff;
+	cb->addr_high |= upper_32_bits(src);
+}
+
+static void
+bcm2712_lite_dma_cb_set_dst(void *data, enum dma_transfer_direction direction,
+			    dma_addr_t dst)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	cb->dst = dst;
+	cb->addr_high &= 0xff00;
+	cb->addr_high |= (upper_32_bits(dst) << 8);
+}
+
+static void bcm2712_lite_dma_cb_set_next(void *data, dma_addr_t next)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	cb->next = next;
+}
+
+/* Common functions */
+
 static void bcm2835_dma_free_cb_chain(struct bcm2835_desc *desc)
 {
 	size_t i;
@@ -1128,14 +1200,23 @@
 		return NULL;
 	}
 
+	if (cfg->bcm2712_hack)
+		dev_warn(chan->device->dev,"bcm2712 hack for HDMI audio enabled\n");
+
 	if (direction == DMA_DEV_TO_MEM) {
 		if (c->cfg.src_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)
 			return NULL;
-		src = cfg->addr_offset + c->cfg.src_addr;
+		if (cfg->bcm2712_hack)
+			src = phys_to_dma(chan->device->dev, c->cfg.src_addr);
+		else
+			src = cfg->addr_offset + c->cfg.src_addr;
 	} else {
 		if (c->cfg.dst_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)
 			return NULL;
-		dst = cfg->addr_offset + c->cfg.dst_addr;
+		if (cfg->bcm2712_hack)
+			dst = phys_to_dma(chan->device->dev, c->cfg.dst_addr);
+		else
+			dst = cfg->addr_offset + c->cfg.dst_addr;
 	}
 
 	/* count frames in sg list */
@@ -1190,15 +1271,24 @@
 			      "%s: buffer_length (%zd) is not a multiple of period_len (%zd)\n",
 			      __func__, buf_len, period_len);
 
+	if (cfg->bcm2712_hack)
+		dev_warn(chan->device->dev,"bcm2712 hack for HDMI audio enabled\n");
+
 	if (direction == DMA_DEV_TO_MEM) {
 		if (c->cfg.src_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)
 			return NULL;
-		src = cfg->addr_offset + c->cfg.src_addr;
+		if (cfg->bcm2712_hack)
+			src = phys_to_dma(chan->device->dev, c->cfg.src_addr);
+		else
+			src = cfg->addr_offset + c->cfg.src_addr;
 		dst = buf_addr;
 	} else {
 		if (c->cfg.dst_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)
 			return NULL;
-		dst = cfg->addr_offset + c->cfg.dst_addr;
+		if (cfg->bcm2712_hack)
+			dst = phys_to_dma(chan->device->dev, c->cfg.dst_addr);
+		else
+			dst = cfg->addr_offset + c->cfg.dst_addr;
 		src = buf_addr;
 	}
 
@@ -1329,6 +1419,8 @@
 	.read_addr = bcm2835_dma_read_addr,
 
 	.dma_mask = DMA_BIT_MASK(32),
+
+	.bcm2712_hack = false,
 };
 
 static const struct bcm2835_dma_cfg bcm2711_data = {
@@ -1340,7 +1432,7 @@
 	.wait_mask = BCM2711_DMA40_WAITING_FOR_WRITES,
 	.reset_mask = BCM2711_DMA40_HALT,
 	.int_mask = BCM2711_DMA40_INTEN,
-	.active_mask = BCM2711_DMA40_ACTIVE,
+	.active_mask = BCM2711_DMA40_ACTIVE | BCM2711_DMA40_PROT,
 
 	.cb_get_length = bcm2711_dma_cb_get_length,
 	.cb_get_addr = bcm2711_dma_cb_get_addr,
@@ -1358,11 +1450,45 @@
 	.read_addr = bcm2711_dma_read_addr,
 
 	.dma_mask = DMA_BIT_MASK(36),
+
+	.bcm2712_hack = false,
+};
+
+static const struct bcm2835_dma_cfg bcm2712_data = {
+	.addr_offset = BCM2711_DMA40_PHYS_ADDR,
+
+	.cs_reg = BCM2711_DMA40_CS,
+	.cb_reg = BCM2711_DMA40_CB,
+
+	.wait_mask = BCM2711_DMA40_WAITING_FOR_WRITES,
+	.reset_mask = BCM2711_DMA40_HALT,
+	.int_mask = BCM2711_DMA40_INTEN,
+	.active_mask = BCM2711_DMA40_ACTIVE | BCM2711_DMA40_PROT,
+
+	.cb_get_length = bcm2711_dma_cb_get_length,
+	.cb_get_addr = bcm2711_dma_cb_get_addr,
+	.cb_init = bcm2711_dma_cb_init,
+	.cb_set_src = bcm2711_dma_cb_set_src,
+	.cb_set_dst = bcm2711_dma_cb_set_dst,
+	.cb_set_next = bcm2711_dma_cb_set_next,
+	.cb_set_length = bcm2711_dma_cb_set_length,
+	.cb_append_extra = bcm2711_dma_cb_append_extra,
+	.cb_dma_abort = bcm2711_dma_cb_abort,
+
+	.to_cb_addr = bcm2711_dma_to_cb_addr,
+
+	.chan_plat_init = bcm2711_dma_chan_plat_init,
+	.read_addr = bcm2711_dma_read_addr,
+
+	.dma_mask = DMA_BIT_MASK(40),
+
+	.bcm2712_hack = true,
 };
 
 static const struct of_device_id bcm2835_dma_of_match[] = {
 	{ .compatible = "brcm,bcm2835-dma", .data = &bcm2835_data },
 	{ .compatible = "brcm,bcm2711-dma", .data = &bcm2711_data },
+	{ .compatible = "brcm,bcm2712-dma", .data = &bcm2712_data },
 	{},
 };
 MODULE_DEVICE_TABLE(of, bcm2835_dma_of_match);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/drm_atomic_state_helper.c linux-6.16-rc2/drivers/gpu/drm/drm_atomic_state_helper.c
--- linux-6.16-rc2/drivers/gpu/drm/drm_atomic_state_helper.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/drm_atomic_state_helper.c	2025-06-16 17:40:50.788351389 +0200
@@ -267,6 +267,20 @@
 			plane_state->color_range = val;
 	}
 
+	if (plane->chroma_siting_h_property) {
+		if (!drm_object_property_get_default_value(&plane->base,
+							   plane->chroma_siting_h_property,
+							   &val))
+			plane_state->chroma_siting_h = val;
+	}
+
+	if (plane->chroma_siting_v_property) {
+		if (!drm_object_property_get_default_value(&plane->base,
+							   plane->chroma_siting_v_property,
+							   &val))
+			plane_state->chroma_siting_v = val;
+	}
+
 	if (plane->zpos_property) {
 		if (!drm_object_property_get_default_value(&plane->base,
 							   plane->zpos_property,
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/drm_atomic_uapi.c linux-6.16-rc2/drivers/gpu/drm/drm_atomic_uapi.c
--- linux-6.16-rc2/drivers/gpu/drm/drm_atomic_uapi.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/drm_atomic_uapi.c	2025-06-16 17:40:50.788351389 +0200
@@ -539,6 +539,10 @@
 		state->color_encoding = val;
 	} else if (property == plane->color_range_property) {
 		state->color_range = val;
+	} else if (property == plane->chroma_siting_h_property) {
+		state->chroma_siting_h = val;
+	} else if (property == plane->chroma_siting_v_property) {
+		state->chroma_siting_v = val;
 	} else if (property == config->prop_fb_damage_clips) {
 		ret = drm_property_replace_blob_from_id(dev,
 					&state->fb_damage_clips,
@@ -621,6 +625,10 @@
 		*val = state->color_encoding;
 	} else if (property == plane->color_range_property) {
 		*val = state->color_range;
+	} else if (property == plane->chroma_siting_h_property) {
+		*val = state->chroma_siting_h;
+	} else if (property == plane->chroma_siting_v_property) {
+		*val = state->chroma_siting_v;
 	} else if (property == config->prop_fb_damage_clips) {
 		*val = (state->fb_damage_clips) ?
 			state->fb_damage_clips->base.id : 0;
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/drm_color_mgmt.c linux-6.16-rc2/drivers/gpu/drm/drm_color_mgmt.c
--- linux-6.16-rc2/drivers/gpu/drm/drm_color_mgmt.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/drm_color_mgmt.c	2025-06-16 17:40:50.788351389 +0200
@@ -330,7 +330,9 @@
 	replaced = drm_property_replace_blob(&crtc_state->degamma_lut,
 					     use_gamma_lut ? NULL : blob);
 	replaced |= drm_property_replace_blob(&crtc_state->ctm, NULL);
-	replaced |= drm_property_replace_blob(&crtc_state->gamma_lut,
+	if (!crtc_state->gamma_lut || !crtc_state->gamma_lut->data ||
+	    memcmp(crtc_state->gamma_lut->data, blob_data, blob->length))
+		replaced |= drm_property_replace_blob(&crtc_state->gamma_lut,
 					      use_gamma_lut ? blob : NULL);
 	crtc_state->color_mgmt_changed |= replaced;
 
@@ -589,6 +591,42 @@
 EXPORT_SYMBOL(drm_plane_create_color_properties);
 
 /**
+ * drm_plane_create_chroma_siting_properties - chroma siting related plane properties
+ * @plane: plane object
+ *
+ * Create and attach plane specific CHROMA_SITING
+ * properties to @plane.
+ */
+int drm_plane_create_chroma_siting_properties(struct drm_plane *plane,
+						int32_t default_chroma_siting_h,
+						int32_t default_chroma_siting_v)
+{
+	struct drm_device *dev = plane->dev;
+	struct drm_property *prop;
+
+	prop = drm_property_create_range(dev, 0, "CHROMA_SITING_H",
+					0, 1<<16);
+	if (!prop)
+		return -ENOMEM;
+	plane->chroma_siting_h_property = prop;
+	drm_object_attach_property(&plane->base, prop, default_chroma_siting_h);
+
+	prop = drm_property_create_range(dev, 0, "CHROMA_SITING_V",
+					0, 1<<16);
+	if (!prop)
+		return -ENOMEM;
+	plane->chroma_siting_v_property = prop;
+	drm_object_attach_property(&plane->base, prop, default_chroma_siting_v);
+
+	if (plane->state) {
+		plane->state->chroma_siting_h = default_chroma_siting_h;
+		plane->state->chroma_siting_v = default_chroma_siting_v;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(drm_plane_create_chroma_siting_properties);
+
+/**
  * drm_color_lut_check - check validity of lookup table
  * @lut: property blob containing LUT to check
  * @tests: bitmask of tests to run
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/Kconfig linux-6.16-rc2/drivers/gpu/drm/vc4/Kconfig
--- linux-6.16-rc2/drivers/gpu/drm/vc4/Kconfig	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/Kconfig	2025-06-16 17:40:50.788351389 +0200
@@ -9,8 +9,6 @@
 	depends on SND && SND_SOC
 	depends on COMMON_CLK
 	depends on PM
-	select DRM_CLIENT_SELECTION
-	select DRM_DISPLAY_HDMI_AUDIO_HELPER
 	select DRM_DISPLAY_HDMI_HELPER
 	select DRM_DISPLAY_HDMI_STATE_HELPER
 	select DRM_DISPLAY_HELPER
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/Makefile linux-6.16-rc2/drivers/gpu/drm/vc4/Makefile
--- linux-6.16-rc2/drivers/gpu/drm/vc4/Makefile	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/Makefile	2025-06-16 17:40:50.788351389 +0200
@@ -9,6 +9,7 @@
 	vc4_dpi.o \
 	vc4_dsi.o \
 	vc4_fence.o \
+	vc4_firmware_kms.o \
 	vc4_kms.o \
 	vc4_gem.o \
 	vc4_hdmi.o \
@@ -30,7 +31,8 @@
 	tests/vc4_mock_crtc.o \
 	tests/vc4_mock_output.o \
 	tests/vc4_mock_plane.o \
-	tests/vc4_test_pv_muxing.o
+	tests/vc4_test_pv_muxing.o \
+	tests/vc4_test_lbm_size.o
 
 vc4-$(CONFIG_DEBUG_FS) += vc4_debugfs.o
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock.c linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock.c	2025-06-16 10:30:23.608245431 +0200
@@ -106,6 +106,26 @@
 							      DRM_MODE_CONNECTOR_HDMIA)),
 );
 
+static const struct vc4_mock_desc vc6_mock =
+	VC4_MOCK_DESC(
+		VC4_MOCK_CRTC_DESC(&bcm2712_mop_data.base,
+				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP0,
+							DRM_MODE_ENCODER_VIRTUAL,
+							DRM_MODE_CONNECTOR_WRITEBACK)),
+		VC4_MOCK_CRTC_DESC(&bcm2712_moplet_data.base,
+				   VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_TXP1,
+							DRM_MODE_ENCODER_VIRTUAL,
+							DRM_MODE_CONNECTOR_WRITEBACK)),
+		VC4_MOCK_PIXELVALVE_DESC(&bcm2712_pv0_data,
+					 VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_HDMI0,
+							      DRM_MODE_ENCODER_TMDS,
+							      DRM_MODE_CONNECTOR_HDMIA)),
+		VC4_MOCK_PIXELVALVE_DESC(&bcm2712_pv1_data,
+					 VC4_MOCK_OUTPUT_DESC(VC4_ENCODER_TYPE_HDMI1,
+							      DRM_MODE_ENCODER_TMDS,
+							      DRM_MODE_CONNECTOR_HDMIA)),
+);
+
 static int __build_one_pipe(struct kunit *test, struct drm_device *drm,
 			    const struct vc4_mock_pipe_desc *pipe)
 {
@@ -157,13 +177,31 @@
 
 static struct vc4_dev *__mock_device(struct kunit *test, enum vc4_gen gen)
 {
+	const struct vc4_mock_desc *desc;
+	const struct drm_driver *drv;
 	struct drm_device *drm;
-	const struct drm_driver *drv = (gen == VC4_GEN_5) ? &vc5_drm_driver : &vc4_drm_driver;
-	const struct vc4_mock_desc *desc = (gen == VC4_GEN_5) ? &vc5_mock : &vc4_mock;
 	struct vc4_dev *vc4;
 	struct device *dev;
 	int ret;
 
+	switch (gen) {
+	case VC4_GEN_4:
+		drv = &vc4_drm_driver;
+		desc = &vc4_mock;
+		break;
+	case VC4_GEN_5:
+		drv = &vc5_drm_driver;
+		desc = &vc5_mock;
+		break;
+	case VC4_GEN_6_C:
+		drv = &vc5_drm_driver;
+		desc = &vc6_mock;
+		break;
+
+	default:
+		return NULL;
+	}
+
 	dev = drm_kunit_helper_alloc_device(test);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, dev);
 
@@ -205,3 +243,8 @@
 {
 	return __mock_device(test, VC4_GEN_5);
 }
+
+struct vc4_dev *vc6_mock_device(struct kunit *test)
+{
+	return __mock_device(test, VC4_GEN_6_C);
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock.h linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock.h
--- linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock.h	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock.h	2025-06-16 17:40:50.788351389 +0200
@@ -7,9 +7,9 @@
 
 static inline
 struct drm_crtc *vc4_find_crtc_for_encoder(struct kunit *test,
-					   struct drm_device *drm,
 					   struct drm_encoder *encoder)
 {
+	struct drm_device *drm = encoder->dev;
 	struct drm_crtc *crtc;
 
 	KUNIT_ASSERT_EQ(test, hweight32(encoder->possible_crtcs), 1);
@@ -21,9 +21,28 @@
 	return NULL;
 }
 
+static inline
+struct drm_plane *vc4_mock_find_plane_for_crtc(struct kunit *test,
+					       struct drm_crtc *crtc)
+{
+	struct drm_device *drm = crtc->dev;
+	struct drm_plane *plane;
+
+	drm_for_each_plane(plane, drm)
+		if (plane->possible_crtcs & drm_crtc_mask(crtc))
+			return plane;
+
+	return NULL;
+}
+
 struct drm_plane *vc4_dummy_plane(struct kunit *test, struct drm_device *drm,
 				  enum drm_plane_type type);
 
+struct drm_plane *
+vc4_mock_atomic_add_plane(struct kunit *test,
+			  struct drm_atomic_state *state,
+			  struct drm_crtc *crtc);
+
 struct vc4_dummy_crtc {
 	struct vc4_crtc crtc;
 };
@@ -50,10 +69,12 @@
 
 struct vc4_dev *vc4_mock_device(struct kunit *test);
 struct vc4_dev *vc5_mock_device(struct kunit *test);
+struct vc4_dev *vc6_mock_device(struct kunit *test);
 
-int vc4_mock_atomic_add_output(struct kunit *test,
-			       struct drm_atomic_state *state,
-			       enum vc4_encoder_type type);
+struct vc4_dummy_output *
+vc4_mock_atomic_add_output(struct kunit *test,
+			   struct drm_atomic_state *state,
+			   enum vc4_encoder_type type);
 int vc4_mock_atomic_del_output(struct kunit *test,
 			       struct drm_atomic_state *state,
 			       enum vc4_encoder_type type);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock_output.c linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock_output.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock_output.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock_output.c	2025-06-16 10:30:23.608245431 +0200
@@ -74,9 +74,10 @@
  * EDEADLK, the entire atomic sequence must be restarted. All other
  * errors are fatal.
  */
-int vc4_mock_atomic_add_output(struct kunit *test,
-			       struct drm_atomic_state *state,
-			       enum vc4_encoder_type type)
+struct vc4_dummy_output *
+vc4_mock_atomic_add_output(struct kunit *test,
+			   struct drm_atomic_state *state,
+			   enum vc4_encoder_type type)
 {
 	struct drm_device *drm = state->dev;
 	struct drm_connector_state *conn_state;
@@ -91,7 +92,7 @@
 	if (!encoder)
 		return -ENODEV;
 
-	crtc = vc4_find_crtc_for_encoder(test, drm, encoder);
+	crtc = vc4_find_crtc_for_encoder(test, encoder);
 	if (!crtc)
 		return -ENODEV;
 
@@ -115,7 +116,7 @@
 
 	crtc_state->active = true;
 
-	return 0;
+	return output;
 }
 
 /**
@@ -148,7 +149,7 @@
 	if (!encoder)
 		return -ENODEV;
 
-	crtc = vc4_find_crtc_for_encoder(test, drm, encoder);
+	crtc = vc4_find_crtc_for_encoder(test, encoder);
 	if (!crtc)
 		return -ENODEV;
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_mock_plane.c	2025-06-16 17:40:50.788351389 +0200
@@ -1,12 +1,31 @@
 // SPDX-License-Identifier: GPL-2.0
 
+#include <drm/drm_modeset_helper_vtables.h>
 #include <drm/drm_kunit_helpers.h>
+#include <drm/drm_atomic_uapi.h>
 #include <drm/drm_plane.h>
 
 #include <kunit/test.h>
 
 #include "vc4_mock.h"
 
+static const struct drm_plane_helper_funcs vc4_dummy_plane_helper_funcs = {
+	.atomic_check = vc4_plane_atomic_check,
+};
+
+static const struct drm_plane_funcs vc4_dummy_plane_funcs = {
+	.atomic_destroy_state	= vc4_plane_destroy_state,
+	.atomic_duplicate_state	= vc4_plane_duplicate_state,
+	.reset			= vc4_plane_reset,
+};
+
+static const uint32_t vc4_dummy_plane_formats[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_YUV420,
+	DRM_FORMAT_YUV422,
+};
+
 struct drm_plane *vc4_dummy_plane(struct kunit *test, struct drm_device *drm,
 				  enum drm_plane_type type)
 {
@@ -15,11 +34,33 @@
 	KUNIT_ASSERT_EQ(test, type, DRM_PLANE_TYPE_PRIMARY);
 
 	plane = drm_kunit_helper_create_primary_plane(test, drm,
-						      NULL,
-						      NULL,
-						      NULL, 0,
+						      &vc4_dummy_plane_funcs,
+						      &vc4_dummy_plane_helper_funcs,
+						      vc4_dummy_plane_formats,
+						      ARRAY_SIZE(vc4_dummy_plane_formats),
 						      NULL);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane);
 
 	return plane;
 }
+
+struct drm_plane *
+vc4_mock_atomic_add_plane(struct kunit *test,
+			  struct drm_atomic_state *state,
+			  struct drm_crtc *crtc)
+{
+	struct drm_plane_state *plane_state;
+	struct drm_plane *plane;
+	int ret;
+
+	plane = vc4_mock_find_plane_for_crtc(test, crtc);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane);
+
+	plane_state = drm_atomic_get_plane_state(state, plane);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane_state);
+
+	ret = drm_atomic_set_crtc_for_plane(plane_state, crtc);
+	KUNIT_EXPECT_EQ(test, ret, 0);
+
+	return plane;
+}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_test_lbm_size.c	2025-06-16 17:40:50.788351389 +0200
@@ -0,0 +1,308 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_atomic_uapi.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_framebuffer.h>
+#include <drm/drm_plane.h>
+#include <drm/drm_kunit_helpers.h>
+
+#include "../../drm_crtc_internal.h"
+#include "../../drm_internal.h"
+
+#include <kunit/test.h>
+
+#include "../vc4_drv.h"
+
+#include "vc4_mock.h"
+
+u32 vc4_lbm_size(struct drm_plane_state *state);
+
+struct vc4_lbm_size_priv {
+	struct vc4_dev *vc4;
+	struct drm_file *file;
+	struct drm_modeset_acquire_ctx ctx;
+	struct drm_atomic_state *state;
+};
+
+struct vc4_lbm_size_param {
+	unsigned int src_w, src_h;
+	unsigned int crtc_w, crtc_h;
+	bool forced_alpha;
+	u32 fourcc;
+	enum vc4_scaling_mode expected_x_scaling[2];
+	enum vc4_scaling_mode expected_y_scaling[2];
+	unsigned int expected_lbm_size;
+};
+
+static const struct vc4_lbm_size_param vc4_test_lbm_size_params[] = {
+	{
+		.src_w = 256,
+		.crtc_w = 256,
+		.src_h = 256,
+		.crtc_h = 512,
+		.fourcc = DRM_FORMAT_ARGB8888,
+		.expected_x_scaling = { VC4_SCALING_NONE, },
+		.expected_y_scaling = { VC4_SCALING_PPF, },
+		.expected_lbm_size = 32,
+	},
+	{
+		.src_w = 256,
+		.crtc_w = 179,
+		.src_h = 256,
+		.crtc_h = 512,
+		.fourcc = DRM_FORMAT_ARGB8888,
+		.expected_x_scaling = { VC4_SCALING_PPF, },
+		.expected_y_scaling = { VC4_SCALING_PPF, },
+		.expected_lbm_size = 23,
+	},
+	{
+		.src_w = 256,
+		.crtc_w = 256,
+		.src_h = 256,
+		.crtc_h = 512,
+		.fourcc = DRM_FORMAT_XRGB8888,
+		.expected_x_scaling = { VC4_SCALING_NONE, },
+		.expected_y_scaling = { VC4_SCALING_PPF, },
+		.expected_lbm_size = 24,
+	},
+	{
+		.src_w = 100,
+		.crtc_w = 73,
+		.src_h = 100,
+		.crtc_h = 73,
+		.fourcc = DRM_FORMAT_XRGB8888,
+		.expected_x_scaling = { VC4_SCALING_PPF, },
+		.expected_y_scaling = { VC4_SCALING_PPF, },
+		.expected_lbm_size = 8,
+	},
+	{
+		.src_w = 256,
+		.crtc_w = 256,
+		.src_h = 256,
+		.crtc_h = 512,
+		.forced_alpha = true,
+		.fourcc = DRM_FORMAT_ARGB8888,
+		.expected_x_scaling = { VC4_SCALING_NONE, },
+		.expected_y_scaling = { VC4_SCALING_PPF, },
+		.expected_lbm_size = 24,
+	},
+	{
+		.src_w = 100,
+		.crtc_w = 73,
+		.src_h = 100,
+		.crtc_h = 73,
+		.forced_alpha = true,
+		.fourcc = DRM_FORMAT_ARGB8888,
+		.expected_x_scaling = { VC4_SCALING_PPF, },
+		.expected_y_scaling = { VC4_SCALING_PPF, },
+		.expected_lbm_size = 8,
+	},
+	{
+		.src_w = 256,
+		.crtc_w = 94,
+		.src_h = 256,
+		.crtc_h = 94,
+		.fourcc = DRM_FORMAT_ARGB8888,
+		.expected_x_scaling = { VC4_SCALING_TPZ, },
+		.expected_y_scaling = { VC4_SCALING_TPZ, },
+		.expected_lbm_size = 6,
+	},
+
+/*
+ * TODO: Those tests reflect the LBM size calculation examples, but the
+ * driver ends up taking different scaler filters decisions, and thus
+ * doesn't end up with the same sizes. It would be valuable to have
+ * those tests, but the driver doesn't take a bad decision either, so
+ * it's not clear what we should do at this point.
+ */
+#if 0
+	{
+		.src_w = 320,
+		.crtc_w = 320,
+		.src_h = 320,
+		.crtc_h = 320,
+		.fourcc = DRM_FORMAT_YUV420,
+		.expected_x_scaling = { VC4_SCALING_NONE, VC4_SCALING_NONE, },
+		.expected_y_scaling = { VC4_SCALING_NONE, VC4_SCALING_PPF, },
+		.expected_lbm_size = 10,
+	},
+	{
+		.src_w = 512,
+		.crtc_w = 512,
+		.src_h = 512,
+		.crtc_h = 256,
+		.fourcc = DRM_FORMAT_YUV420,
+		.expected_x_scaling = { VC4_SCALING_NONE, VC4_SCALING_NONE, },
+		.expected_y_scaling = { VC4_SCALING_TPZ, VC4_SCALING_NONE, },
+		.expected_lbm_size = 5,
+	},
+	{
+		.src_w = 486,
+		.crtc_w = 157,
+		.src_h = 404,
+		.crtc_h = 929,
+		.fourcc = DRM_FORMAT_YUV422,
+		.expected_x_scaling = { VC4_SCALING_PPF, VC4_SCALING_PPF, },
+		.expected_y_scaling = { VC4_SCALING_PPF, VC4_SCALING_PPF, },
+		.expected_lbm_size = 20,
+	},
+	{
+		.src_w = 320,
+		.crtc_w = 128,
+		.src_h = 176,
+		.crtc_h = 70,
+		.fourcc = DRM_FORMAT_YUV420,
+		.expected_x_scaling = { VC4_SCALING_TPZ, VC4_SCALING_TPZ, },
+		.expected_y_scaling = { VC4_SCALING_TPZ, VC4_SCALING_TPZ, },
+		.expected_lbm_size = 8,
+	},
+#endif
+};
+
+static void vc4_test_lbm_size_desc(const struct vc4_lbm_size_param *t, char *desc)
+{
+	snprintf(desc, KUNIT_PARAM_DESC_SIZE,
+		 "%ux%u to %ux%u %s(%p4cc)",
+		 t->src_w, t->src_h,
+		 t->crtc_w, t->crtc_h,
+		 t->forced_alpha ? "with forced alpha " : "",
+		 &t->fourcc);
+}
+
+KUNIT_ARRAY_PARAM(vc4_test_lbm_size,
+		  vc4_test_lbm_size_params,
+		  vc4_test_lbm_size_desc);
+
+static void drm_vc4_test_vc4_lbm_size(struct kunit *test)
+{
+	const struct vc4_lbm_size_param *params = test->param_value;
+	const struct vc4_lbm_size_priv *priv = test->priv;
+	const struct drm_format_info *info;
+	struct drm_mode_fb_cmd2 fb_req = { };
+	struct drm_atomic_state *state = priv->state;
+	struct vc4_plane_state *vc4_plane_state;
+	struct drm_plane_state *plane_state;
+	struct vc4_dummy_output *output;
+	struct drm_framebuffer *fb;
+	struct drm_plane *plane;
+	struct drm_crtc *crtc;
+	unsigned int i;
+	int ret;
+
+	info = drm_format_info(params->fourcc);
+	KUNIT_ASSERT_NOT_NULL(test, info);
+
+	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
+
+	crtc = vc4_find_crtc_for_encoder(test, &output->encoder.base);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, crtc);
+
+	plane = vc4_mock_atomic_add_plane(test, state, crtc);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane);
+
+	plane_state = drm_atomic_get_plane_state(state, plane);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, plane_state);
+
+	vc4_plane_state = to_vc4_plane_state(plane_state);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, vc4_plane_state);
+
+	fb_req.pixel_format = params->fourcc;
+	fb_req.width = params->src_w;
+	fb_req.height = params->src_h;
+
+	for (i = 0; i < info->num_planes; i++) {
+		struct drm_mode_create_dumb dumb_args = { };
+
+		dumb_args.width = params->src_w;
+		dumb_args.height = params->src_h;
+		dumb_args.bpp = drm_format_info_bpp(info, i);
+
+		ret = drm_mode_create_dumb(state->dev, &dumb_args, priv->file);
+		KUNIT_ASSERT_EQ(test, ret, 0);
+
+		fb_req.handles[i] = dumb_args.handle;
+		fb_req.pitches[i] = dumb_args.pitch;
+	}
+
+	fb = drm_internal_framebuffer_create(state->dev, &fb_req, priv->file);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, fb);
+
+	drm_atomic_set_fb_for_plane(plane_state, fb);
+
+	plane_state->src_x = 0;
+	plane_state->src_y = 0;
+	plane_state->src_h = params->src_h << 16;
+	plane_state->src_w = params->src_w << 16;
+
+	plane_state->crtc_x = 0;
+	plane_state->crtc_y = 0;
+	plane_state->crtc_h = params->crtc_h;
+	plane_state->crtc_w = params->crtc_w;
+
+	if (params->forced_alpha)
+		plane_state->alpha = 128;
+
+	ret = drm_atomic_check_only(state);
+	KUNIT_ASSERT_EQ(test, ret, 0);
+
+	KUNIT_EXPECT_EQ(test, vc4_plane_state->lbm_size, params->expected_lbm_size);
+
+	for (i = 0; i < 2; i++) {
+		KUNIT_EXPECT_EQ(test,
+				vc4_plane_state->x_scaling[i],
+				params->expected_x_scaling[i]);
+		KUNIT_EXPECT_EQ(test,
+				vc4_plane_state->y_scaling[i],
+				params->expected_y_scaling[i]);
+	}
+
+	drm_framebuffer_put(fb);
+
+	for (i = 0; i < info->num_planes; i++)
+		drm_mode_destroy_dumb(state->dev, fb_req.handles[i], priv->file);
+}
+
+static struct kunit_case vc4_lbm_size_tests[] = {
+	KUNIT_CASE_PARAM(drm_vc4_test_vc4_lbm_size,
+			 vc4_test_lbm_size_gen_params),
+	{}
+};
+
+static int vc4_lbm_size_test_init(struct kunit *test)
+{
+	struct drm_modeset_acquire_ctx *ctx;
+	struct vc4_lbm_size_priv *priv;
+	struct drm_device *drm;
+	struct vc4_dev *vc4;
+
+	priv = kunit_kzalloc(test, sizeof(*priv), GFP_KERNEL);
+	KUNIT_ASSERT_NOT_NULL(test, priv);
+	test->priv = priv;
+
+	vc4 = vc6_mock_device(test);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, vc4);
+	priv->vc4 = vc4;
+
+	priv->file = drm_file_alloc(priv->vc4->base.primary);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, priv->file);
+
+	ctx = drm_kunit_helper_acquire_ctx_alloc(test);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ctx);
+
+	drm = &vc4->base;
+	priv->state = drm_kunit_helper_atomic_state_alloc(test, drm, ctx);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, priv->state);
+
+	return 0;
+}
+
+static struct kunit_suite vc4_lbm_size_test_suite = {
+	.name = "vc4-lbm-size",
+	.init = vc4_lbm_size_test_init,
+	.test_cases = vc4_lbm_size_tests,
+};
+
+kunit_test_suite(vc4_lbm_size_test_suite);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/tests/vc4_test_pv_muxing.c	2025-06-16 10:30:23.608245431 +0200
@@ -90,7 +90,7 @@
 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI0, 1),
 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_VEC, 1),
 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP0, 2),
-	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_DSI1, 2),
+	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_DSI1, 0, 1, 2),
 };
 
 static const struct encoder_constraint vc5_encoder_constraints[] = {
@@ -103,6 +103,13 @@
 	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI1, 0, 1, 2),
 };
 
+static const struct encoder_constraint vc6_encoder_constraints[] = {
+	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI0, 0),
+	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_HDMI1, 1),
+	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP1, 1),
+	ENCODER_CONSTRAINT(VC4_ENCODER_TYPE_TXP0, 2),
+};
+
 static bool check_vc4_encoder_constraints(enum vc4_encoder_type type, unsigned int channel)
 {
 	return __check_encoder_constraints(vc4_encoder_constraints,
@@ -117,6 +124,13 @@
 					   type, channel);
 }
 
+static bool check_vc6_encoder_constraints(enum vc4_encoder_type type, unsigned int channel)
+{
+	return __check_encoder_constraints(vc6_encoder_constraints,
+					   ARRAY_SIZE(vc6_encoder_constraints),
+					   type, channel);
+}
+
 static struct vc4_crtc_state *
 get_vc4_crtc_state_for_encoder(struct kunit *test,
 			       const struct drm_atomic_state *state,
@@ -130,7 +144,7 @@
 	encoder = vc4_find_encoder_by_type(drm, type);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, encoder);
 
-	crtc = vc4_find_crtc_for_encoder(test, drm, encoder);
+	crtc = vc4_find_crtc_for_encoder(test, encoder);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, crtc);
 
 	new_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
@@ -194,6 +208,9 @@
 #define VC5_PV_MUXING_TEST(_name, ...)		\
 	PV_MUXING_TEST(_name, vc5_mock_device, check_vc5_encoder_constraints, __VA_ARGS__)
 
+#define VC6_PV_MUXING_TEST(_name, ...)		\
+	PV_MUXING_TEST(_name, vc6_mock_device, check_vc6_encoder_constraints, __VA_ARGS__)
+
 static const struct pv_muxing_param vc4_test_pv_muxing_params[] = {
 	VC4_PV_MUXING_TEST("1 output: DSI0",
 			   VC4_ENCODER_TYPE_DSI0),
@@ -240,6 +257,9 @@
 	VC4_PV_MUXING_TEST("2 outputs: VEC, DSI1",
 			   VC4_ENCODER_TYPE_VEC,
 			   VC4_ENCODER_TYPE_DSI1),
+	VC4_PV_MUXING_TEST("2 outputs: TXP, DSI1",
+			   VC4_ENCODER_TYPE_TXP0,
+			   VC4_ENCODER_TYPE_DSI1),
 	VC4_PV_MUXING_TEST("2 outputs: VEC, TXP",
 			   VC4_ENCODER_TYPE_VEC,
 			   VC4_ENCODER_TYPE_TXP0),
@@ -275,6 +295,22 @@
 			   VC4_ENCODER_TYPE_DPI,
 			   VC4_ENCODER_TYPE_VEC,
 			   VC4_ENCODER_TYPE_TXP0),
+	VC4_PV_MUXING_TEST("3 outputs: DSI1, HDMI, TXP",
+			   VC4_ENCODER_TYPE_DSI1,
+			   VC4_ENCODER_TYPE_HDMI0,
+			   VC4_ENCODER_TYPE_TXP0),
+	VC4_PV_MUXING_TEST("3 outputs: DSI1, VEC, TXP",
+			   VC4_ENCODER_TYPE_DSI1,
+			   VC4_ENCODER_TYPE_VEC,
+			   VC4_ENCODER_TYPE_TXP0),
+	VC4_PV_MUXING_TEST("3 outputs: DSI1, DPI, TXP",
+			   VC4_ENCODER_TYPE_DSI1,
+			   VC4_ENCODER_TYPE_DPI,
+			   VC4_ENCODER_TYPE_TXP0),
+	VC4_PV_MUXING_TEST("3 outputs: DSI1, DSI0, TXP",
+			   VC4_ENCODER_TYPE_DSI1,
+			   VC4_ENCODER_TYPE_DSI0,
+			   VC4_ENCODER_TYPE_TXP0),
 };
 
 KUNIT_ARRAY_PARAM(vc4_test_pv_muxing,
@@ -285,9 +321,6 @@
 	VC4_PV_MUXING_TEST("DPI/DSI0 Conflict",
 			   VC4_ENCODER_TYPE_DPI,
 			   VC4_ENCODER_TYPE_DSI0),
-	VC4_PV_MUXING_TEST("TXP/DSI1 Conflict",
-			   VC4_ENCODER_TYPE_TXP0,
-			   VC4_ENCODER_TYPE_DSI1),
 	VC4_PV_MUXING_TEST("HDMI0/VEC Conflict",
 			   VC4_ENCODER_TYPE_HDMI0,
 			   VC4_ENCODER_TYPE_VEC),
@@ -672,6 +705,54 @@
 		  vc5_test_pv_muxing_invalid_params,
 		  vc4_test_pv_muxing_desc);
 
+static const struct pv_muxing_param vc6_test_pv_muxing_params[] = {
+	VC6_PV_MUXING_TEST("1 output: HDMI0",
+			   VC4_ENCODER_TYPE_HDMI0),
+	VC6_PV_MUXING_TEST("1 output: HDMI1",
+			   VC4_ENCODER_TYPE_HDMI1),
+	VC6_PV_MUXING_TEST("1 output: MOPLET",
+			   VC4_ENCODER_TYPE_TXP1),
+	VC6_PV_MUXING_TEST("1 output: MOP",
+			   VC4_ENCODER_TYPE_TXP0),
+	VC6_PV_MUXING_TEST("2 outputs: HDMI0, HDMI1",
+			   VC4_ENCODER_TYPE_HDMI0,
+			   VC4_ENCODER_TYPE_HDMI1),
+	VC6_PV_MUXING_TEST("2 outputs: HDMI0, MOPLET",
+			   VC4_ENCODER_TYPE_HDMI0,
+			   VC4_ENCODER_TYPE_TXP1),
+	VC6_PV_MUXING_TEST("2 outputs: HDMI0, MOP",
+			   VC4_ENCODER_TYPE_HDMI0,
+			   VC4_ENCODER_TYPE_TXP0),
+	VC6_PV_MUXING_TEST("2 outputs: HDMI1, MOP",
+			   VC4_ENCODER_TYPE_HDMI1,
+			   VC4_ENCODER_TYPE_TXP0),
+	VC6_PV_MUXING_TEST("2 outputs: MOPLET, MOP",
+			   VC4_ENCODER_TYPE_TXP1,
+			   VC4_ENCODER_TYPE_TXP0),
+	VC6_PV_MUXING_TEST("3 outputs: HDMI0, HDMI1, MOP",
+			   VC4_ENCODER_TYPE_HDMI0,
+			   VC4_ENCODER_TYPE_HDMI1,
+			   VC4_ENCODER_TYPE_TXP0),
+	VC6_PV_MUXING_TEST("3 outputs: HDMI0, MOPLET, MOP",
+			   VC4_ENCODER_TYPE_HDMI0,
+			   VC4_ENCODER_TYPE_TXP1,
+			   VC4_ENCODER_TYPE_TXP0),
+};
+
+KUNIT_ARRAY_PARAM(vc6_test_pv_muxing,
+		  vc6_test_pv_muxing_params,
+		  vc4_test_pv_muxing_desc);
+
+static const struct pv_muxing_param vc6_test_pv_muxing_invalid_params[] = {
+	VC6_PV_MUXING_TEST("HDMI1/MOPLET Conflict",
+			   VC4_ENCODER_TYPE_HDMI1,
+			   VC4_ENCODER_TYPE_TXP1),
+};
+
+KUNIT_ARRAY_PARAM(vc6_test_pv_muxing_invalid,
+		  vc6_test_pv_muxing_invalid_params,
+		  vc4_test_pv_muxing_desc);
+
 static void drm_vc4_test_pv_muxing(struct kunit *test)
 {
 	const struct pv_muxing_param *params = test->param_value;
@@ -692,16 +773,17 @@
 	state = drm_kunit_helper_atomic_state_alloc(test, drm, &ctx);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, state);
 	for (i = 0; i < params->nencoders; i++) {
+		struct vc4_dummy_output *output;
 		enum vc4_encoder_type enc_type = params->encoders[i];
 
-		ret = vc4_mock_atomic_add_output(test, state, enc_type);
-		if (ret == -EDEADLK) {
+		output = vc4_mock_atomic_add_output(test, state, enc_type);
+		if (IS_ERR(output) && PTR_ERR(output) == -EDEADLK) {
 			drm_atomic_state_clear(state);
 			ret = drm_modeset_backoff(&ctx);
 			if (!ret)
 				goto retry;
 		}
-		KUNIT_ASSERT_EQ(test, ret, 0);
+		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
 	}
 
 	ret = drm_atomic_check_only(state);
@@ -748,16 +830,17 @@
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, state);
 
 	for (i = 0; i < params->nencoders; i++) {
+		struct vc4_dummy_output *output;
 		enum vc4_encoder_type enc_type = params->encoders[i];
 
-		ret = vc4_mock_atomic_add_output(test, state, enc_type);
-		if (ret == -EDEADLK) {
+		output = vc4_mock_atomic_add_output(test, state, enc_type);
+		if (IS_ERR(output) && PTR_ERR(output) == -EDEADLK) {
 			drm_atomic_state_clear(state);
 			ret = drm_modeset_backoff(&ctx);
 			if (!ret)
 				goto retry;
 		}
-		KUNIT_ASSERT_EQ(test, ret, 0);
+		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
 	}
 
 	ret = drm_atomic_check_only(state);
@@ -818,6 +901,20 @@
 	.test_cases = vc5_pv_muxing_tests,
 };
 
+static struct kunit_case vc6_pv_muxing_tests[] = {
+	KUNIT_CASE_PARAM(drm_vc4_test_pv_muxing,
+			 vc6_test_pv_muxing_gen_params),
+	KUNIT_CASE_PARAM(drm_vc4_test_pv_muxing_invalid,
+			 vc6_test_pv_muxing_invalid_gen_params),
+	{}
+};
+
+static struct kunit_suite vc6_pv_muxing_test_suite = {
+	.name = "vc6-pv-muxing-combinations",
+	.init = vc4_pv_muxing_test_init,
+	.test_cases = vc6_pv_muxing_tests,
+};
+
 /* See
  * https://lore.kernel.org/all/3e113525-aa89-b1e2-56b7-ca55bd41d057@samsung.com/
  * and
@@ -827,6 +924,7 @@
 {
 	struct drm_modeset_acquire_ctx ctx;
 	struct drm_atomic_state *state;
+	struct vc4_dummy_output *output;
 	struct vc4_crtc_state *new_vc4_crtc_state;
 	struct vc4_hvs_state *new_hvs_state;
 	unsigned int hdmi0_channel;
@@ -845,14 +943,14 @@
 	state = drm_kunit_helper_atomic_state_alloc(test, drm, &ctx);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, state);
 
-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
-	if (ret == -EDEADLK) {
+	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
+	if (IS_ERR(output) && PTR_ERR(output) == -EDEADLK) {
 		drm_atomic_state_clear(state);
 		ret = drm_modeset_backoff(&ctx);
 		if (!ret)
 			goto retry_first;
 	}
-	KUNIT_ASSERT_EQ(test, ret, 0);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
 
 	ret = drm_atomic_check_only(state);
 	if (ret == -EDEADLK) {
@@ -881,14 +979,14 @@
 	state = drm_kunit_helper_atomic_state_alloc(test, drm, &ctx);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, state);
 
-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
-	if (ret == -EDEADLK) {
+	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
+	if (IS_ERR(output) && PTR_ERR(output) == -EDEADLK) {
 		drm_atomic_state_clear(state);
 		ret = drm_modeset_backoff(&ctx);
 		if (!ret)
 			goto retry_second;
 	}
-	KUNIT_ASSERT_EQ(test, ret, 0);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
 
 	ret = drm_atomic_check_only(state);
 	if (ret == -EDEADLK) {
@@ -927,6 +1025,7 @@
 {
 	struct drm_modeset_acquire_ctx ctx;
 	struct drm_atomic_state *state;
+	struct vc4_dummy_output *output;
 	struct vc4_crtc_state *new_vc4_crtc_state;
 	struct vc4_hvs_state *new_hvs_state;
 	unsigned int old_hdmi0_channel;
@@ -945,23 +1044,23 @@
 	state = drm_kunit_helper_atomic_state_alloc(test, drm, &ctx);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, state);
 
-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
-	if (ret == -EDEADLK) {
+	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
+	if (IS_ERR(output) && PTR_ERR(output) == -EDEADLK) {
 		drm_atomic_state_clear(state);
 		ret = drm_modeset_backoff(&ctx);
 		if (!ret)
 			goto retry_first;
 	}
-	KUNIT_ASSERT_EQ(test, ret, 0);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
 
-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
-	if (ret == -EDEADLK) {
+	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
+	if (IS_ERR(output) && PTR_ERR(output) == -EDEADLK) {
 		drm_atomic_state_clear(state);
 		ret = drm_modeset_backoff(&ctx);
 		if (!ret)
 			goto retry_first;
 	}
-	KUNIT_ASSERT_EQ(test, ret, 0);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
 
 	ret = drm_atomic_check_only(state);
 	if (ret == -EDEADLK) {
@@ -1056,6 +1155,7 @@
 {
 	struct drm_modeset_acquire_ctx ctx;
 	struct drm_atomic_state *state;
+	struct vc4_dummy_output *output;
 	struct vc4_crtc_state *new_vc4_crtc_state;
 	struct drm_device *drm;
 	struct vc4_dev *vc4;
@@ -1071,14 +1171,14 @@
 	state = drm_kunit_helper_atomic_state_alloc(test, drm, &ctx);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, state);
 
-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
-	if (ret == -EDEADLK) {
+	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI0);
+	if (IS_ERR(output) && PTR_ERR(output) == -EDEADLK) {
 		drm_atomic_state_clear(state);
 		ret = drm_modeset_backoff(&ctx);
 		if (!ret)
 			goto retry_first;
 	}
-	KUNIT_ASSERT_EQ(test, ret, 0);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
 
 	ret = drm_atomic_check_only(state);
 	if (ret == -EDEADLK) {
@@ -1095,14 +1195,14 @@
 	state = drm_kunit_helper_atomic_state_alloc(test, drm, &ctx);
 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, state);
 
-	ret = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
-	if (ret == -EDEADLK) {
+	output = vc4_mock_atomic_add_output(test, state, VC4_ENCODER_TYPE_HDMI1);
+	if (IS_ERR(output) && PTR_ERR(output) == -EDEADLK) {
 		drm_atomic_state_clear(state);
 		ret = drm_modeset_backoff(&ctx);
 		if (!ret)
 			goto retry_second;
 	}
-	KUNIT_ASSERT_EQ(test, ret, 0);
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, output);
 
 	ret = drm_atomic_check_only(state);
 	if (ret == -EDEADLK) {
@@ -1136,5 +1236,6 @@
 kunit_test_suites(
 	&vc4_pv_muxing_test_suite,
 	&vc5_pv_muxing_test_suite,
+	&vc6_pv_muxing_test_suite,
 	&vc5_pv_muxing_bugs_test_suite
 );
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_crtc.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_crtc.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_crtc.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_crtc.c	2025-06-16 17:40:50.788351389 +0200
@@ -90,7 +90,7 @@
 	 * presumably ignored).
 	 */
 
-	if (vc4->gen >= VC4_GEN_6_C) {
+	if (vc4->gen >= VC4_GEN_6) {
 		dispbase = HVS_READ(SCALER6_DISPX_COB(channel));
 		top = VC4_GET_FIELD(dispbase, SCALER6_DISPX_COB_TOP) & ~3;
 		base = VC4_GET_FIELD(dispbase, SCALER6_DISPX_COB_BASE) & ~3;
@@ -131,7 +131,7 @@
 	 * Read vertical scanline which is currently composed for our
 	 * pixelvalve by the HVS, and also the scaler status.
 	 */
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		val = HVS_READ(SCALER6_DISPX_STATUS(channel));
 	else
 		val = HVS_READ(SCALER_DISPSTATX(channel));
@@ -144,7 +144,7 @@
 
 	/* Vertical position of hvs composed scanline. */
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		*vpos = VC4_GET_FIELD(val, SCALER6_DISPX_STATUS_YLINE);
 	else
 		*vpos = VC4_GET_FIELD(val, SCALER_DISPSTATX_LINE);
@@ -326,6 +326,23 @@
 	return NULL;
 }
 
+#define drm_for_each_connector_mask(connector, dev, connector_mask) \
+	list_for_each_entry((connector), &(dev)->mode_config.connector_list, head) \
+		for_each_if ((connector_mask) & drm_connector_mask(connector))
+
+struct drm_connector *vc4_get_crtc_connector(struct drm_crtc *crtc,
+					     struct drm_crtc_state *state)
+{
+	struct drm_connector *connector;
+
+	WARN_ON(hweight32(state->connector_mask) > 1);
+
+	drm_for_each_connector_mask(connector, crtc->dev, state->connector_mask)
+		return connector;
+
+	return NULL;
+}
+
 static void vc4_crtc_pixelvalve_reset(struct drm_crtc *crtc)
 {
 	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
@@ -361,7 +378,9 @@
 	bool is_dsi1 = vc4_encoder->type == VC4_ENCODER_TYPE_DSI1;
 	bool is_vec = vc4_encoder->type == VC4_ENCODER_TYPE_VEC;
 	u32 format = is_dsi1 ? PV_CONTROL_FORMAT_DSIV_24 : PV_CONTROL_FORMAT_24;
-	u8 ppc = pv_data->pixels_per_clock;
+	u8 ppc = (mode->flags & DRM_MODE_FLAG_INTERLACE) ?
+			pv_data->pixels_per_clock_int :
+			pv_data->pixels_per_clock;
 
 	u16 vert_bp = mode->crtc_vtotal - mode->crtc_vsync_end;
 	u16 vert_sync = mode->crtc_vsync_end - mode->crtc_vsync_start;
@@ -426,7 +445,8 @@
 		 */
 		CRTC_WRITE(PV_V_CONTROL,
 			   PV_VCONTROL_CONTINUOUS |
-			   (vc4->gen >= VC4_GEN_6_C ? PV_VCONTROL_ODD_TIMING : 0) |
+			   (vc4->gen >= VC4_GEN_6 && ppc == 1 ?
+					PV_VCONTROL_ODD_TIMING : 0) |
 			   (is_dsi ? PV_VCONTROL_DSI : 0) |
 			   PV_VCONTROL_INTERLACE |
 			   (odd_field_first
@@ -438,7 +458,8 @@
 	} else {
 		CRTC_WRITE(PV_V_CONTROL,
 			   PV_VCONTROL_CONTINUOUS |
-			   (vc4->gen >= VC4_GEN_6_C ? PV_VCONTROL_ODD_TIMING : 0) |
+			   (vc4->gen >= VC4_GEN_6 && ppc == 1 ?
+					PV_VCONTROL_ODD_TIMING : 0) |
 			   (is_dsi ? PV_VCONTROL_DSI : 0));
 		CRTC_WRITE(PV_VSYNCD_EVEN, 0);
 	}
@@ -458,7 +479,7 @@
 			   VC4_SET_FIELD(PV_MUX_CFG_RGB_PIXEL_MUX_MODE_NO_SWAP,
 					 PV_MUX_CFG_RGB_PIXEL_MUX_MODE));
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		CRTC_WRITE(PV_PIPE_INIT_CTRL,
 			   VC4_SET_FIELD(1, PV_PIPE_INIT_CTRL_PV_INIT_WIDTH) |
 			   VC4_SET_FIELD(1, PV_PIPE_INIT_CTRL_PV_INIT_IDLE) |
@@ -489,7 +510,7 @@
 	struct vc4_dev *vc4 = to_vc4_dev(dev);
 	struct vc4_hvs *hvs = vc4->hvs;
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		WARN_ON_ONCE(!(HVS_READ(SCALER6_CONTROL) & SCALER6_CONTROL_HVS_EN));
 	else
 		WARN_ON_ONCE(!(HVS_READ(SCALER_DISPCTRL) & SCALER_DISPCTRL_ENABLE));
@@ -640,11 +661,14 @@
 
 	vc4_crtc_disable(crtc, encoder, state, old_vc4_state->assigned_channel);
 
+	vc4_hvs_atomic_disable(crtc, state);
+
 	/*
 	 * Make sure we issue a vblank event after disabling the CRTC if
 	 * someone was waiting it.
 	 */
 	vc4_crtc_send_vblank(crtc);
+	msleep(20);
 }
 
 static void vc4_crtc_atomic_enable(struct drm_crtc *crtc,
@@ -777,8 +801,7 @@
 			memcpy(&vc4_state->margins, &conn_state->tv.margins,
 			       sizeof(vc4_state->margins));
 
-			/*
-			 * Need to force the dlist entries for all planes to be
+			/* Need to force the dlist entries for all planes to be
 			 * updated so that the dest rectangles are changed.
 			 */
 			crtc_state->zpos_changed = true;
@@ -809,12 +832,15 @@
 {
 	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
 	struct drm_device *dev = crtc->dev;
+	struct drm_encoder *encoder = vc4_get_crtc_encoder(crtc, crtc->state);
+	struct vc4_encoder *vc4_encoder = to_vc4_encoder(encoder);
 	int idx;
 
 	if (!drm_dev_enter(dev, &idx))
 		return;
 
-	CRTC_WRITE(PV_INTEN, 0);
+	if (!vc4_encoder || vc4_encoder->type != VC4_ENCODER_TYPE_DSI0)
+		CRTC_WRITE(PV_INTEN, 0);
 
 	drm_dev_exit(idx);
 }
@@ -832,7 +858,7 @@
 	spin_lock_irqsave(&dev->event_lock, flags);
 	spin_lock(&vc4_crtc->irq_lock);
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		current_dlist = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_DL(chan)),
 					      SCALER6_DISPX_DL_LACT);
 	else
@@ -850,7 +876,7 @@
 		 * the CRTC and encoder already reconfigured, leading to
 		 * underruns. This can be seen when reconfiguring the CRTC.
 		 */
-		if (vc4->gen < VC4_GEN_6_C)
+		if (0 && vc4->gen < VC4_GEN_6)
 			vc4_hvs_unmask_underrun(hvs, chan);
 	}
 	spin_unlock(&vc4_crtc->irq_lock);
@@ -859,7 +885,14 @@
 
 void vc4_crtc_handle_vblank(struct vc4_crtc *crtc)
 {
+	struct drm_encoder *encoder = vc4_get_crtc_encoder(&crtc->base, crtc->base.state);
+	struct vc4_encoder *vc4_encoder = to_vc4_encoder(encoder);
+
 	crtc->t_vblank = ktime_get();
+
+	if (vc4_encoder && vc4_encoder->vblank)
+		vc4_encoder->vblank(encoder);
+
 	drm_crtc_handle_vblank(&crtc->base);
 	vc4_crtc_handle_page_flip(crtc);
 }
@@ -1123,14 +1156,8 @@
 	struct vc4_dev *vc4 = to_vc4_dev(crtc->dev);
 	struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(state);
 
-	if (drm_mm_node_allocated(&vc4_state->mm)) {
-		unsigned long flags;
-
-		spin_lock_irqsave(&vc4->hvs->mm_lock, flags);
-		drm_mm_remove_node(&vc4_state->mm);
-		spin_unlock_irqrestore(&vc4->hvs->mm_lock, flags);
-
-	}
+	vc4_hvs_mark_dlist_entry_stale(vc4->hvs, vc4_state->mm);
+	vc4_state->mm = NULL;
 
 	drm_atomic_helper_crtc_destroy_state(crtc, state);
 }
@@ -1198,6 +1225,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 1,
+	.pixels_per_clock_int = 1,
 	.encoder_types = {
 		[PV_CONTROL_CLK_SELECT_DSI] = VC4_ENCODER_TYPE_DSI0,
 		[PV_CONTROL_CLK_SELECT_DPI_SMI_HDMI] = VC4_ENCODER_TYPE_DPI,
@@ -1213,6 +1241,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 1,
+	.pixels_per_clock_int = 1,
 	.encoder_types = {
 		[PV_CONTROL_CLK_SELECT_DSI] = VC4_ENCODER_TYPE_DSI1,
 		[PV_CONTROL_CLK_SELECT_DPI_SMI_HDMI] = VC4_ENCODER_TYPE_SMI,
@@ -1228,6 +1257,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 1,
+	.pixels_per_clock_int = 1,
 	.encoder_types = {
 		[PV_CONTROL_CLK_SELECT_DPI_SMI_HDMI] = VC4_ENCODER_TYPE_HDMI0,
 		[PV_CONTROL_CLK_SELECT_VEC] = VC4_ENCODER_TYPE_VEC,
@@ -1243,6 +1273,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 1,
+	.pixels_per_clock_int = 1,
 	.encoder_types = {
 		[0] = VC4_ENCODER_TYPE_DSI0,
 		[1] = VC4_ENCODER_TYPE_DPI,
@@ -1258,6 +1289,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 1,
+	.pixels_per_clock_int = 1,
 	.encoder_types = {
 		[0] = VC4_ENCODER_TYPE_DSI1,
 		[1] = VC4_ENCODER_TYPE_SMI,
@@ -1273,6 +1305,7 @@
 	},
 	.fifo_depth = 256,
 	.pixels_per_clock = 2,
+	.pixels_per_clock_int = 2,
 	.encoder_types = {
 		[0] = VC4_ENCODER_TYPE_HDMI0,
 	},
@@ -1287,6 +1320,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 1,
+	.pixels_per_clock_int = 1,
 	.encoder_types = {
 		[PV_CONTROL_CLK_SELECT_VEC] = VC4_ENCODER_TYPE_VEC,
 	},
@@ -1301,6 +1335,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 2,
+	.pixels_per_clock_int = 2,
 	.encoder_types = {
 		[0] = VC4_ENCODER_TYPE_HDMI1,
 	},
@@ -1314,6 +1349,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 1,
+	.pixels_per_clock_int = 2,
 	.encoder_types = {
 		[0] = VC4_ENCODER_TYPE_HDMI0,
 	},
@@ -1327,6 +1363,7 @@
 	},
 	.fifo_depth = 64,
 	.pixels_per_clock = 1,
+	.pixels_per_clock_int = 2,
 	.encoder_types = {
 		[0] = VC4_ENCODER_TYPE_HDMI1,
 	},
@@ -1418,17 +1455,35 @@
 	if (vc4->gen == VC4_GEN_4) {
 		drm_mode_crtc_set_gamma_size(crtc, ARRAY_SIZE(vc4_crtc->lut_r));
 		drm_crtc_enable_color_mgmt(crtc, 0, false, crtc->gamma_size);
+	}
+
 
+	if (vc4->gen == VC4_GEN_4) {
 		/* We support CTM, but only for one CRTC at a time. It's therefore
 		 * implemented as private driver state in vc4_kms, not here.
 		 */
-		drm_crtc_enable_color_mgmt(crtc, 0, true, crtc->gamma_size);
-	}
+		drm_crtc_enable_color_mgmt(crtc, 0, true, 0);
 
-	for (i = 0; i < crtc->gamma_size; i++) {
-		vc4_crtc->lut_r[i] = i;
-		vc4_crtc->lut_g[i] = i;
-		vc4_crtc->lut_b[i] = i;
+		/* Initialize the VC4 gamma LUTs */
+		for (i = 0; i < crtc->gamma_size; i++) {
+			vc4_crtc->lut_r[i] = i;
+			vc4_crtc->lut_g[i] = i;
+			vc4_crtc->lut_b[i] = i;
+		}
+	} else {
+		/* Initialize the VC5 gamma PWL entries. Assume 12-bit pipeline,
+		 * evenly spread over full range.
+		 */
+		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++) {
+			vc4_crtc->pwl_r[i] =
+				VC5_HVS_SET_GAMMA_ENTRY(i << 8, i << 12, 1 << 8);
+			vc4_crtc->pwl_g[i] =
+				VC5_HVS_SET_GAMMA_ENTRY(i << 8, i << 12, 1 << 8);
+			vc4_crtc->pwl_b[i] =
+				VC5_HVS_SET_GAMMA_ENTRY(i << 8, i << 12, 1 << 8);
+			vc4_crtc->pwl_a[i] =
+				VC5_HVS_SET_GAMMA_ENTRY(i << 8, i << 12, 1 << 8);
+		}
 	}
 
 	return 0;
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_debugfs.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_debugfs.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_debugfs.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_debugfs.c	2025-06-16 17:40:50.788351389 +0200
@@ -24,7 +24,8 @@
 	struct vc4_dev *vc4 = to_vc4_dev(minor->dev);
 	struct drm_device *drm = &vc4->base;
 
-	drm_WARN_ON(drm, vc4_hvs_debugfs_init(minor));
+	if (vc4->hvs)
+		drm_WARN_ON(drm, vc4_hvs_debugfs_init(minor));
 
 	if (vc4->v3d) {
 		drm_WARN_ON(drm, vc4_bo_debugfs_init(minor));
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_dpi.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_dpi.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_dpi.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_dpi.c	2025-06-16 17:40:50.788351389 +0200
@@ -95,6 +95,8 @@
 	struct clk *core_clock;
 
 	struct debugfs_regset32 regset;
+
+	int rgb_order_override;
 };
 
 #define to_vc4_dpi(_encoder)						\
@@ -205,6 +207,11 @@
 			}
 		}
 
+		if (dpi->rgb_order_override >= 0) {
+			dpi_c &= ~DPI_ORDER_MASK;
+			dpi_c |= VC4_SET_FIELD(dpi->rgb_order_override, DPI_ORDER);
+		}
+
 		if (connector->display_info.bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)
 			dpi_c |= DPI_PIXEL_CLK_INVERT;
 
@@ -313,6 +320,7 @@
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct drm_device *drm = dev_get_drvdata(master);
+	const char *rgb_order = NULL;
 	struct vc4_dpi *dpi;
 	int ret;
 
@@ -361,6 +369,20 @@
 	if (ret)
 		return ret;
 
+	dpi->rgb_order_override = -1;
+	if (!of_property_read_string(dev->of_node, "rgb_order", &rgb_order)) {
+		if (!strcmp(rgb_order, "rgb"))
+			dpi->rgb_order_override = DPI_ORDER_RGB;
+		else if (!strcmp(rgb_order, "bgr"))
+			dpi->rgb_order_override = DPI_ORDER_BGR;
+		else if (!strcmp(rgb_order, "grb"))
+			dpi->rgb_order_override = DPI_ORDER_GRB;
+		else if (!strcmp(rgb_order, "brg"))
+			dpi->rgb_order_override = DPI_ORDER_BRG;
+		else
+			DRM_ERROR("Invalid dpi order %s - ignored\n", rgb_order);
+	}
+
 	ret = drmm_encoder_init(drm, &dpi->encoder.base,
 				&vc4_dpi_encoder_funcs,
 				DRM_MODE_ENCODER_DPI,
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_drv.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_drv.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_drv.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_drv.c	2025-06-16 17:40:50.791684722 +0200
@@ -30,6 +30,7 @@
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
+#include <linux/dma-direct.h>
 
 #include <drm/clients/drm_client_setup.h>
 #include <drm/drm_atomic_helper.h>
@@ -176,6 +177,19 @@
 	kfree(vc4file);
 }
 
+static struct drm_gem_object *
+vc4_prime_import_sg_table(struct drm_device *dev,
+			  struct dma_buf_attachment *attach,
+			  struct sg_table *sgt)
+{
+	phys_addr_t phys = dma_to_phys(dev->dev, sg_dma_address(sgt->sgl));
+
+	if (swiotlb_find_pool(dev->dev, phys))
+		return ERR_PTR(-EINVAL);
+
+	return drm_gem_dma_prime_import_sg_table(dev, attach, sgt);
+}
+
 DEFINE_DRM_GEM_FOPS(vc4_drm_fops);
 
 static const struct drm_ioctl_desc vc4_drm_ioctls[] = {
@@ -212,8 +226,9 @@
 
 	.gem_create_object = vc4_create_object,
 
-	DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(vc4_bo_dumb_create),
 	DRM_FBDEV_DMA_DRIVER_OPS,
+	.dumb_create		= vc4_bo_dumb_create,
+	.gem_prime_import_sg_table = vc4_prime_import_sg_table,
 
 	.ioctls = vc4_drm_ioctls,
 	.num_ioctls = ARRAY_SIZE(vc4_drm_ioctls),
@@ -235,8 +250,9 @@
 	.debugfs_init = vc4_debugfs_init,
 #endif
 
-	DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(vc5_dumb_create),
 	DRM_FBDEV_DMA_DRIVER_OPS,
+	.dumb_create		= vc5_dumb_create,
+	.gem_prime_import_sg_table = vc4_prime_import_sg_table,
 
 	.fops = &vc4_drm_fops,
 
@@ -284,6 +300,18 @@
 	{}
 };
 
+/*
+ * we need this helper function for determining presence of fkms
+ * before it's been bound
+ */
+static bool firmware_kms(void)
+{
+	return of_device_is_available(of_find_compatible_node(NULL, NULL,
+	       "raspberrypi,rpi-firmware-kms")) ||
+	       of_device_is_available(of_find_compatible_node(NULL, NULL,
+	       "raspberrypi,rpi-firmware-kms-2711"));
+}
+
 static int vc4_drm_bind(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -305,7 +333,7 @@
 	else
 		driver = &vc4_drm_driver;
 
-	if (gen >= VC4_GEN_6_C)
+	if (gen >= VC4_GEN_6)
 		dma_set_mask_and_coherent(dev, DMA_BIT_MASK(36));
 	else
 		dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));
@@ -364,7 +392,7 @@
 	if (ret)
 		goto err;
 
-	if (firmware) {
+	if (firmware && !firmware_kms()) {
 		ret = rpi_firmware_property(firmware,
 					    RPI_FIRMWARE_NOTIFY_DISPLAY_DONE,
 					    NULL, 0);
@@ -382,16 +410,20 @@
 	if (ret)
 		goto err;
 
-	ret = vc4_plane_create_additional_planes(drm);
-	if (ret)
-		goto err;
+	if (!vc4->firmware_kms) {
+		ret = vc4_plane_create_additional_planes(drm);
+		if (ret)
+			goto err;
+	}
 
 	ret = vc4_kms_load(drm);
 	if (ret < 0)
 		goto err;
 
-	drm_for_each_crtc(crtc, drm)
-		vc4_crtc_disable_at_boot(crtc);
+	if (!vc4->firmware_kms) {
+		drm_for_each_crtc(crtc, drm)
+			vc4_crtc_disable_at_boot(crtc);
+	}
 
 	ret = drm_dev_register(drm, 0);
 	if (ret < 0)
@@ -437,6 +469,7 @@
 	&vc4_dsi_driver,
 	&vc4_txp_driver,
 	&vc4_crtc_driver,
+	&vc4_firmware_kms_driver,
 	&vc4_v3d_driver,
 };
 
@@ -464,7 +497,7 @@
 static const struct of_device_id vc4_of_match[] = {
 	{ .compatible = "brcm,bcm2711-vc5", .data = (void *)VC4_GEN_5 },
 	/* NB GEN_6_C will be corrected on D0 hw to GEN_6_D via vc4_hvs_bind */
-	{ .compatible = "brcm,bcm2712-vc6", .data = (void *)VC4_GEN_6_C },
+	{ .compatible = "brcm,bcm2712-vc6", .data = (void *)VC4_GEN_6 },
 	{ .compatible = "brcm,bcm2835-vc4", .data = (void *)VC4_GEN_4 },
 	{ .compatible = "brcm,cygnus-vc4", .data = (void *)VC4_GEN_4 },
 	{},
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_drv.h linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_drv.h
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_drv.h	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_drv.h	2025-06-16 17:40:50.791684722 +0200
@@ -24,6 +24,7 @@
 #include <kunit/test-bug.h>
 
 #include "uapi/drm/vc4_drm.h"
+#include "vc4_regs.h"
 
 struct drm_device;
 struct drm_gem_object;
@@ -84,6 +85,7 @@
 enum vc4_gen {
 	VC4_GEN_4,
 	VC4_GEN_5,
+	VC4_GEN_6,
 	VC4_GEN_6_C,
 	VC4_GEN_6_D,
 };
@@ -93,11 +95,16 @@
 	struct device *dev;
 
 	enum vc4_gen gen;
+	bool step_d0;
 
 	unsigned int irq;
 
+	bool firmware_kms;
+	struct rpi_firmware *firmware;
+
 	struct vc4_hvs *hvs;
 	struct vc4_v3d *v3d;
+	struct vc4_fkms *fkms;
 
 	struct vc4_hang_state *hang_state;
 
@@ -297,19 +304,6 @@
 	struct debugfs_regset32 regset;
 };
 
-#define VC4_NUM_UPM_HANDLES 32
-struct vc4_upm_refcounts {
-	refcount_t refcount;
-
-	/* Allocation size */
-	size_t size;
-	/* Our allocation in UPM for prefetching. */
-	struct drm_mm_node upm;
-
-	/* Pointer back to the HVS structure */
-	struct vc4_hvs *hvs;
-};
-
 #define HVS_NUM_CHANNELS 3
 
 struct vc4_hvs {
@@ -322,24 +316,31 @@
 	struct clk *core_clk;
 	struct clk *disp_clk;
 
+	struct {
+		unsigned int desc;
+		unsigned int enabled: 1;
+	} eof_irq[HVS_NUM_CHANNELS];
+
 	unsigned long max_core_rate;
 
 	/* Memory manager for CRTCs to allocate space in the display
 	 * list.  Units are dwords.
 	 */
 	struct drm_mm dlist_mm;
-
 	/* Memory manager for the LBM memory used by HVS scaling. */
 	struct drm_mm lbm_mm;
 
 	/* Memory manager for the UPM memory used for prefetching. */
 	struct drm_mm upm_mm;
 	struct ida upm_handles;
-	struct vc4_upm_refcounts upm_refcounts[VC4_NUM_UPM_HANDLES + 1];
 
 	spinlock_t mm_lock;
 
+	struct list_head stale_dlist_entries;
+	struct work_struct free_dlist_work;
+
 	struct drm_mm_node mitchell_netravali_filter;
+	struct drm_mm_node nearest_neighbour_filter;
 
 	struct debugfs_regset32 regset;
 
@@ -358,7 +359,6 @@
 	bool vc5_hdmi_enable_4096by2160;
 };
 
-#define HVS_NUM_CHANNELS 3
 #define HVS_UBM_WORD_SIZE 256
 
 struct vc4_hvs_state {
@@ -401,6 +401,8 @@
 	u32 dlist_size; /* Number of dwords allocated for the display list */
 	u32 dlist_count; /* Number of used dwords in the display list. */
 
+	u32 lbm_size; /* LBM requirements for this plane */
+
 	/* Offset in the dlist to various words, for pageflip or
 	 * cursor updates.
 	 */
@@ -426,8 +428,8 @@
 	bool is_unity;
 	bool is_yuv;
 
-	/* Our allocation in LBM for temporary storage during scaling. */
-	struct drm_mm_node lbm;
+	/* Our allocation in UPM for prefetching. */
+	struct drm_mm_node upm[DRM_FORMAT_MAX_PLANES];
 
 	/* The Unified Pre-Fetcher Handle */
 	unsigned int upm_handle[DRM_FORMAT_MAX_PLANES];
@@ -484,6 +486,7 @@
 
 	void (*post_crtc_disable)(struct drm_encoder *encoder, struct drm_atomic_state *state);
 	void (*post_crtc_powerdown)(struct drm_encoder *encoder, struct drm_atomic_state *state);
+	void (*vblank)(struct drm_encoder *encoder);
 };
 
 #define to_vc4_encoder(_encoder)				\
@@ -505,6 +508,17 @@
 	return NULL;
 }
 
+struct vc5_gamma_entry {
+	u32 x_c_terms;
+	u32 grad_term;
+};
+
+#define VC5_HVS_SET_GAMMA_ENTRY(x, c, g) (struct vc5_gamma_entry){	\
+	.x_c_terms = VC4_SET_FIELD((x), SCALER5_DSPGAMMA_OFF_X) | 	\
+		     VC4_SET_FIELD((c), SCALER5_DSPGAMMA_OFF_C),	\
+	.grad_term = (g)						\
+}
+
 struct vc4_crtc_data {
 	const char *name;
 
@@ -526,6 +540,8 @@
 	unsigned int supports_40bit_addresses:1;
 };
 
+extern const struct vc4_txp_data bcm2712_mop_data;
+extern const struct vc4_txp_data bcm2712_moplet_data;
 extern const struct vc4_txp_data bcm2835_txp_data;
 
 struct vc4_pv_data {
@@ -536,6 +552,8 @@
 
 	/* Number of pixels output per clock period */
 	u8 pixels_per_clock;
+	/* Number of pixels output per clock period when in an interlaced mode */
+	u8 pixels_per_clock_int;
 
 	enum vc4_encoder_type encoder_types[4];
 };
@@ -560,9 +578,19 @@
 	/* Timestamp at start of vblank irq - unaffected by lock delays. */
 	ktime_t t_vblank;
 
-	u8 lut_r[256];
-	u8 lut_g[256];
-	u8 lut_b[256];
+	union {
+		struct {  /* VC4 gamma LUT */
+			u8 lut_r[256];
+			u8 lut_g[256];
+			u8 lut_b[256];
+		};
+		struct {  /* VC5 gamma PWL entries */
+			struct vc5_gamma_entry pwl_r[SCALER5_DSPGAMMA_NUM_POINTS];
+			struct vc5_gamma_entry pwl_g[SCALER5_DSPGAMMA_NUM_POINTS];
+			struct vc5_gamma_entry pwl_b[SCALER5_DSPGAMMA_NUM_POINTS];
+			struct vc5_gamma_entry pwl_a[SCALER5_DSPGAMMA_NUM_POINTS];
+		};
+	};
 
 	struct drm_pending_vblank_event *event;
 
@@ -594,6 +622,9 @@
 	 * access to that value.
 	 */
 	unsigned int current_hvs_channel;
+
+	/* @lbm: Our allocation in LBM for temporary storage during scaling. */
+	struct drm_mm_node lbm;
 };
 
 #define to_vc4_crtc(_crtc)					\
@@ -613,13 +644,23 @@
 	return container_of_const(data, struct vc4_pv_data, base);
 }
 
+struct drm_connector *vc4_get_crtc_connector(struct drm_crtc *crtc,
+					     struct drm_crtc_state *state);
+
 struct drm_encoder *vc4_get_crtc_encoder(struct drm_crtc *crtc,
 					 struct drm_crtc_state *state);
 
+struct vc4_hvs_dlist_allocation {
+	struct list_head node;
+	struct drm_mm_node mm_node;
+	unsigned int channel;
+	u8 target_frame_count;
+	bool dlist_programmed;
+};
+
 struct vc4_crtc_state {
 	struct drm_crtc_state base;
-	/* Dlist area for this CRTC configuration. */
-	struct drm_mm_node mm;
+	struct vc4_hvs_dlist_allocation *mm;
 	bool txp_armed;
 	unsigned int assigned_channel;
 
@@ -661,10 +702,10 @@
 	} while (0)
 
 #define HVS_READ6(offset) \
-	HVS_READ(hvs->vc4->gen == VC4_GEN_6_C ? SCALER6_ ## offset : SCALER6D_ ## offset)
+	HVS_READ(hvs->vc4->step_d0 ? SCALER6_ ## offset : SCALER6D0_ ## offset)		\
 
 #define HVS_WRITE6(offset, val) \
-	HVS_WRITE(hvs->vc4->gen == VC4_GEN_6_C ? SCALER6_ ## offset : SCALER6D_ ## offset, val)
+	HVS_WRITE(hvs->vc4->step_d0 ? SCALER6_ ## offset : SCALER6D0_ ## offset, val)	\
 
 #define VC4_REG32(reg) { .name = #reg, .offset = reg }
 
@@ -987,6 +1028,9 @@
 /* vc4_fence.c */
 extern const struct dma_fence_ops vc4_fence_ops;
 
+/* vc4_firmware_kms.c */
+extern struct platform_driver vc4_firmware_kms_driver;
+
 /* vc4_gem.c */
 int vc4_gem_init(struct drm_device *dev);
 int vc4_submit_cl_ioctl(struct drm_device *dev, void *data,
@@ -1028,6 +1072,8 @@
 void vc4_hvs_stop_channel(struct vc4_hvs *hvs, unsigned int output);
 int vc4_hvs_get_fifo_from_output(struct vc4_hvs *hvs, unsigned int output);
 u8 vc4_hvs_get_fifo_frame_count(struct vc4_hvs *hvs, unsigned int fifo);
+void vc4_hvs_mark_dlist_entry_stale(struct vc4_hvs *hvs,
+				    struct vc4_hvs_dlist_allocation *alloc);
 int vc4_hvs_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state);
 void vc4_hvs_atomic_begin(struct drm_crtc *crtc, struct drm_atomic_state *state);
 void vc4_hvs_atomic_enable(struct drm_crtc *crtc, struct drm_atomic_state *state);
@@ -1045,6 +1091,12 @@
 struct drm_plane *vc4_plane_init(struct drm_device *dev,
 				 enum drm_plane_type type,
 				 uint32_t possible_crtcs);
+void vc4_plane_reset(struct drm_plane *plane);
+void vc4_plane_destroy_state(struct drm_plane *plane,
+			     struct drm_plane_state *state);
+struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane);
+int vc4_plane_atomic_check(struct drm_plane *plane,
+			   struct drm_atomic_state *state);
 int vc4_plane_create_additional_planes(struct drm_device *dev);
 u32 vc4_plane_write_dlist(struct drm_plane *plane, u32 __iomem *dlist);
 u32 vc4_plane_dlist_size(const struct drm_plane_state *state);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_dsi.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_dsi.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_dsi.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_dsi.c	2025-06-16 17:40:50.791684722 +0200
@@ -286,6 +286,8 @@
 					 DSI1_INT_PR_TO)
 
 #define DSI0_STAT		0x2c
+# define DSI0_STAT_ERR_CONT_LP1		BIT(6)
+# define DSI0_STAT_ERR_CONT_LP0		BIT(5)
 #define DSI0_HSTX_TO_CNT	0x30
 #define DSI0_LPRX_TO_CNT	0x34
 #define DSI0_TA_TO_CNT		0x38
@@ -358,6 +360,16 @@
 # define DSI_PHY_AFEC0_CTATADJ_MASK		VC4_MASK(3, 0)
 # define DSI_PHY_AFEC0_CTATADJ_SHIFT		0
 
+# define DSI0_AFEC0_PD_ALL_LANES	(DSI0_PHY_AFEC0_PD | \
+					 DSI0_PHY_AFEC0_PD_BG | \
+					 DSI0_PHY_AFEC0_PD_DLANE1)
+
+# define DSI1_AFEC0_PD_ALL_LANES	(DSI1_PHY_AFEC0_PD | \
+					 DSI1_PHY_AFEC0_PD_BG | \
+					 DSI1_PHY_AFEC0_PD_DLANE3 | \
+					 DSI1_PHY_AFEC0_PD_DLANE2 | \
+					 DSI1_PHY_AFEC0_PD_DLANE1)
+
 #define DSI0_PHY_AFEC1		0x68
 # define DSI0_PHY_AFEC1_IDR_DLANE1_MASK		VC4_MASK(10, 8)
 # define DSI0_PHY_AFEC1_IDR_DLANE1_SHIFT	8
@@ -398,7 +410,8 @@
 # define DSI1_CTRL_DISABLE_DISP_ECCC	BIT(1)
 # define DSI0_CTRL_CTRL0		BIT(0)
 # define DSI1_CTRL_EN			BIT(0)
-# define DSI0_CTRL_RESET_FIFOS		(DSI_CTRL_CLR_LDF | \
+# define DSI0_CTRL_RESET_FIFOS		(DSI0_CTRL_CTRL0 | \
+					 DSI_CTRL_CLR_LDF | \
 					 DSI0_CTRL_CLR_PBCF | \
 					 DSI0_CTRL_CLR_CPBCF |	\
 					 DSI0_CTRL_CLR_PDF | \
@@ -814,6 +827,15 @@
 	struct vc4_dsi *dsi = bridge_to_vc4_dsi(bridge);
 	struct device *dev = &dsi->pdev->dev;
 
+	/* Reset the DSI and all its fifos. */
+	DSI_PORT_WRITE(CTRL, DSI_CTRL_SOFT_RESET_CFG |
+		       DSI_PORT_BIT(CTRL_RESET_FIFOS));
+
+	/* Power down the analogue front end. */
+	DSI_PORT_WRITE(PHY_AFEC0, DSI_PORT_BIT(PHY_AFEC0_RESET) |
+		       DSI_PORT_BIT(PHY_AFEC0_PD) |
+		       DSI_PORT_BIT(AFEC0_PD_ALL_LANES));
+
 	clk_disable_unprepare(dsi->pll_phy_clock);
 	clk_disable_unprepare(dsi->escape_clock);
 	clk_disable_unprepare(dsi->pixel_clock);
@@ -844,6 +866,7 @@
 	unsigned long pixel_clock_hz = mode->clock * 1000;
 	unsigned long pll_clock = pixel_clock_hz * dsi->divider;
 	int divider;
+	u16 htotal;
 
 	/* Find what divider gets us a faster clock than the requested
 	 * pixel clock.
@@ -860,12 +883,27 @@
 	pixel_clock_hz = pll_clock / dsi->divider;
 
 	adjusted_mode->clock = pixel_clock_hz / 1000;
+	htotal = mode->htotal;
+
+	if (dsi->variant->port == 0 && mode->clock == 30000 &&
+	    mode->hdisplay == 800 && mode->htotal == (800 + 59 + 2 + 45) &&
+	    mode->vdisplay == 480 && mode->vtotal == (480 + 7 + 2 + 22)) {
+		/*
+		 * Raspberry Pi 7" panel via TC358762 seems to have an issue on
+		 * DSI0 that it doesn't actually follow the vertical timing that
+		 * is otherwise identical to that produced on DSI1.
+		 * Fixup the mode.
+		 */
+		htotal = 800 + 59 + 2 + 47;
+		adjusted_mode->vtotal = 480 + 7 + 2 + 45;
+		adjusted_mode->crtc_vtotal = 480 + 7 + 2 + 45;
+	}
 
 	/* Given the new pixel clock, adjust HFP to keep vrefresh the same. */
-	adjusted_mode->htotal = adjusted_mode->clock * mode->htotal /
+	adjusted_mode->htotal = adjusted_mode->clock * htotal /
 				mode->clock;
-	adjusted_mode->hsync_end += adjusted_mode->htotal - mode->htotal;
-	adjusted_mode->hsync_start += adjusted_mode->htotal - mode->htotal;
+	adjusted_mode->hsync_end += adjusted_mode->htotal - htotal;
+	adjusted_mode->hsync_start += adjusted_mode->htotal - htotal;
 
 	return true;
 }
@@ -924,12 +962,32 @@
 			"Failed to set phy clock to %ld: %d\n", phy_clock, ret);
 	}
 
-	/* Reset the DSI and all its fifos. */
+	ret = clk_prepare_enable(dsi->escape_clock);
+	if (ret) {
+		drm_err(bridge->dev, "Failed to turn on DSI escape clock: %d\n",
+			ret);
+		return;
+	}
+
+	ret = clk_prepare_enable(dsi->pll_phy_clock);
+	if (ret) {
+		drm_err(bridge->dev, "Failed to turn on DSI PLL: %d\n", ret);
+		return;
+	}
+
+	hs_clock = clk_get_rate(dsi->pll_phy_clock);
+
+	/*
+	 * Reset the DSI and all its fifos. The block must be enabled for the
+	 * FIFO resets to trigger.
+	 */
 	DSI_PORT_WRITE(CTRL,
 		       DSI_CTRL_SOFT_RESET_CFG |
 		       DSI_PORT_BIT(CTRL_RESET_FIFOS));
 
 	DSI_PORT_WRITE(CTRL,
+		       ((dsi->variant->port == 0) ?
+					DSI0_CTRL_CTRL0 : DSI1_CTRL_EN) |
 		       DSI_CTRL_HSDT_EOT_DISABLE |
 		       DSI_CTRL_RX_LPDT_EOT_DISABLE);
 
@@ -982,21 +1040,6 @@
 		mdelay(1);
 	}
 
-	ret = clk_prepare_enable(dsi->escape_clock);
-	if (ret) {
-		drm_err(bridge->dev, "Failed to turn on DSI escape clock: %d\n",
-			ret);
-		return;
-	}
-
-	ret = clk_prepare_enable(dsi->pll_phy_clock);
-	if (ret) {
-		drm_err(bridge->dev, "Failed to turn on DSI PLL: %d\n", ret);
-		return;
-	}
-
-	hs_clock = clk_get_rate(dsi->pll_phy_clock);
-
 	/* Yes, we set the DSI0P/DSI1P pixel clock to the byte rate,
 	 * not the pixel clock rate.  DSIxP take from the APHY's byte,
 	 * DDR2, or DDR4 clock (we use byte) and feed into the PV at
@@ -1112,12 +1155,6 @@
 				     DSI_DISP1_PFORMAT) |
 		       DSI_DISP1_ENABLE);
 
-	/* Ungate the block. */
-	if (dsi->variant->port == 0)
-		DSI_PORT_WRITE(CTRL, DSI_PORT_READ(CTRL) | DSI0_CTRL_CTRL0);
-	else
-		DSI_PORT_WRITE(CTRL, DSI_PORT_READ(CTRL) | DSI1_CTRL_EN);
-
 	/* Bring AFE out of reset. */
 	DSI_PORT_WRITE(PHY_AFEC0,
 		       DSI_PORT_READ(PHY_AFEC0) &
@@ -1168,10 +1205,9 @@
 				 &dsi->bridge, flags);
 }
 
-static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
-				     const struct mipi_dsi_msg *msg)
+static ssize_t vc4_dsi_transfer(struct vc4_dsi *dsi,
+				const struct mipi_dsi_msg *msg, bool log_error)
 {
-	struct vc4_dsi *dsi = host_to_dsi(host);
 	struct drm_device *drm = dsi->bridge.dev;
 	struct mipi_dsi_packet packet;
 	u32 pkth = 0, pktc = 0;
@@ -1281,10 +1317,12 @@
 	DSI_PORT_WRITE(TXPKT1C, pktc);
 
 	if (!wait_for_completion_timeout(&dsi->xfer_completion,
-					 msecs_to_jiffies(1000))) {
-		dev_err(&dsi->pdev->dev, "transfer interrupt wait timeout");
-		dev_err(&dsi->pdev->dev, "instat: 0x%08x\n",
-			DSI_PORT_READ(INT_STAT));
+					 msecs_to_jiffies(500))) {
+		if (log_error) {
+			dev_err(&dsi->pdev->dev, "transfer interrupt wait timeout");
+			dev_err(&dsi->pdev->dev, "instat: 0x%08x, stat: 0x%08x\n",
+				DSI_PORT_READ(INT_STAT), DSI_PORT_READ(INT_STAT));
+		}
 		ret = -ETIMEDOUT;
 	} else {
 		ret = dsi->xfer_result;
@@ -1327,7 +1365,8 @@
 	return ret;
 
 reset_fifo_and_return:
-	drm_err(drm, "DSI transfer failed, resetting: %d\n", ret);
+	if (log_error)
+		drm_err(drm, "DSI transfer failed, resetting: %d\n", ret);
 
 	DSI_PORT_WRITE(TXPKT1C, DSI_PORT_READ(TXPKT1C) & ~DSI_TXPKT1C_CMD_EN);
 	udelay(1);
@@ -1340,6 +1379,40 @@
 	return ret;
 }
 
+static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
+				     const struct mipi_dsi_msg *msg)
+{
+	struct vc4_dsi *dsi = host_to_dsi(host);
+	u32 stat, disp0_ctrl;
+	int ret;
+
+	ret = vc4_dsi_transfer(dsi, msg, false);
+
+	if (ret == -ETIMEDOUT) {
+		stat = DSI_PORT_READ(STAT);
+		disp0_ctrl = DSI_PORT_READ(DISP0_CTRL);
+
+		DSI_PORT_WRITE(STAT, DSI_PORT_BIT(STAT_ERR_CONT_LP1));
+		if (!(disp0_ctrl & DSI_DISP0_ENABLE)) {
+			/* If video mode not enabled, then try recovering by
+			 * enabling it briefly to clear FIFOs and the state.
+			 */
+			disp0_ctrl |= DSI_DISP0_ENABLE;
+			DSI_PORT_WRITE(DISP0_CTRL, disp0_ctrl);
+			msleep(30);
+			disp0_ctrl &= ~DSI_DISP0_ENABLE;
+			DSI_PORT_WRITE(DISP0_CTRL, disp0_ctrl);
+			msleep(30);
+
+			ret = vc4_dsi_transfer(dsi, msg, true);
+		} else {
+			DRM_ERROR("DSI transfer failed whilst in HS mode stat: 0x%08x\n",
+				  stat);
+		}
+	}
+	return ret;
+}
+
 static const struct component_ops vc4_dsi_ops;
 static int vc4_dsi_host_attach(struct mipi_dsi_host *host,
 			       struct mipi_dsi_device *device)
@@ -1419,6 +1492,15 @@
 	.mode_fixup = vc4_dsi_bridge_mode_fixup,
 };
 
+static void vc4_dsi_reset_fifo(struct drm_encoder *encoder)
+{
+	struct vc4_dsi *dsi = to_vc4_dsi(encoder);
+	u32 val;
+
+	val = DSI_PORT_READ(CTRL);
+	DSI_PORT_WRITE(CTRL, val | DSI0_CTRL_CLR_PBCF);
+}
+
 static int vc4_dsi_late_register(struct drm_encoder *encoder)
 {
 	struct drm_device *drm = encoder->dev;
@@ -1646,6 +1728,9 @@
 	dsi->encoder.type = dsi->variant->port ?
 		VC4_ENCODER_TYPE_DSI1 : VC4_ENCODER_TYPE_DSI0;
 
+	if (dsi->encoder.type == VC4_ENCODER_TYPE_DSI0)
+		dsi->encoder.vblank = vc4_dsi_reset_fifo;
+
 	dsi->regs = vc4_ioremap_regs(pdev, 0);
 	if (IS_ERR(dsi->regs))
 		return PTR_ERR(dsi->regs);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_firmware_kms.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_firmware_kms.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_firmware_kms.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_firmware_kms.c	2025-06-16 17:40:50.791684722 +0200
@@ -0,0 +1,2079 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/**
+ * DOC: VC4 firmware KMS module.
+ *
+ * As a hack to get us from the current closed source driver world
+ * toward a totally open stack, implement KMS on top of the Raspberry
+ * Pi's firmware display stack.
+ */
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_blend.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_fb_dma_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_framebuffer.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_vblank.h>
+
+#include <linux/component.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <soc/bcm2835/raspberrypi-firmware.h>
+
+#include "vc4_drv.h"
+#include "vc4_regs.h"
+#include "vc_image_types.h"
+
+int fkms_max_refresh_rate = 85;
+module_param(fkms_max_refresh_rate, int, 0644);
+MODULE_PARM_DESC(fkms_max_refresh_rate, "Max supported refresh rate");
+
+struct get_display_cfg {
+	u32  max_pixel_clock[2];  //Max pixel clock for each display
+};
+
+enum vc4_fkms_revision {
+	BCM2835_6_7,
+	BCM2711,
+	BCM2712,
+};
+
+struct vc4_fkms {
+	struct get_display_cfg cfg;
+	enum vc4_fkms_revision revision;
+};
+
+#define PLANES_PER_CRTC		8
+
+struct set_plane {
+	u8 display;
+	u8 plane_id;
+	u8 vc_image_type;
+	s8 layer;
+
+	u16 width;
+	u16 height;
+
+	u16 pitch;
+	u16 vpitch;
+
+	u32 src_x;	/* 16p16 */
+	u32 src_y;	/* 16p16 */
+
+	u32 src_w;	/* 16p16 */
+	u32 src_h;	/* 16p16 */
+
+	s16 dst_x;
+	s16 dst_y;
+
+	u16 dst_w;
+	u16 dst_h;
+
+	u8 alpha;
+	u8 num_planes;
+	u8 is_vu;
+	u8 color_encoding;
+
+	u32 planes[4];  /* DMA address of each plane */
+
+	u32 transform;
+};
+
+/* Values for the transform field */
+#define TRANSFORM_NO_ROTATE	0
+#define TRANSFORM_ROTATE_180	BIT(1)
+#define TRANSFORM_FLIP_HRIZ	BIT(16)
+#define TRANSFORM_FLIP_VERT	BIT(17)
+
+struct mailbox_set_plane {
+	struct rpi_firmware_property_tag_header tag;
+	struct set_plane plane;
+};
+
+struct mailbox_blank_display {
+	struct rpi_firmware_property_tag_header tag1;
+	u32 display;
+	struct rpi_firmware_property_tag_header tag2;
+	u32 blank;
+};
+
+struct mailbox_display_pwr {
+	struct rpi_firmware_property_tag_header tag1;
+	u32 display;
+	u32 state;
+};
+
+struct mailbox_get_edid {
+	struct rpi_firmware_property_tag_header tag1;
+	u32 block;
+	u32 display_number;
+	u8 edid[128];
+};
+
+struct set_timings {
+	u8 display;
+	u8 padding;
+	u16 video_id_code;
+
+	u32 clock;		/* in kHz */
+
+	u16 hdisplay;
+	u16 hsync_start;
+
+	u16 hsync_end;
+	u16 htotal;
+
+	u16 hskew;
+	u16 vdisplay;
+
+	u16 vsync_start;
+	u16 vsync_end;
+
+	u16 vtotal;
+	u16 vscan;
+
+	u16 vrefresh;
+	u16 padding2;
+
+	u32 flags;
+#define  TIMINGS_FLAGS_H_SYNC_POS	BIT(0)
+#define  TIMINGS_FLAGS_H_SYNC_NEG	0
+#define  TIMINGS_FLAGS_V_SYNC_POS	BIT(1)
+#define  TIMINGS_FLAGS_V_SYNC_NEG	0
+#define  TIMINGS_FLAGS_INTERLACE	BIT(2)
+
+#define TIMINGS_FLAGS_ASPECT_MASK	GENMASK(7, 4)
+#define TIMINGS_FLAGS_ASPECT_NONE	(0 << 4)
+#define TIMINGS_FLAGS_ASPECT_4_3	(1 << 4)
+#define TIMINGS_FLAGS_ASPECT_16_9	(2 << 4)
+#define TIMINGS_FLAGS_ASPECT_64_27	(3 << 4)
+#define TIMINGS_FLAGS_ASPECT_256_135	(4 << 4)
+
+/* Limited range RGB flag. Not set corresponds to full range. */
+#define TIMINGS_FLAGS_RGB_LIMITED	BIT(8)
+/* DVI monitor, therefore disable infoframes. Not set corresponds to HDMI. */
+#define TIMINGS_FLAGS_DVI		BIT(9)
+/* Double clock */
+#define TIMINGS_FLAGS_DBL_CLK		BIT(10)
+};
+
+struct mailbox_set_mode {
+	struct rpi_firmware_property_tag_header tag1;
+	struct set_timings timings;
+};
+
+static const struct vc_image_format {
+	u32 drm;	/* DRM_FORMAT_* */
+	u32 vc_image;	/* VC_IMAGE_* */
+	u32 is_vu;
+} vc_image_formats[] = {
+	{
+		.drm = DRM_FORMAT_XRGB8888,
+		.vc_image = VC_IMAGE_XRGB8888,
+	},
+	{
+		.drm = DRM_FORMAT_ARGB8888,
+		.vc_image = VC_IMAGE_ARGB8888,
+	},
+	{
+		.drm = DRM_FORMAT_XBGR8888,
+		.vc_image = VC_IMAGE_RGBX32,
+	},
+	{
+		.drm = DRM_FORMAT_ABGR8888,
+		.vc_image = VC_IMAGE_RGBA32,
+	},
+	{
+		.drm = DRM_FORMAT_RGBX8888,
+		.vc_image = VC_IMAGE_BGRX8888,
+	},
+	{
+		.drm = DRM_FORMAT_BGRX8888,
+		.vc_image = VC_IMAGE_RGBX8888,
+	},
+	{
+		.drm = DRM_FORMAT_RGB565,
+		.vc_image = VC_IMAGE_RGB565,
+	},
+	{
+		.drm = DRM_FORMAT_RGB888,
+		.vc_image = VC_IMAGE_BGR888,
+	},
+	{
+		.drm = DRM_FORMAT_BGR888,
+		.vc_image = VC_IMAGE_RGB888,
+	},
+	{
+		.drm = DRM_FORMAT_YUV422,
+		.vc_image = VC_IMAGE_YUV422PLANAR,
+	},
+	{
+		.drm = DRM_FORMAT_YUV420,
+		.vc_image = VC_IMAGE_YUV420,
+	},
+	{
+		.drm = DRM_FORMAT_YVU420,
+		.vc_image = VC_IMAGE_YUV420,
+		.is_vu = 1,
+	},
+	{
+		.drm = DRM_FORMAT_NV12,
+		.vc_image = VC_IMAGE_YUV420SP,
+	},
+	{
+		.drm = DRM_FORMAT_NV21,
+		.vc_image = VC_IMAGE_YUV420SP,
+		.is_vu = 1,
+	},
+	{
+		.drm = DRM_FORMAT_P030,
+		.vc_image = VC_IMAGE_YUV10COL,
+	},
+};
+
+static const struct vc_image_format *vc4_get_vc_image_fmt(u32 drm_format)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(vc_image_formats); i++) {
+		if (vc_image_formats[i].drm == drm_format)
+			return &vc_image_formats[i];
+	}
+
+	return NULL;
+}
+
+/* The firmware delivers a vblank interrupt to us through the SMI
+ * hardware, which has only this one register.
+ */
+#define SMICS 0x0
+#define SMIDSW0 0x14
+#define SMIDSW1 0x1C
+#define SMICS_INTERRUPTS (BIT(9) | BIT(10) | BIT(11))
+
+/* Flag to denote that the firmware is giving multiple display callbacks */
+#define SMI_NEW 0xabcd0000
+
+struct vc4_fkms_crtc {
+	struct drm_crtc base;
+	struct drm_encoder *encoder;
+	struct drm_connector *connector;
+	void __iomem *regs;
+
+	struct drm_pending_vblank_event *event;
+	bool vblank_enabled;
+	u32 display_number;
+	u32 display_type;
+};
+
+static inline struct vc4_fkms_crtc *to_vc4_fkms_crtc(struct drm_crtc *crtc)
+{
+	return container_of(crtc, struct vc4_fkms_crtc, base);
+}
+
+struct vc4_fkms_encoder {
+	struct drm_encoder base;
+	bool hdmi_monitor;
+	bool rgb_range_selectable;
+	int display_num;
+};
+
+static inline struct vc4_fkms_encoder *
+to_vc4_fkms_encoder(struct drm_encoder *encoder)
+{
+	return container_of(encoder, struct vc4_fkms_encoder, base);
+}
+
+/* "Broadcast RGB" property.
+ * Allows overriding of HDMI full or limited range RGB
+ */
+#define VC4_BROADCAST_RGB_AUTO 0
+#define VC4_BROADCAST_RGB_FULL 1
+#define VC4_BROADCAST_RGB_LIMITED 2
+
+/* VC4 FKMS connector KMS struct */
+struct vc4_fkms_connector {
+	struct drm_connector base;
+
+	/* Since the connector is attached to just the one encoder,
+	 * this is the reference to it so we can do the best_encoder()
+	 * hook.
+	 */
+	struct drm_encoder *encoder;
+	struct vc4_dev *vc4_dev;
+	u32 display_number;
+	u32 display_type;
+
+	struct drm_property *broadcast_rgb_property;
+};
+
+static inline struct vc4_fkms_connector *
+to_vc4_fkms_connector(struct drm_connector *connector)
+{
+	return container_of(connector, struct vc4_fkms_connector, base);
+}
+
+/* VC4 FKMS connector state */
+struct vc4_fkms_connector_state {
+	struct drm_connector_state base;
+
+	int broadcast_rgb;
+};
+
+#define to_vc4_fkms_connector_state(x) \
+			container_of(x, struct vc4_fkms_connector_state, base)
+
+static u32 vc4_get_display_type(u32 display_number)
+{
+	const u32 display_types[] = {
+		/* The firmware display (DispmanX) IDs map to specific types in
+		 * a fixed manner.
+		 */
+		DRM_MODE_ENCODER_DSI,	/* MAIN_LCD - DSI or DPI */
+		DRM_MODE_ENCODER_DSI,	/* AUX_LCD */
+		DRM_MODE_ENCODER_TMDS,	/* HDMI0 */
+		DRM_MODE_ENCODER_TVDAC,	/* VEC */
+		DRM_MODE_ENCODER_NONE,	/* FORCE_LCD */
+		DRM_MODE_ENCODER_NONE,	/* FORCE_TV */
+		DRM_MODE_ENCODER_NONE,	/* FORCE_OTHER */
+		DRM_MODE_ENCODER_TMDS,	/* HDMI1 */
+		DRM_MODE_ENCODER_NONE,	/* FORCE_TV2 */
+	};
+	return display_number > ARRAY_SIZE(display_types) - 1 ?
+			DRM_MODE_ENCODER_NONE : display_types[display_number];
+}
+
+/* Firmware's structure for making an FB mbox call. */
+struct fbinfo_s {
+	u32 xres, yres, xres_virtual, yres_virtual;
+	u32 pitch, bpp;
+	u32 xoffset, yoffset;
+	u32 base;
+	u32 screen_size;
+	u16 cmap[256];
+};
+
+struct vc4_fkms_plane {
+	struct drm_plane base;
+	struct fbinfo_s *fbinfo;
+	dma_addr_t fbinfo_bus_addr;
+	u32 pitch;
+	struct mailbox_set_plane mb;
+};
+
+static inline struct vc4_fkms_plane *to_vc4_fkms_plane(struct drm_plane *plane)
+{
+	return (struct vc4_fkms_plane *)plane;
+}
+
+static int vc4_plane_set_blank(struct drm_plane *plane, bool blank)
+{
+	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
+	struct vc4_fkms_plane *vc4_plane = to_vc4_fkms_plane(plane);
+	struct mailbox_set_plane blank_mb = {
+		.tag = { RPI_FIRMWARE_SET_PLANE, sizeof(struct set_plane), 0 },
+		.plane = {
+			.display = vc4_plane->mb.plane.display,
+			.plane_id = vc4_plane->mb.plane.plane_id,
+		}
+	};
+	static const char * const plane_types[] = {
+							"overlay",
+							"primary",
+							"cursor"
+						  };
+	int ret;
+
+	DRM_DEBUG_ATOMIC("[PLANE:%d:%s] %s plane %s",
+			 plane->base.id, plane->name, plane_types[plane->type],
+			 blank ? "blank" : "unblank");
+
+	if (blank)
+		ret = rpi_firmware_property_list(vc4->firmware, &blank_mb,
+						 sizeof(blank_mb));
+	else
+		ret = rpi_firmware_property_list(vc4->firmware, &vc4_plane->mb,
+						 sizeof(vc4_plane->mb));
+
+	WARN_ONCE(ret, "%s: firmware call failed. Please update your firmware",
+		  __func__);
+	return ret;
+}
+
+static void vc4_fkms_crtc_get_margins(struct drm_crtc_state *state,
+				      unsigned int *left, unsigned int *right,
+				      unsigned int *top, unsigned int *bottom)
+{
+	struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(state);
+	struct drm_connector_state *conn_state;
+	struct drm_connector *conn;
+	int i;
+
+	*left = vc4_state->margins.left;
+	*right = vc4_state->margins.right;
+	*top = vc4_state->margins.top;
+	*bottom = vc4_state->margins.bottom;
+
+	/* We have to interate over all new connector states because
+	 * vc4_fkms_crtc_get_margins() might be called before
+	 * vc4_fkms_crtc_atomic_check() which means margins info in
+	 * vc4_crtc_state might be outdated.
+	 */
+	for_each_new_connector_in_state(state->state, conn, conn_state, i) {
+		if (conn_state->crtc != state->crtc)
+			continue;
+
+		*left = conn_state->tv.margins.left;
+		*right = conn_state->tv.margins.right;
+		*top = conn_state->tv.margins.top;
+		*bottom = conn_state->tv.margins.bottom;
+		break;
+	}
+}
+
+static int vc4_fkms_margins_adj(struct drm_plane_state *pstate,
+				struct set_plane *plane)
+{
+	unsigned int left, right, top, bottom;
+	int adjhdisplay, adjvdisplay;
+	struct drm_crtc_state *crtc_state;
+
+	crtc_state = drm_atomic_get_new_crtc_state(pstate->state,
+						   pstate->crtc);
+
+	vc4_fkms_crtc_get_margins(crtc_state, &left, &right, &top, &bottom);
+
+	if (!left && !right && !top && !bottom)
+		return 0;
+
+	if (left + right >= crtc_state->mode.hdisplay ||
+	    top + bottom >= crtc_state->mode.vdisplay)
+		return -EINVAL;
+
+	adjhdisplay = crtc_state->mode.hdisplay - (left + right);
+	plane->dst_x = DIV_ROUND_CLOSEST(plane->dst_x * adjhdisplay,
+					 (int)crtc_state->mode.hdisplay);
+	plane->dst_x += left;
+	if (plane->dst_x > (int)(crtc_state->mode.hdisplay - right))
+		plane->dst_x = crtc_state->mode.hdisplay - right;
+
+	adjvdisplay = crtc_state->mode.vdisplay - (top + bottom);
+	plane->dst_y = DIV_ROUND_CLOSEST(plane->dst_y * adjvdisplay,
+					 (int)crtc_state->mode.vdisplay);
+	plane->dst_y += top;
+	if (plane->dst_y > (int)(crtc_state->mode.vdisplay - bottom))
+		plane->dst_y = crtc_state->mode.vdisplay - bottom;
+
+	plane->dst_w = DIV_ROUND_CLOSEST(plane->dst_w * adjhdisplay,
+					 crtc_state->mode.hdisplay);
+	plane->dst_h = DIV_ROUND_CLOSEST(plane->dst_h * adjvdisplay,
+					 crtc_state->mode.vdisplay);
+
+	if (!plane->dst_w || !plane->dst_h)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void vc4_plane_atomic_update(struct drm_plane *plane,
+				    struct drm_atomic_state *old_state)
+{
+	struct drm_plane_state *state = plane->state;
+
+	/*
+	 * Do NOT set now, as we haven't checked if the crtc is active or not.
+	 * Set from vc4_plane_set_blank instead.
+	 *
+	 * If the CRTC is on (or going to be on) and we're enabled,
+	 * then unblank.  Otherwise, stay blank until CRTC enable.
+	 */
+	if (state->crtc->state->active)
+		vc4_plane_set_blank(plane, false);
+}
+
+static void vc4_plane_atomic_disable(struct drm_plane *plane,
+				     struct drm_atomic_state *old_state)
+{
+	struct drm_plane_state *state = plane->state;
+	struct vc4_fkms_plane *vc4_plane = to_vc4_fkms_plane(plane);
+
+	DRM_DEBUG_ATOMIC("[PLANE:%d:%s] plane disable %dx%d@%d +%d,%d\n",
+			 plane->base.id, plane->name,
+			 state->crtc_w,
+			 state->crtc_h,
+			 vc4_plane->mb.plane.vc_image_type,
+			 state->crtc_x,
+			 state->crtc_y);
+	vc4_plane_set_blank(plane, true);
+}
+
+static bool plane_enabled(struct drm_plane_state *state)
+{
+	return state->fb && state->crtc;
+}
+
+static int vc4_plane_to_mb(struct drm_plane *plane,
+			   struct mailbox_set_plane *mb,
+			   struct drm_plane_state *state)
+{
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_gem_dma_object *bo;
+	const struct drm_format_info *drm_fmt = fb->format;
+	const struct vc_image_format *vc_fmt =
+					vc4_get_vc_image_fmt(drm_fmt->format);
+	int num_planes = fb->format->num_planes;
+	unsigned int rotation;
+
+	mb->plane.vc_image_type = vc_fmt->vc_image;
+	mb->plane.width = fb->width;
+	mb->plane.height = fb->height;
+	mb->plane.pitch = fb->pitches[0];
+	mb->plane.src_w = state->src_w;
+	mb->plane.src_h = state->src_h;
+	mb->plane.src_x = state->src_x;
+	mb->plane.src_y = state->src_y;
+	mb->plane.dst_w = state->crtc_w;
+	mb->plane.dst_h = state->crtc_h;
+	mb->plane.dst_x = state->crtc_x;
+	mb->plane.dst_y = state->crtc_y;
+	mb->plane.alpha = state->alpha >> 8;
+	mb->plane.layer = state->normalized_zpos ?
+					state->normalized_zpos : -127;
+	mb->plane.num_planes = num_planes;
+	mb->plane.is_vu = vc_fmt->is_vu;
+	bo = drm_fb_dma_get_gem_obj(fb, 0);
+	mb->plane.planes[0] = bo->dma_addr + fb->offsets[0];
+
+	rotation = drm_rotation_simplify(state->rotation,
+					 DRM_MODE_ROTATE_0 |
+					 DRM_MODE_REFLECT_X |
+					 DRM_MODE_REFLECT_Y);
+
+	mb->plane.transform = TRANSFORM_NO_ROTATE;
+	if (rotation & DRM_MODE_REFLECT_X)
+		mb->plane.transform |= TRANSFORM_FLIP_HRIZ;
+	if (rotation & DRM_MODE_REFLECT_Y)
+		mb->plane.transform |= TRANSFORM_FLIP_VERT;
+
+	vc4_fkms_margins_adj(state, &mb->plane);
+
+	if (num_planes > 1) {
+		/* Assume this must be YUV */
+		/* Makes assumptions on the stride for the chroma planes as we
+		 * can't easily plumb in non-standard pitches.
+		 */
+		bo = drm_fb_dma_get_gem_obj(fb, 1);
+		mb->plane.planes[1] = bo->dma_addr + fb->offsets[1];
+		if (num_planes > 2) {
+			bo = drm_fb_dma_get_gem_obj(fb, 2);
+			mb->plane.planes[2] = bo->dma_addr + fb->offsets[2];
+		} else {
+			mb->plane.planes[2] = 0;
+		}
+
+		/* Special case the YUV420 with U and V as line interleaved
+		 * planes as we have special handling for that case.
+		 */
+		if (num_planes == 3 &&
+		    (fb->offsets[2] - fb->offsets[1]) == fb->pitches[1])
+			mb->plane.vc_image_type = VC_IMAGE_YUV420_S;
+
+		switch (state->color_encoding) {
+		default:
+		case DRM_COLOR_YCBCR_BT601:
+			if (state->color_range == DRM_COLOR_YCBCR_LIMITED_RANGE)
+				mb->plane.color_encoding =
+						VC_IMAGE_YUVINFO_CSC_ITUR_BT601;
+			else
+				mb->plane.color_encoding =
+						VC_IMAGE_YUVINFO_CSC_JPEG_JFIF;
+			break;
+		case DRM_COLOR_YCBCR_BT709:
+			/* Currently no support for a full range BT709 */
+			mb->plane.color_encoding =
+						VC_IMAGE_YUVINFO_CSC_ITUR_BT709;
+			break;
+		case DRM_COLOR_YCBCR_BT2020:
+			/* Currently no support for a full range BT2020 */
+			mb->plane.color_encoding =
+					VC_IMAGE_YUVINFO_CSC_REC_2020;
+			break;
+		}
+	} else {
+		mb->plane.planes[1] = 0;
+		mb->plane.planes[2] = 0;
+	}
+	mb->plane.planes[3] = 0;
+
+	switch (fourcc_mod_broadcom_mod(fb->modifier)) {
+	case DRM_FORMAT_MOD_BROADCOM_VC4_T_TILED:
+		switch (mb->plane.vc_image_type) {
+		case VC_IMAGE_XRGB8888:
+			mb->plane.vc_image_type = VC_IMAGE_TF_RGBX32;
+			break;
+		case VC_IMAGE_ARGB8888:
+			mb->plane.vc_image_type = VC_IMAGE_TF_RGBA32;
+			break;
+		case VC_IMAGE_RGB565:
+			mb->plane.vc_image_type = VC_IMAGE_TF_RGB565;
+			break;
+		}
+		break;
+	case DRM_FORMAT_MOD_BROADCOM_SAND128:
+		switch (mb->plane.vc_image_type) {
+		case VC_IMAGE_YUV420SP:
+			mb->plane.vc_image_type = VC_IMAGE_YUV_UV;
+			break;
+		/* VC_IMAGE_YUV10COL could be included in here, but it is only
+		 * valid as a SAND128 format, so the table at the top will have
+		 * already set the correct format.
+		 */
+		}
+		/* Note that the column pitch is passed across in lines, not
+		 * bytes.
+		 */
+		mb->plane.pitch = fourcc_mod_broadcom_param(fb->modifier);
+		break;
+	}
+
+	DRM_DEBUG_ATOMIC("[PLANE:%d:%s] plane update %dx%d@%d +dst(%d,%d, %d,%d) +src(%d,%d, %d,%d) 0x%08x/%08x/%08x/%d, alpha %u zpos %u\n",
+			 plane->base.id, plane->name,
+			 mb->plane.width,
+			 mb->plane.height,
+			 mb->plane.vc_image_type,
+			 state->crtc_x,
+			 state->crtc_y,
+			 state->crtc_w,
+			 state->crtc_h,
+			 mb->plane.src_x,
+			 mb->plane.src_y,
+			 mb->plane.src_w,
+			 mb->plane.src_h,
+			 mb->plane.planes[0],
+			 mb->plane.planes[1],
+			 mb->plane.planes[2],
+			 fb->pitches[0],
+			 state->alpha,
+			 state->normalized_zpos);
+
+	return 0;
+}
+
+static int vc4_fkms_plane_atomic_check(struct drm_plane *plane,
+				       struct drm_atomic_state *state)
+{
+	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
+										 plane);
+	struct vc4_fkms_plane *vc4_plane = to_vc4_fkms_plane(plane);
+
+	if (!plane_enabled(new_plane_state))
+		return 0;
+
+	return vc4_plane_to_mb(plane, &vc4_plane->mb, new_plane_state);
+}
+
+static void vc4_plane_atomic_async_update(struct drm_plane *plane,
+					  struct drm_atomic_state *state)
+{
+	struct drm_plane_state *new_plane_state =
+		drm_atomic_get_new_plane_state(state, plane);
+
+	swap(plane->state->fb, new_plane_state->fb);
+	plane->state->crtc_x = new_plane_state->crtc_x;
+	plane->state->crtc_y = new_plane_state->crtc_y;
+	plane->state->crtc_w = new_plane_state->crtc_w;
+	plane->state->crtc_h = new_plane_state->crtc_h;
+	plane->state->src_x = new_plane_state->src_x;
+	plane->state->src_y = new_plane_state->src_y;
+	plane->state->src_w = new_plane_state->src_w;
+	plane->state->src_h = new_plane_state->src_h;
+	plane->state->alpha = new_plane_state->alpha;
+	plane->state->pixel_blend_mode = new_plane_state->pixel_blend_mode;
+	plane->state->rotation = new_plane_state->rotation;
+	plane->state->zpos = new_plane_state->zpos;
+	plane->state->normalized_zpos = new_plane_state->normalized_zpos;
+	plane->state->color_encoding = new_plane_state->color_encoding;
+	plane->state->color_range = new_plane_state->color_range;
+	plane->state->src = new_plane_state->src;
+	plane->state->dst = new_plane_state->dst;
+	plane->state->visible = new_plane_state->visible;
+
+	vc4_plane_set_blank(plane, false);
+}
+
+static int vc4_plane_atomic_async_check(struct drm_plane *plane,
+					struct drm_atomic_state *state, bool)
+{
+	struct drm_plane_state *new_plane_state =
+		drm_atomic_get_new_plane_state(state, plane);
+	int ret = -EINVAL;
+
+	if (plane->type == 2 &&
+	    plane->state->fb &&
+	    new_plane_state->crtc->state->active)
+		ret = 0;
+
+	return ret;
+}
+
+/* Called during init to allocate the plane's atomic state. */
+static void vc4_fkms_plane_reset(struct drm_plane *plane)
+{
+	struct vc4_plane_state *vc4_state;
+
+	WARN_ON(plane->state);
+
+	vc4_state = kzalloc(sizeof(*vc4_state), GFP_KERNEL);
+	if (!vc4_state)
+		return;
+
+	__drm_atomic_helper_plane_reset(plane, &vc4_state->base);
+}
+
+static void vc4_plane_destroy(struct drm_plane *plane)
+{
+	drm_plane_cleanup(plane);
+}
+
+static bool vc4_fkms_format_mod_supported(struct drm_plane *plane,
+					  uint32_t format,
+					  uint64_t modifier)
+{
+	/* Support T_TILING for RGB formats only. */
+	switch (format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_RGB565:
+		switch (modifier) {
+		case DRM_FORMAT_MOD_BROADCOM_VC4_T_TILED:
+		case DRM_FORMAT_MOD_LINEAR:
+			return true;
+		default:
+			return false;
+		}
+	case DRM_FORMAT_NV12:
+		switch (fourcc_mod_broadcom_mod(modifier)) {
+		case DRM_FORMAT_MOD_LINEAR:
+		case DRM_FORMAT_MOD_BROADCOM_SAND128:
+			return true;
+		default:
+			return false;
+		}
+	case DRM_FORMAT_P030:
+		switch (fourcc_mod_broadcom_mod(modifier)) {
+		case DRM_FORMAT_MOD_BROADCOM_SAND128:
+			return true;
+		default:
+			return false;
+		}
+	case DRM_FORMAT_NV21:
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_BGR888:
+	case DRM_FORMAT_YUV422:
+	case DRM_FORMAT_YUV420:
+	case DRM_FORMAT_YVU420:
+	default:
+		return (modifier == DRM_FORMAT_MOD_LINEAR);
+	}
+}
+
+static struct drm_plane_state *vc4_fkms_plane_duplicate_state(struct drm_plane *plane)
+{
+	struct vc4_plane_state *vc4_state;
+
+	if (WARN_ON(!plane->state))
+		return NULL;
+
+	vc4_state = kzalloc(sizeof(*vc4_state), GFP_KERNEL);
+	if (!vc4_state)
+		return NULL;
+
+	__drm_atomic_helper_plane_duplicate_state(plane, &vc4_state->base);
+
+	return &vc4_state->base;
+}
+
+static const struct drm_plane_funcs vc4_plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.destroy = vc4_plane_destroy,
+	.set_property = NULL,
+	.reset = vc4_fkms_plane_reset,
+	.atomic_duplicate_state = vc4_fkms_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+	.format_mod_supported = vc4_fkms_format_mod_supported,
+};
+
+static const struct drm_plane_helper_funcs vc4_plane_helper_funcs = {
+	.prepare_fb = drm_gem_plane_helper_prepare_fb,
+	.cleanup_fb = NULL,
+	.atomic_check = vc4_fkms_plane_atomic_check,
+	.atomic_update = vc4_plane_atomic_update,
+	.atomic_disable = vc4_plane_atomic_disable,
+	.atomic_async_check = vc4_plane_atomic_async_check,
+	.atomic_async_update = vc4_plane_atomic_async_update,
+};
+
+static struct drm_plane *vc4_fkms_plane_init(struct drm_device *dev,
+					     enum drm_plane_type type,
+					     u8 display_num,
+					     u8 plane_id)
+{
+	struct drm_plane *plane = NULL;
+	struct vc4_fkms_plane *vc4_plane;
+	u32 formats[ARRAY_SIZE(vc_image_formats)];
+	unsigned int default_zpos = 0;
+	u32 num_formats = 0;
+	int ret = 0;
+	static const uint64_t modifiers[] = {
+		DRM_FORMAT_MOD_LINEAR,
+		/* VC4_T_TILED should come after linear, because we
+		 * would prefer to scan out linear (less bus traffic).
+		 */
+		DRM_FORMAT_MOD_BROADCOM_VC4_T_TILED,
+		DRM_FORMAT_MOD_BROADCOM_SAND128,
+		DRM_FORMAT_MOD_INVALID,
+	};
+	int i;
+
+	vc4_plane = devm_kzalloc(dev->dev, sizeof(*vc4_plane),
+				 GFP_KERNEL);
+	if (!vc4_plane) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(vc_image_formats); i++)
+		formats[num_formats++] = vc_image_formats[i].drm;
+
+	plane = &vc4_plane->base;
+	ret = drm_universal_plane_init(dev, plane, 0,
+				       &vc4_plane_funcs,
+				       formats, num_formats, modifiers,
+				       type, NULL);
+
+	/* FIXME: Do we need to be checking return values from all these calls?
+	 */
+	drm_plane_helper_add(plane, &vc4_plane_helper_funcs);
+
+	drm_plane_create_alpha_property(plane);
+	drm_plane_create_rotation_property(plane, DRM_MODE_ROTATE_0,
+					   DRM_MODE_ROTATE_0 |
+					   DRM_MODE_ROTATE_180 |
+					   DRM_MODE_REFLECT_X |
+					   DRM_MODE_REFLECT_Y);
+	drm_plane_create_color_properties(plane,
+					  BIT(DRM_COLOR_YCBCR_BT601) |
+					  BIT(DRM_COLOR_YCBCR_BT709) |
+					  BIT(DRM_COLOR_YCBCR_BT2020),
+					  BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |
+					  BIT(DRM_COLOR_YCBCR_FULL_RANGE),
+					  DRM_COLOR_YCBCR_BT709,
+					  DRM_COLOR_YCBCR_LIMITED_RANGE);
+
+	/*
+	 * Default frame buffer setup is with FB on -127, and raspistill etc
+	 * tend to drop overlays on layer 2. Cursor plane was on layer +127.
+	 *
+	 * For F-KMS the mailbox call allows for a s8.
+	 * Remap zpos 0 to -127 for the background layer, but leave all the
+	 * other layers as requested by KMS.
+	 */
+	switch (type) {
+	default:
+	case DRM_PLANE_TYPE_PRIMARY:
+		default_zpos = 0;
+		break;
+	case DRM_PLANE_TYPE_OVERLAY:
+		default_zpos = 1;
+		break;
+	case DRM_PLANE_TYPE_CURSOR:
+		default_zpos = 2;
+		break;
+	}
+	drm_plane_create_zpos_property(plane, default_zpos, 0, 127);
+
+	/* Prepare the static elements of the mailbox structure */
+	vc4_plane->mb.tag.tag = RPI_FIRMWARE_SET_PLANE;
+	vc4_plane->mb.tag.buf_size = sizeof(struct set_plane);
+	vc4_plane->mb.tag.req_resp_size = 0;
+	vc4_plane->mb.plane.display = display_num;
+	vc4_plane->mb.plane.plane_id = plane_id;
+	vc4_plane->mb.plane.layer = default_zpos ? default_zpos : -127;
+
+	return plane;
+fail:
+	if (plane)
+		vc4_plane_destroy(plane);
+
+	return ERR_PTR(ret);
+}
+
+static void vc4_crtc_mode_set_nofb(struct drm_crtc *crtc)
+{
+	struct drm_device *dev = crtc->dev;
+	struct vc4_dev *vc4 = to_vc4_dev(dev);
+	struct vc4_fkms_crtc *vc4_fkms_crtc = to_vc4_fkms_crtc(crtc);
+	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	struct vc4_fkms_encoder *vc4_encoder =
+					to_vc4_fkms_encoder(vc4_fkms_crtc->encoder);
+	struct mailbox_set_mode mb = {
+		.tag1 = { RPI_FIRMWARE_SET_TIMING,
+			  sizeof(struct set_timings), 0},
+	};
+	union hdmi_infoframe frame;
+	int ret;
+
+	ret = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, vc4_fkms_crtc->connector, mode);
+	if (ret < 0) {
+		DRM_ERROR("couldn't fill AVI infoframe\n");
+		return;
+	}
+
+	DRM_DEBUG_KMS("Setting mode for display num %u mode name %s, clk %d, h(disp %d, start %d, end %d, total %d, skew %d) v(disp %d, start %d, end %d, total %d, scan %d), vrefresh %d, par %u, flags 0x%04x\n",
+		      vc4_fkms_crtc->display_number, mode->name, mode->clock,
+		      mode->hdisplay, mode->hsync_start, mode->hsync_end,
+		      mode->htotal, mode->hskew, mode->vdisplay,
+		      mode->vsync_start, mode->vsync_end, mode->vtotal,
+		      mode->vscan, drm_mode_vrefresh(mode),
+		      mode->picture_aspect_ratio, mode->flags);
+	mb.timings.display = vc4_fkms_crtc->display_number;
+
+	mb.timings.clock = mode->clock;
+	mb.timings.hdisplay = mode->hdisplay;
+	mb.timings.hsync_start = mode->hsync_start;
+	mb.timings.hsync_end = mode->hsync_end;
+	mb.timings.htotal = mode->htotal;
+	mb.timings.hskew = mode->hskew;
+	mb.timings.vdisplay = mode->vdisplay;
+	mb.timings.vsync_start = mode->vsync_start;
+	mb.timings.vsync_end = mode->vsync_end;
+	mb.timings.vtotal = mode->vtotal;
+	mb.timings.vscan = mode->vscan;
+	mb.timings.vrefresh = drm_mode_vrefresh(mode);
+	mb.timings.flags = 0;
+	if (mode->flags & DRM_MODE_FLAG_PHSYNC)
+		mb.timings.flags |= TIMINGS_FLAGS_H_SYNC_POS;
+	if (mode->flags & DRM_MODE_FLAG_PVSYNC)
+		mb.timings.flags |= TIMINGS_FLAGS_V_SYNC_POS;
+
+	switch (frame.avi.picture_aspect) {
+	default:
+	case HDMI_PICTURE_ASPECT_NONE:
+		mb.timings.flags |= TIMINGS_FLAGS_ASPECT_NONE;
+		break;
+	case HDMI_PICTURE_ASPECT_4_3:
+		mb.timings.flags |= TIMINGS_FLAGS_ASPECT_4_3;
+		break;
+	case HDMI_PICTURE_ASPECT_16_9:
+		mb.timings.flags |= TIMINGS_FLAGS_ASPECT_16_9;
+		break;
+	case HDMI_PICTURE_ASPECT_64_27:
+		mb.timings.flags |= TIMINGS_FLAGS_ASPECT_64_27;
+		break;
+	case HDMI_PICTURE_ASPECT_256_135:
+		mb.timings.flags |= TIMINGS_FLAGS_ASPECT_256_135;
+		break;
+	}
+
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		mb.timings.flags |= TIMINGS_FLAGS_INTERLACE;
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		mb.timings.flags |= TIMINGS_FLAGS_DBL_CLK;
+
+	mb.timings.video_id_code = frame.avi.video_code;
+
+	if (!vc4_encoder->hdmi_monitor) {
+		mb.timings.flags |= TIMINGS_FLAGS_DVI;
+	} else {
+		struct vc4_fkms_connector_state *conn_state =
+			to_vc4_fkms_connector_state(vc4_fkms_crtc->connector->state);
+
+		if (conn_state->broadcast_rgb == VC4_BROADCAST_RGB_AUTO) {
+			/* See CEA-861-E - 5.1 Default Encoding Parameters */
+			if (drm_default_rgb_quant_range(mode) ==
+					HDMI_QUANTIZATION_RANGE_LIMITED)
+				mb.timings.flags |= TIMINGS_FLAGS_RGB_LIMITED;
+		} else {
+			if (conn_state->broadcast_rgb ==
+						VC4_BROADCAST_RGB_LIMITED)
+				mb.timings.flags |= TIMINGS_FLAGS_RGB_LIMITED;
+
+			/* If not using the default range, then do not provide
+			 * a VIC as the HDMI spec requires that we do not
+			 * signal the opposite of the defined range in the AVI
+			 * infoframe.
+			 */
+			if (!!(mb.timings.flags & TIMINGS_FLAGS_RGB_LIMITED) !=
+			    (drm_default_rgb_quant_range(mode) ==
+					HDMI_QUANTIZATION_RANGE_LIMITED))
+				mb.timings.video_id_code = 0;
+		}
+	}
+
+	/*
+	 * FIXME: To implement
+	 * switch(mode->flag & DRM_MODE_FLAG_3D_MASK) {
+	 * case DRM_MODE_FLAG_3D_NONE:
+	 * case DRM_MODE_FLAG_3D_FRAME_PACKING:
+	 * case DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE:
+	 * case DRM_MODE_FLAG_3D_LINE_ALTERNATIVE:
+	 * case DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL:
+	 * case DRM_MODE_FLAG_3D_L_DEPTH:
+	 * case DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH:
+	 * case DRM_MODE_FLAG_3D_TOP_AND_BOTTOM:
+	 * case DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF:
+	 * }
+	 */
+
+	ret = rpi_firmware_property_list(vc4->firmware, &mb, sizeof(mb));
+}
+
+static void vc4_crtc_disable(struct drm_crtc *crtc,
+			     struct drm_atomic_state *state)
+{
+	struct drm_device *dev = crtc->dev;
+	struct drm_plane *plane;
+
+	DRM_DEBUG_KMS("[CRTC:%d] vblanks off.\n",
+		      crtc->base.id);
+	drm_crtc_vblank_off(crtc);
+
+	/* Always turn the planes off on CRTC disable. In DRM, planes
+	 * are enabled/disabled through the update/disable hooks
+	 * above, and the CRTC enable/disable independently controls
+	 * whether anything scans out at all, but the firmware doesn't
+	 * give us a CRTC-level control for that.
+	 */
+
+	drm_atomic_crtc_for_each_plane(plane, crtc)
+		vc4_plane_atomic_disable(plane, state);
+
+	/*
+	 * Make sure we issue a vblank event after disabling the CRTC if
+	 * someone was waiting it.
+	 */
+	if (crtc->state->event) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&dev->event_lock, flags);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		crtc->state->event = NULL;
+		spin_unlock_irqrestore(&dev->event_lock, flags);
+	}
+}
+
+static void vc4_crtc_consume_event(struct drm_crtc *crtc)
+{
+	struct vc4_fkms_crtc *vc4_fkms_crtc = to_vc4_fkms_crtc(crtc);
+	struct drm_device *dev = crtc->dev;
+	unsigned long flags;
+
+	if (!crtc->state->event)
+		return;
+
+	crtc->state->event->pipe = drm_crtc_index(crtc);
+
+	WARN_ON(drm_crtc_vblank_get(crtc) != 0);
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+	vc4_fkms_crtc->event = crtc->state->event;
+	crtc->state->event = NULL;
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+}
+
+static void vc4_crtc_enable(struct drm_crtc *crtc,
+			    struct drm_atomic_state *state)
+{
+	struct drm_plane *plane;
+
+	DRM_DEBUG_KMS("[CRTC:%d] vblanks on.\n",
+		      crtc->base.id);
+	drm_crtc_vblank_on(crtc);
+	vc4_crtc_consume_event(crtc);
+
+	/* Unblank the planes (if they're supposed to be displayed). */
+	drm_atomic_crtc_for_each_plane(plane, crtc)
+		if (plane->state->fb)
+			vc4_plane_set_blank(plane, plane->state->visible);
+}
+
+static enum drm_mode_status
+vc4_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *mode)
+{
+	struct vc4_fkms_crtc *vc4_fkms_crtc = to_vc4_fkms_crtc(crtc);
+	struct drm_device *dev = crtc->dev;
+	struct vc4_dev *vc4 = to_vc4_dev(dev);
+	struct vc4_fkms *fkms = vc4->fkms;
+
+	/* Do not allow doublescan modes from user space */
+	if (mode->flags & DRM_MODE_FLAG_DBLSCAN) {
+		DRM_DEBUG_KMS("[CRTC:%d] Doublescan mode rejected.\n",
+			      crtc->base.id);
+		return MODE_NO_DBLESCAN;
+	}
+
+	/* Disable refresh rates > defined threshold (default 85Hz) as limited
+	 * gain from them
+	 */
+	if (drm_mode_vrefresh(mode) > fkms_max_refresh_rate)
+		return MODE_BAD_VVALUE;
+
+	/* Limit the pixel clock based on the HDMI clock limits from the
+	 * firmware
+	 */
+	switch (vc4_fkms_crtc->display_number) {
+	case 2:	/* HDMI0 */
+		if (fkms->cfg.max_pixel_clock[0] &&
+		    mode->clock > fkms->cfg.max_pixel_clock[0])
+			return MODE_CLOCK_HIGH;
+		break;
+	case 7:	/* HDMI1 */
+		if (fkms->cfg.max_pixel_clock[1] &&
+		    mode->clock > fkms->cfg.max_pixel_clock[1])
+			return MODE_CLOCK_HIGH;
+		break;
+	}
+
+	/* Pi4 can't generate odd horizontal timings on HDMI, so reject modes
+	 * that would set them.
+	 */
+	if (fkms->revision >= BCM2711 &&
+	    (vc4_fkms_crtc->display_number == 2 || vc4_fkms_crtc->display_number == 7) &&
+	    !(mode->flags & DRM_MODE_FLAG_DBLCLK) &&
+	    ((mode->hdisplay |				/* active */
+	      (mode->hsync_start - mode->hdisplay) |	/* front porch */
+	      (mode->hsync_end - mode->hsync_start) |	/* sync pulse */
+	      (mode->htotal - mode->hsync_end)) & 1))	/* back porch */ {
+		DRM_DEBUG_KMS("[CRTC:%d] Odd timing rejected %u %u %u %u.\n",
+			      crtc->base.id, mode->hdisplay, mode->hsync_start,
+			      mode->hsync_end, mode->htotal);
+		return MODE_H_ILLEGAL;
+	}
+
+	return MODE_OK;
+}
+
+static int vc4_fkms_crtc_atomic_check(struct drm_crtc *crtc,
+				 struct drm_atomic_state *state)
+{
+	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,
+									  crtc);
+	struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);
+	struct drm_connector *conn;
+	struct drm_connector_state *conn_state;
+	int i;
+
+	DRM_DEBUG_KMS("[CRTC:%d] crtc_atomic_check.\n", crtc->base.id);
+
+	for_each_new_connector_in_state(crtc_state->state, conn, conn_state, i) {
+		if (conn_state->crtc != crtc)
+			continue;
+
+		vc4_state->margins.left = conn_state->tv.margins.left;
+		vc4_state->margins.right = conn_state->tv.margins.right;
+		vc4_state->margins.top = conn_state->tv.margins.top;
+		vc4_state->margins.bottom = conn_state->tv.margins.bottom;
+		break;
+	}
+	return 0;
+}
+
+static void vc4_crtc_atomic_flush(struct drm_crtc *crtc,
+				  struct drm_atomic_state *state)
+{
+	struct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,
+									 crtc);
+
+	DRM_DEBUG_KMS("[CRTC:%d] crtc_atomic_flush.\n",
+		      crtc->base.id);
+	if (crtc->state->active && old_state->active && crtc->state->event)
+		vc4_crtc_consume_event(crtc);
+}
+
+static void vc4_crtc_handle_page_flip(struct vc4_fkms_crtc *vc4_fkms_crtc)
+{
+	struct drm_crtc *crtc = &vc4_fkms_crtc->base;
+	struct drm_device *dev = crtc->dev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->event_lock, flags);
+	if (vc4_fkms_crtc->event) {
+		drm_crtc_send_vblank_event(crtc, vc4_fkms_crtc->event);
+		vc4_fkms_crtc->event = NULL;
+		drm_crtc_vblank_put(crtc);
+	}
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+}
+
+static irqreturn_t vc4_crtc_irq_handler(int irq, void *data)
+{
+	struct vc4_fkms_crtc **crtc_list = data;
+	int i;
+	u32 stat = readl(crtc_list[0]->regs + SMICS);
+	irqreturn_t ret = IRQ_NONE;
+	u32 chan;
+
+	if (stat & SMICS_INTERRUPTS) {
+		writel(0, crtc_list[0]->regs + SMICS);
+
+		chan = readl(crtc_list[0]->regs + SMIDSW0);
+
+		if ((chan & 0xFFFF0000) != SMI_NEW) {
+			/* Older firmware. Treat the one interrupt as vblank/
+			 * complete for all crtcs.
+			 */
+			for (i = 0; crtc_list[i]; i++) {
+				if (crtc_list[i]->vblank_enabled)
+					drm_crtc_handle_vblank(&crtc_list[i]->base);
+				vc4_crtc_handle_page_flip(crtc_list[i]);
+			}
+		} else {
+			if (chan & 1) {
+				writel(SMI_NEW, crtc_list[0]->regs + SMIDSW0);
+				if (crtc_list[0]->vblank_enabled)
+					drm_crtc_handle_vblank(&crtc_list[0]->base);
+				vc4_crtc_handle_page_flip(crtc_list[0]);
+			}
+
+			if (crtc_list[1]) {
+				/* Check for the secondary display too */
+				chan = readl(crtc_list[0]->regs + SMIDSW1);
+
+				if (chan & 1) {
+					writel(SMI_NEW, crtc_list[0]->regs + SMIDSW1);
+
+					if (crtc_list[1]->vblank_enabled)
+						drm_crtc_handle_vblank(&crtc_list[1]->base);
+					vc4_crtc_handle_page_flip(crtc_list[1]);
+				}
+			}
+		}
+
+		ret = IRQ_HANDLED;
+	}
+
+	return ret;
+}
+
+static irqreturn_t vc4_crtc2712_irq_handler(int irq, void *data)
+{
+	struct vc4_fkms_crtc **crtc_list = data;
+	int i;
+
+	for (i = 0; crtc_list[i]; i++) {
+		if (crtc_list[i]->vblank_enabled)
+			drm_crtc_handle_vblank(&crtc_list[i]->base);
+		vc4_crtc_handle_page_flip(crtc_list[i]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int vc4_fkms_page_flip(struct drm_crtc *crtc,
+			      struct drm_framebuffer *fb,
+			      struct drm_pending_vblank_event *event,
+			      uint32_t flags,
+			      struct drm_modeset_acquire_ctx *ctx)
+{
+	if (flags & DRM_MODE_PAGE_FLIP_ASYNC) {
+		DRM_ERROR("Async flips aren't allowed\n");
+		return -EINVAL;
+	}
+
+	return drm_atomic_helper_page_flip(crtc, fb, event, flags, ctx);
+}
+
+static struct drm_crtc_state *
+vc4_fkms_crtc_duplicate_state(struct drm_crtc *crtc)
+{
+	struct vc4_crtc_state *vc4_state, *old_vc4_state;
+
+	vc4_state = kzalloc(sizeof(*vc4_state), GFP_KERNEL);
+	if (!vc4_state)
+		return NULL;
+
+	old_vc4_state = to_vc4_crtc_state(crtc->state);
+	vc4_state->margins = old_vc4_state->margins;
+
+	__drm_atomic_helper_crtc_duplicate_state(crtc, &vc4_state->base);
+	return &vc4_state->base;
+}
+
+static void
+vc4_fkms_crtc_reset(struct drm_crtc *crtc)
+{
+	if (crtc->state)
+		__drm_atomic_helper_crtc_destroy_state(crtc->state);
+
+	crtc->state = kzalloc(sizeof(*crtc->state), GFP_KERNEL);
+	if (crtc->state)
+		crtc->state->crtc = crtc;
+}
+
+static int vc4_fkms_enable_vblank(struct drm_crtc *crtc)
+{
+	struct vc4_fkms_crtc *vc4_fkms_crtc = to_vc4_fkms_crtc(crtc);
+
+	DRM_DEBUG_KMS("[CRTC:%d] enable_vblank.\n",
+		      crtc->base.id);
+	vc4_fkms_crtc->vblank_enabled = true;
+
+	return 0;
+}
+
+static void vc4_fkms_disable_vblank(struct drm_crtc *crtc)
+{
+	struct vc4_fkms_crtc *vc4_fkms_crtc = to_vc4_fkms_crtc(crtc);
+
+	DRM_DEBUG_KMS("[CRTC:%d] disable_vblank.\n",
+		      crtc->base.id);
+	vc4_fkms_crtc->vblank_enabled = false;
+}
+
+static const struct drm_crtc_funcs vc4_crtc_funcs = {
+	.set_config = drm_atomic_helper_set_config,
+	.destroy = drm_crtc_cleanup,
+	.page_flip = vc4_fkms_page_flip,
+	.set_property = NULL,
+	.cursor_set = NULL, /* handled by drm_mode_cursor_universal */
+	.cursor_move = NULL, /* handled by drm_mode_cursor_universal */
+	.reset = vc4_fkms_crtc_reset,
+	.atomic_duplicate_state = vc4_fkms_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = vc4_fkms_enable_vblank,
+	.disable_vblank = vc4_fkms_disable_vblank,
+};
+
+static const struct drm_crtc_helper_funcs vc4_crtc_helper_funcs = {
+	.mode_set_nofb = vc4_crtc_mode_set_nofb,
+	.mode_valid = vc4_crtc_mode_valid,
+	.atomic_check = vc4_fkms_crtc_atomic_check,
+	.atomic_flush = vc4_crtc_atomic_flush,
+	.atomic_enable = vc4_crtc_enable,
+	.atomic_disable = vc4_crtc_disable,
+};
+
+static const struct of_device_id vc4_firmware_kms_dt_match[] = {
+	{ .compatible = "raspberrypi,rpi-firmware-kms",
+	  .data = (void *)BCM2835_6_7 },
+	{ .compatible = "raspberrypi,rpi-firmware-kms-2711",
+	  .data = (void *)BCM2711 },
+	{ .compatible = "raspberrypi,rpi-firmware-kms-2712",
+	  .data = (void *)BCM2712 },
+	{}
+};
+
+static enum drm_connector_status
+vc4_fkms_connector_detect(struct drm_connector *connector, bool force)
+{
+	DRM_DEBUG_KMS("connector detect.\n");
+	return connector_status_connected;
+}
+
+/* Queries the firmware to populate a drm_mode structure for this display */
+static int vc4_fkms_get_fw_mode(struct vc4_fkms_connector *fkms_connector,
+				struct drm_display_mode *mode)
+{
+	struct vc4_dev *vc4 = fkms_connector->vc4_dev;
+	struct set_timings timings = { 0 };
+	int ret;
+
+	timings.display = fkms_connector->display_number;
+
+	ret = rpi_firmware_property(vc4->firmware,
+				    RPI_FIRMWARE_GET_DISPLAY_TIMING, &timings,
+				    sizeof(timings));
+	if (ret || !timings.clock)
+		/* No mode returned - abort */
+		return -1;
+
+	/* Equivalent to DRM_MODE macro. */
+	memset(mode, 0, sizeof(*mode));
+	strncpy(mode->name, "FIXED_MODE", sizeof(mode->name));
+	mode->status = 0;
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	mode->clock = timings.clock;
+	mode->hdisplay = timings.hdisplay;
+	mode->hsync_start = timings.hsync_start;
+	mode->hsync_end = timings.hsync_end;
+	mode->htotal = timings.htotal;
+	mode->hskew = 0;
+	mode->vdisplay = timings.vdisplay;
+	mode->vsync_start = timings.vsync_start;
+	mode->vsync_end = timings.vsync_end;
+	mode->vtotal = timings.vtotal;
+	mode->vscan = timings.vscan;
+
+	if (timings.flags & TIMINGS_FLAGS_H_SYNC_POS)
+		mode->flags |= DRM_MODE_FLAG_PHSYNC;
+	else
+		mode->flags |= DRM_MODE_FLAG_NHSYNC;
+
+	if (timings.flags & TIMINGS_FLAGS_V_SYNC_POS)
+		mode->flags |= DRM_MODE_FLAG_PVSYNC;
+	else
+		mode->flags |= DRM_MODE_FLAG_NVSYNC;
+
+	if (timings.flags & TIMINGS_FLAGS_INTERLACE)
+		mode->flags |= DRM_MODE_FLAG_INTERLACE;
+
+	return 0;
+}
+
+static int vc4_fkms_get_edid_block(void *data, u8 *buf, unsigned int block,
+				   size_t len)
+{
+	struct vc4_fkms_connector *fkms_connector =
+					(struct vc4_fkms_connector *)data;
+	struct vc4_dev *vc4 = fkms_connector->vc4_dev;
+	struct mailbox_get_edid mb = {
+		.tag1 = { RPI_FIRMWARE_GET_EDID_BLOCK_DISPLAY,
+			  128 + 8, 0 },
+		.block = block,
+		.display_number = fkms_connector->display_number,
+	};
+	int ret = 0;
+
+	ret = rpi_firmware_property_list(vc4->firmware, &mb, sizeof(mb));
+
+	if (!ret)
+		memcpy(buf, mb.edid, len);
+
+	return ret;
+}
+
+static int vc4_fkms_connector_get_modes(struct drm_connector *connector)
+{
+	struct vc4_fkms_connector *fkms_connector =
+					to_vc4_fkms_connector(connector);
+	struct drm_encoder *encoder = fkms_connector->encoder;
+	struct vc4_fkms_encoder *vc4_encoder = to_vc4_fkms_encoder(encoder);
+	struct drm_display_mode fw_mode;
+	struct drm_display_mode *mode;
+	const struct drm_edid *drm_edid;
+	const struct edid *edid;
+	int num_modes;
+
+	if (!vc4_fkms_get_fw_mode(fkms_connector, &fw_mode)) {
+		drm_mode_debug_printmodeline(&fw_mode);
+		mode = drm_mode_duplicate(connector->dev,
+					  &fw_mode);
+		drm_mode_probed_add(connector, mode);
+		num_modes = 1;	/* 1 mode */
+	} else {
+		drm_edid = drm_edid_read_custom(connector, vc4_fkms_get_edid_block,
+				       fkms_connector);
+		edid = drm_edid_raw(drm_edid);
+
+		/* FIXME: Can we do CEC?
+		 * cec_s_phys_addr_from_edid(vc4->hdmi->cec_adap, edid);
+		 * if (!edid)
+		 *	return -ENODEV;
+		 */
+
+		vc4_encoder->hdmi_monitor = drm_detect_hdmi_monitor(edid);
+
+		drm_connector_update_edid_property(connector, edid);
+		num_modes = drm_add_edid_modes(connector, (struct edid *)edid);
+		kfree(drm_edid);
+	}
+
+	return num_modes;
+}
+
+/* This is the DSI panel resolution. Use this as a default should the firmware
+ * not respond to our request for the timings.
+ */
+static const struct drm_display_mode lcd_mode = {
+	DRM_MODE("800x480", DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+		 25979400 / 1000,
+		 800, 800 + 1, 800 + 1 + 2, 800 + 1 + 2 + 46, 0,
+		 480, 480 + 7, 480 + 7 + 2, 480 + 7 + 2 + 21, 0,
+		 0)
+};
+
+static int vc4_fkms_lcd_connector_get_modes(struct drm_connector *connector)
+{
+	struct vc4_fkms_connector *fkms_connector =
+					to_vc4_fkms_connector(connector);
+	struct drm_display_mode *mode;
+	struct drm_display_mode fw_mode;
+
+	if (!vc4_fkms_get_fw_mode(fkms_connector, &fw_mode) && fw_mode.clock)
+		mode = drm_mode_duplicate(connector->dev,
+					  &fw_mode);
+	else
+		mode = drm_mode_duplicate(connector->dev,
+					  &lcd_mode);
+
+	if (!mode) {
+		DRM_ERROR("Failed to create a new display mode\n");
+		return -ENOMEM;
+	}
+
+	drm_mode_probed_add(connector, mode);
+
+	/* We have one mode */
+	return 1;
+}
+
+static struct drm_encoder *
+vc4_fkms_connector_best_encoder(struct drm_connector *connector)
+{
+	struct vc4_fkms_connector *fkms_connector =
+		to_vc4_fkms_connector(connector);
+	DRM_DEBUG_KMS("best_connector.\n");
+	return fkms_connector->encoder;
+}
+
+static void vc4_fkms_connector_destroy(struct drm_connector *connector)
+{
+	DRM_DEBUG_KMS("[CONNECTOR:%d] destroy.\n",
+		      connector->base.id);
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
+/**
+ * vc4_connector_duplicate_state - duplicate connector state
+ * @connector: digital connector
+ *
+ * Allocates and returns a copy of the connector state (both common and
+ * digital connector specific) for the specified connector.
+ *
+ * Returns: The newly allocated connector state, or NULL on failure.
+ */
+static struct drm_connector_state *
+vc4_connector_duplicate_state(struct drm_connector *connector)
+{
+	struct vc4_fkms_connector_state *state;
+
+	state = kmemdup(connector->state, sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	__drm_atomic_helper_connector_duplicate_state(connector, &state->base);
+	return &state->base;
+}
+
+/**
+ * vc4_connector_atomic_get_property - hook for connector->atomic_get_property.
+ * @connector: Connector to get the property for.
+ * @state: Connector state to retrieve the property from.
+ * @property: Property to retrieve.
+ * @val: Return value for the property.
+ *
+ * Returns the atomic property value for a digital connector.
+ */
+static int vc4_connector_atomic_get_property(struct drm_connector *connector,
+				      const struct drm_connector_state *state,
+				      struct drm_property *property,
+				      uint64_t *val)
+{
+	struct vc4_fkms_connector *fkms_connector =
+					to_vc4_fkms_connector(connector);
+	struct vc4_fkms_connector_state *vc4_conn_state =
+					to_vc4_fkms_connector_state(state);
+
+	if (property == fkms_connector->broadcast_rgb_property) {
+		*val = vc4_conn_state->broadcast_rgb;
+	} else {
+		DRM_DEBUG_ATOMIC("Unknown property [PROP:%d:%s]\n",
+				 property->base.id, property->name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * vc4_connector_atomic_set_property - hook for connector->atomic_set_property.
+ * @connector: Connector to set the property for.
+ * @state: Connector state to set the property on.
+ * @property: Property to set.
+ * @val: New value for the property.
+ *
+ * Sets the atomic property value for a digital connector.
+ */
+static int vc4_connector_atomic_set_property(struct drm_connector *connector,
+				      struct drm_connector_state *state,
+				      struct drm_property *property,
+				      uint64_t val)
+{
+	struct vc4_fkms_connector *fkms_connector =
+					to_vc4_fkms_connector(connector);
+	struct vc4_fkms_connector_state *vc4_conn_state =
+					to_vc4_fkms_connector_state(state);
+
+	if (property == fkms_connector->broadcast_rgb_property) {
+		vc4_conn_state->broadcast_rgb = val;
+		return 0;
+	}
+
+	DRM_DEBUG_ATOMIC("Unknown property [PROP:%d:%s]\n",
+			 property->base.id, property->name);
+	return -EINVAL;
+}
+
+static int vc4_connector_atomic_check(struct drm_connector *connector,
+			       struct drm_atomic_state *state)
+{
+	struct drm_connector_state *old_state =
+		drm_atomic_get_old_connector_state(state, connector);
+	struct vc4_fkms_connector_state *vc4_old_state =
+					to_vc4_fkms_connector_state(old_state);
+	struct drm_connector_state *new_state =
+		drm_atomic_get_new_connector_state(state, connector);
+	struct vc4_fkms_connector_state *vc4_new_state =
+					to_vc4_fkms_connector_state(new_state);
+	struct drm_crtc *crtc = new_state->crtc;
+
+	if (!crtc)
+		return 0;
+
+	if (vc4_old_state->broadcast_rgb != vc4_new_state->broadcast_rgb) {
+		struct drm_crtc_state *crtc_state;
+
+		crtc_state = drm_atomic_get_crtc_state(state, crtc);
+		if (IS_ERR(crtc_state))
+			return PTR_ERR(crtc_state);
+
+		crtc_state->mode_changed = true;
+	}
+	return 0;
+}
+
+static void vc4_hdmi_connector_reset(struct drm_connector *connector)
+{
+	drm_atomic_helper_connector_reset(connector);
+	drm_atomic_helper_connector_tv_margins_reset(connector);
+}
+
+static const struct drm_connector_funcs vc4_fkms_connector_funcs = {
+	.detect = vc4_fkms_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = vc4_fkms_connector_destroy,
+	.reset = vc4_hdmi_connector_reset,
+	.atomic_duplicate_state = vc4_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+	.atomic_get_property = vc4_connector_atomic_get_property,
+	.atomic_set_property = vc4_connector_atomic_set_property,
+};
+
+static const struct drm_connector_helper_funcs vc4_fkms_connector_helper_funcs = {
+	.get_modes = vc4_fkms_connector_get_modes,
+	.best_encoder = vc4_fkms_connector_best_encoder,
+	.atomic_check = vc4_connector_atomic_check,
+};
+
+static const struct drm_connector_helper_funcs vc4_fkms_lcd_conn_helper_funcs = {
+	.get_modes = vc4_fkms_lcd_connector_get_modes,
+	.best_encoder = vc4_fkms_connector_best_encoder,
+};
+
+static const struct drm_prop_enum_list broadcast_rgb_names[] = {
+	{ VC4_BROADCAST_RGB_AUTO, "Automatic" },
+	{ VC4_BROADCAST_RGB_FULL, "Full" },
+	{ VC4_BROADCAST_RGB_LIMITED, "Limited 16:235" },
+};
+
+static void
+vc4_attach_broadcast_rgb_property(struct vc4_fkms_connector *fkms_connector)
+{
+	struct drm_device *dev = fkms_connector->base.dev;
+	struct drm_property *prop;
+
+	prop = fkms_connector->broadcast_rgb_property;
+	if (!prop) {
+		prop = drm_property_create_enum(dev, DRM_MODE_PROP_ENUM,
+						"Broadcast RGB",
+						broadcast_rgb_names,
+						ARRAY_SIZE(broadcast_rgb_names));
+		if (!prop)
+			return;
+
+		fkms_connector->broadcast_rgb_property = prop;
+	}
+
+	drm_object_attach_property(&fkms_connector->base.base, prop, 0);
+}
+
+static struct drm_connector *
+vc4_fkms_connector_init(struct drm_device *dev, struct drm_encoder *encoder,
+			u32 display_num)
+{
+	struct drm_connector *connector = NULL;
+	struct vc4_fkms_connector *fkms_connector;
+	struct vc4_fkms_connector_state *conn_state = NULL;
+	struct vc4_dev *vc4_dev = to_vc4_dev(dev);
+	int ret = 0;
+
+	DRM_DEBUG_KMS("connector_init, display_num %u\n", display_num);
+
+	fkms_connector = devm_kzalloc(dev->dev, sizeof(*fkms_connector),
+				      GFP_KERNEL);
+	if (!fkms_connector)
+		return ERR_PTR(-ENOMEM);
+
+	/*
+	 * Allocate enough memory to hold vc4_fkms_connector_state,
+	 */
+	conn_state = kzalloc(sizeof(*conn_state), GFP_KERNEL);
+	if (!conn_state) {
+		kfree(fkms_connector);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	connector = &fkms_connector->base;
+
+	fkms_connector->encoder = encoder;
+	fkms_connector->display_number = display_num;
+	fkms_connector->display_type = vc4_get_display_type(display_num);
+	fkms_connector->vc4_dev = vc4_dev;
+
+	__drm_atomic_helper_connector_reset(connector,
+					    &conn_state->base);
+
+	if (fkms_connector->display_type == DRM_MODE_ENCODER_DSI) {
+		drm_connector_init(dev, connector, &vc4_fkms_connector_funcs,
+				   DRM_MODE_CONNECTOR_DSI);
+		drm_connector_helper_add(connector,
+					 &vc4_fkms_lcd_conn_helper_funcs);
+		connector->interlace_allowed = 0;
+	} else if (fkms_connector->display_type == DRM_MODE_ENCODER_TVDAC) {
+		drm_connector_init(dev, connector, &vc4_fkms_connector_funcs,
+				   DRM_MODE_CONNECTOR_Composite);
+		drm_connector_helper_add(connector,
+					 &vc4_fkms_lcd_conn_helper_funcs);
+		connector->interlace_allowed = 1;
+	} else {
+		drm_connector_init(dev, connector, &vc4_fkms_connector_funcs,
+				   DRM_MODE_CONNECTOR_HDMIA);
+		drm_connector_helper_add(connector,
+					 &vc4_fkms_connector_helper_funcs);
+		connector->interlace_allowed = 1;
+	}
+
+	ret = drm_mode_create_tv_margin_properties(dev);
+	if (ret)
+		goto fail;
+
+	drm_connector_attach_tv_margin_properties(connector);
+
+	connector->polled = (DRM_CONNECTOR_POLL_CONNECT |
+			     DRM_CONNECTOR_POLL_DISCONNECT);
+
+	connector->doublescan_allowed = 0;
+
+	vc4_attach_broadcast_rgb_property(fkms_connector);
+
+	drm_connector_attach_encoder(connector, encoder);
+
+	return connector;
+
+ fail:
+	if (connector)
+		vc4_fkms_connector_destroy(connector);
+
+	return ERR_PTR(ret);
+}
+
+static void vc4_fkms_encoder_destroy(struct drm_encoder *encoder)
+{
+	DRM_DEBUG_KMS("Encoder_destroy\n");
+	drm_encoder_cleanup(encoder);
+}
+
+static const struct drm_encoder_funcs vc4_fkms_encoder_funcs = {
+	.destroy = vc4_fkms_encoder_destroy,
+};
+
+static void vc4_fkms_display_power(struct drm_encoder *encoder, bool power)
+{
+	struct vc4_fkms_encoder *vc4_encoder = to_vc4_fkms_encoder(encoder);
+	struct vc4_dev *vc4 = to_vc4_dev(encoder->dev);
+
+	struct mailbox_display_pwr pwr = {
+		.tag1 = {RPI_FIRMWARE_SET_DISPLAY_POWER, 8, 0, },
+		.display = vc4_encoder->display_num,
+		.state = power ? 1 : 0,
+	};
+
+	rpi_firmware_property_list(vc4->firmware, &pwr, sizeof(pwr));
+}
+
+static void vc4_fkms_encoder_enable(struct drm_encoder *encoder)
+{
+	vc4_fkms_display_power(encoder, true);
+	DRM_DEBUG_KMS("Encoder_enable\n");
+}
+
+static void vc4_fkms_encoder_disable(struct drm_encoder *encoder)
+{
+	vc4_fkms_display_power(encoder, false);
+	DRM_DEBUG_KMS("Encoder_disable\n");
+}
+
+static const struct drm_encoder_helper_funcs vc4_fkms_encoder_helper_funcs = {
+	.enable = vc4_fkms_encoder_enable,
+	.disable = vc4_fkms_encoder_disable,
+};
+
+static int vc4_fkms_create_screen(struct device *dev, struct drm_device *drm,
+				  int display_idx, int display_ref,
+				  struct vc4_fkms_crtc **ret_crtc)
+{
+	struct vc4_dev *vc4 = to_vc4_dev(drm);
+	struct vc4_fkms_crtc *vc4_fkms_crtc;
+	struct vc4_fkms_encoder *vc4_encoder;
+	struct drm_crtc *crtc;
+	struct drm_plane *destroy_plane, *temp;
+	struct mailbox_blank_display blank = {
+		.tag1 = {RPI_FIRMWARE_FRAMEBUFFER_SET_DISPLAY_NUM, 4, 0, },
+		.display = display_idx,
+		.tag2 = { RPI_FIRMWARE_FRAMEBUFFER_BLANK, 4, 0, },
+		.blank = 1,
+	};
+	struct drm_plane *planes[PLANES_PER_CRTC];
+	int ret, i;
+
+	vc4_fkms_crtc = devm_kzalloc(dev, sizeof(*vc4_fkms_crtc), GFP_KERNEL);
+	if (!vc4_fkms_crtc)
+		return -ENOMEM;
+	crtc = &vc4_fkms_crtc->base;
+
+	vc4_fkms_crtc->display_number = display_ref;
+	vc4_fkms_crtc->display_type = vc4_get_display_type(display_ref);
+
+	/* Blank the firmware provided framebuffer */
+	rpi_firmware_property_list(vc4->firmware, &blank, sizeof(blank));
+
+	for (i = 0; i < PLANES_PER_CRTC; i++) {
+		planes[i] = vc4_fkms_plane_init(drm,
+						(i == 0) ?
+						  DRM_PLANE_TYPE_PRIMARY :
+						  (i == PLANES_PER_CRTC - 1) ?
+							DRM_PLANE_TYPE_CURSOR :
+							DRM_PLANE_TYPE_OVERLAY,
+						display_ref,
+						i + (display_idx * PLANES_PER_CRTC)
+					       );
+		if (IS_ERR(planes[i])) {
+			dev_err(dev, "failed to construct plane %u\n", i);
+			ret = PTR_ERR(planes[i]);
+			goto err;
+		}
+	}
+
+	drm_crtc_init_with_planes(drm, crtc, planes[0],
+				  planes[PLANES_PER_CRTC - 1], &vc4_crtc_funcs,
+				  NULL);
+	drm_crtc_helper_add(crtc, &vc4_crtc_helper_funcs);
+
+	/* Update the possible_crtcs mask for the overlay plane(s) */
+	for (i = 1; i < (PLANES_PER_CRTC - 1); i++)
+		planes[i]->possible_crtcs = drm_crtc_mask(crtc);
+
+	vc4_encoder = devm_kzalloc(dev, sizeof(*vc4_encoder), GFP_KERNEL);
+	if (!vc4_encoder)
+		return -ENOMEM;
+	vc4_fkms_crtc->encoder = &vc4_encoder->base;
+
+	vc4_encoder->display_num = display_ref;
+	vc4_encoder->base.possible_crtcs |= drm_crtc_mask(crtc);
+
+	drm_encoder_init(drm, &vc4_encoder->base, &vc4_fkms_encoder_funcs,
+			 vc4_fkms_crtc->display_type, NULL);
+	drm_encoder_helper_add(&vc4_encoder->base,
+			       &vc4_fkms_encoder_helper_funcs);
+
+	vc4_fkms_crtc->connector = vc4_fkms_connector_init(drm, &vc4_encoder->base,
+							   display_ref);
+	if (IS_ERR(vc4_fkms_crtc->connector)) {
+		ret = PTR_ERR(vc4_fkms_crtc->connector);
+		goto err_destroy_encoder;
+	}
+
+	*ret_crtc = vc4_fkms_crtc;
+
+	return 0;
+
+err_destroy_encoder:
+	vc4_fkms_encoder_destroy(vc4_fkms_crtc->encoder);
+	list_for_each_entry_safe(destroy_plane, temp,
+				 &drm->mode_config.plane_list, head) {
+		if (destroy_plane->possible_crtcs == 1 << drm_crtc_index(crtc))
+			destroy_plane->funcs->destroy(destroy_plane);
+	}
+err:
+	return ret;
+}
+
+static int vc4_fkms_bind(struct device *dev, struct device *master, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct drm_device *drm = dev_get_drvdata(master);
+	struct vc4_dev *vc4 = to_vc4_dev(drm);
+	struct device_node *firmware_node;
+	const struct of_device_id *match;
+	struct vc4_fkms_crtc **crtc_list;
+	u32 num_displays, display_num;
+	struct vc4_fkms *fkms;
+	int ret;
+	u32 display_id;
+
+	vc4->firmware_kms = true;
+
+	fkms = devm_kzalloc(dev, sizeof(*fkms), GFP_KERNEL);
+	if (!fkms)
+		return -ENOMEM;
+
+	match = of_match_device(vc4_firmware_kms_dt_match, dev);
+	if (!match)
+		return -ENODEV;
+	fkms->revision = (enum vc4_fkms_revision)match->data;
+
+	firmware_node = of_parse_phandle(dev->of_node, "brcm,firmware", 0);
+	vc4->firmware = devm_rpi_firmware_get(&pdev->dev, firmware_node);
+	if (!vc4->firmware) {
+		DRM_DEBUG("Failed to get Raspberry Pi firmware reference.\n");
+		return -EPROBE_DEFER;
+	}
+	of_node_put(firmware_node);
+
+	ret = rpi_firmware_property(vc4->firmware,
+				    RPI_FIRMWARE_FRAMEBUFFER_GET_NUM_DISPLAYS,
+				    &num_displays, sizeof(u32));
+
+	/* If we fail to get the number of displays, then
+	 * assume old firmware that doesn't have the mailbox call, so just
+	 * set one display
+	 */
+	if (ret) {
+		num_displays = 1;
+		DRM_WARN("Unable to determine number of displays - assuming 1\n");
+		ret = 0;
+	}
+
+	ret = rpi_firmware_property(vc4->firmware,
+				    RPI_FIRMWARE_GET_DISPLAY_CFG,
+				    &fkms->cfg, sizeof(fkms->cfg));
+
+	if (ret)
+		return -EINVAL;
+	/* The firmware works in Hz. This will be compared against kHz, so div
+	 * 1000 now rather than multiple times later.
+	 */
+	fkms->cfg.max_pixel_clock[0] /= 1000;
+	fkms->cfg.max_pixel_clock[1] /= 1000;
+
+	/* Allocate a list, with space for a NULL on the end */
+	crtc_list = devm_kzalloc(dev, sizeof(crtc_list) * (num_displays + 1),
+				 GFP_KERNEL);
+	if (!crtc_list)
+		return -ENOMEM;
+
+	for (display_num = 0; display_num < num_displays; display_num++) {
+		display_id = display_num;
+		ret = rpi_firmware_property(vc4->firmware,
+					    RPI_FIRMWARE_FRAMEBUFFER_GET_DISPLAY_ID,
+					    &display_id, sizeof(display_id));
+		/* FIXME: Determine the correct error handling here.
+		 * Should we fail to create the one "screen" but keep the
+		 * others, or fail the whole thing?
+		 */
+		if (ret)
+			DRM_ERROR("Failed to get display id %u\n", display_num);
+
+		ret = vc4_fkms_create_screen(dev, drm, display_num, display_id,
+					     &crtc_list[display_num]);
+		if (ret)
+			DRM_ERROR("Oh dear, failed to create display %u\n",
+				  display_num);
+	}
+
+	if (num_displays > 0) {
+		if (fkms->revision >= BCM2712) {
+			ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
+					       vc4_crtc2712_irq_handler, 0,
+					       "vc4 firmware kms", crtc_list);
+		} else {
+			/* Map the SMI interrupt reg */
+			crtc_list[0]->regs = vc4_ioremap_regs(pdev, 0);
+			if (IS_ERR(crtc_list[0]->regs))
+				DRM_ERROR("Oh dear, failed to map registers\n");
+
+			writel(0, crtc_list[0]->regs + SMICS);
+			ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
+					       vc4_crtc_irq_handler, 0,
+					       "vc4 firmware kms", crtc_list);
+		}
+		if (ret)
+			DRM_ERROR("Oh dear, failed to register IRQ\n");
+	} else {
+		DRM_WARN("No displays found. Consider forcing hotplug if HDMI is attached\n");
+	}
+
+	vc4->fkms = fkms;
+
+	platform_set_drvdata(pdev, crtc_list);
+
+	return 0;
+}
+
+static void vc4_fkms_unbind(struct device *dev, struct device *master,
+			    void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct vc4_fkms_crtc **crtc_list = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; crtc_list[i]; i++) {
+		vc4_fkms_connector_destroy(crtc_list[i]->connector);
+		vc4_fkms_encoder_destroy(crtc_list[i]->encoder);
+		drm_crtc_cleanup(&crtc_list[i]->base);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+}
+
+static const struct component_ops vc4_fkms_ops = {
+	.bind   = vc4_fkms_bind,
+	.unbind = vc4_fkms_unbind,
+};
+
+static int vc4_fkms_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &vc4_fkms_ops);
+}
+
+static void vc4_fkms_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &vc4_fkms_ops);
+}
+
+struct platform_driver vc4_firmware_kms_driver = {
+	.probe = vc4_fkms_probe,
+	.remove = vc4_fkms_remove,
+	.driver = {
+		.name = "vc4_firmware_kms",
+		.of_match_table = vc4_firmware_kms_dt_match,
+	},
+};
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi.c	2025-06-16 10:30:23.608245431 +0200
@@ -44,6 +44,8 @@
 #include <linux/component.h>
 #include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/pm_runtime.h>
@@ -113,6 +115,10 @@
 
 #define HDMI_14_MAX_TMDS_CLK   (340 * 1000 * 1000)
 
+/* bit field to force hotplug detection. bit0 = HDMI0 */
+static int force_hotplug;
+module_param(force_hotplug, int, 0644);
+
 static bool vc4_hdmi_supports_scrambling(struct vc4_hdmi *vc4_hdmi)
 {
 	struct drm_display_info *display = &vc4_hdmi->connector.display_info;
@@ -360,6 +366,12 @@
 	int ret;
 
 	/*
+	 * Needs to be called for both connects and disconnects for HDMI
+	 * audio hotplug to work correctly.
+	 */
+	drm_atomic_helper_connector_hdmi_hotplug(connector, status);
+
+	/*
 	 * NOTE: This function should really be called with vc4_hdmi->mutex
 	 * held, but doing so results in reentrancy issues since
 	 * cec_s_phys_addr() might call .adap_enable, which leads to that
@@ -423,7 +435,9 @@
 		return connector_status_unknown;
 	}
 
-	if (vc4_hdmi->hpd_gpio) {
+	if (force_hotplug & BIT(vc4_hdmi->encoder.type - VC4_ENCODER_TYPE_HDMI0))
+		status = connector_status_connected;
+	else if (vc4_hdmi->hpd_gpio) {
 		if (gpiod_get_value_cansleep(vc4_hdmi->hpd_gpio))
 			status = connector_status_connected;
 	} else {
@@ -560,6 +574,12 @@
 	if (ret)
 		return ret;
 
+	ret = drm_connector_hdmi_audio_init(connector, dev->dev,
+					    &vc4_hdmi_audio_funcs,
+					    8, false, -1);
+	if (ret)
+		return ret;
+
 	drm_connector_helper_add(connector, &vc4_hdmi_connector_helper_funcs);
 
 	/*
@@ -703,6 +723,24 @@
 	return ret;
 }
 
+static int vc4_hdmi_clear_infoframe(struct drm_connector *connector,
+				    enum hdmi_infoframe_type type)
+{
+	struct vc4_hdmi *vc4_hdmi = connector_to_vc4_hdmi(connector);
+	struct drm_device *drm = connector->dev;
+	int ret;
+	int idx;
+
+	if (!drm_dev_enter(drm, &idx))
+		return 0;
+
+	ret = vc4_hdmi_stop_packet(vc4_hdmi, type, true);
+	if (ret)
+		drm_err(drm, "Failed to wait for infoframe to go idle: %d\n", ret);
+
+	drm_dev_exit(idx);
+	return ret;
+}
 #define SCRAMBLING_POLLING_DELAY_MS	1000
 
 static void vc4_hdmi_enable_scrambling(struct drm_encoder *encoder)
@@ -864,6 +902,8 @@
 	if (vc4_hdmi->variant->phy_disable)
 		vc4_hdmi->variant->phy_disable(vc4_hdmi);
 
+	/* we no longer require a minimum clock rate */
+	clk_set_min_rate(vc4_hdmi->pixel_bvb_clock, 0);
 	clk_disable_unprepare(vc4_hdmi->pixel_bvb_clock);
 	clk_disable_unprepare(vc4_hdmi->pixel_clock);
 
@@ -1661,6 +1701,7 @@
 static const struct drm_connector_hdmi_funcs vc4_hdmi_hdmi_connector_funcs = {
 	.tmds_char_rate_valid	= vc4_hdmi_connector_clock_valid,
 	.write_infoframe	= vc4_hdmi_write_infoframe,
+	.clear_infoframe	= vc4_hdmi_clear_infoframe,
 };
 
 #define WIFI_2_4GHz_CH1_MIN_FREQ	2400000000ULL
@@ -1675,7 +1716,9 @@
 	unsigned long long tmds_char_rate = mode->clock * 1000;
 	unsigned long long tmds_bit_rate;
 
-	if (vc4_hdmi->variant->unsupported_odd_h_timings) {
+	if (vc4_hdmi->variant->unsupported_odd_h_timings ||
+	    (vc4_hdmi->variant->unsupported_int_odd_h_timings &&
+		(mode->flags & DRM_MODE_FLAG_INTERLACE))) {
 		if (mode->flags & DRM_MODE_FLAG_DBLCLK) {
 			/* Only try to fixup DBLCLK modes to get 480i and 576i
 			 * working.
@@ -2193,7 +2236,7 @@
 	struct snd_soc_dai_link *dai_link = &vc4_hdmi->audio.link;
 	struct snd_soc_card *card = &vc4_hdmi->audio.card;
 	struct device *dev = &vc4_hdmi->pdev->dev;
-	const __be32 *addr;
+	struct resource *iomem;
 	int index, len;
 	int ret;
 
@@ -2229,22 +2272,18 @@
 	}
 
 	/*
-	 * Get the physical address of VC4_HD_MAI_DATA. We need to retrieve
-	 * the bus address specified in the DT, because the physical address
-	 * (the one returned by platform_get_resource()) is not appropriate
-	 * for DMA transfers.
-	 * This VC/MMU should probably be exposed to avoid this kind of hacks.
+	 * Get the physical address of VC4_HD_MAI_DATA.
 	 */
 	index = of_property_match_string(dev->of_node, "reg-names", "hd");
 	/* Before BCM2711, we don't have a named register range */
 	if (index < 0)
 		index = 1;
 
-	addr = of_get_address(dev->of_node, index, NULL, NULL);
-	if (!addr)
+	iomem = platform_get_resource(vc4_hdmi->pdev, IORESOURCE_MEM, index);
+	if (!iomem)
 		return -EINVAL;
 
-	vc4_hdmi->audio.dma_data.addr = be32_to_cpup(addr) + mai_data->offset;
+	vc4_hdmi->audio.dma_data.addr = iomem->start + mai_data->offset;
 	vc4_hdmi->audio.dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	vc4_hdmi->audio.dma_data.maxburst = 2;
 
@@ -2285,12 +2324,6 @@
 		return ret;
 	}
 
-	ret = drm_connector_hdmi_audio_init(&vc4_hdmi->connector, dev,
-					    &vc4_hdmi_audio_funcs, 8, false,
-					    -1);
-	if (ret)
-		return ret;
-
 	dai_link->cpus		= &vc4_hdmi->audio.cpu;
 	dai_link->codecs	= &vc4_hdmi->audio.codec;
 	dai_link->platforms	= &vc4_hdmi->audio.platform;
@@ -2307,6 +2340,8 @@
 	dai_link->platforms->name = dev_name(dev);
 	dai_link->init = vc4_hdmi_codec_init;
 
+	dai_link->init = vc4_hdmi_codec_init;
+
 	card->dai_link = dai_link;
 	card->num_links = 1;
 	card->name = vc4_hdmi->variant->card_name;
@@ -2336,7 +2371,7 @@
 	struct drm_connector *connector = &vc4_hdmi->connector;
 	struct drm_device *dev = connector->dev;
 
-	if (dev && dev->registered)
+	if (dev && dev->registered && !force_hotplug)
 		drm_connector_helper_hpd_irq_event(connector);
 
 	return IRQ_HANDLED;
@@ -3062,6 +3097,8 @@
 	struct vc4_hdmi *vc4_hdmi = dev_get_drvdata(dev);
 
 	clk_disable_unprepare(vc4_hdmi->audio_clock);
+	/* we no longer require a minimum clock rate */
+	clk_set_min_rate(vc4_hdmi->hsm_clock, 0);
 	clk_disable_unprepare(vc4_hdmi->hsm_clock);
 
 	return 0;
@@ -3186,7 +3223,7 @@
 	vc4_hdmi->ddc = of_find_i2c_adapter_by_node(ddc_node);
 	of_node_put(ddc_node);
 	if (!vc4_hdmi->ddc) {
-		drm_err(drm, "Failed to get ddc i2c adapter by node\n");
+		drm_dbg(drm, "Failed to get ddc i2c adapter by node\n");
 		return -EPROBE_DEFER;
 	}
 
@@ -3310,6 +3347,7 @@
 		PHY_LANE_CK,
 	},
 	.unsupported_odd_h_timings	= true,
+	.unsupported_int_odd_h_timings	= true,
 	.external_irq_controller	= true,
 
 	.init_resources		= vc5_hdmi_init_resources,
@@ -3339,6 +3377,7 @@
 		PHY_LANE_2,
 	},
 	.unsupported_odd_h_timings	= true,
+	.unsupported_int_odd_h_timings	= true,
 	.external_irq_controller	= true,
 
 	.init_resources		= vc5_hdmi_init_resources,
@@ -3368,6 +3407,7 @@
 		PHY_LANE_CK,
 	},
 	.unsupported_odd_h_timings	= false,
+	.unsupported_int_odd_h_timings	= true,
 	.external_irq_controller	= true,
 
 	.init_resources		= vc5_hdmi_init_resources,
@@ -3395,6 +3435,7 @@
 		PHY_LANE_CK,
 	},
 	.unsupported_odd_h_timings	= false,
+	.unsupported_int_odd_h_timings	= true,
 	.external_irq_controller	= true,
 
 	.init_resources		= vc5_hdmi_init_resources,
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi.h linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi.h
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi.h	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi.h	2025-06-16 10:30:23.608245431 +0200
@@ -47,6 +47,10 @@
 
 	/* The BCM2711 cannot deal with odd horizontal pixel timings */
 	bool unsupported_odd_h_timings;
+	/* The BCM2712 can handle odd horizontal pixel timings, but not in
+	 * interlaced modes
+	 */
+	bool unsupported_int_odd_h_timings;
 
 	/*
 	 * The BCM2711 CEC/hotplug IRQ controller is shared between the
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi_phy.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi_phy.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi_phy.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hdmi_phy.c	2025-06-16 17:40:50.791684722 +0200
@@ -137,6 +137,7 @@
 #define VC6_HDMI_TX_PHY_PLL_REFCLK_REFCLK_SEL_CMOS	BIT(13)
 #define VC6_HDMI_TX_PHY_PLL_REFCLK_REFFRQ_MASK		VC4_MASK(9, 0)
 
+#define VC6_HDMI_TX_PHY_PLL_POST_KDIV_BYPASS_EN		BIT(4)
 #define VC6_HDMI_TX_PHY_PLL_POST_KDIV_CLK0_SEL_MASK	VC4_MASK(3, 2)
 #define VC6_HDMI_TX_PHY_PLL_POST_KDIV_KDIV_MASK		VC4_MASK(1, 0)
 
@@ -947,6 +948,7 @@
 
 	HDMI_WRITE(HDMI_TX_PHY_RESET_CTL, 0);
 	HDMI_WRITE(HDMI_TX_PHY_POWERUP_CTL, 0);
+	HDMI_WRITE(HDMI_TX_PHY_PLL_POST_KDIV, VC6_HDMI_TX_PHY_PLL_POST_KDIV_BYPASS_EN);
 }
 
 void vc6_hdmi_phy_init(struct vc4_hdmi *vc4_hdmi,
@@ -1197,4 +1199,9 @@
 
 void vc6_hdmi_phy_disable(struct vc4_hdmi *vc4_hdmi)
 {
+	unsigned long flags;
+
+	spin_lock_irqsave(&vc4_hdmi->hw_lock, flags);
+	vc6_hdmi_reset_phy(vc4_hdmi);
+	spin_unlock_irqrestore(&vc4_hdmi->hw_lock, flags);
 }
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hvs.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hvs.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hvs.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_hvs.c	2025-06-16 17:40:50.791684722 +0200
@@ -104,7 +104,6 @@
 	VC4_REG32(SCALER6_DISP2_RUN),
 	VC4_REG32(SCALER6_EOLN),
 	VC4_REG32(SCALER6_DL_STATUS),
-	VC4_REG32(SCALER6_BFG_MISC),
 	VC4_REG32(SCALER6_QOS0),
 	VC4_REG32(SCALER6_PROF0),
 	VC4_REG32(SCALER6_QOS1),
@@ -141,64 +140,64 @@
 	VC4_REG32(SCALER6_BAD_AXI),
 };
 
-static const struct debugfs_reg32 vc6_d_hvs_regs[] = {
-	VC4_REG32(SCALER6D_VERSION),
-	VC4_REG32(SCALER6D_CXM_SIZE),
-	VC4_REG32(SCALER6D_LBM_SIZE),
-	VC4_REG32(SCALER6D_UBM_SIZE),
-	VC4_REG32(SCALER6D_COBA_SIZE),
-	VC4_REG32(SCALER6D_COB_SIZE),
-	VC4_REG32(SCALER6D_CONTROL),
-	VC4_REG32(SCALER6D_FETCHER_STATUS),
-	VC4_REG32(SCALER6D_FETCH_STATUS),
-	VC4_REG32(SCALER6D_HANDLE_ERROR),
-	VC4_REG32(SCALER6D_DISP0_CTRL0),
-	VC4_REG32(SCALER6D_DISP0_CTRL1),
-	VC4_REG32(SCALER6D_DISP0_BGND0),
-	VC4_REG32(SCALER6D_DISP0_BGND1),
-	VC4_REG32(SCALER6D_DISP0_LPTRS),
-	VC4_REG32(SCALER6D_DISP0_COB),
-	VC4_REG32(SCALER6D_DISP0_STATUS),
-	VC4_REG32(SCALER6D_DISP0_DL),
-	VC4_REG32(SCALER6D_DISP0_RUN),
-	VC4_REG32(SCALER6D_DISP1_CTRL0),
-	VC4_REG32(SCALER6D_DISP1_CTRL1),
-	VC4_REG32(SCALER6D_DISP1_BGND0),
-	VC4_REG32(SCALER6D_DISP1_BGND1),
-	VC4_REG32(SCALER6D_DISP1_LPTRS),
-	VC4_REG32(SCALER6D_DISP1_COB),
-	VC4_REG32(SCALER6D_DISP1_STATUS),
-	VC4_REG32(SCALER6D_DISP1_DL),
-	VC4_REG32(SCALER6D_DISP1_RUN),
-	VC4_REG32(SCALER6D_DISP2_CTRL0),
-	VC4_REG32(SCALER6D_DISP2_CTRL1),
-	VC4_REG32(SCALER6D_DISP2_BGND0),
-	VC4_REG32(SCALER6D_DISP2_BGND1),
-	VC4_REG32(SCALER6D_DISP2_LPTRS),
-	VC4_REG32(SCALER6D_DISP2_COB),
-	VC4_REG32(SCALER6D_DISP2_STATUS),
-	VC4_REG32(SCALER6D_DISP2_DL),
-	VC4_REG32(SCALER6D_DISP2_RUN),
-	VC4_REG32(SCALER6D_EOLN),
-	VC4_REG32(SCALER6D_DL_STATUS),
-	VC4_REG32(SCALER6D_QOS0),
-	VC4_REG32(SCALER6D_PROF0),
-	VC4_REG32(SCALER6D_QOS1),
-	VC4_REG32(SCALER6D_PROF1),
-	VC4_REG32(SCALER6D_QOS2),
-	VC4_REG32(SCALER6D_PROF2),
-	VC4_REG32(SCALER6D_PRI_MAP0),
-	VC4_REG32(SCALER6D_PRI_MAP1),
-	VC4_REG32(SCALER6D_HISTCTRL),
-	VC4_REG32(SCALER6D_HISTBIN0),
-	VC4_REG32(SCALER6D_HISTBIN1),
-	VC4_REG32(SCALER6D_HISTBIN2),
-	VC4_REG32(SCALER6D_HISTBIN3),
-	VC4_REG32(SCALER6D_HISTBIN4),
-	VC4_REG32(SCALER6D_HISTBIN5),
-	VC4_REG32(SCALER6D_HISTBIN6),
-	VC4_REG32(SCALER6D_HISTBIN7),
-	VC4_REG32(SCALER6D_HVS_ID),
+static const struct debugfs_reg32 vc6_hvs_regs_d0[] = {
+	VC4_REG32(SCALER6D0_VERSION),
+	VC4_REG32(SCALER6D0_CXM_SIZE),
+	VC4_REG32(SCALER6D0_LBM_SIZE),
+	VC4_REG32(SCALER6D0_UBM_SIZE),
+	VC4_REG32(SCALER6D0_COBA_SIZE),
+	VC4_REG32(SCALER6D0_COB_SIZE),
+	VC4_REG32(SCALER6D0_CONTROL),
+	VC4_REG32(SCALER6D0_FETCHER_STATUS),
+	VC4_REG32(SCALER6D0_FETCH_STATUS),
+	VC4_REG32(SCALER6D0_HANDLE_ERROR),
+	VC4_REG32(SCALER6D0_DISP0_CTRL0),
+	VC4_REG32(SCALER6D0_DISP0_CTRL1),
+	VC4_REG32(SCALER6D0_DISP0_BGND0),
+	VC4_REG32(SCALER6D0_DISP0_BGND1),
+	VC4_REG32(SCALER6D0_DISP0_LPTRS),
+	VC4_REG32(SCALER6D0_DISP0_COB),
+	VC4_REG32(SCALER6D0_DISP0_STATUS),
+	VC4_REG32(SCALER6D0_DISP0_DL),
+	VC4_REG32(SCALER6D0_DISP0_RUN),
+	VC4_REG32(SCALER6D0_DISP1_CTRL0),
+	VC4_REG32(SCALER6D0_DISP1_CTRL1),
+	VC4_REG32(SCALER6D0_DISP1_BGND0),
+	VC4_REG32(SCALER6D0_DISP1_BGND1),
+	VC4_REG32(SCALER6D0_DISP1_LPTRS),
+	VC4_REG32(SCALER6D0_DISP1_COB),
+	VC4_REG32(SCALER6D0_DISP1_STATUS),
+	VC4_REG32(SCALER6D0_DISP1_DL),
+	VC4_REG32(SCALER6D0_DISP1_RUN),
+	VC4_REG32(SCALER6D0_DISP2_CTRL0),
+	VC4_REG32(SCALER6D0_DISP2_CTRL1),
+	VC4_REG32(SCALER6D0_DISP2_BGND0),
+	VC4_REG32(SCALER6D0_DISP2_BGND1),
+	VC4_REG32(SCALER6D0_DISP2_LPTRS),
+	VC4_REG32(SCALER6D0_DISP2_COB),
+	VC4_REG32(SCALER6D0_DISP2_STATUS),
+	VC4_REG32(SCALER6D0_DISP2_DL),
+	VC4_REG32(SCALER6D0_DISP2_RUN),
+	VC4_REG32(SCALER6D0_EOLN),
+	VC4_REG32(SCALER6D0_DL_STATUS),
+	VC4_REG32(SCALER6D0_QOS0),
+	VC4_REG32(SCALER6D0_PROF0),
+	VC4_REG32(SCALER6D0_QOS1),
+	VC4_REG32(SCALER6D0_PROF1),
+	VC4_REG32(SCALER6D0_QOS2),
+	VC4_REG32(SCALER6D0_PROF2),
+	VC4_REG32(SCALER6D0_PRI_MAP0),
+	VC4_REG32(SCALER6D0_PRI_MAP1),
+	VC4_REG32(SCALER6D0_HISTCTRL),
+	VC4_REG32(SCALER6D0_HISTBIN0),
+	VC4_REG32(SCALER6D0_HISTBIN1),
+	VC4_REG32(SCALER6D0_HISTBIN2),
+	VC4_REG32(SCALER6D0_HISTBIN3),
+	VC4_REG32(SCALER6D0_HISTBIN4),
+	VC4_REG32(SCALER6D0_HISTBIN5),
+	VC4_REG32(SCALER6D0_HISTBIN6),
+	VC4_REG32(SCALER6D0_HISTBIN7),
+	VC4_REG32(SCALER6D0_HVS_ID),
 };
 
 void vc4_hvs_dump_state(struct vc4_hvs *hvs)
@@ -281,8 +280,8 @@
 
 static int vc6_hvs_debugfs_dlist(struct seq_file *m, void *data)
 {
-	struct drm_info_node *node = m->private;
-	struct drm_device *dev = node->minor->dev;
+	struct drm_debugfs_entry *entry = m->private;
+	struct drm_device *dev = entry->dev;
 	struct vc4_dev *vc4 = to_vc4_dev(dev);
 	struct vc4_hvs *hvs = vc4->hvs;
 	struct drm_printer p = drm_seq_file_printer(m);
@@ -294,18 +293,18 @@
 		unsigned int active_dlist, dispstat;
 		unsigned int j;
 
-		dispstat = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_STATUS(i)),
-					 SCALER6_DISPX_STATUS_MODE);
-		if (dispstat == SCALER6_DISPX_STATUS_MODE_DISABLED ||
-		    dispstat == SCALER6_DISPX_STATUS_MODE_EOF) {
+		dispstat = VC4_GET_FIELD6(HVS_READ(SCALER6_DISPX_STATUS(i)),
+					 DISPX_STATUS_MODE);
+		if (dispstat == SCALER6(DISPX_STATUS_MODE_DISABLED) ||
+		    dispstat == SCALER6(DISPX_STATUS_MODE_EOF)) {
 			drm_printf(&p, "HVS chan %u disabled\n", i);
 			continue;
 		}
 
 		drm_printf(&p, "HVS chan %u:\n", i);
 
-		active_dlist = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_DL(i)),
-					     SCALER6_DISPX_DL_LACT);
+		active_dlist = VC4_GET_FIELD6(HVS_READ(SCALER6_DISPX_DL(i)),
+					     DISPX_DL_LACT);
 		next_entry_start = 0;
 
 		for (j = active_dlist; j < dlist_mem_size; j++) {
@@ -328,24 +327,112 @@
 	return 0;
 }
 
-static int vc6_hvs_debugfs_upm_allocs(struct seq_file *m, void *data)
+static int vc5_hvs_debugfs_gamma(struct seq_file *m, void *data)
 {
 	struct drm_debugfs_entry *entry = m->private;
 	struct drm_device *dev = entry->dev;
 	struct vc4_dev *vc4 = to_vc4_dev(dev);
 	struct vc4_hvs *hvs = vc4->hvs;
 	struct drm_printer p = drm_seq_file_printer(m);
-	struct vc4_upm_refcounts *refcount;
-	unsigned int i;
+	unsigned int i, chan;
+	u32 dispstat, dispbkgndx;
 
-	drm_printf(&p, "UPM Handles:\n");
-	for (i = 1; i <= VC4_NUM_UPM_HANDLES; i++) {
-		refcount = &hvs->upm_refcounts[i];
-		drm_printf(&p, "handle %u: refcount %u, size %zu [%08llx + %08llx]\n",
-			   i, refcount_read(&refcount->refcount), refcount->size,
-			   refcount->upm.start, refcount->upm.size);
+	for (chan = 0; chan < SCALER_CHANNELS_COUNT; chan++) {
+		u32 x_c, grad;
+		u32 offset = SCALER5_DSPGAMMA_START +
+			chan * SCALER5_DSPGAMMA_CHAN_OFFSET;
+
+		dispstat = VC4_GET_FIELD(HVS_READ(SCALER_DISPSTATX(chan)),
+					 SCALER_DISPSTATX_MODE);
+		if (dispstat == SCALER_DISPSTATX_MODE_DISABLED ||
+		    dispstat == SCALER_DISPSTATX_MODE_EOF) {
+			drm_printf(&p, "HVS channel %u: Channel disabled\n", chan);
+			continue;
+		}
+
+		dispbkgndx = HVS_READ(SCALER_DISPBKGNDX(chan));
+		if (!(dispbkgndx & SCALER_DISPBKGND_GAMMA)) {
+			drm_printf(&p, "HVS channel %u: Gamma disabled\n", chan);
+			continue;
+		}
+
+		drm_printf(&p, "HVS channel %u:\n", chan);
+		drm_printf(&p, "  red:\n");
+		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8) {
+			x_c = HVS_READ(offset);
+			grad = HVS_READ(offset + 4);
+			drm_printf(&p, "  %08x %08x - x %u, c %u, grad %u\n",
+				   x_c, grad,
+				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_X),
+				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_C),
+				   grad);
+		}
+		drm_printf(&p, "  green:\n");
+		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8) {
+			x_c = HVS_READ(offset);
+			grad = HVS_READ(offset + 4);
+			drm_printf(&p, "  %08x %08x - x %u, c %u, grad %u\n",
+				   x_c, grad,
+				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_X),
+				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_C),
+				   grad);
+		}
+		drm_printf(&p, "  blue:\n");
+		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8) {
+			x_c = HVS_READ(offset);
+			grad = HVS_READ(offset + 4);
+			drm_printf(&p, "  %08x %08x - x %u, c %u, grad %u\n",
+				   x_c, grad,
+				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_X),
+				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_C),
+				   grad);
+		}
+
+		/* Alpha only valid on channel 2 */
+		if (chan != 2)
+			continue;
+
+		drm_printf(&p, "  alpha:\n");
+		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8) {
+			x_c = HVS_READ(offset);
+			grad = HVS_READ(offset + 4);
+			drm_printf(&p, "  %08x %08x - x %u, c %u, grad %u\n",
+				   x_c, grad,
+				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_X),
+				   VC4_GET_FIELD(x_c, SCALER5_DSPGAMMA_OFF_C),
+				   grad);
+		}
+	}
+	return 0;
+}
+
+static int vc4_hvs_debugfs_dlist_allocs(struct seq_file *m, void *data)
+{
+	struct drm_debugfs_entry *entry = m->private;
+	struct drm_device *dev = entry->dev;
+	struct vc4_dev *vc4 = to_vc4_dev(dev);
+	struct vc4_hvs *hvs = vc4->hvs;
+	struct drm_printer p = drm_seq_file_printer(m);
+	struct vc4_hvs_dlist_allocation *cur, *next;
+	struct drm_mm_node *mm_node;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hvs->mm_lock, flags);
+
+	drm_printf(&p, "Allocated nodes:\n");
+	list_for_each_entry(mm_node, drm_mm_nodes(&hvs->dlist_mm), node_list) {
+		drm_printf(&p, "node [%08llx + %08llx]\n", mm_node->start, mm_node->size);
 	}
 
+	drm_printf(&p, "Stale nodes:\n");
+	list_for_each_entry_safe(cur, next, &hvs->stale_dlist_entries, node) {
+		drm_printf(&p, "node [%08llx + %08llx] channel %u frcnt %u\n",
+			   cur->mm_node.start, cur->mm_node.size, cur->channel,
+			   cur->target_frame_count);
+	}
+
+	spin_unlock_irqrestore(&hvs->mm_lock, flags);
+
 	return 0;
 }
 
@@ -382,6 +469,9 @@
 static const u32 mitchell_netravali_1_3_1_3_kernel[] =
 	VC4_LINEAR_PHASE_KERNEL(0, -2, -6, -8, -10, -8, -3, 2, 18,
 				50, 82, 119, 155, 187, 213, 227);
+static const u32 nearest_neighbour_kernel[] =
+	VC4_LINEAR_PHASE_KERNEL(0, 0, 0, 0, 0, 0, 0, 0,
+				1, 1, 1, 1, 255, 255, 255, 255);
 
 static int vc4_hvs_upload_linear_kernel(struct vc4_hvs *hvs,
 					struct drm_mm_node *space,
@@ -431,9 +521,6 @@
 	if (!drm_dev_enter(drm, &idx))
 		return;
 
-	if (hvs->vc4->gen != VC4_GEN_4)
-		goto exit;
-
 	/* The LUT memory is laid out with each HVS channel in order,
 	 * each of which takes 256 writes for R, 256 for G, then 256
 	 * for B.
@@ -449,14 +536,14 @@
 	for (i = 0; i < crtc->gamma_size; i++)
 		HVS_WRITE(SCALER_GAMDATA, vc4_crtc->lut_b[i]);
 
-exit:
 	drm_dev_exit(idx);
 }
 
 static void vc4_hvs_update_gamma_lut(struct vc4_hvs *hvs,
 				     struct vc4_crtc *vc4_crtc)
 {
-	struct drm_crtc_state *crtc_state = vc4_crtc->base.state;
+	struct drm_crtc *crtc = &vc4_crtc->base;
+	struct drm_crtc_state *crtc_state = crtc->state;
 	struct drm_color_lut *lut = crtc_state->gamma_lut->data;
 	u32 length = drm_color_lut_size(crtc_state->gamma_lut);
 	u32 i;
@@ -470,6 +557,348 @@
 	vc4_hvs_lut_load(hvs, vc4_crtc);
 }
 
+static void vc5_hvs_write_gamma_entry(struct vc4_hvs *hvs,
+				      u32 offset,
+				      struct vc5_gamma_entry *gamma)
+{
+	HVS_WRITE(offset, gamma->x_c_terms);
+	HVS_WRITE(offset + 4, gamma->grad_term);
+}
+
+static void vc5_hvs_lut_load(struct vc4_hvs *hvs,
+			     struct vc4_crtc *vc4_crtc)
+{
+	struct drm_crtc *crtc = &vc4_crtc->base;
+	struct drm_crtc_state *crtc_state = crtc->state;
+	struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);
+	u32 i;
+	u32 offset = SCALER5_DSPGAMMA_START +
+		vc4_state->assigned_channel * SCALER5_DSPGAMMA_CHAN_OFFSET;
+
+	for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8)
+		vc5_hvs_write_gamma_entry(hvs, offset, &vc4_crtc->pwl_r[i]);
+	for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8)
+		vc5_hvs_write_gamma_entry(hvs, offset, &vc4_crtc->pwl_g[i]);
+	for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8)
+		vc5_hvs_write_gamma_entry(hvs, offset, &vc4_crtc->pwl_b[i]);
+
+	if (vc4_state->assigned_channel == 2) {
+		/* Alpha only valid on channel 2 */
+		for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++, offset += 8)
+			vc5_hvs_write_gamma_entry(hvs, offset, &vc4_crtc->pwl_a[i]);
+	}
+}
+
+static void vc5_hvs_update_gamma_lut(struct vc4_hvs *hvs,
+				     struct vc4_crtc *vc4_crtc)
+{
+	struct drm_crtc *crtc = &vc4_crtc->base;
+	struct drm_color_lut *lut = crtc->state->gamma_lut->data;
+	unsigned int step, i;
+	u32 start, end;
+
+#define VC5_HVS_UPDATE_GAMMA_ENTRY_FROM_LUT(pwl, chan)			\
+	start = drm_color_lut_extract(lut[i * step].chan, 12);		\
+	end = drm_color_lut_extract(lut[(i + 1) * step - 1].chan, 12);	\
+									\
+	/* Negative gradients not permitted by the hardware, so		\
+	 * flatten such points out.					\
+	 */								\
+	if (end < start)						\
+		end = start;						\
+									\
+	/* Assume 12bit pipeline.					\
+	 * X evenly spread over full range (12 bit).			\
+	 * C as U12.4 format.						\
+	 * Gradient as U4.8 format.					\
+	*/								\
+	vc4_crtc->pwl[i] =						\
+		VC5_HVS_SET_GAMMA_ENTRY(i << 8, start << 4,		\
+				((end - start) << 4) / (step - 1))
+
+	/* HVS5 has a 16 point piecewise linear function for each colour
+	 * channel (including alpha on channel 2) on each display channel.
+	 *
+	 * Currently take a crude subsample of the gamma LUT, but this could
+	 * be improved to implement curve fitting.
+	 */
+	step = crtc->gamma_size / SCALER5_DSPGAMMA_NUM_POINTS;
+	for (i = 0; i < SCALER5_DSPGAMMA_NUM_POINTS; i++) {
+		VC5_HVS_UPDATE_GAMMA_ENTRY_FROM_LUT(pwl_r, red);
+		VC5_HVS_UPDATE_GAMMA_ENTRY_FROM_LUT(pwl_g, green);
+		VC5_HVS_UPDATE_GAMMA_ENTRY_FROM_LUT(pwl_b, blue);
+	}
+
+	vc5_hvs_lut_load(hvs, vc4_crtc);
+}
+
+static void vc4_hvs_irq_enable_eof(struct vc4_hvs *hvs,
+				   unsigned int channel)
+{
+	struct vc4_dev *vc4 = hvs->vc4;
+
+	if (hvs->eof_irq[channel].enabled)
+		return;
+
+	switch (vc4->gen) {
+	case VC4_GEN_4:
+		HVS_WRITE(SCALER_DISPCTRL,
+			  HVS_READ(SCALER_DISPCTRL) |
+			  SCALER_DISPCTRL_DSPEIEOF(channel));
+		break;
+
+	case VC4_GEN_5:
+		HVS_WRITE(SCALER_DISPCTRL,
+			  HVS_READ(SCALER_DISPCTRL) |
+			  SCALER5_DISPCTRL_DSPEIEOF(channel));
+		break;
+
+	case VC4_GEN_6:
+		enable_irq(hvs->eof_irq[channel].desc);
+		break;
+
+	default:
+		break;
+	}
+
+	hvs->eof_irq[channel].enabled = true;
+}
+
+static void vc4_hvs_irq_clear_eof(struct vc4_hvs *hvs,
+				  unsigned int channel)
+{
+	struct vc4_dev *vc4 = hvs->vc4;
+
+	if (!hvs->eof_irq[channel].enabled)
+		return;
+
+	switch (vc4->gen) {
+	case VC4_GEN_4:
+		HVS_WRITE(SCALER_DISPCTRL,
+			  HVS_READ(SCALER_DISPCTRL) &
+			  ~SCALER_DISPCTRL_DSPEIEOF(channel));
+		break;
+
+	case VC4_GEN_5:
+		HVS_WRITE(SCALER_DISPCTRL,
+			  HVS_READ(SCALER_DISPCTRL) &
+			  ~SCALER5_DISPCTRL_DSPEIEOF(channel));
+		break;
+
+	case VC4_GEN_6:
+		disable_irq_nosync(hvs->eof_irq[channel].desc);
+		break;
+
+	default:
+		break;
+	}
+
+	hvs->eof_irq[channel].enabled = false;
+}
+
+static void vc4_hvs_free_dlist_entry_locked(struct vc4_hvs *hvs,
+					    struct vc4_hvs_dlist_allocation *alloc);
+
+static struct vc4_hvs_dlist_allocation *
+vc4_hvs_alloc_dlist_entry(struct vc4_hvs *hvs,
+			  unsigned int channel,
+			  size_t dlist_count)
+{
+	struct vc4_dev *vc4 = hvs->vc4;
+	struct drm_device *dev = &vc4->base;
+	struct vc4_hvs_dlist_allocation *alloc;
+	struct vc4_hvs_dlist_allocation *cur, *next;
+	unsigned long flags;
+	int ret;
+
+	if (channel == VC4_HVS_CHANNEL_DISABLED)
+		return NULL;
+
+	alloc = kzalloc(sizeof(*alloc), GFP_KERNEL);
+	if (!alloc)
+		return ERR_PTR(-ENOMEM);
+
+	INIT_LIST_HEAD(&alloc->node);
+
+	spin_lock_irqsave(&hvs->mm_lock, flags);
+	ret = drm_mm_insert_node(&hvs->dlist_mm, &alloc->mm_node,
+				 dlist_count);
+	spin_unlock_irqrestore(&hvs->mm_lock, flags);
+	if (ret) {
+		drm_err(dev, "Failed to allocate DLIST entry. Requested size=%zu. ret=%d. DISPCTRL is %08x\n",
+			dlist_count, ret, HVS_READ(SCALER_DISPCTRL));
+
+		/* This should never happen as stale entries should get released
+		 * as the frame counter interrupt triggers.
+		 * However we've seen this fail for reasons currently unknown.
+		 * Free all stale entries now so we should be able to complete
+		 * this allocation.
+		 */
+		spin_lock_irqsave(&hvs->mm_lock, flags);
+		list_for_each_entry_safe(cur, next, &hvs->stale_dlist_entries, node) {
+			vc4_hvs_free_dlist_entry_locked(hvs, cur);
+		}
+
+		ret = drm_mm_insert_node(&hvs->dlist_mm, &alloc->mm_node,
+					 dlist_count);
+		spin_unlock_irqrestore(&hvs->mm_lock, flags);
+
+		if (ret)
+			return ERR_PTR(ret);
+	}
+
+	alloc->channel = channel;
+
+	return alloc;
+}
+
+static void vc4_hvs_free_dlist_entry_locked(struct vc4_hvs *hvs,
+					    struct vc4_hvs_dlist_allocation *alloc)
+{
+	lockdep_assert_held(&hvs->mm_lock);
+
+	if (!list_empty(&alloc->node))
+		list_del(&alloc->node);
+
+	drm_mm_remove_node(&alloc->mm_node);
+	kfree(alloc);
+}
+
+void vc4_hvs_mark_dlist_entry_stale(struct vc4_hvs *hvs,
+				    struct vc4_hvs_dlist_allocation *alloc)
+{
+	unsigned long flags;
+	u8 frcnt;
+
+	if (!alloc)
+		return;
+
+	if (!drm_mm_node_allocated(&alloc->mm_node))
+		return;
+
+	/*
+	 * Kunit tests run with a mock device and we consider any hardware
+	 * access a test failure. Let's free the dlist allocation right away if
+	 * we're running under kunit, we won't risk a dlist corruption anyway.
+	 *
+	 * Likewise if the allocation was only checked and never programmed, we
+	 * can destroy the allocation immediately.
+	 */
+	if (kunit_get_current_test() || !alloc->dlist_programmed) {
+		spin_lock_irqsave(&hvs->mm_lock, flags);
+		vc4_hvs_free_dlist_entry_locked(hvs, alloc);
+		spin_unlock_irqrestore(&hvs->mm_lock, flags);
+		return;
+	}
+
+	frcnt = vc4_hvs_get_fifo_frame_count(hvs, alloc->channel);
+	alloc->target_frame_count = (frcnt + 1) & ((1 << 6) - 1);
+
+	spin_lock_irqsave(&hvs->mm_lock, flags);
+
+	list_add_tail(&alloc->node, &hvs->stale_dlist_entries);
+
+	HVS_WRITE(SCALER_DISPSTAT, SCALER_DISPSTAT_EOF(alloc->channel));
+	vc4_hvs_irq_enable_eof(hvs, alloc->channel);
+
+	spin_unlock_irqrestore(&hvs->mm_lock, flags);
+}
+
+static void vc4_hvs_schedule_dlist_sweep(struct vc4_hvs *hvs,
+					 unsigned int channel)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hvs->mm_lock, flags);
+
+	if (!list_empty(&hvs->stale_dlist_entries))
+		queue_work(system_unbound_wq, &hvs->free_dlist_work);
+
+	if (list_empty(&hvs->stale_dlist_entries))
+		vc4_hvs_irq_clear_eof(hvs, channel);
+
+	spin_unlock_irqrestore(&hvs->mm_lock, flags);
+}
+
+/*
+ * Frame counts are essentially sequence numbers over 6 bits, and we
+ * thus can use sequence number arithmetic and follow the RFC1982 to
+ * implement proper comparison between them.
+ */
+static bool vc4_hvs_frcnt_lte(u8 cnt1, u8 cnt2)
+{
+	return (s8)((cnt1 << 2) - (cnt2 << 2)) <= 0;
+}
+
+static bool vc4_hvs_check_channel_active(struct vc4_hvs *hvs, unsigned int fifo)
+{
+	struct vc4_dev *vc4 = hvs->vc4;
+	struct drm_device *drm = &vc4->base;
+	bool enabled = false;
+	int idx;
+
+	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
+
+	if (!drm_dev_enter(drm, &idx))
+		return 0;
+
+	if (vc4->gen >= VC4_GEN_6)
+		enabled = HVS_READ(SCALER6_DISPX_CTRL0(fifo)) & SCALER6(DISPX_CTRL0_ENB);
+	else
+		enabled = HVS_READ(SCALER_DISPCTRLX(fifo)) & SCALER_DISPCTRLX_ENABLE;
+
+	drm_dev_exit(idx);
+	return enabled;
+}
+
+/*
+ * Some atomic commits (legacy cursor updates, mostly) will not wait for
+ * the next vblank and will just return once the commit has been pushed
+ * to the hardware.
+ *
+ * On the hardware side, our HVS stores the planes parameters in its
+ * context RAM, and will use part of the RAM to store data during the
+ * frame rendering.
+ *
+ * This interacts badly if we get multiple commits before the next
+ * vblank since we could end up overwriting the DLIST entries used by
+ * previous commits if our dlist allocation reuses that entry. In such a
+ * case, we would overwrite the data currently being used by the
+ * hardware, resulting in a corrupted frame.
+ *
+ * In order to work around this, we'll queue the dlist entries in a list
+ * once the associated CRTC state is destroyed. The HVS only allows us
+ * to know which entry is being active, but not which one are no longer
+ * being used, so in order to avoid freeing entries that are still used
+ * by the hardware we add a guesstimate of the frame count where our
+ * entry will no longer be used, and thus will only free those entries
+ * when we will have reached that frame count.
+ */
+static void vc4_hvs_dlist_free_work(struct work_struct *work)
+{
+	struct vc4_hvs *hvs = container_of(work, struct vc4_hvs, free_dlist_work);
+	struct vc4_hvs_dlist_allocation *cur, *next;
+	unsigned long flags;
+	bool active[3];
+	u8 frcnt[3];
+	int i;
+
+
+	spin_lock_irqsave(&hvs->mm_lock, flags);
+	for (i = 0; i < 3; i++) {
+		frcnt[i] = vc4_hvs_get_fifo_frame_count(hvs, i);
+		active[i] = vc4_hvs_check_channel_active(hvs, i);
+	}
+	list_for_each_entry_safe(cur, next, &hvs->stale_dlist_entries, node) {
+		if (active[cur->channel] &&
+		    !vc4_hvs_frcnt_lte(cur->target_frame_count, frcnt[cur->channel]))
+			continue;
+
+		vc4_hvs_free_dlist_entry_locked(hvs, cur);
+	}
+	spin_unlock_irqrestore(&hvs->mm_lock, flags);
+}
+
 u8 vc4_hvs_get_fifo_frame_count(struct vc4_hvs *hvs, unsigned int fifo)
 {
 	struct vc4_dev *vc4 = hvs->vc4;
@@ -477,16 +906,15 @@
 	u8 field = 0;
 	int idx;
 
-	WARN_ON_ONCE(vc4->gen > VC4_GEN_6_D);
+	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
 
 	if (!drm_dev_enter(drm, &idx))
 		return 0;
 
 	switch (vc4->gen) {
-	case VC4_GEN_6_C:
-	case VC4_GEN_6_D:
-		field = VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_STATUS(fifo)),
-				      SCALER6_DISPX_STATUS_FRCNT);
+	case VC4_GEN_6:
+		field = VC4_GET_FIELD6(HVS_READ(SCALER6_DISPX_STATUS(fifo)),
+				      DISPX_STATUS_FRCNT);
 		break;
 	case VC4_GEN_5:
 		switch (fifo) {
@@ -520,9 +948,6 @@
 			break;
 		}
 		break;
-	default:
-		drm_err(drm, "Unknown VC4 generation: %d", vc4->gen);
-		break;
 	}
 
 	drm_dev_exit(idx);
@@ -535,7 +960,7 @@
 	u32 reg;
 	int ret;
 
-	WARN_ON_ONCE(vc4->gen > VC4_GEN_6_D);
+	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
 
 	switch (vc4->gen) {
 	case VC4_GEN_4:
@@ -592,8 +1017,7 @@
 			return -EPIPE;
 		}
 
-	case VC4_GEN_6_C:
-	case VC4_GEN_6_D:
+	case VC4_GEN_6:
 		switch (output) {
 		case 0:
 			return 0;
@@ -609,10 +1033,9 @@
 		default:
 			return -EPIPE;
 		}
-
-	default:
-		return -EPIPE;
 	}
+
+	return -EPIPE;
 }
 
 static int vc4_hvs_init_channel(struct vc4_hvs *hvs, struct drm_crtc *crtc,
@@ -666,14 +1089,20 @@
 	dispbkgndx &= ~SCALER_DISPBKGND_GAMMA;
 	dispbkgndx &= ~SCALER_DISPBKGND_INTERLACE;
 
+	if (crtc->state->gamma_lut)
+		/* Enable gamma on if required */
+		dispbkgndx |= SCALER_DISPBKGND_GAMMA;
+
 	HVS_WRITE(SCALER_DISPBKGNDX(chan), dispbkgndx |
-		  ((vc4->gen == VC4_GEN_4) ? SCALER_DISPBKGND_GAMMA : 0) |
 		  (interlace ? SCALER_DISPBKGND_INTERLACE : 0));
 
 	/* Reload the LUT, since the SRAMs would have been disabled if
 	 * all CRTCs had SCALER_DISPBKGND_GAMMA unset at once.
 	 */
-	vc4_hvs_lut_load(hvs, vc4_crtc);
+	if (vc4->gen == VC4_GEN_4)
+		vc4_hvs_lut_load(hvs, vc4_crtc);
+	else
+		vc5_hvs_lut_load(hvs, vc4_crtc);
 
 	drm_dev_exit(idx);
 
@@ -691,25 +1120,25 @@
 	u32 disp_ctrl1;
 	int idx;
 
-	WARN_ON_ONCE(vc4->gen < VC4_GEN_6_C);
+	WARN_ON_ONCE(vc4->gen != VC4_GEN_6);
 
 	if (!drm_dev_enter(drm, &idx))
 		return -ENODEV;
 
-	HVS_WRITE(SCALER6_DISPX_CTRL0(chan), SCALER6_DISPX_CTRL0_RESET);
+	HVS_WRITE(SCALER6_DISPX_CTRL0(chan), SCALER6(DISPX_CTRL0_RESET));
 
 	disp_ctrl1 = HVS_READ(SCALER6_DISPX_CTRL1(chan));
-	disp_ctrl1 &= ~SCALER6_DISPX_CTRL1_INTLACE;
+	disp_ctrl1 &= ~SCALER6(DISPX_CTRL1_INTLACE);
 	HVS_WRITE(SCALER6_DISPX_CTRL1(chan),
-		  disp_ctrl1 | (interlace ? SCALER6_DISPX_CTRL1_INTLACE : 0));
+		  disp_ctrl1 | (interlace ? SCALER6(DISPX_CTRL1_INTLACE) : 0));
 
 	HVS_WRITE(SCALER6_DISPX_CTRL0(chan),
-		  SCALER6_DISPX_CTRL0_ENB |
-		  VC4_SET_FIELD(mode->hdisplay - 1,
-				SCALER6_DISPX_CTRL0_FWIDTH) |
-		  (oneshot ? SCALER6_DISPX_CTRL0_ONESHOT : 0) |
-		  VC4_SET_FIELD(mode->vdisplay - 1,
-				SCALER6_DISPX_CTRL0_LINES));
+		  SCALER6(DISPX_CTRL0_ENB) |
+		  VC4_SET_FIELD6(mode->hdisplay - 1,
+				DISPX_CTRL0_FWIDTH) |
+		  (oneshot ? SCALER6(DISPX_CTRL0_ONESHOT) : 0) |
+		  VC4_SET_FIELD6(mode->vdisplay - 1,
+				DISPX_CTRL0_LINES));
 
 	drm_dev_exit(idx);
 
@@ -740,10 +1169,6 @@
 				   SCALER_DISPSTATX_MODE) !=
 		     SCALER_DISPSTATX_MODE_DISABLED);
 
-	WARN_ON_ONCE((HVS_READ(SCALER_DISPSTATX(chan)) &
-		      (SCALER_DISPSTATX_FULL | SCALER_DISPSTATX_EMPTY)) !=
-		     SCALER_DISPSTATX_EMPTY);
-
 out:
 	drm_dev_exit(idx);
 }
@@ -754,23 +1179,23 @@
 	struct drm_device *drm = &vc4->base;
 	int idx;
 
-	WARN_ON_ONCE(vc4->gen < VC4_GEN_6_C);
+	WARN_ON_ONCE(vc4->gen != VC4_GEN_6);
 
 	if (!drm_dev_enter(drm, &idx))
 		return;
 
-	if (!(HVS_READ(SCALER6_DISPX_CTRL0(chan)) & SCALER6_DISPX_CTRL0_ENB))
+	if (!(HVS_READ(SCALER6_DISPX_CTRL0(chan)) & SCALER6(DISPX_CTRL0_ENB)))
 		goto out;
 
 	HVS_WRITE(SCALER6_DISPX_CTRL0(chan),
-		  HVS_READ(SCALER6_DISPX_CTRL0(chan)) | SCALER6_DISPX_CTRL0_RESET);
+		  HVS_READ(SCALER6_DISPX_CTRL0(chan)) | SCALER6(DISPX_CTRL0_RESET));
 
 	HVS_WRITE(SCALER6_DISPX_CTRL0(chan),
-		  HVS_READ(SCALER6_DISPX_CTRL0(chan)) & ~SCALER6_DISPX_CTRL0_ENB);
+		  HVS_READ(SCALER6_DISPX_CTRL0(chan)) & ~SCALER6(DISPX_CTRL0_ENB));
 
-	WARN_ON_ONCE(VC4_GET_FIELD(HVS_READ(SCALER6_DISPX_STATUS(chan)),
-				   SCALER6_DISPX_STATUS_MODE) !=
-		     SCALER6_DISPX_STATUS_MODE_DISABLED);
+	WARN_ON_ONCE(VC4_GET_FIELD6(HVS_READ(SCALER6_DISPX_STATUS(chan)),
+				   DISPX_STATUS_MODE) !=
+		     SCALER6(DISPX_STATUS_MODE_DISABLED));
 
 out:
 	drm_dev_exit(idx);
@@ -780,23 +1205,63 @@
 {
 	struct vc4_dev *vc4 = hvs->vc4;
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		__vc6_hvs_stop_channel(hvs, chan);
 	else
 		__vc4_hvs_stop_channel(hvs, chan);
 }
 
+static int vc4_hvs_gamma_check(struct drm_crtc *crtc,
+			       struct drm_atomic_state *state)
+{
+	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
+	struct drm_connector_state *conn_state;
+	struct drm_connector *connector;
+	struct drm_device *dev = crtc->dev;
+	struct vc4_dev *vc4 = to_vc4_dev(dev);
+
+	if (vc4->gen == VC4_GEN_4)
+		return 0;
+
+	if (!crtc_state->color_mgmt_changed)
+		return 0;
+
+	if (crtc_state->gamma_lut) {
+		unsigned int len = drm_color_lut_size(crtc_state->gamma_lut);
+
+		if (len != crtc->gamma_size) {
+			DRM_DEBUG_KMS("Invalid LUT size; got %u, expected %u\n",
+				      len, crtc->gamma_size);
+			return -EINVAL;
+		}
+	}
+
+	connector = vc4_get_crtc_connector(crtc, crtc_state);
+	if (!connector)
+		return -EINVAL;
+
+	if (!(connector->connector_type == DRM_MODE_CONNECTOR_HDMIA))
+		return 0;
+
+	conn_state = drm_atomic_get_connector_state(state, connector);
+	if (!conn_state)
+		return -EINVAL;
+
+	crtc_state->mode_changed = true;
+	return 0;
+}
+
 int vc4_hvs_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state)
 {
 	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
 	struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);
+	struct vc4_hvs_dlist_allocation *alloc;
 	struct drm_device *dev = crtc->dev;
 	struct vc4_dev *vc4 = to_vc4_dev(dev);
 	struct drm_plane *plane;
-	unsigned long flags;
 	const struct drm_plane_state *plane_state;
 	u32 dlist_count = 0;
-	int ret;
+	u32 lbm_count = 0;
 
 	/* The pixelvalve can only feed one encoder (and encoders are
 	 * 1:1 with connectors.)
@@ -805,6 +1270,8 @@
 		return -EINVAL;
 
 	drm_atomic_crtc_state_for_each_plane_state(plane, plane_state, crtc_state) {
+		const struct vc4_plane_state *vc4_plane_state =
+						to_vc4_plane_state(plane_state);
 		u32 plane_dlist_count = vc4_plane_dlist_size(plane_state);
 
 		drm_dbg_driver(dev, "[CRTC:%d:%s] Found [PLANE:%d:%s] with DLIST size: %u\n",
@@ -813,22 +1280,23 @@
 			       plane_dlist_count);
 
 		dlist_count += plane_dlist_count;
+		lbm_count += vc4_plane_state->lbm_size;
 	}
 
 	dlist_count++; /* Account for SCALER_CTL0_END. */
 
 	drm_dbg_driver(dev, "[CRTC:%d:%s] Allocating DLIST block with size: %u\n",
 		       crtc->base.id, crtc->name, dlist_count);
-	spin_lock_irqsave(&vc4->hvs->mm_lock, flags);
-	ret = drm_mm_insert_node(&vc4->hvs->dlist_mm, &vc4_state->mm,
-				 dlist_count);
-	spin_unlock_irqrestore(&vc4->hvs->mm_lock, flags);
-	if (ret) {
-		drm_err(dev, "Failed to allocate DLIST entry: %d\n", ret);
-		return ret;
-	}
 
-	return 0;
+	alloc = vc4_hvs_alloc_dlist_entry(vc4->hvs, vc4_state->assigned_channel, dlist_count);
+	if (IS_ERR(alloc))
+		return PTR_ERR(alloc);
+
+	vc4_state->mm = alloc;
+
+	/* FIXME: Check total lbm allocation here */
+
+	return vc4_hvs_gamma_check(crtc, state);
 }
 
 static void vc4_hvs_install_dlist(struct drm_crtc *crtc)
@@ -842,13 +1310,16 @@
 	if (!drm_dev_enter(dev, &idx))
 		return;
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	WARN_ON(!vc4_state->mm);
+	vc4_state->mm->dlist_programmed = true;
+
+	if (vc4->gen >= VC4_GEN_6)
 		HVS_WRITE(SCALER6_DISPX_LPTRS(vc4_state->assigned_channel),
-			  VC4_SET_FIELD(vc4_state->mm.start,
-					SCALER6_DISPX_LPTRS_HEADE));
+			  VC4_SET_FIELD6(vc4_state->mm->mm_node.start,
+					DISPX_LPTRS_HEADE));
 	else
 		HVS_WRITE(SCALER_DISPLISTX(vc4_state->assigned_channel),
-			  vc4_state->mm.start);
+			  vc4_state->mm->mm_node.start);
 
 	drm_dev_exit(idx);
 }
@@ -875,8 +1346,10 @@
 		spin_unlock_irqrestore(&dev->event_lock, flags);
 	}
 
+	WARN_ON(!vc4_state->mm);
+
 	spin_lock_irqsave(&vc4_crtc->irq_lock, flags);
-	vc4_crtc->current_dlist = vc4_state->mm.start;
+	vc4_crtc->current_dlist = vc4_state->mm->mm_node.start;
 	spin_unlock_irqrestore(&vc4_crtc->irq_lock, flags);
 }
 
@@ -904,7 +1377,7 @@
 	vc4_hvs_install_dlist(crtc);
 	vc4_hvs_update_dlist(crtc);
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		vc6_hvs_init_channel(vc4->hvs, crtc, mode, oneshot);
 	else
 		vc4_hvs_init_channel(vc4->hvs, crtc, mode, oneshot);
@@ -937,13 +1410,15 @@
 	struct vc4_plane_state *vc4_plane_state;
 	bool debug_dump_regs = false;
 	bool enable_bg_fill = true;
-	u32 __iomem *dlist_start = vc4->hvs->dlist + vc4_state->mm.start;
-	u32 __iomem *dlist_next = dlist_start;
+	u32 __iomem *dlist_start, *dlist_next;
+	unsigned long irqflags;
 	unsigned int zpos = 0;
+	u32 lbm_offset = 0;
+	u32 lbm_size = 0;
 	bool found = false;
 	int idx;
 
-	WARN_ON_ONCE(vc4->gen > VC4_GEN_6_D);
+	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
 
 	if (!drm_dev_enter(dev, &idx)) {
 		vc4_crtc_send_vblank(crtc);
@@ -951,13 +1426,45 @@
 	}
 
 	if (vc4_state->assigned_channel == VC4_HVS_CHANNEL_DISABLED)
-		goto exit;
+		return;
 
 	if (debug_dump_regs) {
 		DRM_INFO("CRTC %d HVS before:\n", drm_crtc_index(crtc));
 		vc4_hvs_dump_state(hvs);
 	}
 
+	drm_atomic_crtc_for_each_plane(plane, crtc) {
+		vc4_plane_state = to_vc4_plane_state(plane->state);
+		lbm_size += vc4_plane_state->lbm_size;
+	}
+
+	if (drm_mm_node_allocated(&vc4_crtc->lbm)) {
+		spin_lock_irqsave(&vc4_crtc->irq_lock, irqflags);
+		drm_mm_remove_node(&vc4_crtc->lbm);
+		spin_unlock_irqrestore(&vc4_crtc->irq_lock, irqflags);
+	}
+
+	if (lbm_size) {
+		int ret;
+
+		spin_lock_irqsave(&vc4_crtc->irq_lock, irqflags);
+		ret = drm_mm_insert_node_generic(&vc4->hvs->lbm_mm,
+						 &vc4_crtc->lbm,
+						 lbm_size, 1,
+						 0, 0);
+		spin_unlock_irqrestore(&vc4_crtc->irq_lock, irqflags);
+
+		if (ret) {
+			pr_err("Failed to allocate LBM ret %d\n", ret);
+			return;
+		}
+	}
+
+	lbm_offset = vc4_crtc->lbm.start;
+
+	dlist_start = vc4->hvs->dlist + vc4_state->mm->mm_node.start;
+	dlist_next = dlist_start;
+
 	/* Copy all the active planes' dlist contents to the hardware dlist. */
 	do {
 		found = false;
@@ -966,6 +1473,8 @@
 			if (plane->state->normalized_zpos != zpos)
 				continue;
 
+			vc4_plane_state = to_vc4_plane_state(plane->state);
+
 			/* Is this the first active plane? */
 			if (dlist_next == dlist_start) {
 				/* We need to enable background fill when a plane
@@ -976,10 +1485,15 @@
 				 * already needs it or all planes on top blend from
 				 * the first or a lower plane.
 				 */
-				vc4_plane_state = to_vc4_plane_state(plane->state);
 				enable_bg_fill = vc4_plane_state->needs_bg_fill;
 			}
 
+			if (vc4_plane_state->lbm_size) {
+				vc4_plane_state->dlist[vc4_plane_state->lbm_offset] =
+								lbm_offset;
+				lbm_offset += vc4_plane_state->lbm_size;
+			}
+
 			dlist_next += vc4_plane_write_dlist(plane, dlist_next);
 
 			found = true;
@@ -991,20 +1505,21 @@
 	writel(SCALER_CTL0_END, dlist_next);
 	dlist_next++;
 
-	WARN_ON_ONCE(dlist_next - dlist_start != vc4_state->mm.size);
+	WARN_ON(!vc4_state->mm);
+	WARN_ON_ONCE(dlist_next - dlist_start != vc4_state->mm->mm_node.size);
 
-	if (vc4->gen >= VC4_GEN_6_C) {
+	if (vc4->gen >= VC4_GEN_6) {
 		/* This sets a black background color fill, as is the case
 		 * with other DRM drivers.
 		 */
 		if (enable_bg_fill)
 			HVS_WRITE(SCALER6_DISPX_CTRL1(channel),
 				  HVS_READ(SCALER6_DISPX_CTRL1(channel)) |
-				  SCALER6_DISPX_CTRL1_BGENB);
+				  SCALER6(DISPX_CTRL1_BGENB));
 		else
 			HVS_WRITE(SCALER6_DISPX_CTRL1(channel),
 				  HVS_READ(SCALER6_DISPX_CTRL1(channel)) &
-				  ~SCALER6_DISPX_CTRL1_BGENB);
+				  ~SCALER6(DISPX_CTRL1_BGENB));
 	} else {
 		/* we can actually run with a lower core clock when background
 		 * fill is enabled on VC4_GEN_5 so leave it enabled always.
@@ -1032,14 +1547,25 @@
 		WARN_ON_ONCE(vc4->gen > VC4_GEN_5);
 
 		if (crtc->state->gamma_lut) {
-			vc4_hvs_update_gamma_lut(hvs, vc4_crtc);
-			dispbkgndx |= SCALER_DISPBKGND_GAMMA;
+			if (vc4->gen == VC4_GEN_4) {
+				vc4_hvs_update_gamma_lut(hvs, vc4_crtc);
+				dispbkgndx |= SCALER_DISPBKGND_GAMMA;
+			} else {
+				vc5_hvs_update_gamma_lut(hvs, vc4_crtc);
+			}
 		} else {
 			/* Unsetting DISPBKGND_GAMMA skips the gamma lut step
 			 * in hardware, which is the same as a linear lut that
 			 * DRM expects us to use in absence of a user lut.
+			 *
+			 * Do NOT change state dynamically for hvs5 as it
+			 * inserts a delay in the pipeline that will cause
+			 * stalls if enabled/disabled whilst running. The other
+			 * should already be disabling/enabling the pipeline
+			 * when gamma changes.
 			 */
-			dispbkgndx &= ~SCALER_DISPBKGND_GAMMA;
+			if (vc4->gen == VC4_GEN_4)
+				dispbkgndx &= ~SCALER_DISPBKGND_GAMMA;
 		}
 		HVS_WRITE(SCALER_DISPBKGNDX(channel), dispbkgndx);
 	}
@@ -1049,7 +1575,6 @@
 		vc4_hvs_dump_state(hvs);
 	}
 
-exit:
 	drm_dev_exit(idx);
 }
 
@@ -1147,6 +1672,11 @@
 
 			irqret = IRQ_HANDLED;
 		}
+
+		if (status & SCALER_DISPSTAT_EOF(channel)) {
+			vc4_hvs_schedule_dlist_sweep(hvs, channel);
+			irqret = IRQ_HANDLED;
+		}
 	}
 
 	/* Clear every per-channel interrupt flag. */
@@ -1157,29 +1687,59 @@
 	return irqret;
 }
 
+static irqreturn_t vc6_hvs_eof_irq_handler(int irq, void *data)
+{
+	struct drm_device *dev = data;
+	struct vc4_dev *vc4 = to_vc4_dev(dev);
+	struct vc4_hvs *hvs = vc4->hvs;
+	unsigned int i;
+
+	WARN_ON(vc4->gen < VC4_GEN_6);
+
+	for (i = 0; i < HVS_NUM_CHANNELS; i++) {
+		if (!hvs->eof_irq[i].enabled)
+			continue;
+
+		if (hvs->eof_irq[i].desc != irq)
+			continue;
+
+		vc4_hvs_schedule_dlist_sweep(hvs, i);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
 int vc4_hvs_debugfs_init(struct drm_minor *minor)
 {
 	struct drm_device *drm = minor->dev;
 	struct vc4_dev *vc4 = to_vc4_dev(drm);
 	struct vc4_hvs *hvs = vc4->hvs;
 
+	if (vc4->firmware_kms)
+		return 0;
+
 	if (!vc4->hvs)
 		return -ENODEV;
 
-	if (vc4->gen == VC4_GEN_4)
+	if (vc4->gen == VC4_GEN_4) {
 		debugfs_create_bool("hvs_load_tracker", S_IRUGO | S_IWUSR,
 				    minor->debugfs_root,
 				    &vc4->load_tracker_enabled);
 
-	if (vc4->gen >= VC4_GEN_6_C) {
+		drm_debugfs_add_file(drm, "hvs_gamma", vc5_hvs_debugfs_gamma,
+				     NULL);
+	}
+
+	if (vc4->gen >= VC4_GEN_6)
 		drm_debugfs_add_file(drm, "hvs_dlists", vc6_hvs_debugfs_dlist, NULL);
-		drm_debugfs_add_file(drm, "hvs_upm", vc6_hvs_debugfs_upm_allocs, NULL);
-	} else {
+	else
 		drm_debugfs_add_file(drm, "hvs_dlists", vc4_hvs_debugfs_dlist, NULL);
-	}
 
 	drm_debugfs_add_file(drm, "hvs_underrun", vc4_hvs_debugfs_underrun, NULL);
 
+	drm_debugfs_add_file(drm, "hvs_dlist_allocs", vc4_hvs_debugfs_dlist_allocs, NULL);
+
 	vc4_debugfs_add_regset32(drm, "hvs_regs", &hvs->regset);
 
 	return 0;
@@ -1194,7 +1754,6 @@
 	unsigned int dlist_start;
 	size_t dlist_size;
 	size_t lbm_size;
-	unsigned int i;
 
 	hvs = drmm_kzalloc(drm, sizeof(*hvs), GFP_KERNEL);
 	if (!hvs)
@@ -1206,6 +1765,9 @@
 
 	spin_lock_init(&hvs->mm_lock);
 
+	INIT_LIST_HEAD(&hvs->stale_dlist_entries);
+	INIT_WORK(&hvs->free_dlist_work, vc4_hvs_dlist_free_work);
+
 	switch (vc4->gen) {
 	case VC4_GEN_4:
 	case VC4_GEN_5:
@@ -1219,8 +1781,7 @@
 		dlist_size = (SCALER_DLIST_SIZE >> 2) - HVS_BOOTLOADER_DLIST_END;
 		break;
 
-	case VC4_GEN_6_C:
-	case VC4_GEN_6_D:
+	case VC4_GEN_6:
 		dlist_start = HVS_BOOTLOADER_DLIST_END;
 
 		/*
@@ -1228,15 +1789,10 @@
 		 * access a register. Use a plausible size then.
 		 */
 		if (!kunit_get_current_test())
-			dlist_size = HVS_READ(SCALER6_CXM_SIZE);
+			dlist_size = HVS_READ(SCALER6(CXM_SIZE));
 		else
 			dlist_size = 4096;
 
-		for (i = 0; i < VC4_NUM_UPM_HANDLES; i++) {
-			refcount_set(&hvs->upm_refcounts[i].refcount, 0);
-			hvs->upm_refcounts[i].hvs = hvs;
-		}
-
 		break;
 
 	default:
@@ -1265,8 +1821,7 @@
 		lbm_size = 60 * SZ_1K;
 		break;
 
-	case VC4_GEN_6_C:
-	case VC4_GEN_6_D:
+	case VC4_GEN_6:
 		/*
 		 * If we are running a test, it means that we can't
 		 * access a register. Use a plausible size then.
@@ -1281,7 +1836,7 @@
 
 	drm_mm_init(&hvs->lbm_mm, 0, lbm_size);
 
-	if (vc4->gen >= VC4_GEN_6_C) {
+	if (vc4->gen >= VC4_GEN_6) {
 		ida_init(&hvs->upm_handles);
 
 		/*
@@ -1385,6 +1940,17 @@
 	dispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_PANIC1);
 	dispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_PANIC2);
 
+	/* Set AXI panic mode.
+	 * VC4 panics when < 2 lines in FIFO.
+	 * VC5 panics when less than 1 line in the FIFO.
+	 */
+	dispctrl &= ~(SCALER_DISPCTRL_PANIC0_MASK |
+		      SCALER_DISPCTRL_PANIC1_MASK |
+		      SCALER_DISPCTRL_PANIC2_MASK);
+	dispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_PANIC0);
+	dispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_PANIC1);
+	dispctrl |= VC4_SET_FIELD(2, SCALER_DISPCTRL_PANIC2);
+
 	HVS_WRITE(SCALER_DISPCTRL, dispctrl);
 
 	return 0;
@@ -1479,16 +2045,29 @@
 	const struct vc6_csc_coeff_entry *coeffs;
 	unsigned int i;
 
-	HVS_WRITE(SCALER6_CONTROL,
+	HVS_WRITE6(CONTROL,
 		  SCALER6_CONTROL_HVS_EN |
-		  VC4_SET_FIELD(8, SCALER6_CONTROL_PF_LINES) |
+		  VC4_SET_FIELD(8, SCALER6_CONTROL_PF_LINES)|
 		  VC4_SET_FIELD(15, SCALER6_CONTROL_MAX_REQS));
 
 	/* Set HVS arbiter priority to max */
 	HVS_WRITE(SCALER6(PRI_MAP0), 0xffffffff);
 	HVS_WRITE(SCALER6(PRI_MAP1), 0xffffffff);
 
-	if (hvs->vc4->gen == VC4_GEN_6_C) {
+	if (hvs->vc4->step_d0) {
+		for (i = 0; i < 8; i++) {
+			HVS_WRITE(SCALER_PI_CMP_CSC_RED0(i), 0x1f002566);
+			HVS_WRITE(SCALER_PI_CMP_CSC_RED1(i), 0x3994);
+			HVS_WRITE(SCALER_PI_CMP_CSC_RED_CLAMP(i), 0xfff00000);
+			HVS_WRITE(SCALER_PI_CMP_CSC_CFG(i), 0x1);
+			HVS_WRITE(SCALER_PI_CMP_CSC_GREEN0(i), 0x18002566);
+			HVS_WRITE(SCALER_PI_CMP_CSC_GREEN1(i), 0xf927eee2);
+			HVS_WRITE(SCALER_PI_CMP_CSC_GREEN_CLAMP(i), 0xfff00000);
+			HVS_WRITE(SCALER_PI_CMP_CSC_BLUE0(i), 0x18002566);
+			HVS_WRITE(SCALER_PI_CMP_CSC_BLUE1(i), 0x43d80000);
+			HVS_WRITE(SCALER_PI_CMP_CSC_BLUE_CLAMP(i), 0xfff00000);
+		}
+	} else {
 		for (i = 0; i < 6; i++) {
 			coeffs = &csc_coeffs[i / 3][i % 3];
 
@@ -1512,19 +2091,6 @@
 
 			HVS_WRITE(CFC1_N_NL_CSC_CTRL(i), BIT(15));
 		}
-	} else {
-		for (i = 0; i < 8; i++) {
-			HVS_WRITE(SCALER_PI_CMP_CSC_RED0(i), 0x1f002566);
-			HVS_WRITE(SCALER_PI_CMP_CSC_RED1(i), 0x3994);
-			HVS_WRITE(SCALER_PI_CMP_CSC_RED_CLAMP(i), 0xfff00000);
-			HVS_WRITE(SCALER_PI_CMP_CSC_CFG(i), 0x1);
-			HVS_WRITE(SCALER_PI_CMP_CSC_GREEN0(i), 0x18002566);
-			HVS_WRITE(SCALER_PI_CMP_CSC_GREEN1(i), 0xf927eee2);
-			HVS_WRITE(SCALER_PI_CMP_CSC_GREEN_CLAMP(i), 0xfff00000);
-			HVS_WRITE(SCALER_PI_CMP_CSC_BLUE0(i), 0x18002566);
-			HVS_WRITE(SCALER_PI_CMP_CSC_BLUE1(i), 0x43d80000);
-			HVS_WRITE(SCALER_PI_CMP_CSC_BLUE_CLAMP(i), 0xfff00000);
-		}
 	}
 
 	return 0;
@@ -1594,28 +2160,27 @@
 		HVS_WRITE(SCALER_DISPBASE0, reg);
 		break;
 
-	case VC4_GEN_6_C:
-	case VC4_GEN_6_D:
+	case VC4_GEN_6:
 		#define VC6_COB_LINE_WIDTH	3840
 		#define VC6_COB_NUM_LINES	4
-		base = 0;
+		reg = 0;
 		top = 3840;
 
-		HVS_WRITE(SCALER6_DISPX_COB(2),
+		HVS_WRITE(SCALER6(DISP2_COB),
 			  VC4_SET_FIELD(top, SCALER6_DISPX_COB_TOP) |
 			  VC4_SET_FIELD(base, SCALER6_DISPX_COB_BASE));
 
 		base = top + 16;
 		top += VC6_COB_LINE_WIDTH * VC6_COB_NUM_LINES;
 
-		HVS_WRITE(SCALER6_DISPX_COB(1),
+		HVS_WRITE(SCALER6(DISP1_COB),
 			  VC4_SET_FIELD(top, SCALER6_DISPX_COB_TOP) |
 			  VC4_SET_FIELD(base, SCALER6_DISPX_COB_BASE));
 
 		base = top + 16;
 		top += VC6_COB_LINE_WIDTH * VC6_COB_NUM_LINES;
 
-		HVS_WRITE(SCALER6_DISPX_COB(0),
+		HVS_WRITE(SCALER6(DISP0_COB),
 			  VC4_SET_FIELD(top, SCALER6_DISPX_COB_TOP) |
 			  VC4_SET_FIELD(base, SCALER6_DISPX_COB_BASE));
 		break;
@@ -1646,16 +2211,12 @@
 
 	hvs->regset.base = hvs->regs;
 
-	if (vc4->gen == VC4_GEN_6_C) {
+	if (vc4->gen >= VC4_GEN_6 && vc4->step_d0) {
+		hvs->regset.regs = vc6_hvs_regs_d0;
+		hvs->regset.nregs = ARRAY_SIZE(vc6_hvs_regs_d0);
+	} else if (vc4->gen >= VC4_GEN_6) {
 		hvs->regset.regs = vc6_hvs_regs;
 		hvs->regset.nregs = ARRAY_SIZE(vc6_hvs_regs);
-
-		if (VC4_GET_FIELD(HVS_READ(SCALER6_VERSION), SCALER6_VERSION) ==
-						SCALER6_VERSION_D0) {
-			vc4->gen = VC4_GEN_6_D;
-			hvs->regset.regs = vc6_d_hvs_regs;
-			hvs->regset.nregs = ARRAY_SIZE(vc6_d_hvs_regs);
-		}
 	} else {
 		hvs->regset.regs = vc4_hvs_regs;
 		hvs->regset.nregs = ARRAY_SIZE(vc4_hvs_regs);
@@ -1676,14 +2237,14 @@
 			return -EPROBE_DEFER;
 
 		hvs->core_clk = devm_clk_get(&pdev->dev,
-					     (vc4->gen >= VC4_GEN_6_C) ? "core" : NULL);
+					     (vc4->gen >= VC4_GEN_6) ? "core" : NULL);
 		if (IS_ERR(hvs->core_clk)) {
 			dev_err(&pdev->dev, "Couldn't get core clock\n");
 			return PTR_ERR(hvs->core_clk);
 		}
 
 		hvs->disp_clk = devm_clk_get(&pdev->dev,
-					     (vc4->gen >= VC4_GEN_6_C) ? "disp" : NULL);
+					     (vc4->gen >= VC4_GEN_6) ? "disp" : NULL);
 		if (IS_ERR(hvs->disp_clk)) {
 			dev_err(&pdev->dev, "Couldn't get disp clock\n");
 			return PTR_ERR(hvs->disp_clk);
@@ -1713,32 +2274,65 @@
 		}
 	}
 
+	if (vc4->gen >= VC4_GEN_6) {
+		unsigned int i;
+
+		for (i = 0; i < HVS_NUM_CHANNELS; i++) {
+			char irq_name[16];
+			int irq;
+
+			snprintf(irq_name, sizeof(irq_name), "ch%u-eof", i);
+
+			irq = platform_get_irq_byname(pdev, irq_name);
+			if (irq < 0) {
+				dev_err(&pdev->dev,
+					"Couldn't get %s interrupt: %d\n",
+					irq_name, irq);
+				return irq;
+			}
+
+			ret = devm_request_irq(&pdev->dev,
+					       irq,
+					       vc6_hvs_eof_irq_handler,
+					       IRQF_NO_AUTOEN,
+					       dev_name(&pdev->dev),
+					       drm);
+
+			hvs->eof_irq[i].desc = irq;
+		}
+	}
+
 	if (vc4->gen >= VC4_GEN_5)
 		hvs->dlist = hvs->regs + SCALER5_DLIST_START;
 	else
 		hvs->dlist = hvs->regs + SCALER_DLIST_START;
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		ret = vc6_hvs_hw_init(hvs);
 	else
 		ret = vc4_hvs_hw_init(hvs);
 	if (ret)
 		return ret;
 
-	/* Upload filter kernels.  We only have the one for now, so we
-	 * keep it around for the lifetime of the driver.
+	/* Upload filter kernels.  We only have the two for now, so we
+	 * keep them around for the lifetime of the driver.
 	 */
 	ret = vc4_hvs_upload_linear_kernel(hvs,
 					   &hvs->mitchell_netravali_filter,
 					   mitchell_netravali_1_3_1_3_kernel);
 	if (ret)
 		return ret;
+	ret = vc4_hvs_upload_linear_kernel(hvs,
+					   &hvs->nearest_neighbour_filter,
+					   nearest_neighbour_kernel);
+	if (ret)
+		return ret;
 
 	ret = vc4_hvs_cob_init(hvs);
 	if (ret)
 		return ret;
 
-	if (vc4->gen < VC4_GEN_6_C) {
+	if (vc4->gen < VC4_GEN_6) {
 		ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
 				       vc4_hvs_irq_handler, 0, "vc4 hvs", drm);
 		if (ret)
@@ -1758,6 +2352,8 @@
 
 	if (drm_mm_node_allocated(&vc4->hvs->mitchell_netravali_filter))
 		drm_mm_remove_node(&vc4->hvs->mitchell_netravali_filter);
+	if (drm_mm_node_allocated(&vc4->hvs->nearest_neighbour_filter))
+		drm_mm_remove_node(&vc4->hvs->nearest_neighbour_filter);
 
 	drm_mm_for_each_node_safe(node, next, &vc4->hvs->dlist_mm)
 		drm_mm_remove_node(node);
@@ -1792,6 +2388,7 @@
 static const struct of_device_id vc4_hvs_dt_match[] = {
 	{ .compatible = "brcm,bcm2711-hvs" },
 	{ .compatible = "brcm,bcm2712-hvs" },
+	{ .compatible = "brcm,bcm2712d0-hvs" },
 	{ .compatible = "brcm,bcm2835-hvs" },
 	{}
 };
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_kms.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_kms.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_kms.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_kms.c	2025-06-16 17:40:50.791684722 +0200
@@ -138,6 +138,9 @@
 	struct vc4_ctm_state *ctm_state = to_vc4_ctm_state(vc4->ctm_manager.state);
 	struct drm_color_ctm *ctm = ctm_state->ctm;
 
+	if (vc4->firmware_kms)
+		return;
+
 	WARN_ON_ONCE(vc4->gen > VC4_GEN_5);
 
 	if (ctm_state->fifo) {
@@ -334,7 +337,7 @@
 	struct drm_crtc *crtc;
 	unsigned int i;
 
-	WARN_ON_ONCE(vc4->gen != VC4_GEN_6_C && vc4->gen != VC4_GEN_6_D);
+	WARN_ON_ONCE(vc4->gen != VC4_GEN_6);
 
 	for_each_new_crtc_in_state(state, crtc, crtc_state, i) {
 		struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc_state);
@@ -361,9 +364,6 @@
 			break;
 
 		default:
-			drm_err(&vc4->base, "Unhandled encoder type for PV muxing %d",
-				vc4_encoder->type);
-			mux = 0;
 			break;
 		}
 
@@ -391,7 +391,7 @@
 	if (WARN_ON(IS_ERR(new_hvs_state)))
 		return;
 
-	if (vc4->gen < VC4_GEN_6_C) {
+	if (0 && vc4->gen < VC4_GEN_6) {
 		struct drm_crtc_state *new_crtc_state;
 		struct drm_crtc *crtc;
 		int i;
@@ -399,6 +399,9 @@
 		for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
 			struct vc4_crtc_state *vc4_crtc_state;
 
+			if (vc4->firmware_kms)
+				continue;
+
 			if (!new_crtc_state->commit)
 				continue;
 
@@ -426,7 +429,7 @@
 		old_hvs_state->fifo_state[channel].pending_commit = NULL;
 	}
 
-	if (vc4->gen == VC4_GEN_5) {
+	if (vc4->gen == VC4_GEN_5 && !vc4->firmware_kms) {
 		unsigned long state_rate = max(old_hvs_state->core_clock_rate,
 					       new_hvs_state->core_clock_rate);
 		unsigned long core_rate = clamp_t(unsigned long, state_rate,
@@ -447,23 +450,24 @@
 	if (vc4->gen <= VC4_GEN_5)
 		vc4_ctm_commit(vc4, state);
 
-	switch (vc4->gen) {
-	case VC4_GEN_4:
-		vc4_hvs_pv_muxing_commit(vc4, state);
-		break;
+	if (!vc4->firmware_kms) {
+		switch (vc4->gen) {
+		case VC4_GEN_4:
+			vc4_hvs_pv_muxing_commit(vc4, state);
+			break;
 
-	case VC4_GEN_5:
-		vc5_hvs_pv_muxing_commit(vc4, state);
-		break;
+		case VC4_GEN_5:
+			vc5_hvs_pv_muxing_commit(vc4, state);
+			break;
 
-	case VC4_GEN_6_C:
-	case VC4_GEN_6_D:
-		vc6_hvs_pv_muxing_commit(vc4, state);
-		break;
+		case VC4_GEN_6:
+			vc6_hvs_pv_muxing_commit(vc4, state);
+			break;
 
-	default:
-		drm_err(dev, "Unknown VC4 generation: %d", vc4->gen);
-		break;
+		default:
+			drm_err(dev, "Unknown VC4 generation: %d", vc4->gen);
+			break;
+		}
 	}
 
 	drm_atomic_helper_commit_planes(dev, state,
@@ -479,7 +483,7 @@
 
 	drm_atomic_helper_cleanup_planes(dev, state);
 
-	if (vc4->gen == VC4_GEN_5) {
+	if (vc4->gen == VC4_GEN_5 && !vc4->firmware_kms) {
 		unsigned long core_rate = min_t(unsigned long,
 						hvs->max_core_rate,
 						new_hvs_state->core_clock_rate);
@@ -500,11 +504,21 @@
 
 static int vc4_atomic_commit_setup(struct drm_atomic_state *state)
 {
+	struct drm_device *dev = state->dev;
+	struct vc4_dev *vc4 = to_vc4_dev(dev);
 	struct drm_crtc_state *crtc_state;
 	struct vc4_hvs_state *hvs_state;
 	struct drm_crtc *crtc;
 	unsigned int i;
 
+	/* We know for sure we don't want an async update here. Set
+	 * state->legacy_cursor_update to false to prevent
+	 * drm_atomic_helper_setup_commit() from auto-completing
+	 * commit->flip_done.
+	 */
+	if (!vc4->firmware_kms)
+		state->legacy_cursor_update = false;
+
 	hvs_state = vc4_hvs_get_new_global_state(state);
 	if (WARN_ON(IS_ERR(hvs_state)))
 		return PTR_ERR(hvs_state);
@@ -873,6 +887,7 @@
 static int vc4_pv_muxing_atomic_check(struct drm_device *dev,
 				      struct drm_atomic_state *state)
 {
+	struct vc4_dev *vc4 = to_vc4_dev(state->dev);
 	struct vc4_hvs_state *hvs_new_state;
 	struct drm_crtc **sorted_crtcs;
 	struct drm_crtc *crtc;
@@ -880,6 +895,9 @@
 	unsigned int i;
 	int ret;
 
+	if (vc4->firmware_kms)
+		return 0;
+
 	hvs_new_state = vc4_hvs_get_global_state(state);
 	if (IS_ERR(hvs_new_state))
 		return PTR_ERR(hvs_new_state);
@@ -1130,7 +1148,7 @@
 		return ret;
 	}
 
-	if (vc4->gen >= VC4_GEN_6_C) {
+	if (vc4->gen >= VC4_GEN_6) {
 		dev->mode_config.max_width = 8192;
 		dev->mode_config.max_height = 8192;
 	} else if (vc4->gen >= VC4_GEN_5) {
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_perfmon.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_perfmon.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_perfmon.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_perfmon.c	2025-06-16 17:40:50.791684722 +0200
@@ -241,7 +241,11 @@
 		return -ENODEV;
 	}
 
-	perfmon = vc4_perfmon_find(vc4file, req->id);
+	mutex_lock(&vc4file->perfmon.lock);
+	perfmon = idr_find(&vc4file->perfmon.idr, req->id);
+	vc4_perfmon_get(perfmon);
+	mutex_unlock(&vc4file->perfmon.lock);
+
 	if (!perfmon)
 		return -EINVAL;
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_plane.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_plane.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_plane.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_plane.c	2025-06-16 17:40:50.791684722 +0200
@@ -276,10 +276,8 @@
 	return state->fb && !WARN_ON(!state->crtc);
 }
 
-static struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane)
+struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane)
 {
-	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
-	struct vc4_hvs *hvs = vc4->hvs;
 	struct vc4_plane_state *vc4_state;
 	unsigned int i;
 
@@ -290,12 +288,10 @@
 	if (!vc4_state)
 		return NULL;
 
-	memset(&vc4_state->lbm, 0, sizeof(vc4_state->lbm));
+	memset(&vc4_state->upm, 0, sizeof(vc4_state->upm));
 
-	for (i = 0; i < DRM_FORMAT_MAX_PLANES; i++) {
-		if (vc4_state->upm_handle[i])
-			refcount_inc(&hvs->upm_refcounts[vc4_state->upm_handle[i]].refcount);
-	}
+	for (i = 0; i < DRM_FORMAT_MAX_PLANES; i++)
+		vc4_state->upm_handle[i] = 0;
 
 	vc4_state->dlist_initialized = 0;
 
@@ -315,47 +311,26 @@
 	return &vc4_state->base;
 }
 
-static void vc4_plane_release_upm_ida(struct vc4_hvs *hvs, unsigned int upm_handle)
-{
-	struct vc4_upm_refcounts *refcount = &hvs->upm_refcounts[upm_handle];
-	unsigned long irqflags;
-
-	spin_lock_irqsave(&hvs->mm_lock, irqflags);
-	drm_mm_remove_node(&refcount->upm);
-	spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
-	refcount->upm.start = 0;
-	refcount->upm.size = 0;
-	refcount->size = 0;
-
-	ida_free(&hvs->upm_handles, upm_handle);
-}
-
-static void vc4_plane_destroy_state(struct drm_plane *plane,
-				    struct drm_plane_state *state)
+void vc4_plane_destroy_state(struct drm_plane *plane,
+			     struct drm_plane_state *state)
 {
 	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
 	struct vc4_hvs *hvs = vc4->hvs;
 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
 	unsigned int i;
 
-	if (drm_mm_node_allocated(&vc4_state->lbm)) {
-		unsigned long irqflags;
-
-		spin_lock_irqsave(&hvs->mm_lock, irqflags);
-		drm_mm_remove_node(&vc4_state->lbm);
-		spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
-	}
-
 	for (i = 0; i < DRM_FORMAT_MAX_PLANES; i++) {
-		struct vc4_upm_refcounts *refcount;
+		unsigned long irqflags;
 
-		if (!vc4_state->upm_handle[i])
+		if (!drm_mm_node_allocated(&vc4_state->upm[i]))
 			continue;
 
-		refcount = &hvs->upm_refcounts[vc4_state->upm_handle[i]];
+		spin_lock_irqsave(&hvs->mm_lock, irqflags);
+		drm_mm_remove_node(&vc4_state->upm[i]);
+		spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
 
-		if (refcount_dec_and_test(&refcount->refcount))
-			vc4_plane_release_upm_ida(hvs, vc4_state->upm_handle[i]);
+		if (vc4_state->upm_handle[i] > 0)
+			ida_free(&hvs->upm_handles, vc4_state->upm_handle[i]);
 	}
 
 	kfree(vc4_state->dlist);
@@ -364,14 +339,11 @@
 }
 
 /* Called during init to allocate the plane's atomic state. */
-static void vc4_plane_reset(struct drm_plane *plane)
+void vc4_plane_reset(struct drm_plane *plane)
 {
 	struct vc4_plane_state *vc4_state;
 
-	if (plane->state)
-		__drm_atomic_helper_plane_destroy_state(plane->state);
-
-	kfree(plane->state);
+	WARN_ON(plane->state);
 
 	vc4_state = kzalloc(sizeof(*vc4_state), GFP_KERNEL);
 	if (!vc4_state)
@@ -519,6 +491,11 @@
 	vc4_state->crtc_w = state->dst.x2 - state->dst.x1;
 	vc4_state->crtc_h = state->dst.y2 - state->dst.y1;
 
+	if (!vc4_state->crtc_w)
+		vc4_state->crtc_w = state->crtc->mode.hdisplay;
+	if (!vc4_state->crtc_h)
+		vc4_state->crtc_h = state->crtc->mode.vdisplay;
+
 	ret = vc4_plane_margins_adj(state);
 	if (ret)
 		return ret;
@@ -572,7 +549,7 @@
 	struct vc4_dev *vc4 = to_vc4_dev(vc4_state->base.plane->dev);
 	u32 scale, recip;
 
-	WARN_ON_ONCE(vc4->gen > VC4_GEN_6_D);
+	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
 
 	scale = src / dst;
 
@@ -597,46 +574,35 @@
 #define PHASE_BITS 6
 
 static void vc4_write_ppf(struct vc4_plane_state *vc4_state, u32 src, u32 dst,
-			  u32 xy, int channel)
+			  u32 xy, int channel, int chroma_offset,
+			  bool no_interpolate)
 {
 	struct vc4_dev *vc4 = to_vc4_dev(vc4_state->base.plane->dev);
 	u32 scale = src / dst;
 	s32 offset, offset2;
 	s32 phase;
 
-	WARN_ON_ONCE(vc4->gen > VC4_GEN_6_D);
+	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
 
-	/*
-	 * Start the phase at 1/2 pixel from the 1st pixel at src_x.
-	 * 1/4 pixel for YUV.
-	 */
+	/* Start the phase at 1/2 pixel from the 1st pixel at src_x.
+	   1/4 pixel for YUV, plus the offset for chroma siting */
 	if (channel) {
-		/*
-		 * The phase is relative to scale_src->x, so shift it for
-		 * display list's x value
-		 */
+		/* the phase is relative to scale_src->x, so shift it for display list's x value */
 		offset = (xy & 0x1ffff) >> (16 - PHASE_BITS) >> 1;
+		offset -= chroma_offset >> (17 - PHASE_BITS);
 		offset += -(1 << PHASE_BITS >> 2);
 	} else {
-		/*
-		 * The phase is relative to scale_src->x, so shift it for
-		 * display list's x value
-		 */
+		/* the phase is relative to scale_src->x, so shift it for display list's x value */
 		offset = (xy & 0xffff) >> (16 - PHASE_BITS);
 		offset += -(1 << PHASE_BITS >> 1);
 
-		/*
-		 * This is a kludge to make sure the scaling factors are
-		 * consistent with YUV's luma scaling. We lose 1-bit precision
-		 * because of this.
-		 */
+		/* This is a kludge to make sure the scaling factors are consitent with YUV's luma scaling.
+		   we lose 1bit precision because of this. */
 		scale &= ~1;
 	}
 
-	/*
-	 * There may be a also small error introduced by precision of scale.
-	 * Add half of that as a compromise
-	 */
+	/* There may be a also small error introduced by precision of scale.
+	   Add half of that as a compromise */
 	offset2 = src - dst * scale;
 	offset2 >>= 16 - PHASE_BITS;
 	phase = offset + (offset2 >> 1);
@@ -648,6 +614,7 @@
 	phase &= SCALER_PPF_IPHASE_MASK;
 
 	vc4_dlist_write(vc4_state,
+			(no_interpolate ? SCALER_PPF_NOINTERP : 0) |
 			SCALER_PPF_AGC |
 			VC4_SET_FIELD(scale, SCALER_PPF_SCALE) |
 			/*
@@ -807,7 +774,7 @@
 	    vc4_state->y_scaling[1] == VC4_SCALING_NONE)
 		return 0;
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		return __vc6_lbm_size(state);
 	else
 		return __vc4_lbm_size(state);
@@ -837,31 +804,35 @@
 	struct vc4_dev *vc4 = to_vc4_dev(state->plane->dev);
 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
 
-	WARN_ON_ONCE(vc4->gen > VC4_GEN_6_D);
+	WARN_ON_ONCE(vc4->gen > VC4_GEN_6);
 
 	/* Ch0 H-PPF Word 0: Scaling Parameters */
 	if (vc4_state->x_scaling[channel] == VC4_SCALING_PPF) {
-		vc4_write_ppf(vc4_state, vc4_state->src_w[channel],
-			      vc4_state->crtc_w, vc4_state->src_x, channel);
+		vc4_write_ppf(vc4_state,
+			      vc4_state->src_w[channel], vc4_state->crtc_w, vc4_state->src_x,
+			      channel, state->chroma_siting_h,
+			      state->scaling_filter == DRM_SCALING_FILTER_NEAREST_NEIGHBOR);
 	}
 
 	/* Ch0 V-PPF Words 0-1: Scaling Parameters, Context */
 	if (vc4_state->y_scaling[channel] == VC4_SCALING_PPF) {
-		vc4_write_ppf(vc4_state, vc4_state->src_h[channel],
-			      vc4_state->crtc_h, vc4_state->src_y, channel);
+		vc4_write_ppf(vc4_state,
+			      vc4_state->src_h[channel], vc4_state->crtc_h, vc4_state->src_y,
+			      channel, state->chroma_siting_v,
+			      state->scaling_filter == DRM_SCALING_FILTER_NEAREST_NEIGHBOR);
 		vc4_dlist_write(vc4_state, 0xc0c0c0c0);
 	}
 
 	/* Ch0 H-TPZ Words 0-1: Scaling Parameters, Recip */
 	if (vc4_state->x_scaling[channel] == VC4_SCALING_TPZ) {
-		vc4_write_tpz(vc4_state, vc4_state->src_w[channel],
-			      vc4_state->crtc_w);
+		vc4_write_tpz(vc4_state,
+			      vc4_state->src_w[channel], vc4_state->crtc_w);
 	}
 
 	/* Ch0 V-TPZ Words 0-2: Scaling Parameters, Recip, Context */
 	if (vc4_state->y_scaling[channel] == VC4_SCALING_TPZ) {
-		vc4_write_tpz(vc4_state, vc4_state->src_h[channel],
-			      vc4_state->crtc_h);
+		vc4_write_tpz(vc4_state,
+			      vc4_state->src_h[channel], vc4_state->crtc_h);
 		vc4_dlist_write(vc4_state, 0xc0c0c0c0);
 	}
 }
@@ -928,12 +899,13 @@
 	struct vc4_dev *vc4 = to_vc4_dev(drm);
 	struct drm_plane *plane = state->plane;
 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
-	unsigned long irqflags;
 	u32 lbm_size;
 
 	lbm_size = vc4_lbm_size(state);
-	if (!lbm_size)
+	if (!lbm_size) {
+		vc4_state->lbm_size = 0;
 		return 0;
+	}
 
 	/*
 	 * NOTE: BCM2712 doesn't need to be aligned, since the size
@@ -950,28 +922,10 @@
 	if (WARN_ON(!vc4_state->lbm_offset))
 		return -EINVAL;
 
-	/* Allocate the LBM memory that the HVS will use for temporary
-	 * storage due to our scaling/format conversion.
+	/* FIXME: Add loop here that ensures that the total LBM assigned in this
+	 *  state is less than the total lbm size
 	 */
-	if (!drm_mm_node_allocated(&vc4_state->lbm)) {
-		int ret;
-
-		spin_lock_irqsave(&vc4->hvs->mm_lock, irqflags);
-		ret = drm_mm_insert_node_generic(&vc4->hvs->lbm_mm,
-						 &vc4_state->lbm,
-						 lbm_size, 1,
-						 0, 0);
-		spin_unlock_irqrestore(&vc4->hvs->mm_lock, irqflags);
-
-		if (ret) {
-			drm_err(drm, "Failed to allocate LBM entry: %d\n", ret);
-			return ret;
-		}
-	} else {
-		WARN_ON_ONCE(lbm_size != vc4_state->lbm.size);
-	}
-
-	vc4_state->dlist[vc4_state->lbm_offset] = vc4_state->lbm.start;
+	vc4_state->lbm_size = lbm_size;
 
 	return 0;
 }
@@ -986,65 +940,37 @@
 	unsigned int i;
 	int ret;
 
-	WARN_ON_ONCE(vc4->gen < VC4_GEN_6_C);
+	WARN_ON_ONCE(vc4->gen < VC4_GEN_6);
 
 	vc4_state->upm_buffer_lines = SCALER6_PTR0_UPM_BUFF_SIZE_2_LINES;
 
 	for (i = 0; i < info->num_planes; i++) {
-		struct vc4_upm_refcounts *refcount;
-		int upm_handle;
 		unsigned long irqflags;
 		size_t upm_size;
 
 		upm_size = vc6_upm_size(state, i);
 		if (!upm_size)
 			return -EINVAL;
-		upm_handle = vc4_state->upm_handle[i];
 
-		if (upm_handle &&
-		    hvs->upm_refcounts[upm_handle].size == upm_size) {
-			/* Allocation is the same size as the previous user of
-			 * the plane. Keep the allocation.
-			 */
-			vc4_state->upm_handle[i] = upm_handle;
-		} else {
-			if (upm_handle &&
-			    refcount_dec_and_test(&hvs->upm_refcounts[upm_handle].refcount)) {
-				vc4_plane_release_upm_ida(hvs, upm_handle);
-				vc4_state->upm_handle[i] = 0;
-			}
-
-			upm_handle = ida_alloc_range(&hvs->upm_handles, 1,
-						     VC4_NUM_UPM_HANDLES,
-						     GFP_KERNEL);
-			if (upm_handle < 0) {
-				drm_dbg(drm, "Out of upm_handles\n");
-				return upm_handle;
-			}
-			vc4_state->upm_handle[i] = upm_handle;
+		spin_lock_irqsave(&hvs->mm_lock, irqflags);
+		ret = drm_mm_insert_node_generic(&hvs->upm_mm,
+						 &vc4_state->upm[i],
+						 upm_size, HVS_UBM_WORD_SIZE,
+						 0, 0);
+		spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
+		if (ret) {
+			drm_err(drm, "Failed to allocate UPM entry: %d\n", ret);
+			return ret;
+		}
 
-			refcount = &hvs->upm_refcounts[upm_handle];
-			refcount_set(&refcount->refcount, 1);
-			refcount->size = upm_size;
+		ret = ida_alloc_range(&hvs->upm_handles, 1, 32, GFP_KERNEL);
+		if (ret < 0)
+			return ret;
 
-			spin_lock_irqsave(&hvs->mm_lock, irqflags);
-			ret = drm_mm_insert_node_generic(&hvs->upm_mm,
-							 &refcount->upm,
-							 upm_size, HVS_UBM_WORD_SIZE,
-							 0, 0);
-			spin_unlock_irqrestore(&hvs->mm_lock, irqflags);
-			if (ret) {
-				drm_err(drm, "Failed to allocate UPM entry: %d\n", ret);
-				refcount_set(&refcount->refcount, 0);
-				ida_free(&hvs->upm_handles, upm_handle);
-				vc4_state->upm_handle[i] = 0;
-				return ret;
-			}
-		}
+		vc4_state->upm_handle[i] = ret;
 
-		refcount = &hvs->upm_refcounts[upm_handle];
 		vc4_state->dlist[vc4_state->ptr0_offset[i]] |=
-			VC4_SET_FIELD(refcount->upm.start / HVS_UBM_WORD_SIZE,
+			VC4_SET_FIELD(vc4_state->upm[i].start / HVS_UBM_WORD_SIZE,
 				      SCALER6_PTR0_UPM_BASE) |
 			VC4_SET_FIELD(vc4_state->upm_handle[i] - 1,
 				      SCALER6_PTR0_UPM_HANDLE) |
@@ -1055,29 +981,6 @@
 	return 0;
 }
 
-static void vc6_plane_free_upm(struct drm_plane_state *state)
-{
-	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
-	struct drm_device *drm = state->plane->dev;
-	struct vc4_dev *vc4 = to_vc4_dev(drm);
-	struct vc4_hvs *hvs = vc4->hvs;
-	unsigned int i;
-
-	WARN_ON_ONCE(vc4->gen < VC4_GEN_6_C);
-
-	for (i = 0; i < DRM_FORMAT_MAX_PLANES; i++) {
-		unsigned int upm_handle;
-
-		upm_handle = vc4_state->upm_handle[i];
-		if (!upm_handle)
-			continue;
-
-		if (refcount_dec_and_test(&hvs->upm_refcounts[upm_handle].refcount))
-			vc4_plane_release_upm_ida(hvs, upm_handle);
-		vc4_state->upm_handle[i] = 0;
-	}
-}
-
 /*
  * The colorspace conversion matrices are held in 3 entries in the dlist.
  * Create an array of them, with entries for each full and limited mode, and
@@ -1154,35 +1057,31 @@
 	struct drm_device *dev = state->state->dev;
 	struct vc4_dev *vc4 = to_vc4_dev(dev);
 
-	WARN_ON_ONCE(vc4->gen != VC4_GEN_5 && vc4->gen != VC4_GEN_6_C &&
-		     vc4->gen != VC4_GEN_6_D);
-
-	switch (vc4->gen) {
-	default:
-	case VC4_GEN_5:
-	case VC4_GEN_6_C:
-		if (!state->fb->format->has_alpha)
-			return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_FIXED,
-					     SCALER5_CTL2_ALPHA_MODE);
+	WARN_ON_ONCE(vc4->gen != VC4_GEN_5 && vc4->gen != VC4_GEN_6);
 
-		switch (state->pixel_blend_mode) {
-		case DRM_MODE_BLEND_PIXEL_NONE:
-			return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_FIXED,
-					     SCALER5_CTL2_ALPHA_MODE);
-		default:
-		case DRM_MODE_BLEND_PREMULTI:
-			return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_PIPELINE,
-					     SCALER5_CTL2_ALPHA_MODE) |
-				SCALER5_CTL2_ALPHA_PREMULT;
-		case DRM_MODE_BLEND_COVERAGE:
-			return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_PIPELINE,
-					     SCALER5_CTL2_ALPHA_MODE);
-		}
-	case VC4_GEN_6_D:
-		/* 2712-D configures fixed alpha mode in CTL0 */
+	if (vc4->gen == VC4_GEN_6 && vc4->step_d0) {
 		return state->pixel_blend_mode == DRM_MODE_BLEND_PREMULTI ?
 			SCALER5_CTL2_ALPHA_PREMULT : 0;
 	}
+
+
+	if (!state->fb->format->has_alpha)
+		return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_FIXED,
+				     SCALER5_CTL2_ALPHA_MODE);
+
+	switch (state->pixel_blend_mode) {
+	case DRM_MODE_BLEND_PIXEL_NONE:
+		return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_FIXED,
+				     SCALER5_CTL2_ALPHA_MODE);
+	default:
+	case DRM_MODE_BLEND_PREMULTI:
+		return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_PIPELINE,
+				     SCALER5_CTL2_ALPHA_MODE) |
+			SCALER5_CTL2_ALPHA_PREMULT;
+	case DRM_MODE_BLEND_COVERAGE:
+		return VC4_SET_FIELD(SCALER5_CTL2_ALPHA_MODE_PIPELINE,
+				     SCALER5_CTL2_ALPHA_MODE);
+	}
 }
 
 static u32 vc4_hvs6_get_alpha_mask_mode(struct drm_plane_state *state)
@@ -1190,13 +1089,12 @@
 	struct drm_device *dev = state->state->dev;
 	struct vc4_dev *vc4 = to_vc4_dev(dev);
 
-	WARN_ON_ONCE(vc4->gen != VC4_GEN_6_C && vc4->gen != VC4_GEN_6_D);
+	WARN_ON_ONCE(vc4->gen != VC4_GEN_6);
 
-	if (vc4->gen == VC4_GEN_6_D &&
-	    (!state->fb->format->has_alpha ||
-	     state->pixel_blend_mode == DRM_MODE_BLEND_PIXEL_NONE))
-		return VC4_SET_FIELD(SCALER6D_CTL0_ALPHA_MASK_FIXED,
-				     SCALER6_CTL0_ALPHA_MASK);
+	if (vc4->step_d0 && (!state->fb->format->has_alpha ||
+	    state->pixel_blend_mode == DRM_MODE_BLEND_PIXEL_NONE))
+		return VC4_SET_FIELD(SCALER6_CTL0_ALPHA_MASK_FIXED,
+		       SCALER6_CTL0_ALPHA_MASK);
 
 	return VC4_SET_FIELD(SCALER6_CTL0_ALPHA_MASK_NONE, SCALER6_CTL0_ALPHA_MASK);
 }
@@ -1233,16 +1131,15 @@
 	if (ret)
 		return ret;
 
-	if (!vc4_state->src_w[0] || !vc4_state->src_h[0] ||
-	    !vc4_state->crtc_w || !vc4_state->crtc_h) {
+	width = vc4_state->src_w[0] >> 16;
+	height = vc4_state->src_h[0] >> 16;
+
+	if (!width || !height || !vc4_state->crtc_w || !vc4_state->crtc_h) {
 		/* 0 source size probably means the plane is offscreen */
 		vc4_state->dlist_initialized = 1;
 		return 0;
 	}
 
-	width = vc4_state->src_w[0] >> 16;
-	height = vc4_state->src_h[0] >> 16;
-
 	/* SCL1 is used for Cb/Cr scaling of planar formats.  For RGB
 	 * and 4:4:4, scl1 should be set to scl0 so both channels of
 	 * the scaler do the same thing.  For YUV, the Y plane needs
@@ -1455,7 +1352,7 @@
 
 	/* same for the right side */
 	if (((vc4_state->src_x + vc4_state->src_w[0]) & 0xffff) &&
-	    vc4_state->src_x + vc4_state->src_w[0] < (state->fb->width << 16))
+	       vc4_state->src_x + vc4_state->src_w[0] < (state->fb->width << 16))
 		width++;
 
 	/* now for the top */
@@ -1464,12 +1361,10 @@
 
 	/* and the bottom */
 	if (((vc4_state->src_y + vc4_state->src_h[0]) & 0xffff) &&
-	    vc4_state->src_y + vc4_state->src_h[0] < (state->fb->height << 16))
+	       vc4_state->src_y + vc4_state->src_h[0] < (state->fb->height << 16))
 		height++;
 
-	/* For YUV444 the hardware wants double the width, otherwise it doesn't
-	 * fetch full width of chroma
-	 */
+	/* for YUV444 hardware wants double the width, otherwise it doesn't fetch full width of chroma */
 	if (format->drm == DRM_FORMAT_YUV444 || format->drm == DRM_FORMAT_YVU444)
 		width <<= 1;
 
@@ -1657,7 +1552,18 @@
 		    vc4_state->y_scaling[0] == VC4_SCALING_PPF ||
 		    vc4_state->x_scaling[1] == VC4_SCALING_PPF ||
 		    vc4_state->y_scaling[1] == VC4_SCALING_PPF) {
-			u32 kernel = VC4_SET_FIELD(vc4->hvs->mitchell_netravali_filter.start,
+			struct drm_mm_node *filter;
+
+			switch (state->scaling_filter) {
+			case DRM_SCALING_FILTER_DEFAULT:
+			default:
+				filter = &vc4->hvs->mitchell_netravali_filter;
+				break;
+			case DRM_SCALING_FILTER_NEAREST_NEIGHBOR:
+				filter = &vc4->hvs->nearest_neighbour_filter;
+				break;
+			}
+			u32 kernel = VC4_SET_FIELD(filter->start,
 						   SCALER_PPF_KERNEL_OFFSET);
 
 			/* HPPF plane 0 */
@@ -1720,14 +1626,14 @@
 		if (color_range > DRM_COLOR_YCBCR_FULL_RANGE)
 			color_range = DRM_COLOR_YCBCR_LIMITED_RANGE;
 
-		if (vc4->gen == VC4_GEN_6_C) {
-			ret |= SCALER6C_CTL2_CSC_ENABLE;
+		if (vc4->step_d0) {
+			ret |= SCALER6D0_CTL2_CSC_ENABLE;
 			ret |= VC4_SET_FIELD(color_encoding + (color_range * 3),
-					     SCALER6C_CTL2_BRCM_CFC_CONTROL);
+					SCALER6D0_CTL2_BRCM_CFC_CONTROL);
 		} else {
-			ret |= SCALER6D_CTL2_CSC_ENABLE;
+			ret |= SCALER6_CTL2_CSC_ENABLE;
 			ret |= VC4_SET_FIELD(color_encoding + (color_range * 3),
-					     SCALER6D_CTL2_BRCM_CFC_CONTROL);
+					SCALER6_CTL2_BRCM_CFC_CONTROL);
 		}
 	}
 
@@ -1763,8 +1669,10 @@
 	if (ret)
 		return ret;
 
-	if (!vc4_state->src_w[0] || !vc4_state->src_h[0] ||
-	    !vc4_state->crtc_w || !vc4_state->crtc_h) {
+	width = vc4_state->src_w[0] >> 16;
+	height = vc4_state->src_h[0] >> 16;
+
+	if (!width || !height || !vc4_state->crtc_w || !vc4_state->crtc_h) {
 		/* 0 source size probably means the plane is offscreen.
 		 * 0 destination size is a redundant plane.
 		 */
@@ -1772,9 +1680,6 @@
 		return 0;
 	}
 
-	width = vc4_state->src_w[0] >> 16;
-	height = vc4_state->src_h[0] >> 16;
-
 	/* SCL1 is used for Cb/Cr scaling of planar formats.  For RGB
 	 * and 4:4:4, scl1 should be set to scl0 so both channels of
 	 * the scaler do the same thing.  For YUV, the Y plane needs
@@ -2069,9 +1974,19 @@
 		    vc4_state->y_scaling[0] == VC4_SCALING_PPF ||
 		    vc4_state->x_scaling[1] == VC4_SCALING_PPF ||
 		    vc4_state->y_scaling[1] == VC4_SCALING_PPF) {
-			u32 kernel =
-				VC4_SET_FIELD(vc4->hvs->mitchell_netravali_filter.start,
-					      SCALER_PPF_KERNEL_OFFSET);
+			struct drm_mm_node *filter;
+
+			switch (state->scaling_filter) {
+			case DRM_SCALING_FILTER_DEFAULT:
+			default:
+				filter = &vc4->hvs->mitchell_netravali_filter;
+				break;
+			case DRM_SCALING_FILTER_NEAREST_NEIGHBOR:
+				filter = &vc4->hvs->nearest_neighbour_filter;
+				break;
+			}
+			u32 kernel = VC4_SET_FIELD(filter->start,
+						   SCALER_PPF_KERNEL_OFFSET);
 
 			/* HPPF plane 0 */
 			vc4_dlist_write(vc4_state, kernel);
@@ -2125,8 +2040,8 @@
  * compute the dlist here and have all active plane dlists get updated
  * in the CRTC's flush.
  */
-static int vc4_plane_atomic_check(struct drm_plane *plane,
-				  struct drm_atomic_state *state)
+int vc4_plane_atomic_check(struct drm_plane *plane,
+			   struct drm_atomic_state *state)
 {
 	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
 	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
@@ -2136,18 +2051,10 @@
 
 	vc4_state->dlist_count = 0;
 
-	if (!plane_enabled(new_plane_state)) {
-		struct drm_plane_state *old_plane_state =
-				drm_atomic_get_old_plane_state(state, plane);
-
-		if (vc4->gen >= VC4_GEN_6_C && old_plane_state &&
-		    plane_enabled(old_plane_state)) {
-			vc6_plane_free_upm(new_plane_state);
-		}
+	if (!plane_enabled(new_plane_state))
 		return 0;
-	}
 
-	if (vc4->gen >= VC4_GEN_6_C)
+	if (vc4->gen >= VC4_GEN_6)
 		ret = vc6_plane_mode_set(plane, new_plane_state);
 	else
 		ret = vc4_plane_mode_set(plane, new_plane_state);
@@ -2162,7 +2069,7 @@
 	if (ret)
 		return ret;
 
-	if (vc4->gen >= VC4_GEN_6_C) {
+	if (vc4->gen >= VC4_GEN_6) {
 		ret = vc6_plane_allocate_upm(new_plane_state);
 		if (ret)
 			return ret;
@@ -2228,7 +2135,7 @@
 	 */
 	WARN_ON_ONCE(plane->state->crtc_x < 0 || plane->state->crtc_y < 0);
 
-	if (vc4->gen == VC4_GEN_6_C) {
+	if (vc4->gen == VC4_GEN_6) {
 		u32 value;
 
 		value = vc4_state->dlist[vc4_state->ptr0_offset[0]] &
@@ -2340,17 +2247,17 @@
 static int vc4_plane_atomic_async_check(struct drm_plane *plane,
 					struct drm_atomic_state *state, bool flip)
 {
-	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
 	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
 										 plane);
+	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
 	struct vc4_plane_state *old_vc4_state, *new_vc4_state;
 	int ret;
 	u32 i;
 
-	if (vc4->gen <= VC4_GEN_5)
-		ret = vc4_plane_mode_set(plane, new_plane_state);
-	else
+	if (vc4->gen >= VC4_GEN_6)
 		ret = vc6_plane_mode_set(plane, new_plane_state);
+	else
+		ret = vc4_plane_mode_set(plane, new_plane_state);
 	if (ret)
 		return ret;
 
@@ -2564,6 +2471,12 @@
 					  DRM_COLOR_YCBCR_BT709,
 					  DRM_COLOR_YCBCR_LIMITED_RANGE);
 
+	drm_plane_create_scaling_filter_property(plane,
+						 BIT(DRM_SCALING_FILTER_DEFAULT) |
+						 BIT(DRM_SCALING_FILTER_NEAREST_NEIGHBOR));
+
+	drm_plane_create_chroma_siting_properties(plane, 0, 0);
+
 	if (type == DRM_PLANE_TYPE_PRIMARY)
 		drm_plane_create_zpos_immutable_property(plane, 0);
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_regs.h linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_regs.h
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_regs.h	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_regs.h	2025-06-16 17:40:50.791684722 +0200
@@ -13,25 +13,24 @@
 /* Using the GNU statement expression extension */
 #define VC4_SET_FIELD(value, field)					\
 	({								\
-		WARN_ON(!FIELD_FIT(field##_MASK, value));		\
-		FIELD_PREP(field##_MASK, value);			\
+		WARN_ON(!FIELD_FIT(field ## _MASK, value));		\
+		FIELD_PREP(field ## _MASK, value);			\
 	 })
 
-#define VC4_GET_FIELD(word, field) FIELD_GET(field##_MASK, word)
+#define VC4_GET_FIELD(word, field) FIELD_GET(field ## _MASK, word)
 
-#define VC6_SET_FIELD(value, field)					\
+#define VC4_SET_FIELD6(value, field)					\
 	({								\
-		WARN_ON(!FIELD_FIT(hvs->vc4->gen == VC4_GEN_6_C ?	\
-				    SCALER6_ ## field ## _MASK :	\
-				    SCALER6D_ ## field ## _MASK, value));\
-		FIELD_PREP(hvs->vc4->gen == VC4_GEN_6_C ?		\
-				    SCALER6_ ## field ## _MASK :	\
-				    SCALER6D_ ## field ## _MASK, value);	\
+		WARN_ON(!FIELD_FIT(hvs->vc4->step_d0 ?			\
+				    SCALER6D0_ ## field ## _MASK :	\
+				    SCALER6_ ## field ## _MASK, value));\
+		FIELD_PREP(hvs->vc4->step_d0 ?				\
+				    SCALER6D0_ ## field ## _MASK :	\
+				    SCALER6_ ## field ## _MASK, value);	\
 	 })
 
-#define VC6_GET_FIELD(word, field) FIELD_GET(hvs->vc4->gen == VC4_GEN_6_C ?	\
-					     SCALER6_ ## field ## _MASK :	\
-					     SCALER6D_ ## field ## _MASK, word)
+#define VC4_GET_FIELD6(word, field) FIELD_GET(hvs->vc4->step_d0 ? \
+				    SCALER6D0_ ## field ## _MASK : SCALER6_ ## field ## _MASK, word)
 
 #define V3D_IDENT0   0x00000
 # define V3D_EXPECTED_IDENT0 \
@@ -538,12 +537,31 @@
 #define SCALER_DLIST_START                      0x00002000
 #define SCALER_DLIST_SIZE                       0x00004000
 
+/* Gamma PWL for each channel. 16 points for each of 4 colour channels (alpha
+ * only on channel 2). 8 bytes per entry, offsets first, then gradient:
+ *   Y = GRAD * X + C
+ *
+ * Values for X and C are left justified, and vary depending on the width of
+ * the HVS channel:
+ *    8-bit pipeline: X uses [31:24], C is U8.8 format, and GRAD is U4.8.
+ *   12-bit pipeline: X uses [31:20], C is U12.4 format, and GRAD is U4.8.
+ *
+ * The 3 HVS channels start at 0x400 offsets (ie chan 1 starts at 0x2400, and
+ * chan 2 at 0x2800).
+ */
+#define SCALER5_DSPGAMMA_NUM_POINTS		16
+#define SCALER5_DSPGAMMA_START			0x00002000
+#define SCALER5_DSPGAMMA_CHAN_OFFSET		0x400
+# define SCALER5_DSPGAMMA_OFF_X_MASK		VC4_MASK(31, 20)
+# define SCALER5_DSPGAMMA_OFF_X_SHIFT		20
+# define SCALER5_DSPGAMMA_OFF_C_MASK		VC4_MASK(15, 0)
+# define SCALER5_DSPGAMMA_OFF_C_SHIFT		0
+# define SCALER5_DSPGAMMA_GRAD_MASK		VC4_MASK(11, 0)
+# define SCALER5_DSPGAMMA_GRAD_SHIFT		0
+
 #define SCALER5_DLIST_START			0x00004000
 
 #define SCALER6_VERSION				0x00000000
-# define SCALER6_VERSION_MASK			VC4_MASK(7, 0)
-# define SCALER6_VERSION_C0			0x00000053
-# define SCALER6_VERSION_D0			0x00000054
 #define SCALER6_CXM_SIZE			0x00000004
 #define SCALER6_LBM_SIZE			0x00000008
 #define SCALER6_UBM_SIZE			0x0000000c
@@ -562,9 +580,9 @@
 #define SCALER6_HANDLE_ERROR			0x0000002c
 
 #define SCALER6_DISP0_CTRL0			0x00000030
-#define SCALER6_DISPX_CTRL0(x)		((hvs->vc4->gen == VC4_GEN_6_C) ? \
-	(SCALER6_DISP0_CTRL0 + ((x) * (SCALER6_DISP1_CTRL0 - SCALER6_DISP0_CTRL0))) : \
-	(SCALER6D_DISP0_CTRL0 + ((x) * (SCALER6D_DISP1_CTRL0 - SCALER6D_DISP0_CTRL0))))
+#define SCALER6_DISPX_CTRL0(x)	((hvs->vc4->step_d0) ? \
+	(SCALER6D0_DISP0_CTRL0 + ((x) * (SCALER6D0_DISP1_CTRL0 - SCALER6D0_DISP0_CTRL0))) : \
+	(SCALER6_DISP0_CTRL0 + ((x) * (SCALER6_DISP1_CTRL0 - SCALER6_DISP0_CTRL0))))
 # define SCALER6_DISPX_CTRL0_ENB		BIT(31)
 # define SCALER6_DISPX_CTRL0_RESET		BIT(30)
 # define SCALER6_DISPX_CTRL0_FWIDTH_MASK	VC4_MASK(28, 16)
@@ -573,34 +591,35 @@
 # define SCALER6_DISPX_CTRL0_LINES_MASK		VC4_MASK(12, 0)
 
 #define SCALER6_DISP0_CTRL1			0x00000034
-#define SCALER6_DISPX_CTRL1(x)		((hvs->vc4->gen == VC4_GEN_6_C) ? \
-	(SCALER6_DISP0_CTRL1 + ((x) * (SCALER6_DISP1_CTRL1 - SCALER6_DISP0_CTRL1))) : \
-	(SCALER6D_DISP0_CTRL1 + ((x) * (SCALER6D_DISP1_CTRL1 - SCALER6D_DISP0_CTRL1))))
+#define SCALER6_DISPX_CTRL1(x)		((hvs->vc4->step_d0) ? \
+	(SCALER6D0_DISP0_CTRL1 + ((x) * (SCALER6D0_DISP1_CTRL1 - SCALER6D0_DISP0_CTRL1))) : \
+	(SCALER6_DISP0_CTRL1 + ((x) * (SCALER6_DISP1_CTRL1 - SCALER6_DISP0_CTRL1))))
 # define SCALER6_DISPX_CTRL1_BGENB		BIT(8)
 # define SCALER6_DISPX_CTRL1_INTLACE		BIT(0)
 
 #define SCALER6_DISP0_BGND			0x00000038
-#define SCALER6_DISPX_BGND(x)		((hvs->vc4->gen == VC4_GEN_6_C) ? \
-	(SCALER6_DISP0_BGND + ((x) * (SCALER6_DISP1_BGND - SCALER6_DISP0_BGND))) : \
-	(SCALER6D_DISP0_BGND + ((x) * (SCALER6D_DISP1_BGND - SCALER6D_DISP0_BGND))))
+#define SCALER6_DISPX_BGND(x)		((hvs->vc4->step_d0) ? \
+	(SCALER6D0_DISP0_BGND + ((x) * (SCALER6D0_DISP1_BGND - SCALER6D0_DISP0_BGND))) : \
+	(SCALER6_DISP0_BGND + ((x) * (SCALER6_DISP1_BGND - SCALER6_DISP0_BGND))))
 
 #define SCALER6_DISP0_LPTRS			0x0000003c
-#define SCALER6_DISPX_LPTRS(x)		((hvs->vc4->gen == VC4_GEN_6_C) ? \
-	(SCALER6_DISP0_LPTRS + ((x) * (SCALER6_DISP1_LPTRS - SCALER6_DISP0_LPTRS))) : \
-	(SCALER6D_DISP0_LPTRS + ((x) * (SCALER6D_DISP1_LPTRS - SCALER6D_DISP0_LPTRS))))
+#define SCALER6_DISPX_LPTRS(x)		((hvs->vc4->step_d0) ? \
+	(SCALER6D0_DISP0_LPTRS + ((x) * (SCALER6D0_DISP1_LPTRS - SCALER6D0_DISP0_LPTRS))) : \
+	(SCALER6_DISP0_LPTRS + ((x) * (SCALER6_DISP1_LPTRS - SCALER6_DISP0_LPTRS))))
 # define SCALER6_DISPX_LPTRS_HEADE_MASK		VC4_MASK(11, 0)
 
 #define SCALER6_DISP0_COB			0x00000040
-#define SCALER6_DISPX_COB(x)		((hvs->vc4->gen == VC4_GEN_6_C) ? \
-	(SCALER6_DISP0_COB + ((x) * (SCALER6_DISP1_COB - SCALER6_DISP0_COB))) : \
-	(SCALER6D_DISP0_COB + ((x) * (SCALER6D_DISP1_COB - SCALER6D_DISP0_COB))))
+#define SCALER6_DISPX_COB(x)		((hvs->vc4->step_d0) ? \
+	(SCALER6D0_DISP0_COB + ((x) * (SCALER6D0_DISP1_COB - SCALER6D0_DISP0_COB))) : \
+	(SCALER6_DISP0_COB + ((x) * (SCALER6_DISP1_COB - SCALER6_DISP0_COB))))
 # define SCALER6_DISPX_COB_TOP_MASK		VC4_MASK(31, 16)
 # define SCALER6_DISPX_COB_BASE_MASK		VC4_MASK(15, 0)
 
 #define SCALER6_DISP0_STATUS			0x00000044
-#define SCALER6_DISPX_STATUS(x)		((hvs->vc4->gen == VC4_GEN_6_C) ? \
-	(SCALER6_DISP0_STATUS + ((x) * (SCALER6_DISP1_STATUS - SCALER6_DISP0_STATUS))) : \
-	(SCALER6D_DISP0_STATUS + ((x) * (SCALER6D_DISP1_STATUS - SCALER6D_DISP0_STATUS))))
+
+#define SCALER6_DISPX_STATUS(x)	((hvs->vc4->step_d0) ? \
+	(SCALER6D0_DISP0_STATUS + ((x) * (SCALER6D0_DISP1_STATUS - SCALER6D0_DISP0_STATUS))) : \
+	(SCALER6_DISP0_STATUS + ((x) * (SCALER6_DISP1_STATUS - SCALER6_DISP0_STATUS))))
 # define SCALER6_DISPX_STATUS_EMPTY		BIT(22)
 # define SCALER6_DISPX_STATUS_FRCNT_MASK	VC4_MASK(21, 16)
 # define SCALER6_DISPX_STATUS_OFIELD		BIT(15)
@@ -613,9 +632,9 @@
 
 #define SCALER6_DISP0_DL			0x00000048
 
-#define SCALER6_DISPX_DL(x)		((hvs->vc4->gen == VC4_GEN_6_C) ? \
-	(SCALER6_DISP0_DL + ((x) * (SCALER6_DISP1_DL - SCALER6_DISP0_DL))) : \
-	(SCALER6D_DISP0_DL + ((x) * (SCALER6D_DISP1_DL - SCALER6D_DISP0_DL))))
+#define SCALER6_DISPX_DL(x)	((hvs->vc4->step_d0) ? \
+	(SCALER6D0_DISP0_DL + ((x) * (SCALER6D0_DISP1_DL - SCALER6D0_DISP0_DL))) : \
+	(SCALER6_DISP0_DL + ((x) * (SCALER6_DISP1_DL - SCALER6_DISP0_DL))))
 # define SCALER6_DISPX_DL_LACT_MASK		VC4_MASK(11, 0)
 
 #define SCALER6_DISP0_RUN			0x0000004c
@@ -673,72 +692,105 @@
 #define SCALER6_BAD_UPM				0x0000022c
 #define SCALER6_BAD_AXI				0x00000230
 
-#define SCALER6D_VERSION			0x00000000
-#define SCALER6D_CXM_SIZE			0x00000004
-#define SCALER6D_LBM_SIZE			0x00000008
-#define SCALER6D_UBM_SIZE			0x0000000c
-#define SCALER6D_COBA_SIZE			0x00000010
-#define SCALER6D_COB_SIZE			0x00000014
-#define SCALER6D_CONTROL			0x00000020
-#define SCALER6D_FETCHER_STATUS			0x00000024
-#define SCALER6D_FETCH_STATUS			0x00000028
-#define SCALER6D_HANDLE_ERROR			0x0000002c
-#define SCALER6D_EOLN				0x00000030
-#define SCALER6D_DL_STATUS			0x00000034
-#define SCALER6D_PRI_MAP0			0x00000038
-#define SCALER6D_PRI_MAP1			0x0000003c
-#define SCALER6D_HISTCTRL			0x000000d0
-#define SCALER6D_HISTBIN0			0x000000d4
-#define SCALER6D_HISTBIN1			0x000000d8
-#define SCALER6D_HISTBIN2			0x000000dc
-#define SCALER6D_HISTBIN3			0x000000e0
-#define SCALER6D_HISTBIN4			0x000000e4
-#define SCALER6D_HISTBIN5			0x000000e8
-#define SCALER6D_HISTBIN6			0x000000ec
-#define SCALER6D_HISTBIN7			0x000000f0
-#define SCALER6D_HVS_ID				0x000000fc
 
-#define SCALER6D_DISP0_CTRL0			0x00000100
-#define SCALER6D_DISP0_CTRL1			0x00000104
-#define SCALER6D_DISP0_BGND			0x00000108
-#define SCALER6D_DISP0_LPTRS			0x00000110
-#define SCALER6D_DISP0_COB			0x00000114
-#define SCALER6D_DISP0_STATUS			0x00000118
-#define SCALER6D_DISP0_CTRL0			0x00000100
-#define SCALER6D_DISP0_CTRL1			0x00000104
-#define SCALER6D_DISP0_BGND0			0x00000108
-#define SCALER6D_DISP0_BGND1			0x0000010c
-#define SCALER6D_DISP0_LPTRS			0x00000110
-#define SCALER6D_DISP0_COB			0x00000114
-#define SCALER6D_DISP0_STATUS			0x00000118
-#define SCALER6D_DISP0_DL			0x0000011c
-#define SCALER6D_DISP0_RUN			0x00000120
-#define SCALER6D_QOS0				0x00000124
-#define SCALER6D_PROF0				0x00000128
-#define SCALER6D_DISP1_CTRL0			0x00000140
-#define SCALER6D_DISP1_CTRL1			0x00000144
-#define SCALER6D_DISP1_BGND0			0x00000148
-#define SCALER6D_DISP1_BGND1			0x0000014c
-#define SCALER6D_DISP1_LPTRS			0x00000150
-#define SCALER6D_DISP1_COB			0x00000154
-#define SCALER6D_DISP1_STATUS			0x00000158
-#define SCALER6D_DISP1_DL			0x0000015c
-#define SCALER6D_DISP1_RUN			0x00000160
-#define SCALER6D_QOS1				0x00000164
-#define SCALER6D_PROF1				0x00000168
-#define SCALER6D_DISP2_CTRL0			0x00000180
-#define SCALER6D_DISP2_CTRL1			0x00000184
-#define SCALER6D_DISP2_BGND0			0x00000188
-#define SCALER6D_DISP2_BGND1			0x0000018c
-#define SCALER6D_DISP2_LPTRS			0x00000190
-#define SCALER6D_DISP2_COB			0x00000194
-#define SCALER6D_DISP2_STATUS			0x00000198
-#define SCALER6D_DISP2_DL			0x0000019c
-#define SCALER6D_DISP2_RUN			0x000001a0
-#define SCALER6D_QOS2				0x000001a4
-#define SCALER6D_PROF2				0x000001a8
+#define SCALER6D0_VERSION				0x00000000
+#define SCALER6D0_CXM_SIZE			0x00000004
+#define SCALER6D0_LBM_SIZE			0x00000008
+#define SCALER6D0_UBM_SIZE			0x0000000c
+#define SCALER6D0_COBA_SIZE			0x00000010
+#define SCALER6D0_COB_SIZE			0x00000014
+#define SCALER6D0_CONTROL				0x00000020
+#define SCALER6D0_FETCHER_STATUS			0x00000024
+#define SCALER6D0_FETCH_STATUS			0x00000028
+#define SCALER6D0_HANDLE_ERROR			0x0000002c
 
-#define SCALER6(x) ((hvs->vc4->gen == VC4_GEN_6_C) ? SCALER6_ ## x : SCALER6D_ ## x)
+#define SCALER6D0_EOLN				0x00000030
+#define SCALER6D0_DL_STATUS			0x00000034
+#define SCALER6D0_PRI_MAP0			0x00000038
+#define SCALER6D0_PRI_MAP1			0x0000003c
+#define SCALER6D0_HISTCTRL			0x000000d0
+#define SCALER6D0_HISTBIN0			0x000000d4
+#define SCALER6D0_HISTBIN1			0x000000d8
+#define SCALER6D0_HISTBIN2			0x000000dc
+#define SCALER6D0_HISTBIN3			0x000000e0
+#define SCALER6D0_HISTBIN4			0x000000e4
+#define SCALER6D0_HISTBIN5			0x000000e8
+#define SCALER6D0_HISTBIN6			0x000000ec
+#define SCALER6D0_HISTBIN7			0x000000f0
+#define SCALER6D0_HVS_ID			0x000000fc
+
+#define SCALER6D0_DISP0_CTRL0			0x00000100
+# define SCALER6D0_DISPX_CTRL0_ENB		BIT(31)
+# define SCALER6D0_DISPX_CTRL0_RESET		BIT(30)
+# define SCALER6D0_DISPX_CTRL0_FWIDTH_MASK	VC4_MASK(28, 16)
+# define SCALER6D0_DISPX_CTRL0_ONESHOT		BIT(15)
+# define SCALER6D0_DISPX_CTRL0_ONECTX_MASK	VC4_MASK(14, 13)
+# define SCALER6D0_DISPX_CTRL0_LINES_MASK		VC4_MASK(12, 0)
+
+#define SCALER6D0_DISP0_CTRL1			0x00000104
+# define SCALER6D0_DISPX_CTRL1_BGENB		BIT(8)
+# define SCALER6D0_DISPX_CTRL1_INTLACE		BIT(0)
+
+#define SCALER6D0_DISP0_BGND			0x00000108
+
+#define SCALER6D0_DISP0_LPTRS			0x00000110
+# define SCALER6D0_DISPX_LPTRS_HEADE_MASK		VC4_MASK(11, 0)
+
+#define SCALER6D0_DISP0_COB			0x00000114
+# define SCALER6D0_DISPX_COB_TOP_MASK		VC4_MASK(31, 16)
+# define SCALER6D0_DISPX_COB_BASE_MASK		VC4_MASK(15, 0)
+
+#define SCALER6D0_DISP0_STATUS			0x00000118
+
+# define SCALER6D0_DISPX_STATUS_EMPTY		BIT(22)
+# define SCALER6D0_DISPX_STATUS_FRCNT_MASK	VC4_MASK(21, 16)
+# define SCALER6D0_DISPX_STATUS_OFIELD		BIT(15)
+# define SCALER6D0_DISPX_STATUS_MODE_MASK		VC4_MASK(14, 13)
+# define SCALER6D0_DISPX_STATUS_MODE_DISABLED	0
+# define SCALER6D0_DISPX_STATUS_MODE_INIT		1
+# define SCALER6D0_DISPX_STATUS_MODE_RUN		2
+# define SCALER6D0_DISPX_STATUS_MODE_EOF		3
+# define SCALER6D0_DISPX_STATUS_YLINE_MASK	VC4_MASK(12, 0)
+
+
+#define SCALER6D0_DISP0_CTRL0			0x00000100
+#define SCALER6D0_DISP0_CTRL1			0x00000104
+#define SCALER6D0_DISP0_BGND0			0x00000108
+#define SCALER6D0_DISP0_BGND1			0x0000010c
+#define SCALER6D0_DISP0_LPTRS			0x00000110
+#define SCALER6D0_DISP0_COB			0x00000114
+#define SCALER6D0_DISP0_STATUS			0x00000118
+#define SCALER6D0_DISP0_DL			0x0000011c
+# define SCALER6D0_DISPX_DL_LACT_MASK		VC4_MASK(11, 0)
+#define SCALER6D0_DISP0_RUN			0x00000120
+#define SCALER6D0_QOS0				0x00000124
+#define SCALER6D0_PROF0				0x00000128
+
+#define SCALER6D0_DISP1_CTRL0			0x00000140
+#define SCALER6D0_DISP1_CTRL1			0x00000144
+#define SCALER6D0_DISP1_BGND0			0x00000148
+#define SCALER6D0_DISP1_BGND1			0x0000014c
+#define SCALER6D0_DISP1_LPTRS			0x00000150
+#define SCALER6D0_DISP1_COB			0x00000154
+#define SCALER6D0_DISP1_STATUS			0x00000158
+#define SCALER6D0_DISP1_DL			0x0000015c
+#define SCALER6D0_DISP1_RUN			0x00000160
+#define SCALER6D0_QOS1				0x00000164
+#define SCALER6D0_PROF1				0x00000168
+
+#define SCALER6D0_DISP2_CTRL0			0x00000180
+#define SCALER6D0_DISP2_CTRL1			0x00000184
+#define SCALER6D0_DISP2_BGND0			0x00000188
+#define SCALER6D0_DISP2_BGND1			0x0000018c
+#define SCALER6D0_DISP2_LPTRS			0x00000190
+#define SCALER6D0_DISP2_COB			0x00000194
+#define SCALER6D0_DISP2_STATUS			0x00000198
+#define SCALER6D0_DISP2_DL			0x0000019c
+#define SCALER6D0_DISP2_RUN			0x000001a0
+#define SCALER6D0_QOS2				0x000001a4
+#define SCALER6D0_PROF2				0x000001a8
+
+#define SCALER6(x) ((hvs->vc4->step_d0) ? SCALER6D0_ ## x : SCALER6_ ## x)
 
 # define VC4_HDMI_SW_RESET_FORMAT_DETECT	BIT(1)
 # define VC4_HDMI_SW_RESET_HDMI			BIT(0)
@@ -987,14 +1039,14 @@
 # define VC4_HD_MAI_THR_DREQLOW_MASK		VC4_MASK(5, 0)
 # define VC4_HD_MAI_THR_DREQLOW_SHIFT		0
 
-# define VC6_D_HD_MAI_THR_PANICHIGH_MASK	VC4_MASK(29, 23)
-# define VC6_D_HD_MAI_THR_PANICHIGH_SHIFT	23
-# define VC6_D_HD_MAI_THR_PANICLOW_MASK		VC4_MASK(21, 15)
-# define VC6_D_HD_MAI_THR_PANICLOW_SHIFT	15
-# define VC6_D_HD_MAI_THR_DREQHIGH_MASK		VC4_MASK(13, 7)
-# define VC6_D_HD_MAI_THR_DREQHIGH_SHIFT	7
-# define VC6_D_HD_MAI_THR_DREQLOW_MASK		VC4_MASK(6, 0)
-# define VC6_D_HD_MAI_THR_DREQLOW_SHIFT		0
+# define VC4_D0_HD_MAI_THR_PANICHIGH_MASK		VC4_MASK(29, 23)
+# define VC4_D0_HD_MAI_THR_PANICHIGH_SHIFT		23
+# define VC4_D0_HD_MAI_THR_PANICLOW_MASK		VC4_MASK(21, 15)
+# define VC4_D0_HD_MAI_THR_PANICLOW_SHIFT		15
+# define VC4_D0_HD_MAI_THR_DREQHIGH_MASK		VC4_MASK(13, 7)
+# define VC4_D0_HD_MAI_THR_DREQHIGH_SHIFT		7
+# define VC4_D0_HD_MAI_THR_DREQLOW_MASK		VC4_MASK(6, 0)
+# define VC4_D0_HD_MAI_THR_DREQLOW_SHIFT		0
 
 /* Divider from HDMI HSM clock to MAI serial clock.  Sampling period
  * converges to N / (M + 1) cycles.
@@ -1203,9 +1255,6 @@
 #define SCALER5_CTL2_ALPHA_MASK			VC4_MASK(15, 4)
 #define SCALER5_CTL2_ALPHA_SHIFT		4
 
-#define SCALER6D_CTL2_CSC_ENABLE		BIT(19)
-#define SCALER6D_CTL2_BRCM_CFC_CONTROL_MASK	VC4_MASK(22, 20)
-
 #define SCALER_POS1_SCL_HEIGHT_MASK		VC4_MASK(27, 16)
 #define SCALER_POS1_SCL_HEIGHT_SHIFT		16
 
@@ -1360,7 +1409,8 @@
 
 #define SCALER6_CTL0_ALPHA_MASK_MASK		VC4_MASK(19, 18)
 #define SCALER6_CTL0_ALPHA_MASK_NONE		0
-#define SCALER6D_CTL0_ALPHA_MASK_FIXED		3
+#define SCALER6_CTL0_ALPHA_MASK_FIXED		3
+
 #define SCALER6_CTL0_UNITY			BIT(15)
 #define SCALER6_CTL0_ORDERRGBA_MASK		VC4_MASK(14, 13)
 #define SCALER6_CTL0_SCL1_MODE_MASK		VC4_MASK(10, 8)
@@ -1375,10 +1425,13 @@
 #define SCALER6_CTL2_ALPHA_PREMULT		BIT(29)
 #define SCALER6_CTL2_ALPHA_MIX			BIT(28)
 #define SCALER6_CTL2_BFG			BIT(26)
-#define SCALER6C_CTL2_CSC_ENABLE		BIT(25)
-#define SCALER6C_CTL2_BRCM_CFC_CONTROL_MASK	VC4_MASK(18, 16)
+#define SCALER6_CTL2_CSC_ENABLE			BIT(25)
+#define SCALER6_CTL2_BRCM_CFC_CONTROL_MASK	VC4_MASK(18, 16)
 #define SCALER6_CTL2_ALPHA_MASK			VC4_MASK(15, 4)
 
+#define SCALER6D0_CTL2_CSC_ENABLE		BIT(19)
+#define SCALER6D0_CTL2_BRCM_CFC_CONTROL_MASK	VC4_MASK(22, 20)
+
 #define SCALER6_POS1_SCL_LINES_MASK		VC4_MASK(28, 16)
 #define SCALER6_POS1_SCL_WIDTH_MASK		VC4_MASK(12, 0)
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_txp.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_txp.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_txp.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_txp.c	2025-06-16 17:40:50.791684722 +0200
@@ -405,7 +405,7 @@
 		WARN_ON(TXP_READ(TXP_DST_CTRL) & TXP_BUSY);
 	}
 
-	if (vc4->gen < VC4_GEN_6_C)
+	if (vc4->gen < VC4_GEN_6)
 		TXP_WRITE(TXP_DST_CTRL, TXP_POWERDOWN);
 
 	drm_dev_exit(idx);
@@ -510,7 +510,7 @@
 	return IRQ_HANDLED;
 }
 
-static const struct vc4_txp_data bcm2712_mop_data = {
+const struct vc4_txp_data bcm2712_mop_data = {
 	.base = {
 		.name = "mop",
 		.debugfs_name = "mop_regs",
@@ -524,7 +524,7 @@
 	.supports_40bit_addresses = true,
 };
 
-static const struct vc4_txp_data bcm2712_moplet_data = {
+const struct vc4_txp_data bcm2712_moplet_data = {
 	.base = {
 		.name = "moplet",
 		.debugfs_name = "moplet_regs",
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_vec.c linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_vec.c
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_vec.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc4_vec.c	2025-06-16 17:40:50.791684722 +0200
@@ -67,7 +67,7 @@
 #define VEC_CONFIG0_YCDELAY		BIT(4)
 #define VEC_CONFIG0_RAMPEN		BIT(2)
 #define VEC_CONFIG0_YCDIS		BIT(2)
-#define VEC_CONFIG0_STD_MASK		GENMASK(1, 0)
+#define VEC_CONFIG0_STD_MASK		(VEC_CONFIG0_SECAM_STD | GENMASK(1, 0))
 #define VEC_CONFIG0_NTSC_STD		0
 #define VEC_CONFIG0_PAL_BDGHI_STD	1
 #define VEC_CONFIG0_PAL_M_STD		2
@@ -186,6 +186,8 @@
 #define VEC_DAC_MISC_DAC_RST_N		BIT(0)
 
 
+static char *vc4_vec_tv_norm;
+
 struct vc4_vec_variant {
 	u32 dac_config;
 };
@@ -272,6 +274,18 @@
 	VC4_REG32(VEC_DAC_MISC),
 };
 
+static const struct drm_display_mode drm_mode_240p = {
+	DRM_MODE("720x240", DRM_MODE_TYPE_DRIVER, 13500,
+		 720, 720 + 14, 720 + 14 + 64, 720 + 14 + 64 + 60, 0,
+		 240, 240 + 3, 240 + 3 + 3, 262, 0, 0)
+};
+
+static const struct drm_display_mode drm_mode_288p = {
+	DRM_MODE("720x288", DRM_MODE_TYPE_DRIVER, 13500,
+		 720, 720 + 20, 720 + 20 + 64, 720 + 20 + 64 + 60, 0,
+		 288, 288 + 2, 288 + 2 + 3, 312, 0, 0)
+};
+
 static const struct vc4_vec_tv_mode vc4_vec_tv_modes[] = {
 	{
 		.mode = DRM_MODE_TV_MODE_NTSC,
@@ -371,6 +385,35 @@
 	{ VC4_VEC_TV_MODE_MONOCHROME, "Mono", },
 };
 
+static enum drm_connector_tv_mode
+vc4_vec_get_default_mode(struct drm_connector *connector)
+{
+	if (connector->cmdline_mode.tv_mode_specified) {
+		return connector->cmdline_mode.tv_mode;
+	} else if (vc4_vec_tv_norm) {
+		int ret;
+
+		ret = drm_get_tv_mode_from_name(vc4_vec_tv_norm, strlen(vc4_vec_tv_norm));
+		if (ret >= 0)
+			return ret;
+	} else if (connector->cmdline_mode.specified &&
+		   ((connector->cmdline_mode.refresh_specified &&
+		     (connector->cmdline_mode.refresh == 25 ||
+		      connector->cmdline_mode.refresh == 50)) ||
+		    (!connector->cmdline_mode.refresh_specified &&
+		     (connector->cmdline_mode.yres == 288 ||
+		      connector->cmdline_mode.yres == 576)))) {
+		/*
+		 * no explicitly specified TV norm; use PAL if a mode that
+		 * looks like PAL has been specified on the command line
+		 */
+		return DRM_MODE_TV_MODE_PAL;
+	}
+
+	/* in all other cases, default to NTSC */
+	return DRM_MODE_TV_MODE_NTSC;
+}
+
 static enum drm_connector_status
 vc4_vec_connector_detect(struct drm_connector *connector, bool force)
 {
@@ -436,52 +479,55 @@
 }
 
 static int
-vc4_vec_connector_get_property(struct drm_connector *connector,
-			       const struct drm_connector_state *state,
-			       struct drm_property *property,
-			       uint64_t *val)
+vc4_vec_generic_tv_mode_to_legacy(enum drm_connector_tv_mode tv_mode)
 {
-	struct vc4_vec *vec = connector_to_vc4_vec(connector);
-
-	if (property != vec->legacy_tv_mode_property)
-		return -EINVAL;
-
-	switch (state->tv.mode) {
+	switch (tv_mode) {
 	case DRM_MODE_TV_MODE_NTSC:
-		*val = VC4_VEC_TV_MODE_NTSC;
-		break;
+		return VC4_VEC_TV_MODE_NTSC;
 
 	case DRM_MODE_TV_MODE_NTSC_443:
-		*val = VC4_VEC_TV_MODE_NTSC_443;
-		break;
+		return VC4_VEC_TV_MODE_NTSC_443;
 
 	case DRM_MODE_TV_MODE_NTSC_J:
-		*val = VC4_VEC_TV_MODE_NTSC_J;
-		break;
+		return VC4_VEC_TV_MODE_NTSC_J;
 
 	case DRM_MODE_TV_MODE_PAL:
-		*val = VC4_VEC_TV_MODE_PAL;
-		break;
+		return VC4_VEC_TV_MODE_PAL;
 
 	case DRM_MODE_TV_MODE_PAL_M:
-		*val = VC4_VEC_TV_MODE_PAL_M;
-		break;
+		return VC4_VEC_TV_MODE_PAL_M;
 
 	case DRM_MODE_TV_MODE_PAL_N:
-		*val = VC4_VEC_TV_MODE_PAL_N;
-		break;
+		return VC4_VEC_TV_MODE_PAL_N;
 
 	case DRM_MODE_TV_MODE_SECAM:
-		*val = VC4_VEC_TV_MODE_SECAM;
-		break;
+		return VC4_VEC_TV_MODE_SECAM;
 
 	case DRM_MODE_TV_MODE_MONOCHROME:
-		*val = VC4_VEC_TV_MODE_MONOCHROME;
-		break;
+		return VC4_VEC_TV_MODE_MONOCHROME;
 
 	default:
 		return -EINVAL;
 	}
+}
+
+static int
+vc4_vec_connector_get_property(struct drm_connector *connector,
+			       const struct drm_connector_state *state,
+			       struct drm_property *property,
+			       uint64_t *val)
+{
+	struct vc4_vec *vec = connector_to_vc4_vec(connector);
+	enum vc4_vec_tv_mode_id legacy_mode;
+
+	if (property != vec->legacy_tv_mode_property)
+		return -EINVAL;
+
+	legacy_mode = vc4_vec_generic_tv_mode_to_legacy(state->tv.mode);
+	if (legacy_mode < 0)
+		return legacy_mode;
+
+	*val = legacy_mode;
 
 	return 0;
 }
@@ -496,14 +542,38 @@
 	.atomic_set_property = vc4_vec_connector_set_property,
 };
 
+static int vc4_vec_connector_get_modes(struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+	int count = drm_connector_helper_tv_get_modes(connector);
+
+	mode = drm_mode_duplicate(connector->dev, &drm_mode_240p);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_probed_add(connector, mode);
+	count++;
+
+	mode = drm_mode_duplicate(connector->dev, &drm_mode_288p);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_probed_add(connector, mode);
+	count++;
+
+	return count;
+}
+
 static const struct drm_connector_helper_funcs vc4_vec_connector_helper_funcs = {
 	.atomic_check = drm_atomic_helper_connector_tv_check,
-	.get_modes = drm_connector_helper_tv_get_modes,
+	.get_modes = vc4_vec_connector_get_modes,
 };
 
 static int vc4_vec_connector_init(struct drm_device *dev, struct vc4_vec *vec)
 {
 	struct drm_connector *connector = &vec->connector;
+	enum vc4_vec_tv_mode_id legacy_default_mode;
+	enum drm_connector_tv_mode default_mode;
 	struct drm_property *prop;
 	int ret;
 
@@ -516,9 +586,17 @@
 
 	drm_connector_helper_add(connector, &vc4_vec_connector_helper_funcs);
 
+	default_mode = vc4_vec_get_default_mode(connector);
+	if (default_mode < 0)
+		return default_mode;
+
 	drm_object_attach_property(&connector->base,
 				   dev->mode_config.tv_mode_property,
-				   DRM_MODE_TV_MODE_NTSC);
+				   default_mode);
+
+	legacy_default_mode = vc4_vec_generic_tv_mode_to_legacy(default_mode);
+	if (legacy_default_mode < 0)
+		return legacy_default_mode;
 
 	prop = drm_property_create_enum(dev, 0, "mode",
 					legacy_tv_mode_names,
@@ -527,7 +605,7 @@
 		return -ENOMEM;
 	vec->legacy_tv_mode_property = prop;
 
-	drm_object_attach_property(&connector->base, prop, VC4_VEC_TV_MODE_NTSC);
+	drm_object_attach_property(&connector->base, prop, legacy_default_mode);
 
 	drm_connector_attach_tv_margin_properties(connector);
 
@@ -854,3 +932,10 @@
 		.of_match_table = vc4_vec_dt_match,
 	},
 };
+
+module_param_named(tv_norm, vc4_vec_tv_norm, charp, 0600);
+MODULE_PARM_DESC(tv_norm, "Default TV norm.\n"
+		 "\t\tSupported: NTSC, NTSC-J, NTSC-443, PAL, PAL-M, PAL-N,\n"
+		 "\t\t\tPAL60, SECAM.\n"
+		 "\t\tDefault: PAL if a 50 Hz mode has been set via video=,\n"
+		 "\t\t\tNTSC otherwise");
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/vc4/vc_image_types.h linux-6.16-rc2/drivers/gpu/drm/vc4/vc_image_types.h
--- linux-6.16-rc2/drivers/gpu/drm/vc4/vc_image_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.16-rc2/drivers/gpu/drm/vc4/vc_image_types.h	2025-06-16 17:40:50.791684722 +0200
@@ -0,0 +1,175 @@
+
+/*
+ * Copyright (c) 2012, Broadcom Europe Ltd
+ *
+ * Values taken from vc_image_types.h released by Broadcom at
+ * https://github.com/raspberrypi/userland/blob/master/interface/vctypes/vc_image_types.h
+ * and vc_image_structs.h at
+ * https://github.com/raspberrypi/userland/blob/master/interface/vctypes/vc_image_structs.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+enum {
+	VC_IMAGE_MIN = 0, //bounds for error checking
+
+	VC_IMAGE_RGB565 = 1,
+	VC_IMAGE_1BPP,
+	VC_IMAGE_YUV420,
+	VC_IMAGE_48BPP,
+	VC_IMAGE_RGB888,
+	VC_IMAGE_8BPP,
+	/* 4bpp palettised image */
+	VC_IMAGE_4BPP,
+	/* A separated format of 16 colour/light shorts followed by 16 z
+	 * values
+	 */
+	VC_IMAGE_3D32,
+	/* 16 colours followed by 16 z values */
+	VC_IMAGE_3D32B,
+	/* A separated format of 16 material/colour/light shorts followed by
+	 * 16 z values
+	 */
+	VC_IMAGE_3D32MAT,
+	/* 32 bit format containing 18 bits of 6.6.6 RGB, 9 bits per short */
+	VC_IMAGE_RGB2X9,
+	/* 32-bit format holding 18 bits of 6.6.6 RGB */
+	VC_IMAGE_RGB666,
+	/* 4bpp palettised image with embedded palette */
+	VC_IMAGE_PAL4_OBSOLETE,
+	/* 8bpp palettised image with embedded palette */
+	VC_IMAGE_PAL8_OBSOLETE,
+	/* RGB888 with an alpha byte after each pixel */
+	VC_IMAGE_RGBA32,
+	/* a line of Y (32-byte padded), a line of U (16-byte padded), and a
+	 * line of V (16-byte padded)
+	 */
+	VC_IMAGE_YUV422,
+	/* RGB565 with a transparent patch */
+	VC_IMAGE_RGBA565,
+	/* Compressed (4444) version of RGBA32 */
+	VC_IMAGE_RGBA16,
+	/* VCIII codec format */
+	VC_IMAGE_YUV_UV,
+	/* VCIII T-format RGBA8888 */
+	VC_IMAGE_TF_RGBA32,
+	/* VCIII T-format RGBx8888 */
+	VC_IMAGE_TF_RGBX32,
+	/* VCIII T-format float */
+	VC_IMAGE_TF_FLOAT,
+	/* VCIII T-format RGBA4444 */
+	VC_IMAGE_TF_RGBA16,
+	/* VCIII T-format RGB5551 */
+	VC_IMAGE_TF_RGBA5551,
+	/* VCIII T-format RGB565 */
+	VC_IMAGE_TF_RGB565,
+	/* VCIII T-format 8-bit luma and 8-bit alpha */
+	VC_IMAGE_TF_YA88,
+	/* VCIII T-format 8 bit generic sample */
+	VC_IMAGE_TF_BYTE,
+	/* VCIII T-format 8-bit palette */
+	VC_IMAGE_TF_PAL8,
+	/* VCIII T-format 4-bit palette */
+	VC_IMAGE_TF_PAL4,
+	/* VCIII T-format Ericsson Texture Compressed */
+	VC_IMAGE_TF_ETC1,
+	/* RGB888 with R & B swapped */
+	VC_IMAGE_BGR888,
+	/* RGB888 with R & B swapped, but with no pitch, i.e. no padding after
+	 * each row of pixels
+	 */
+	VC_IMAGE_BGR888_NP,
+	/* Bayer image, extra defines which variant is being used */
+	VC_IMAGE_BAYER,
+	/* General wrapper for codec images e.g. JPEG from camera */
+	VC_IMAGE_CODEC,
+	/* VCIII codec format */
+	VC_IMAGE_YUV_UV32,
+	/* VCIII T-format 8-bit luma */
+	VC_IMAGE_TF_Y8,
+	/* VCIII T-format 8-bit alpha */
+	VC_IMAGE_TF_A8,
+	/* VCIII T-format 16-bit generic sample */
+	VC_IMAGE_TF_SHORT,
+	/* VCIII T-format 1bpp black/white */
+	VC_IMAGE_TF_1BPP,
+	VC_IMAGE_OPENGL,
+	/* VCIII-B0 HVS YUV 4:4:4 interleaved samples */
+	VC_IMAGE_YUV444I,
+	/* Y, U, & V planes separately (VC_IMAGE_YUV422 has them interleaved on
+	 * a per line basis)
+	 */
+	VC_IMAGE_YUV422PLANAR,
+	/* 32bpp with 8bit alpha at MS byte, with R, G, B (LS byte) */
+	VC_IMAGE_ARGB8888,
+	/* 32bpp with 8bit unused at MS byte, with R, G, B (LS byte) */
+	VC_IMAGE_XRGB8888,
+
+	/* interleaved 8 bit samples of Y, U, Y, V (4 flavours) */
+	VC_IMAGE_YUV422YUYV,
+	VC_IMAGE_YUV422YVYU,
+	VC_IMAGE_YUV422UYVY,
+	VC_IMAGE_YUV422VYUY,
+
+	/* 32bpp like RGBA32 but with unused alpha */
+	VC_IMAGE_RGBX32,
+	/* 32bpp, corresponding to RGBA with unused alpha */
+	VC_IMAGE_RGBX8888,
+	/* 32bpp, corresponding to BGRA with unused alpha */
+	VC_IMAGE_BGRX8888,
+
+	/* Y as a plane, then UV byte interleaved in plane with same pitch,
+	 * half height
+	 */
+	VC_IMAGE_YUV420SP,
+
+	/* Y, U, & V planes separately 4:4:4 */
+	VC_IMAGE_YUV444PLANAR,
+
+	/* T-format 8-bit U - same as TF_Y8 buf from U plane */
+	VC_IMAGE_TF_U8,
+	/* T-format 8-bit U - same as TF_Y8 buf from V plane */
+	VC_IMAGE_TF_V8,
+
+	/* YUV4:2:0 planar, 16bit values */
+	VC_IMAGE_YUV420_16,
+	/* YUV4:2:0 codec format, 16bit values */
+	VC_IMAGE_YUV_UV_16,
+	/* YUV4:2:0 with U,V in side-by-side format */
+	VC_IMAGE_YUV420_S,
+	/* 10-bit YUV 420 column image format */
+	VC_IMAGE_YUV10COL,
+	/* 32-bpp, 10-bit R/G/B, 2-bit Alpha */
+	VC_IMAGE_RGBA1010102,
+
+	VC_IMAGE_MAX,     /* bounds for error checking */
+	VC_IMAGE_FORCE_ENUM_16BIT = 0xffff,
+};
+
+enum {
+	/* Unknown or unset - defaults to BT601 interstitial */
+	VC_IMAGE_YUVINFO_UNSPECIFIED    = 0,
+
+	/* colour-space conversions data [4 bits] */
+
+	/* ITU-R BT.601-5 [SDTV] (compatible with VideoCore-II) */
+	VC_IMAGE_YUVINFO_CSC_ITUR_BT601      = 1,
+	/* ITU-R BT.709-3 [HDTV] */
+	VC_IMAGE_YUVINFO_CSC_ITUR_BT709      = 2,
+	/* JPEG JFIF */
+	VC_IMAGE_YUVINFO_CSC_JPEG_JFIF       = 3,
+	/* Title 47 Code of Federal Regulations (2003) 73.682 (a) (20) */
+	VC_IMAGE_YUVINFO_CSC_FCC             = 4,
+	/* Society of Motion Picture and Television Engineers 240M (1999) */
+	VC_IMAGE_YUVINFO_CSC_SMPTE_240M      = 5,
+	/* ITU-R BT.470-2 System M */
+	VC_IMAGE_YUVINFO_CSC_ITUR_BT470_2_M  = 6,
+	/* ITU-R BT.470-2 System B,G */
+	VC_IMAGE_YUVINFO_CSC_ITUR_BT470_2_BG = 7,
+	/* JPEG JFIF, but with 16..255 luma */
+	VC_IMAGE_YUVINFO_CSC_JPEG_JFIF_Y16_255 = 8,
+	/* Rec 2020 */
+	VC_IMAGE_YUVINFO_CSC_REC_2020        = 9,
+};
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/include/drm/drm_color_mgmt.h linux-6.16-rc2/include/drm/drm_color_mgmt.h
--- linux-6.16-rc2/include/drm/drm_color_mgmt.h	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/include/drm/drm_color_mgmt.h	2025-06-16 17:40:50.795018056 +0200
@@ -91,6 +91,9 @@
 				      enum drm_color_encoding default_encoding,
 				      enum drm_color_range default_range);
 
+int drm_plane_create_chroma_siting_properties(struct drm_plane *plane,
+						int32_t default_chroma_siting_h, int32_t default_chroma_siting_v);
+
 /**
  * enum drm_color_lut_tests - hw-specific LUT tests to perform
  *
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/include/drm/drm_plane.h linux-6.16-rc2/include/drm/drm_plane.h
--- linux-6.16-rc2/include/drm/drm_plane.h	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/include/drm/drm_plane.h	2025-06-16 17:40:50.795018056 +0200
@@ -184,6 +184,24 @@
 	enum drm_color_range color_range;
 
 	/**
+	 * @chroma_siting_h:
+	 *
+	 * Location of chroma samples horizontally compared to luma
+	 * 0 means chroma is sited with left luma
+	 * 0x8000 is interstitial. 0x10000 is sited with right luma
+	 */
+	int32_t chroma_siting_h;
+
+	/**
+	 * @chroma_siting_v:
+	 *
+	 * Location of chroma samples vertically compared to luma
+	 * 0 means chroma is sited with top luma
+	 * 0x8000 is interstitial. 0x10000 is sited with bottom luma
+	 */
+	int32_t chroma_siting_v;
+
+	/**
 	 * @fb_damage_clips:
 	 *
 	 * Blob representing damage (area in plane framebuffer that changed
@@ -800,9 +818,22 @@
 	struct drm_property *hotspot_y_property;
 
 	/**
-	 * @kmsg_panic: Used to register a panic notifier for this plane
+	 * @chroma_siting_h_property:
+	 *
+	 * Optional "CHROMA_SITING_H" property for specifying
+	 * chroma siting for YUV formats.
+	 * See drm_plane_create_chroma_siting_properties().
 	 */
-	struct kmsg_dumper kmsg_panic;
+	struct drm_property *chroma_siting_h_property;
+
+	/**
+	 * @chroma_siting_v_property:
+	 *
+	 * Optional "CHROMA_SITING_V" property for specifying
+	 * chroma siting for YUV formats.
+	 * See drm_plane_create_chroma_siting_properties().
+	 */
+	struct drm_property *chroma_siting_v_property;
 };
 
 #define obj_to_plane(x) container_of(x, struct drm_plane, base)
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/include/soc/bcm2835/raspberrypi-firmware.h linux-6.16-rc2/include/soc/bcm2835/raspberrypi-firmware.h
--- linux-6.16-rc2/include/soc/bcm2835/raspberrypi-firmware.h	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/include/soc/bcm2835/raspberrypi-firmware.h	2025-06-16 17:40:50.795018056 +0200
@@ -36,6 +36,8 @@
 enum rpi_firmware_property_tag {
 	RPI_FIRMWARE_PROPERTY_END =                           0,
 	RPI_FIRMWARE_GET_FIRMWARE_REVISION =                  0x00000001,
+	RPI_FIRMWARE_GET_FIRMWARE_VARIANT =                   0x00000002,
+	RPI_FIRMWARE_GET_FIRMWARE_HASH =                      0x00000003,
 
 	RPI_FIRMWARE_SET_CURSOR_INFO =                        0x00008010,
 	RPI_FIRMWARE_SET_CURSOR_STATE =                       0x00008011,
@@ -71,6 +73,7 @@
 	RPI_FIRMWARE_GET_DISPMANX_RESOURCE_MEM_HANDLE =       0x00030014,
 	RPI_FIRMWARE_GET_EDID_BLOCK =                         0x00030020,
 	RPI_FIRMWARE_GET_CUSTOMER_OTP =                       0x00030021,
+	RPI_FIRMWARE_GET_EDID_BLOCK_DISPLAY =                 0x00030023,
 	RPI_FIRMWARE_GET_DOMAIN_STATE =                       0x00030030,
 	RPI_FIRMWARE_GET_THROTTLED =                          0x00030046,
 	RPI_FIRMWARE_GET_CLOCK_MEASURED =                     0x00030047,
@@ -89,8 +92,11 @@
 	RPI_FIRMWARE_GET_PERIPH_REG =                         0x00030045,
 	RPI_FIRMWARE_SET_PERIPH_REG =                         0x00038045,
 	RPI_FIRMWARE_GET_POE_HAT_VAL =                        0x00030049,
-	RPI_FIRMWARE_SET_POE_HAT_VAL =                        0x00030050,
+	RPI_FIRMWARE_SET_POE_HAT_VAL =                        0x00038049,
+	RPI_FIRMWARE_SET_POE_HAT_VAL_OLD =                    0x00030050,
 	RPI_FIRMWARE_NOTIFY_XHCI_RESET =                      0x00030058,
+	RPI_FIRMWARE_GET_REBOOT_FLAGS =                       0x00030064,
+	RPI_FIRMWARE_SET_REBOOT_FLAGS =                       0x00038064,
 	RPI_FIRMWARE_NOTIFY_DISPLAY_DONE =                    0x00030066,
 
 	/* Dispmanx TAGS */
@@ -105,9 +111,16 @@
 	RPI_FIRMWARE_FRAMEBUFFER_GET_VIRTUAL_OFFSET =         0x00040009,
 	RPI_FIRMWARE_FRAMEBUFFER_GET_OVERSCAN =               0x0004000a,
 	RPI_FIRMWARE_FRAMEBUFFER_GET_PALETTE =                0x0004000b,
+	RPI_FIRMWARE_FRAMEBUFFER_GET_LAYER =                  0x0004000c,
+	RPI_FIRMWARE_FRAMEBUFFER_GET_TRANSFORM =              0x0004000d,
+	RPI_FIRMWARE_FRAMEBUFFER_GET_VSYNC =                  0x0004000e,
 	RPI_FIRMWARE_FRAMEBUFFER_GET_TOUCHBUF =               0x0004000f,
 	RPI_FIRMWARE_FRAMEBUFFER_GET_GPIOVIRTBUF =            0x00040010,
 	RPI_FIRMWARE_FRAMEBUFFER_RELEASE =                    0x00048001,
+	RPI_FIRMWARE_FRAMEBUFFER_GET_DISPLAY_ID =             0x00040016,
+	RPI_FIRMWARE_FRAMEBUFFER_SET_DISPLAY_NUM =            0x00048013,
+	RPI_FIRMWARE_FRAMEBUFFER_GET_NUM_DISPLAYS =           0x00040013,
+	RPI_FIRMWARE_FRAMEBUFFER_GET_DISPLAY_SETTINGS =       0x00040014,
 	RPI_FIRMWARE_FRAMEBUFFER_TEST_PHYSICAL_WIDTH_HEIGHT = 0x00044003,
 	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_WIDTH_HEIGHT =  0x00044004,
 	RPI_FIRMWARE_FRAMEBUFFER_TEST_DEPTH =                 0x00044005,
@@ -116,22 +129,33 @@
 	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_OFFSET =        0x00044009,
 	RPI_FIRMWARE_FRAMEBUFFER_TEST_OVERSCAN =              0x0004400a,
 	RPI_FIRMWARE_FRAMEBUFFER_TEST_PALETTE =               0x0004400b,
+	RPI_FIRMWARE_FRAMEBUFFER_TEST_LAYER =                 0x0004400c,
+	RPI_FIRMWARE_FRAMEBUFFER_TEST_TRANSFORM =             0x0004400d,
 	RPI_FIRMWARE_FRAMEBUFFER_TEST_VSYNC =                 0x0004400e,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_PHYSICAL_WIDTH_HEIGHT =  0x00048003,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_WIDTH_HEIGHT =   0x00048004,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_DEPTH =                  0x00048005,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_PIXEL_ORDER =            0x00048006,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_ALPHA_MODE =             0x00048007,
+	RPI_FIRMWARE_FRAMEBUFFER_SET_PITCH =                  0x00048008,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_OFFSET =         0x00048009,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_OVERSCAN =               0x0004800a,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_PALETTE =                0x0004800b,
+
 	RPI_FIRMWARE_FRAMEBUFFER_SET_TOUCHBUF =               0x0004801f,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_GPIOVIRTBUF =            0x00048020,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_VSYNC =                  0x0004800e,
+	RPI_FIRMWARE_FRAMEBUFFER_SET_LAYER =                  0x0004800c,
+	RPI_FIRMWARE_FRAMEBUFFER_SET_TRANSFORM =              0x0004800d,
 	RPI_FIRMWARE_FRAMEBUFFER_SET_BACKLIGHT =              0x0004800f,
 
 	RPI_FIRMWARE_VCHIQ_INIT =                             0x00048010,
 
+	RPI_FIRMWARE_SET_PLANE =                              0x00048015,
+	RPI_FIRMWARE_GET_DISPLAY_TIMING =                     0x00040017,
+	RPI_FIRMWARE_SET_TIMING =                             0x00048017,
+	RPI_FIRMWARE_GET_DISPLAY_CFG =                        0x00040018,
+	RPI_FIRMWARE_SET_DISPLAY_POWER =		      0x00048019,
 	RPI_FIRMWARE_GET_COMMAND_LINE =                       0x00050001,
 	RPI_FIRMWARE_GET_DMA_CHANNELS =                       0x00060001,
 };
@@ -156,6 +180,8 @@
 	RPI_FIRMWARE_NUM_CLK_ID,
 };
 
+#define GET_DISPLAY_SETTINGS_PAYLOAD_SIZE 64
+
 /**
  * struct rpi_firmware_clk_rate_request - Firmware Request for a rate
  * @id:	ID of the clock being queried
