From 44d54f1f19cbff630f96a55bb6f635dcfd26cf9d Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Wed, 4 Dec 2024 13:26:13 +0200
Subject: [PATCH 097/112] [WIP-YUV420] drm/rockchip: vop2: Add YUV420 output
 format support

TODO: proper colorspace conversion handling

Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/gpu/drm/rockchip/rockchip_drm_drv.h  |  2 +
 drivers/gpu/drm/rockchip/rockchip_drm_vop2.c | 43 ++++++++++++++++++++
 drivers/gpu/drm/rockchip/rockchip_drm_vop2.h |  3 ++
 3 files changed, 48 insertions(+)

diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_drv.h b/drivers/gpu/drm/rockchip/rockchip_drm_drv.h
index 2e86ad00979..084a383da30 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_drv.h
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_drv.h
@@ -57,6 +57,8 @@ struct rockchip_crtc_state {
 #define to_rockchip_crtc_state(s) \
 		container_of(s, struct rockchip_crtc_state, base)
 
+int rockchip_drm_colorimetry_to_v4l_colorspace(int drm_colorspace);
+
 /*
  * Rockchip drm private structure.
  *
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c
index cd70928acf0..949401cf69e 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c
@@ -656,6 +656,39 @@ static void vop2_setup_scale(struct vop2 *vop2, const struct vop2_win *win,
 	}
 }
 
+/*
+ * Convert drm_colorspace to v4l2_colorspace.
+ *
+ * TODO: this should be moved to rockchip_drm_drv.c but it requires
+ * including <uapi/linux/videodev2.h> which is not used elsewere.
+ */
+int rockchip_drm_colorimetry_to_v4l_colorspace(int drm_colorspace)
+{
+	switch (drm_colorspace) {
+	case DRM_MODE_COLORIMETRY_SMPTE_170M_YCC:
+	case DRM_MODE_COLORIMETRY_XVYCC_601:
+	case DRM_MODE_COLORIMETRY_SYCC_601:
+	case DRM_MODE_COLORIMETRY_OPYCC_601:
+	case DRM_MODE_COLORIMETRY_BT601_YCC:
+		return V4L2_COLORSPACE_SMPTE170M;
+
+	default:
+	case DRM_MODE_COLORIMETRY_NO_DATA:
+	case DRM_MODE_COLORIMETRY_BT709_YCC:
+	case DRM_MODE_COLORIMETRY_XVYCC_709:
+	case DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED:
+	case DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT:
+		return V4L2_COLORSPACE_DEFAULT;
+
+	case DRM_MODE_COLORIMETRY_BT2020_CYCC:
+	case DRM_MODE_COLORIMETRY_BT2020_YCC:
+	case DRM_MODE_COLORIMETRY_BT2020_RGB:
+	case DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65:
+	case DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER:
+		return V4L2_COLORSPACE_BT2020;
+	}
+}
+
 static int vop2_convert_csc_mode(int csc_mode)
 {
 	switch (csc_mode) {
@@ -1549,6 +1582,7 @@ static void vop2_post_config(struct drm_crtc *crtc)
 	struct vop2_video_port *vp = to_vop2_video_port(crtc);
 	struct vop2 *vop2 = vp->vop2;
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	struct rockchip_crtc_state *vcstate = to_rockchip_crtc_state(crtc->state);
 	u64 bgcolor = crtc->state->background_color;
 	u16 vtotal = mode->crtc_vtotal;
 	u16 hdisplay = mode->crtc_hdisplay;
@@ -1600,6 +1634,15 @@ static void vop2_post_config(struct drm_crtc *crtc)
 	val |= FIELD_PREP(RK3568_VP_DSP_BG__DSP_BG_GREEN, DRM_ARGB64_GETG_BPC(bgcolor, 10));
 	val |= FIELD_PREP(RK3568_VP_DSP_BG__DSP_BG_BLUE, DRM_ARGB64_GETB_BPC(bgcolor, 10));
 	vop2_vp_write(vp, RK3568_VP_DSP_BG, val);
+
+	if (vcstate->output_mode == ROCKCHIP_OUT_MODE_YUV420) {
+		val = RK3568_VP_BCSH_CTRL__BCSH_R2Y_EN;
+		u32 csc_mode = vop2_convert_csc_mode(vcstate->color_space);
+		val |= FIELD_PREP(RK3568_VP_BCSH_CTRL__BCSH_R2Y_CSC_MODE, csc_mode);
+	} else {
+		val = 0;
+	}
+	vop2_vp_write(vp, RK3568_VP_BCSH_CTRL, val);
 }
 
 static int us_to_vertical_line(struct drm_display_mode *mode, int us)
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop2.h b/drivers/gpu/drm/rockchip/rockchip_drm_vop2.h
index b8198714c1c..95f13de1ae6 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop2.h
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop2.h
@@ -674,6 +674,9 @@ enum dst_factor_mode {
 #define RK3568_VP_POST_SCL_CTRL__VSCALEDOWN		BIT(1)
 #define RK3568_VP_POST_SCL_CTRL__HSCALEDOWN		BIT(0)
 
+#define RK3568_VP_BCSH_CTRL__BCSH_R2Y_CSC_MODE		GENMASK(7, 6)
+#define RK3568_VP_BCSH_CTRL__BCSH_R2Y_EN		BIT(4)
+
 #define RK3568_SYS_DSP_INFACE_EN_LVDS1_MUX		GENMASK(26, 25)
 #define RK3568_SYS_DSP_INFACE_EN_LVDS1			BIT(24)
 #define RK3568_SYS_DSP_INFACE_EN_MIPI1_MUX		GENMASK(22, 21)
-- 
2.46.0

From c24cdce2e96208003694e4feb865b030e48efd3b Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Wed, 4 Dec 2024 14:09:35 +0200
Subject: [PATCH 098/112] [WIP-YUV420] drm/rockchip: dw_hdmi_qp: Add YUV420
 output format support

Program the necessary bridge registers to allow using the YUV420 color
format.

Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 .../gpu/drm/rockchip/dw_hdmi_qp-rockchip.c    | 27 ++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/rockchip/dw_hdmi_qp-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi_qp-rockchip.c
index 4711ef5f515..d03a5dd3e2e 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi_qp-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi_qp-rockchip.c
@@ -9,6 +9,7 @@
 
 #include <linux/clk.h>
 #include <linux/gpio/consumer.h>
+#include <linux/hdmi.h>
 #include <linux/hw_bitfield.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
@@ -140,6 +141,14 @@ dw_hdmi_qp_rockchip_encoder_atomic_check(struct drm_encoder *encoder,
 	union phy_configure_opts phy_cfg = {};
 	int ret;
 
+	switch (conn_state->hdmi.output_format) {
+	case HDMI_COLORSPACE_YUV420:
+		s->output_mode = ROCKCHIP_OUT_MODE_YUV420;
+		break;
+	default:
+		s->output_mode = ROCKCHIP_OUT_MODE_AAAA;
+	}
+
 	if (hdmi->tmds_char_rate == conn_state->hdmi.tmds_char_rate &&
 	    s->output_bpc == conn_state->hdmi.output_bpc)
 		return 0;
@@ -150,9 +159,13 @@ dw_hdmi_qp_rockchip_encoder_atomic_check(struct drm_encoder *encoder,
 	ret = phy_configure(hdmi->phy, &phy_cfg);
 	if (!ret) {
 		hdmi->tmds_char_rate = conn_state->hdmi.tmds_char_rate;
-		s->output_mode = ROCKCHIP_OUT_MODE_AAAA;
 		s->output_type = DRM_MODE_CONNECTOR_HDMIA;
 		s->output_bpc = conn_state->hdmi.output_bpc;
+		/*
+		 * TODO: Adapt for vop2_convert_csc_mode() which uses v4l2_colorspace
+		 * instead of drm_colorspace.
+		 */
+		s->color_space = rockchip_drm_colorimetry_to_v4l_colorspace(conn_state->colorspace);
 	} else {
 		dev_err(hdmi->dev, "Failed to configure phy: %d\n", ret);
 	}
@@ -398,6 +411,11 @@ static void dw_hdmi_qp_rk3576_enc_init(struct rockchip_hdmi_qp *hdmi,
 	else
 		val = FIELD_PREP_WM16(RK3576_COLOR_DEPTH_MASK, RK3576_8BPC);
 
+	if (state->output_mode == ROCKCHIP_OUT_MODE_YUV420)
+		val |= FIELD_PREP_WM16(RK3576_COLOR_FORMAT_MASK, RK3576_YUV420);
+	else
+		val |= FIELD_PREP_WM16(RK3576_COLOR_FORMAT_MASK, RK3576_RGB);
+
 	regmap_write(hdmi->vo_regmap, RK3576_VO0_GRF_SOC_CON8, val);
 }
 
@@ -411,6 +429,11 @@ static void dw_hdmi_qp_rk3588_enc_init(struct rockchip_hdmi_qp *hdmi,
 	else
 		val = FIELD_PREP_WM16(RK3588_COLOR_DEPTH_MASK, RK3588_8BPC);
 
+	if (state->output_mode == ROCKCHIP_OUT_MODE_YUV420)
+		val |= FIELD_PREP_WM16(RK3588_COLOR_FORMAT_MASK, RK3588_YUV420);
+	else
+		val |= FIELD_PREP_WM16(RK3588_COLOR_FORMAT_MASK, RK3588_RGB);
+
 	regmap_write(hdmi->vo_regmap,
 		     hdmi->port_id ? RK3588_GRF_VO1_CON6 : RK3588_GRF_VO1_CON3,
 		     val);
@@ -519,6 +542,8 @@ static int dw_hdmi_qp_rockchip_bind(struct device *dev, struct device *master,
 
 	plat_data.phy_ops = cfg->phy_ops;
 	plat_data.phy_data = hdmi;
+	plat_data.supported_formats = BIT(HDMI_COLORSPACE_RGB) |
+				      BIT(HDMI_COLORSPACE_YUV420);
 	plat_data.max_bpc = 10;
 
 	encoder = &hdmi->encoder.encoder;
-- 
2.46.0

