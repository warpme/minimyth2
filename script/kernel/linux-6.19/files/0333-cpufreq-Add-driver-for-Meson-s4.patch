
From: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Subject: [PATCH] WiP: meson-s4 cpufreq

Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
---
 ...amlogic,meson-s4-cpu-operating-points.yaml |  77 ++++++
 drivers/cpufreq/Kconfig.arm                   |  10 +
 drivers/cpufreq/Makefile                      |   1 +
 drivers/cpufreq/cpufreq-dt-platdev.c          |   1 +
 drivers/cpufreq/meson-s4-cpufreq.c            | 251 ++++++++++++++++++
 8 files changed, 458 insertions(+), 1 deletion(-)
 create mode 100644 Documentation/devicetree/bindings/opp/amlogic,meson-s4-cpu-operating-points.yaml
 create mode 100644 arch/arm64/boot/dts/amlogic/meson-s4-s805x2.dtsi
 create mode 100644 drivers/cpufreq/meson-s4-cpufreq.c

diff --git a/Documentation/devicetree/bindings/opp/amlogic,meson-s4-cpu-operating-points.yaml b/Documentation/devicetree/bindings/opp/amlogic,meson-s4-cpu-operating-points.yaml
new file mode 100644
index 00000000000000..c8d6c9dec166ba
--- /dev/null
+++ b/Documentation/devicetree/bindings/opp/amlogic,meson-s4-cpu-operating-points.yaml
@@ -0,0 +1,77 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/opp/amlogic,meson-s4-cpu-operating-points.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Amlogic Meson-S4 CPU OPP
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+description: |
+  On Amlogic Meson-S4 SoCs the voltages of the CPU OPPs depend on the
+  silicon quality. The secure monitor firmware exposes the silicon
+  binning information, where higher bins are of better silicon quality
+  (meaning: the same frequency requires lower operating voltages).
+
+allOf:
+  - $ref: opp-v2-base.yaml#
+
+properties:
+  compatible:
+    const: amlogic,meson-s4-cpu-operating-points
+
+  secure-monitor:
+    description: phandle to the secure-monitor node
+    $ref: /schemas/types.yaml#/definitions/phandle
+
+  opp-shared: true
+
+required:
+  - compatible
+
+patternProperties:
+  "^opp-[0-9]+$":
+    type: object
+
+    properties:
+      opp-hz: true
+      clock-latency-ns: true
+      opp-microvolt: true
+
+    patternProperties:
+      "^opp-microvolt-bin[0-9]$": true
+
+    required:
+      - opp-hz
+
+    unevaluatedProperties: false
+
+additionalProperties: false
+
+examples:
+  - |
+    cpu_opp_table: opp-table {
+        compatible = "amlogic,meson-s4-cpu-operating-points";
+        secure-monitor = <&sm>;
+        opp-shared;
+
+        opp-100000000 {
+            opp-hz = /bits/ 64 <100000000>;
+            opp-microvolt-bin0 = <769000>;
+            opp-microvolt-bin1 = <769000>;
+            opp-microvolt-bin2 = <759000>;
+            opp-microvolt-bin3 = <759000>;
+            clock-latency-ns = <50000>;
+        };
+
+        opp-1800000000 {
+            opp-hz = /bits/ 64 <1704000000>;
+            opp-microvolt-bin0 = <1009000>;
+            opp-microvolt-bin1 = <1009000>;
+            opp-microvolt-bin2 = <999000>;
+            opp-microvolt-bin3 = <939000>;
+            clock-latency-ns = <50000>;
+        };
+    };
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index 26a7ae265b170c..be0f1453b96e27 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -141,6 +141,7 @@ config ARM_MEDIATEK_CPUFREQ_HW
 	  The driver implements the cpufreq interface for this HW engine.
 	  Say Y if you want to support CPUFreq HW.
 
+
 config ARM_MESON8_SOC_CPUFREQ
 	tristate "Amlogic Meson8/8b/8m2 SoC CPUFreq support"
 	depends on (ARCH_MESON && ARM) || COMPILE_TEST
@@ -149,6 +150,15 @@ config ARM_MESON8_SOC_CPUFREQ
 	help
 	  This adds the CPUFreq driver for Amlogic Meson8/8b/8m2 SoCs.
 
+config ARM_MESON_S4_SOC_CPUFREQ
+	tristate "Amlogic Meson-S4 SoC CPUFreq support"
+	depends on ARCH_MESON || COMPILE_TEST
+	depends on MESON_SM
+	depends on CPUFREQ_DT
+	default ARCH_MESON
+	help
+	  This adds the CPUFreq driver for Amlogic Meson-S4 SoCs.
+
 config ARM_OMAP2PLUS_CPUFREQ
 	bool "TI OMAP2+"
 	depends on ARCH_OMAP2PLUS || COMPILE_TEST
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 46d872bc2bcb68..3ec70f4588369e 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -69,6 +69,7 @@ obj-$(CONFIG_ARM_KIRKWOOD_CPUFREQ)	+= kirkwood-cpufreq.o
 obj-$(CONFIG_ARM_MEDIATEK_CPUFREQ)	+= mediatek-cpufreq.o
 obj-$(CONFIG_ARM_MEDIATEK_CPUFREQ_HW)	+= mediatek-cpufreq-hw.o
 obj-$(CONFIG_ARM_MESON8_SOC_CPUFREQ)	+= meson8-cpufreq.o
+obj-$(CONFIG_ARM_MESON_S4_SOC_CPUFREQ)	+= meson-s4-cpufreq.o
 obj-$(CONFIG_MACH_MVEBU_V7)		+= mvebu-cpufreq.o
 obj-$(CONFIG_ARM_OMAP2PLUS_CPUFREQ)	+= omap-cpufreq.o
 obj-$(CONFIG_ARM_PXA2xx_CPUFREQ)	+= pxa2xx-cpufreq.o
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index 8228505aae6754..ee9dd26a11c799 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -116,6 +116,7 @@ static const struct of_device_id blocklist[] __initconst = {
 	{ .compatible = "amlogic,meson8", },
 	{ .compatible = "amlogic,meson8b", },
 	{ .compatible = "amlogic,meson8m2", },
+	{ .compatible = "amlogic,meson-s4", },
 
 	{ .compatible = "apple,arm-platform", },
 
diff --git a/drivers/cpufreq/meson-s4-cpufreq.c b/drivers/cpufreq/meson-s4-cpufreq.c
new file mode 100644
index 00000000000000..476f21edc0cef1
--- /dev/null
+++ b/drivers/cpufreq/meson-s4-cpufreq.c
@@ -0,0 +1,251 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Amlogic SoCs typically have to update to an intermediate clock for stable
+ * operation when changing the CPU clocks.
+ * Meson-S4 SoCs additionally uses secure monitor firmware to get binning
+ * information (which means that better quality silicon can run a given
+ * frequency at a lower voltage).
+ *
+ * Copyright (C) 2026 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/cpu.h>
+#include <linux/cpufreq.h>
+#include <linux/firmware/meson/meson_sm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/slab.h>
+
+#include "cpufreq-dt.h"
+
+static struct platform_device *meson_s4_cpufreq_pdev, *cpufreq_dt_pdev;
+
+enum meson_s4_cpufreq_meson_clocks {
+	MESON_S4_CPUFREQ_CPU_CLOCK = 0,
+	MESON_S4_CPUFREQ_XTAL_CLOCK,
+	MESON_S4_CPUFREQ_CPU_DYN_CLOCK,
+	MESON_S4_CPUFREQ_SYS_PLL_CLOCK,
+	MESON_S4_CPUFREQ_NUM_CLOCKS,
+};
+
+struct meson_s4_cpufreq_priv {
+	struct clk_bulk_data clks[MESON_S4_CPUFREQ_NUM_CLOCKS];
+	int cpu_opp_tokens[];
+};
+
+static unsigned int meson_s4_cpufreq_get_intermediate(struct cpufreq_policy *policy,
+						      unsigned int index)
+{
+	unsigned int new_rate = policy->freq_table[index].frequency;
+	struct meson_s4_cpufreq_priv *priv;
+	struct clk *cpu_dyn_clk;
+
+	priv = platform_get_drvdata(meson_s4_cpufreq_pdev);
+	cpu_dyn_clk = priv->clks[MESON_S4_CPUFREQ_CPU_DYN_CLOCK].clk;
+
+	return min_t(unsigned int, new_rate, clk_round_rate(cpu_dyn_clk, ~0));
+}
+
+static int meson_s4_cpufreq_target_intermediate(struct cpufreq_policy *policy,
+						unsigned int index)
+{
+	unsigned int new_rate = policy->freq_table[index].frequency;
+	struct meson_s4_cpufreq_priv *priv;
+	struct clk *cpu_dyn_clk;
+	int ret;
+
+	priv = platform_get_drvdata(meson_s4_cpufreq_pdev);
+
+	cpu_dyn_clk = priv->clks[MESON_S4_CPUFREQ_CPU_DYN_CLOCK].clk;
+
+	ret = clk_set_rate(cpu_dyn_clk, new_rate);
+	if (ret)
+		return ret;
+
+	return clk_set_parent(priv->clks[MESON_S4_CPUFREQ_CPU_CLOCK].clk,
+			      cpu_dyn_clk);
+}
+
+static struct cpufreq_dt_platform_data meson_s4_cpufreq_dt_pdata = {
+	.get_intermediate = meson_s4_cpufreq_get_intermediate,
+	.target_intermediate = meson_s4_cpufreq_target_intermediate,
+};
+
+static void meson_s4_cpufreq_clear_opp_tokens(void *data)
+{
+	struct meson_s4_cpufreq_priv *priv = data;
+	unsigned int cpu;
+
+	for_each_present_cpu(cpu)
+		dev_pm_opp_clear_config(priv->cpu_opp_tokens[cpu]);
+}
+
+static int meson_s4_cpufreq_init_opp_tokens(struct meson_s4_cpufreq_priv *priv,
+					    s32 dvfs_table_index)
+{
+	struct dev_pm_opp_config config = {};
+	char name[] = "binXXXXXXXXXXX"; /* Integers can take 11 chars max */
+	struct device *cpu_dev;
+	unsigned int cpu;
+	int ret;
+
+	config.supported_hw = &dvfs_table_index;
+	config.supported_hw_count = 1;
+
+	snprintf(name, sizeof(name), "bin%d", dvfs_table_index);
+	config.prop_name = name;
+
+	for_each_present_cpu(cpu) {
+		cpu_dev = get_cpu_device(cpu);
+		if (!cpu_dev)
+			return -ENODEV;
+
+		ret = dev_pm_opp_set_config(cpu_dev, &config);
+		if (ret < 0)
+			return ret;
+
+		priv->cpu_opp_tokens[cpu] = ret;
+	}
+
+	return 0;
+}
+
+static void meson_s4_cpufreq_put_clks(void *data)
+{
+	struct meson_s4_cpufreq_priv *priv = data;
+
+	clk_bulk_put(MESON_S4_CPUFREQ_NUM_CLOCKS, priv->clks);
+}
+
+static void meson_s4_cpufreq_dt_pdev_unregister(void *data)
+{
+	platform_device_unregister(cpufreq_dt_pdev);
+}
+
+static int meson_s4_cpufreq_probe(struct platform_device *pdev)
+{
+	struct meson_s4_cpufreq_priv *priv;
+	struct meson_sm_firmware *fw;
+	struct device *cpu_dev;
+	s32 dvfs_table_index;
+	int ret;
+
+	cpu_dev = get_cpu_device(0);
+	if (!cpu_dev)
+		return -ENODEV;
+
+	struct device_node *opp_np __free(device_node) =
+		dev_pm_opp_of_get_opp_desc_node(cpu_dev);
+	if (!opp_np)
+		return -ENOENT;
+
+	if (!of_device_is_compatible(opp_np,
+				     "amlogic,meson-s4-cpu-operating-points"))
+		return 0;
+
+	struct device_node *sm_np __free(device_node) =
+			of_parse_phandle(opp_np, "secure-monitor", 0);
+	if (!sm_np)
+		return dev_err_probe(&pdev->dev, -ENODEV,
+				     "Could not get secure-monitor phandle\n");
+
+	fw = meson_sm_get(sm_np);
+	if (!fw)
+		return -EPROBE_DEFER;
+
+	ret = meson_sm_call(fw, SM_S4_GET_DVFS_TABLE_INDEX, &dvfs_table_index,
+			    0, 0, 0, 0, 0);
+	if (ret)
+		return ret;
+
+	priv = devm_kzalloc(&pdev->dev,
+			    struct_size(priv, cpu_opp_tokens, num_possible_cpus()),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->clks[MESON_S4_CPUFREQ_CPU_CLOCK].id = "cpu";
+	priv->clks[MESON_S4_CPUFREQ_XTAL_CLOCK].id = "xtal";
+	priv->clks[MESON_S4_CPUFREQ_CPU_DYN_CLOCK].id = "cpu_dyn";
+	priv->clks[MESON_S4_CPUFREQ_SYS_PLL_CLOCK].id = "sys_pll";
+	ret = clk_bulk_get(cpu_dev, MESON_S4_CPUFREQ_NUM_CLOCKS, priv->clks);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret,
+				     "Failed to get CPU clocks\n");
+
+	ret = devm_add_action_or_reset(&pdev->dev, meson_s4_cpufreq_put_clks,
+				       priv);
+	if (ret)
+		return ret;
+
+	ret = devm_add_action(&pdev->dev, meson_s4_cpufreq_clear_opp_tokens,
+			      priv);
+	if (ret)
+		return ret;
+
+	ret = meson_s4_cpufreq_init_opp_tokens(priv, dvfs_table_index);
+	if (ret)
+		return ret;
+
+	cpufreq_dt_pdev = platform_device_register_data(NULL, "cpufreq-dt", -1,
+							&meson_s4_cpufreq_dt_pdata,
+							sizeof(meson_s4_cpufreq_dt_pdata));
+	if (IS_ERR(cpufreq_dt_pdev))
+		return dev_err_probe(&pdev->dev, PTR_ERR(cpufreq_dt_pdev),
+				     "Failed to register cpufreq-dt platform device\n");
+
+	return devm_add_action_or_reset(&pdev->dev,
+					meson_s4_cpufreq_dt_pdev_unregister,
+					NULL);
+}
+
+static const struct of_device_id meson_s4_cpufreq_of_match_list[] = {
+	{ .compatible = "amlogic,meson-s4", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, meson_s4_cpufreq_of_match_list);
+
+static struct platform_driver meson_s4_cpufreq_driver = {
+	.probe = meson_s4_cpufreq_probe,
+	.driver = {
+		.name = "meson-s4-cpufreq",
+	},
+};
+
+static int __init meson_s4_cpufreq_init(void)
+{
+	const char *platform_id;
+	int ret;
+
+	platform_id = of_machine_get_match_data(meson_s4_cpufreq_of_match_list);
+	if (!platform_id)
+		return -ENODEV;
+
+	ret = platform_driver_register(&meson_s4_cpufreq_driver);
+	if (ret)
+		return ret;
+
+	meson_s4_cpufreq_pdev = platform_device_register_simple("meson-s4-cpufreq",
+								-1, NULL, 0);
+	ret = PTR_ERR_OR_ZERO(meson_s4_cpufreq_pdev);
+	if (ret)
+		platform_driver_unregister(&meson_s4_cpufreq_driver);
+
+	return ret;
+}
+module_init(meson_s4_cpufreq_init);
+
+static void __exit meson_s4_cpufreq_exit(void)
+{
+	platform_device_unregister(meson_s4_cpufreq_pdev);
+	platform_driver_unregister(&meson_s4_cpufreq_driver);
+}
+module_exit(meson_s4_cpufreq_exit);
+
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_DESCRIPTION("Amlogic Meson-S4 cpufreq driver");
+MODULE_LICENSE("GPL v2");
