From 2932399261043dbb75320a40f5dd73171d3dfed5 Mon Sep 17 00:00:00 2001
From: Roger Siddons <dizygotheca@ntlworld.com>
Date: Sat, 22 Aug 2015 14:56:30 +0100
Subject: [PATCH 08/10] Gallery: Redesign to support local media

Current design only manages storage group images.
This rewrite:

- Also manages local media (USBs/CDs etc) attached to frontend.
- Adds caching to improve UI responsiveness
- Improves metadata handling (Exif/Ffmpeg tags)

Image manager is now provided by libmythmetadata.
One instance is used by each frontend to manage local media.
Another instance is used by backend to manage storage group.
UI uses both instances seamlessly.

This patch contains lots of changes but are all internal to Gallery except:

mythcorecontext:   Add support for mythffprobe, used to retrieve metadata tags for videos.
mythuifilebrowser: Reverts changes introduced by 897020. Import dialog (mythuimultifilebrowser) is no longer needed.
mythfrontend/main: Add mediamonitor support & key binding fixes.

diff --git a/mythtv/libs/libmythbase/mythcorecontext.h b/mythtv/libs/libmythbase/mythcorecontext.h
index 3abe59d..c7e28d8 100644
--- a/mythtv/libs/libmythbase/mythcorecontext.h
+++ b/mythtv/libs/libmythbase/mythcorecontext.h
@@ -31,6 +31,7 @@
 #define MYTH_APPNAME_MYTHUTIL "mythutil"
 #define MYTH_APPNAME_MYTHLOGSERVER "mythlogserver"
 #define MYTH_APPNAME_MYTHSCREENWIZARD "mythscreenwizard"
+#define MYTH_APPNAME_MYTHFFPROBE "mythffprobe"
 
 class MDBManager;
 class MythCoreContextPrivate;
diff --git a/mythtv/libs/libmythmetadata/imagemanager.cpp b/mythtv/libs/libmythmetadata/imagemanager.cpp
new file mode 100644
index 0000000..9279a84
--- /dev/null
+++ b/mythtv/libs/libmythmetadata/imagemanager.cpp
@@ -0,0 +1,2447 @@
+#include "imagemanager.h"
+
+#include <QRunnable>
+#include <QImageReader>
+
+#include "dbaccess.h"  // for FileAssociations
+#include "mthreadpool.h"
+#include "mythdate.h"
+#include "mythmediamonitor.h"
+
+
+#define LOC QString("ImageManager: ")
+#define DBLOC QString("ImageDb(%1): ").arg(m_table)
+
+// Must be empty as it's prepended to path
+#define STORAGE_GROUP_MOUNT  ""
+
+#define DB_TABLE "gallery_files"
+
+#define RESULT_ERR(ERR, MESG) \
+{   LOG(VB_GENERAL, LOG_ERR, LOC + MESG); \
+    return QStringList("ERROR") << tr(ERR); }
+
+#define RESULT_OK(MESG) \
+{   LOG(VB_FILE, LOG_DEBUG, LOC + MESG); \
+    return QStringList("OK"); }
+
+
+//! A device containing images (ie. USB stick, CD, storage group etc)
+class Device
+{
+public:
+    Device(const QString &name, const QString &mount,
+           MythMediaDevice *media = NULL, QTemporaryDir *import = NULL)
+        : m_present(true), m_name(name), m_mount(mount),
+          m_media(media), m_dir(import)
+    {
+        // Path relative to TEMP storage group
+        m_thumbs = QString("%1/%2").arg(THUMBNAIL_SUBDIR, m_name);
+    }
+
+
+    //! Delete device, its thumbnails and any imported images
+    ~Device()
+    {
+        Close();
+
+        // Remove imported images
+        if (m_dir)
+            delete m_dir;
+
+        // Clean up non-SG thumbnails
+        if (m_mount != STORAGE_GROUP_MOUNT)
+            RemoveThumbs();
+    }
+
+
+    //! Releases device
+    void Close(bool eject = false)
+    {
+        // Imports remain present; others do not
+        m_present = isImport();
+
+        // Release device
+        if (m_media)
+        {
+            if (eject)
+            {
+                LOG(VB_GENERAL, LOG_INFO, LOC + QString("Ejecting '%1' at '%2'")
+                    .arg(m_name, m_mount));
+                MediaMonitor::GetMediaMonitor()->EjectMedia(m_media->getDevicePath());
+            }
+            else
+                LOG(VB_MEDIA, LOG_DEBUG, LOC + QString("Unlocked '%1'").arg(m_name));
+
+            MediaMonitor::GetMediaMonitor()->Unlock(m_media);
+            m_media = NULL;
+        }
+    }
+
+
+    //! Delete thumbnails associated with device
+    void RemoveThumbs(bool eject = false)
+    {
+        // Remove thumbnails
+        QString dir = QString("%1/" TEMP_SUBDIR "/%2").arg(GetConfDir(), m_thumbs);
+        LOG(VB_FILE, LOG_INFO, LOC + QString("Removing thumbnails in %1").arg(dir));
+        QDir(dir).removeRecursively();
+        QDir::root().rmpath(dir);
+    }
+
+
+    bool isImport() const                    { return m_dir; }
+    bool isPresent() const                   { return m_present; }
+    void setPresent(MythMediaDevice *media)  { m_present = true; m_media = media; }
+
+    //! True when gallery UI is running & device is useable. Always true for imports
+    bool             m_present;
+    QString          m_name;   //!< Device model/volume/id
+    QString          m_mount;  //!< Mountpoint
+    QString          m_thumbs; //!< Dir sub-path of device thumbnails
+    MythMediaDevice *m_media;  //!< Set for MediaMonitor devices only
+    QTemporaryDir   *m_dir;    //!< Dir path of images: import devices only
+};
+
+
+static Device kNullDevice = Device("Unknown Device", "<Invalid Path>");
+
+
+DeviceManager::~DeviceManager()
+{
+    qDeleteAll(m_devices);
+}
+
+
+//! Get path at which the device is mounted
+QString DeviceManager::DeviceMount(int devId) const
+{
+    return m_devices.value(devId, &kNullDevice)->m_mount;
+}
+
+
+//! Get model name of the device
+QString DeviceManager::DeviceName(int devId) const
+{
+    return m_devices.value(devId, &kNullDevice)->m_name;
+}
+
+
+QString DeviceManager::ThumbDir(int fs) const
+{
+    return m_devices.value(fs, &kNullDevice)->m_thumbs;
+}
+
+
+/*!
+ \brief Define a new device and assign it a unique id. If the device is already
+ known, its existing id is returned.
+ \param device Device
+ \return int A unique id for this device.
+*/
+int DeviceManager::OpenDevice(const QString &name, const QString &mount,
+                              MythMediaDevice *media, QTemporaryDir *dir)
+{
+    // Handle devices reappearing at same mountpoint.
+    // If a USB is unplugged whilst in use (without unmounting) we get no event
+    // but we do when it's re-inserted
+    QString state("Known");
+    int id = LocateMount(mount);
+
+    if (id == DEVICE_INVALID)
+    {
+        state = "New";
+        id = m_devices.isEmpty() ? 0 : m_devices.lastKey() + 1;
+        m_devices.insert(id, new Device(name, mount, media, dir));
+    }
+    else
+        m_devices.value(id)->setPresent(media);
+
+    LOG(VB_GENERAL, LOG_INFO, LOC +
+        QString("%1 device %2 mounted at '%3' [Id %4]")
+        .arg(state, name, mount).arg(id));
+
+    return id;
+}
+
+
+/*!
+ \brief Remove a device
+ \param devId Id of device to remove
+ \param removeImport If false, the Import device will not be discarded
+ \return bool True if device is recognized
+*/
+QStringList DeviceManager::CloseDevices(int devId, const QString &action)
+{
+    QStringList clear;
+
+    if (action == "DEVICE CLOSE ALL")
+    {
+        // Close all devices but retain their thumbnails
+        foreach (Device *dev, m_devices)
+            if (dev)
+                dev->Close();
+    }
+    else if (action == "DEVICE CLEAR ALL")
+    {
+        // Remove all thumbnails but retain devices
+        foreach (Device *dev, m_devices)
+            if (dev)
+            {
+                clear << dev->m_mount;
+                dev->RemoveThumbs();
+            }
+    }
+    else
+    {
+        // Remove single device & its thumbnails, optionally ejecting it
+        Device *dev = m_devices.take(devId);
+        if (dev)
+        {
+            if (action == "DEVICE EJECT")
+                dev->Close(true);
+            clear << dev->m_mount;
+            delete dev;
+        }
+    }
+    return clear;
+}
+
+
+/*!
+ \brief Find the id of a device
+ \param device Device
+ \return int Id (positive) if found, 0 if unknown
+*/
+int DeviceManager::LocateMount(const QString &mount) const
+{
+    DeviceMap::const_iterator it = m_devices.constBegin();
+    while (it != m_devices.constEnd())
+    {
+        if (it.value()->m_mount == mount)
+            return it.key();
+        ++it;
+    }
+    return DEVICE_INVALID;
+}
+
+
+//! Get all known devices
+StringMap DeviceManager::GetDeviceDirs() const
+{
+    StringMap paths;
+    foreach (int id, m_devices.keys())
+    {
+        Device *dev = m_devices.value(id);
+        if (dev)
+            paths.insert(id, dev->m_mount);
+    }
+    return paths;
+}
+
+
+//! Get list of mountpoints for non-import devices
+QList<int> DeviceManager::GetAbsentees()
+{
+    QList<int> absent;
+    foreach (int id, m_devices.keys())
+    {
+        Device *dev = m_devices.value(id);
+        if (dev && !dev->isPresent())
+            absent << id;
+    }
+    return absent;
+}
+
+
+/*!
+ \brief Constructor
+ \param thumbPath Absolute path of dir where thumbnails will be stored
+*/
+ImageAdapterBase::ImageAdapterBase() : DeviceManager()
+{
+    // Determine supported picture formats from Qt
+    m_imageFileExt.clear();
+    foreach (const QByteArray &ext, QImageReader::supportedImageFormats())
+        m_imageFileExt << QString(ext);
+
+    // Determine supported video formats from MythVideo
+    m_videoFileExt.clear();
+    const FileAssociations::association_list faList =
+        FileAssociations::getFileAssociation().getList();
+    for (FileAssociations::association_list::const_iterator p =
+        faList.begin(); p != faList.end(); ++p)
+    {
+        if (!p->use_default && p->playcommand == "Internal")
+            m_videoFileExt << QString(p->extension);
+    }
+
+    // Generate glob list from supported extensions
+    QStringList glob;
+    foreach (const QString &ext, m_imageFileExt + m_videoFileExt)
+        glob << "*." + ext;
+
+    // Apply filters to only detect image files
+    m_dirFilter.setNameFilters(glob);
+    m_dirFilter.setFilter(QDir::AllDirs | QDir::Files | QDir::Readable |
+                          QDir::NoDotAndDotDot | QDir::NoSymLinks);
+
+    // Sync files before dirs to improve thumb generation response
+    // Order by time (oldest first) - this determines the order thumbs appear
+    m_dirFilter.setSorting(QDir::DirsLast | QDir::Time | QDir::Reversed);
+}
+
+
+/*!
+ \brief Construct a local image from a file
+ \param fileInfo File
+ \param parentId Id of the parent dir
+ \param devId Id of device containing the file
+ \param base Unused but required for adapter interface
+ \return ImageItem An image object
+*/
+ImageItem *ImageAdapterLocal::CreateItem(const QFileInfo &fi, int parentId,
+                                         int devId, const QString &) const
+{
+    ImageItem *im = new ImageItem();
+
+    im->m_parentId  = parentId;
+    im->m_device    = devId;
+    im->m_filePath  = fi.absoluteFilePath();
+
+    if (parentId == GALLERY_DB_ID)
+    {
+        // Devices hold 'last scan time'
+        im->m_type    = kDevice;
+        im->m_date    = QDateTime::currentMSecsSinceEpoch() / 1000;
+        im->m_modTime = im->m_date;
+        return im;
+    }
+
+    // Strip device path & leading / to create a relative path
+    im->m_modTime = fi.lastModified().toTime_t();
+
+    if (fi.isDir())
+    {
+        im->m_type = kDirectory;
+        return im;
+    }
+
+    im->m_extension = fi.suffix().toLower();
+    im->m_type      = GetImageType(im->m_extension);
+
+    if (im->m_type == kUnknown)
+    {
+        delete im;
+        return NULL;
+    }
+
+    im->m_thumbPath = GetAbsThumbPath(ThumbDir(im->m_device), ThumbPath(*im));
+    im->m_size      = fi.size();
+
+    return im;
+}
+
+
+/*!
+ * \brief Send local message to UI about local ids
+ * \param mesg Message name
+ * \param extra Message data
+ */
+void ImageAdapterLocal::Notify(const QString &mesg,
+                               const QStringList &extra) const
+{
+    QString host(gCoreContext->GetHostName());
+    gCoreContext->SendEvent(MythEvent(QString("%1 %2").arg(mesg, host), extra));
+}
+
+
+/*!
+ \brief Construct a remote image from a file
+ \param fileInfo File
+ \param parentId Id of the parent dir
+ \param devId Unused
+ \param base SG dir path
+ \return ImageItem An image object
+*/
+ImageItem *ImageAdapterSg::CreateItem(const QFileInfo &fi, int parentId,
+                                      int, const QString &base) const
+{
+    ImageItem *im = new ImageItem();
+
+    im->m_device    = 0;
+    im->m_parentId  = parentId;
+
+    if (parentId == GALLERY_DB_ID)
+    {
+        // All SG dirs map to a single Db dir
+        im->m_filePath = "";
+        im->m_type     = kDevice;
+        im->m_date     = QDateTime::currentMSecsSinceEpoch() / 1000;
+        im->m_modTime  = im->m_date;
+        return im;
+    }
+
+    // Strip SG path & leading / to leave a relative path
+    im->m_filePath = fi.absoluteFilePath().mid(base.size() + 1);
+    im->m_modTime  = fi.lastModified().toTime_t();
+
+    if (fi.isDir())
+    {
+        im->m_type = kDirectory;
+        return im;
+    }
+
+    im->m_extension = fi.suffix().toLower();
+    im->m_type      = GetImageType(im->m_extension);
+
+    if (im->m_type == kUnknown)
+    {
+        delete im;
+        return NULL;
+    }
+
+    im->m_thumbPath = GetAbsThumbPath(ThumbDir(im->m_device), ThumbPath(*im));
+    im->m_size      = fi.size();
+
+    return im;
+}
+
+
+/*!
+ * \brief Send message to all clients about remote ids
+ * \param mesg Message name
+ * \param extra Message data
+ */
+void ImageAdapterSg::Notify(const QString &mesg,
+                            const QStringList &extra) const
+{
+    gCoreContext->SendEvent(MythEvent(mesg, extra));
+}
+
+
+/*!
+ \brief Returns SG dirs
+ \return StringMap Map <Arbitrary id, Device Path>
+*/
+StringMap ImageAdapterSg::GetScanDirs() const
+{
+    StringMap map;
+    int i = 0;
+    foreach (const QString &path, m_sg.GetDirList())
+        map.insert(i++, path);
+    return map;
+}
+
+
+/*!
+ \brief Get absolute filepath for a remote image
+ \details For the SG node the path of SG dir with most space is returned
+ \param im Image
+ \return QString Absolute filepath
+*/
+QString ImageAdapterSg::GetAbsFilePath(const ImagePtrK &im) const
+{
+    if (im->IsDevice())
+        return m_sg.FindNextDirMostFree();
+    return im->m_filePath.startsWith("/") ? im->m_filePath
+                                          : m_sg.FindFile(im->m_filePath);
+}
+
+
+// Database fields used by several image queries
+#define DB_COLUMNS \
+"file_id, filename, name, dir_id, type, modtime, size, " \
+"extension, date, hidden, orientation, angle, path, zoom"
+// Id, filepath, basename, parentId, type, modtime, size,
+// extension, image date, hidden, orientation, cover id, comment, device id
+
+
+/*!
+\brief Create image from Db query data
+\param query Db query result
+\return ImageItem An image object
+*/
+template <class FS>
+ImageItem *ImageDb<FS>::CreateImage(const MSqlQuery &query) const
+{
+    ImageItem *im = new ImageItem(FS::ImageId(query.value(0).toInt()));
+
+    // Ordered as per DB_COLUMNS
+    im->m_filePath      = query.value(1).toString();
+    im->m_baseName      = query.value(2).toString();
+    im->m_parentId      = FS::ImageId(query.value(3).toInt());
+    im->m_type          = query.value(4).toInt();
+    im->m_modTime       = query.value(5).toInt();
+    im->m_size          = query.value(6).toInt();
+    im->m_extension     = query.value(7).toString();
+    im->m_date          = query.value(8).toUInt();
+    im->m_isHidden      = query.value(9).toInt();
+    im->m_orientation   = query.value(10).toInt();
+    im->m_userThumbnail = FS::ImageId(query.value(11).toInt());
+    im->m_comment       = query.value(12).toString();
+    im->m_device        = query.value(13).toInt();
+    im->m_url           = FS::MakeFileUrl(im->m_filePath);
+
+    if (im->IsFile())
+    {
+        // Only pics/vids have thumbs
+        QString thumbPath(FS::ThumbPath(*im));
+        QString devPath(FS::ThumbDir(im->m_device));
+        QString url(FS::MakeThumbUrl(devPath, thumbPath));
+
+        im->m_thumbPath = FS::GetAbsThumbPath(devPath, thumbPath);
+        im->m_thumbNails.append(qMakePair(im->m_id, url));
+    }
+    return im;
+}
+
+
+/*!
+ * \brief Read database images/dirs by id
+ * \param[in] ids Comma-separated list of ids
+ * \param[in out] files List of files
+ * \param[in out] files List of dirs
+ * \param[in] refine SQL clause to refine selection & apply ordering
+ * \return int Number of items matching query, -1 on SQL error
+ */
+template <class FS>
+int ImageDb<FS>::GetImages(const QString &ids, ImageList &files, ImageList &dirs,
+                           const QString &refine) const
+{
+    if (ids.isEmpty())
+        return 0;
+
+    QString select = QString("file_id IN (%1) %2").arg(FS::DbIds(ids), refine);
+    return ReadImages(dirs, files, select);
+}
+
+
+/*!
+ \brief Read immediate children of a dir
+ \param[in out] dirs List of child subdirs
+ \param[in out] files List of child files
+ \param[in] ids Comma-separated list of dir ids
+ \param[in] refine SQL clause to refine selection & apply ordering
+ \return int Number of items matching query, -1 on SQL error
+*/
+template <class FS>
+int ImageDb<FS>::GetChildren(QString ids, ImageList &files, ImageList &dirs,
+                const QString &refine) const
+{
+    QString select = QString("dir_id IN (%1) %2").arg(FS::DbIds(ids), refine);
+    return ReadImages(dirs, files, select);
+}
+
+
+/*!
+ \brief Read a dir and its immediate children from Db
+ \param[out] parent Dir item
+ \param[in out] dirs List of child subdirs
+ \param[in out] files List of child files
+ \param[in] ids Comma-separated list of dir ids
+ \param[in] refine SQL clause to refine selection & apply ordering
+ \return int Number of items matching query, -1 on SQL error
+
+ \param[in out] subdirs Ordered/filtered child subdirs
+ \param[in out] files Ordered/filtered child files
+ \param[in] id Dir id
+ \param[in] refine SQL clause for filtering/ordering child images
+ \return int Number of items matching query.
+*/
+template <class FS>
+int ImageDb<FS>::GetDirectory(int id, ImagePtr &parent,
+                              ImageList &files, ImageList &dirs,
+                              const QString &refine) const
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString("SELECT " DB_COLUMNS " FROM %1 "
+                          "WHERE (dir_id = :ID OR file_id = :ID) "
+                          "%2;").arg(m_table, refine));
+
+    query.bindValue(":ID",  FS::DbId(id));
+
+    if (!query.exec())
+    {
+        MythDB::DBError(DBLOC, query);
+        return -1;
+    }
+    else while (query.next())
+    {
+        ImagePtr im(CreateImage(query));
+
+        if (im->IsFile())
+            files.append(im);
+        else if (im->m_id == id)
+            parent = im;
+        else
+            dirs.append(im);
+    }
+    return query.size();
+}
+
+
+/*!
+ \brief Return images and all of their descendants.
+
+ \param[in out] files Ordered/filtered files
+ \param[in out] dirs  Ordered/filtered dirs
+ \param[in] ids Image ids
+ \param[in] refine SQL clause for filtering/ordering child images
+*/
+template <class FS>
+bool ImageDb<FS>::GetDescendants(const QString &ids,
+                                 ImageList &files, ImageList &dirs) const
+{
+    if (ids.isEmpty())
+        return false;
+
+    if (ReadImages(dirs, files, QString("file_id IN (%1)").arg(FS::DbIds(ids))) < 0)
+        return false;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    QString sql =
+            QString("SELECT " DB_COLUMNS
+                    ", LENGTH(filename) - LENGTH(REPLACE(filename, '/', ''))"
+                    " AS depth "
+                    "FROM %1 WHERE filename LIKE :PREFIX "
+                    "ORDER BY depth;").arg(m_table);
+
+    foreach (const ImagePtr &im, dirs)
+    {
+        query.prepare(sql);
+        query.bindValue(":PREFIX", im->m_filePath + "/%");
+
+        if (!query.exec())
+        {
+            MythDB::DBError(DBLOC, query);
+            return false;
+        }
+
+        while (query.next())
+        {
+            ImagePtr im(CreateImage(query));
+            if (im->IsDirectory())
+                dirs.append(im);
+            else
+                files.append(im);
+        }
+    }
+    return true;
+}
+
+
+/*!
+ \brief Returns all files in the sub-tree of a dir.
+ \param[in out] files List of images within sub-tree. Direct children first, then
+  depth-first traversal of peer sub-dirs. Each level ordered as per refine criteria
+ \param id Dir id
+ \param refine SQL clause defining filter & ordering criteria
+*/
+template <class FS>
+bool ImageDb<FS>::GetImageTree(int id, ImageList &files, const QString &refine) const
+{
+    // Load starting children
+    ImageList dirs;
+    if (GetChildren(QString::number(id), files, dirs, refine) < 0)
+        return false;
+
+    foreach (const ImagePtr &im, dirs)
+        if (!GetImageTree(im->m_id, files, refine))
+            return false;
+    return true;
+}
+
+
+/*!
+ * \brief Read all database images and dirs as map. No filters or ordering applied.
+ * \param[in out] files Map <filepath, image>
+ * \param[in out] dirs Map <filepath, dir>
+ */
+template <class FS>
+bool ImageDb<FS>::ReadAllImages(ImageHash &files, ImageHash &dirs) const
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString("SELECT " DB_COLUMNS " FROM %1").arg(m_table));
+
+    if (!query.exec())
+    {
+        MythDB::DBError(DBLOC, query);
+        return false;
+    }
+
+    while (query.next())
+    {
+        ImagePtr im(CreateImage(query));
+        if (im->IsDirectory())
+            dirs.insert(im->m_filePath, im);
+        else
+            files.insert(im->m_filePath, im);
+    }
+    return true;
+}
+
+
+/*!
+ \brief Clear Db for device & remove device
+ \param devId Device id, 0 to clear all devices
+ \param removeImport If false, the Import device will not be removed
+ \return Either list of ids that have been deleted or "ALL" with list of
+ filepath prefixes that will remove device images from the UI image cache
+*/
+template <class FS>
+void ImageDb<FS>::ClearDb(int devId, const QString &action)
+{
+    if (action == "DEVICE CLOSE ALL")
+        // Retain Db images when closing UI
+        return;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    if (action == "DEVICE CLEAR ALL")
+    {
+        // Clear images from all devices. Reset auto-increment
+        query.prepare(QString("TRUNCATE TABLE %1;").arg(m_table));
+
+        if (!query.exec())
+            MythDB::DBError(DBLOC, query);
+    }
+    else // Actions DEVICE REMOVE & DEVICE EJECT
+    {
+        // Delete all images of the device
+        query.prepare(QString("DELETE IGNORE FROM %1 WHERE zoom = :FS;").arg(m_table));
+        query.bindValue(":FS", devId);
+
+        if (!query.exec())
+            MythDB::DBError(DBLOC, query);
+    }
+}
+
+
+/*!
+ \brief Adds new image to database, optionally checking for existing filepath
+ \param im Image to add
+ \param checkForDuplicate If true, the image will not be added if its filepath
+ already exists in Db.
+ \return int Id of new image or the existing image with same filepath
+*/
+template <class FS>
+int ImageDb<FS>::InsertDbImage(ImageItemK &im, bool checkForDuplicate) const
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    if (checkForDuplicate)
+    {
+        query.prepare(QString("SELECT file_id FROM %1 WHERE filename = :NAME;")
+                      .arg(m_table));
+
+        query.bindValue(":NAME", im.m_filePath);
+
+        if (!query.exec())
+        {
+            MythDB::DBError(DBLOC, query);
+            return -1;
+        }
+
+        if (query.size() > 0)
+        {
+            LOG(VB_FILE, LOG_DEBUG, QString("Image: %1 already exists in Db")
+                .arg(im.m_filePath));
+            return query.value(0).toInt();
+        }
+    }
+
+    query.prepare(QString("INSERT INTO %1 (" DB_COLUMNS ") VALUES (0, "
+                          ":FILEPATH, :NAME,      :PARENT, :TYPE,   :MODTIME, "
+                          ":SIZE,     :EXTENSION, :DATE,   :HIDDEN, :ORIENT, "
+                          ":COVER,    :COMMENT,   :FS);").arg(m_table));
+
+    query.bindValue(":FILEPATH",  im.m_filePath);
+    query.bindValue(":NAME",      FS::BaseNameOf(im.m_filePath));
+    query.bindValue(":FS",        im.m_device);
+    query.bindValue(":PARENT",    FS::DbId(im.m_parentId));
+    query.bindValue(":TYPE",      im.m_type);
+    query.bindValue(":MODTIME",   im.m_modTime);
+    query.bindValue(":SIZE",      im.m_size);
+    query.bindValue(":EXTENSION", im.m_extension);
+    query.bindValue(":DATE",      im.m_date);
+    query.bindValue(":ORIENT",    im.m_orientation);
+    query.bindValue(":COMMENT",   im.m_comment.isNull() ? "" : im.m_comment);
+    query.bindValue(":HIDDEN",    im.m_isHidden);
+    query.bindValue(":COVER",     FS::DbId(im.m_userThumbnail));
+
+    if (query.exec())
+        return FS::ImageId(query.lastInsertId().toInt());
+
+    MythDB::DBError(DBLOC, query);
+    return -1;
+}
+
+
+/*!
+ * \brief Updates or creates database image or dir
+ * \details Item does not need to pre-exist
+ * \param im Image or dir
+ */
+template <class FS>
+bool ImageDb<FS>::UpdateDbImage(ImageItemK &im) const
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString
+                  ("UPDATE %1 SET "
+                   "filename = :FILEPATH,  name = :NAME, "
+                   "dir_id = :PARENT,    type = :TYPE, "
+                   "modtime = :MODTIME,   size = :SIZE, "
+                   "extension = :EXTENSION, date = :DATE,   zoom = :FS, "
+                   "hidden = :HIDDEN,    orientation = :ORIENT, "
+                   "angle = :COVER,     path = :COMMENT "
+                   "WHERE file_id = :ID;").arg(m_table));
+
+    query.bindValue(":ID",        FS::DbId(im.m_id));
+    query.bindValue(":FILEPATH",  im.m_filePath);
+    query.bindValue(":NAME",      FS::BaseNameOf(im.m_filePath));
+    query.bindValue(":PARENT",    FS::DbId(im.m_parentId));
+    query.bindValue(":TYPE",      im.m_type);
+    query.bindValue(":MODTIME",   im.m_modTime);
+    query.bindValue(":SIZE",      im.m_size);
+    query.bindValue(":EXTENSION", im.m_extension);
+    query.bindValue(":DATE",      im.m_date);
+    query.bindValue(":FS",        im.m_device);
+    query.bindValue(":HIDDEN",    im.m_isHidden);
+    query.bindValue(":ORIENT",    im.m_orientation);
+    query.bindValue(":COVER",     FS::DbId(im.m_userThumbnail));
+    query.bindValue(":COMMENT",   im.m_comment.isNull() ? "" : im.m_comment);
+
+    if (query.exec())
+        return true;
+
+    MythDB::DBError(DBLOC, query);
+    return false;
+}
+
+
+/*!
+ * \brief Remove images/dirs from database
+ * \details Item does not need to exist in db
+ * \param imList List of items to delete
+ * \return QStringList List of ids that were successfully removed
+ */
+template <class FS>
+QStringList ImageDb<FS>::RemoveFromDB(const ImageList &imList) const
+{
+    QStringList ids;
+    if (!imList.isEmpty())
+    {
+        foreach (const ImagePtr &im, imList)
+            ids << QString::number(FS::DbId(im->m_id));
+
+        QString idents = ids.join(",");
+        MSqlQuery query(MSqlQuery::InitCon());
+        query.prepare(QString("DELETE IGNORE FROM %1 WHERE file_id IN (%2);")
+                      .arg(m_table, idents));
+
+        if (!query.exec())
+        {
+            MythDB::DBError(DBLOC, query);
+            return QStringList();
+        }
+    }
+    return ids;
+}
+
+
+/*!
+ * \brief Sets hidden status of an image/dir in database
+ * \param hide True = hidden, False = unhidden
+ * \param ids List of item ids
+ * \return bool False if db update failed
+ */
+template <class FS>
+bool ImageDb<FS>::SetHidden(bool hide, QString ids) const
+{
+    if (ids.isEmpty())
+        return false;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    query.prepare(QString("UPDATE %1 SET "
+                          "hidden = :HIDDEN "
+                          "WHERE file_id IN (%2);").arg(m_table, FS::DbIds(ids)));
+    query.bindValue(":HIDDEN", hide ? 1 : 0);
+
+    if (query.exec())
+        return true;
+
+    MythDB::DBError(DBLOC, query);
+    return false;
+}
+
+
+/*!
+ * \brief Set the thumbnail(s) to be used for a dir
+ * \param dir Dir id
+ * \param id Image id to use as cover/thumbnail
+ */
+template <class FS>
+bool ImageDb<FS>::SetCover(int dir, int id) const
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    query.prepare(QString("UPDATE %1 SET "
+                          "angle = :COVER "
+                          "WHERE file_id = :DIR").arg(m_table));
+    query.bindValue(":COVER", FS::DbId(id));
+    query.bindValue(":DIR", FS::DbId(dir));
+    \
+    if (query.exec())
+        return true;
+
+    MythDB::DBError(DBLOC, query);
+    return false;
+}
+
+
+/*!
+ \brief Sets image orientation in Db
+ \param id Image id
+ \param orientation Exif orientation code
+*/
+template <class FS>
+bool ImageDb<FS>::SetOrientation(int id, int orientation) const
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    query.prepare(QString("UPDATE %1 SET ").arg(m_table) +
+                  "orientation = :ORIENTATION "
+                  "WHERE file_id = :ID");
+    query.bindValue(":ORIENTATION", orientation);
+    query.bindValue(":ID", FS::DbId(id));
+    \
+    if (query.exec())
+        return true;
+
+    MythDB::DBError(DBLOC, query);
+    return false;
+}
+
+
+/*!
+ \brief Read selected database images/dirs
+ \param[out] dirs List of the dirs
+ \param[out] files List of the files
+ \param selector SQL clause specifying selection and ordering of images
+ \return int Number of items retreved
+*/
+template <class FS>
+int ImageDb<FS>::ReadImages(ImageList &dirs, ImageList &files,
+                            const QString &selector) const
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString("SELECT " DB_COLUMNS " FROM %1 WHERE %2")
+                  .arg(m_table, selector));
+    if (!query.exec())
+    {
+        MythDB::DBError(DBLOC, query);
+        return -1;
+    }
+
+    while (query.next())
+    {
+        ImagePtr im(CreateImage(query));
+
+        if (im->IsFile())
+            files.append(im);
+        else
+            dirs.append(im);
+    }
+    return query.size();
+}
+
+
+/*!
+ \brief Return counts of dirs, pics, videos and size in the subtree of a dir.
+ \param[in] id Dir id
+ \param[in] all Sum whole table (without filtering on dir path)
+ \param[in out] dirs Number of dirs in parent sub-tree
+ \param[in out] pics Number of pictures in parent sub-tree
+ \param[in out] videos Number of videos in parent sub-tree
+ \param[in out] sizeKb Size in KiB of parent sub-tree
+*/
+template <class FS>
+void ImageDb<FS>::GetDescendantCount(int id, bool all, int &dirs,
+                                     int &pics, int &videos, int &sizeKb) const
+{
+    QString whereClause;
+    if (!all)
+    {
+        whereClause = "WHERE filename LIKE "
+                      "( SELECT CONCAT(filename, '/%') "
+                      "  FROM %2 WHERE file_id = :ID);";
+    }
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString("SELECT SUM(type <= :FLDR) AS Fldr, "
+                          "       SUM(type =  :PIC)  AS Pics, "
+                          "       SUM(type =  :VID)  AS Vids, "
+                          "       SUM(size / 1024) "
+                          "FROM %2 %1;").arg(whereClause).arg(m_table));
+
+    query.bindValue(":FLDR", kDirectory);
+    query.bindValue(":PIC",  kImageFile);
+    query.bindValue(":VID",  kVideoFile);
+    if (!all)
+        query.bindValue(":ID", FS::DbId(id));
+
+    if (!query.exec())
+    {
+        MythDB::DBError(DBLOC, query);
+    }
+    else if (query.next())
+    {
+        dirs   += query.value(0).toInt();
+        pics   += query.value(1).toInt();
+        videos += query.value(2).toInt();
+        sizeKb += query.value(3).toInt();
+    }
+}
+
+
+/*!
+ * \brief SG database constructor
+ */
+ImageDbSg::ImageDbSg() : ImageDb(DB_TABLE)
+{
+    // Be has a single SG device
+    OpenDevice("Photographs", STORAGE_GROUP_MOUNT);
+}
+
+
+/*!
+ \brief Local database constructor
+*/
+ImageDbLocal::ImageDbLocal()
+    : ImageDb(DB_TABLE "_" + gCoreContext->GetHostName()),
+      m_DbExists(false)
+{
+    // Remove any table leftover from a previous FE crash
+    DropTable();
+}
+
+
+/*!
+ \brief Remove local image table
+*/
+void ImageDbLocal::DropTable()
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString("DROP TABLE IF EXISTS %1;").arg(m_table));
+    if (query.exec())
+        m_DbExists = false;
+    else
+        MythDB::DBError(DBLOC, query);
+}
+
+
+/*!
+ \brief Create local database table, if it doesn't exist
+*/
+bool ImageDbLocal::CreateTable()
+{
+    if (m_DbExists)
+        return true;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    // Create temporary table
+    query.prepare(QString("CREATE TABLE %1 LIKE " DB_TABLE ";").arg(m_table));
+    if (query.exec())
+    {
+        // Store it in memory only
+        query.prepare(QString("ALTER TABLE %1 ENGINE = MEMORY;").arg(m_table));
+        if (query.exec())
+        {
+            m_DbExists = true;
+            LOG(VB_FILE, LOG_DEBUG, QString("Created Db table %1").arg(m_table));
+            return true;
+        }
+    }
+    MythDB::DBError(DBLOC, query);
+
+    // Clean up after failure
+    query.prepare(QString("DROP TABLE IF EXISTS %1;").arg(m_table));
+    query.exec();
+    return false;
+}
+
+
+/*!
+ * \brief Task to read all metadata from file
+ */
+class ReadMetaThread : public QRunnable
+{
+public:
+    ReadMetaThread(ImagePtrK im, const QString &path)
+        : QRunnable(), m_im(im), m_path(path) {}
+
+    void run()
+    {
+        QStringList tags;
+        QString     orientation, size;
+
+        // Read metadata for files only
+        if (m_im->IsFile())
+        {
+            ImageMetaData *metadata = (m_im->m_type == kVideoFile)
+                    ? ImageMetaData::FromVideo(m_path)
+                    : ImageMetaData::FromPicture(m_path);
+            tags        = metadata->GetAllTags();
+            orientation = Orientation(m_im->m_orientation).Description();
+            size        = ImageAdapterBase::FormatSize(m_im->m_size / 1024);
+            delete metadata;
+        }
+
+        // Add identifier at front
+        tags.prepend(QString::number(m_im->m_id));
+
+        // Include file info
+        tags << ImageMetaData::ToString(EXIF_MYTH_HOST,   "Host",
+                                        gCoreContext->GetHostName());
+        tags << ImageMetaData::ToString(EXIF_MYTH_PATH,   "Path",
+                                        ImageAdapterBase::PathOf(m_path));
+        tags << ImageMetaData::ToString(EXIF_MYTH_NAME,   "Name",
+                                        ImageAdapterBase::BaseNameOf(m_path));
+        tags << ImageMetaData::ToString(EXIF_MYTH_SIZE,   "Size", size);
+        tags << ImageMetaData::ToString(EXIF_MYTH_ORIENT, "Orientation",
+                                        orientation);
+
+        MythEvent me("IMAGE_METADATA", tags);
+        gCoreContext->SendEvent(me);
+    }
+
+private:
+    ImagePtrK m_im;
+    QString   m_path;
+};
+
+
+/*!
+ \brief Read meta data for an image
+ \details Reads exif tags from a picture or FFMPEG video tags
+ \param id Image id
+ \return QStringList Error message or "OK", seperator token,
+ list of <tag name><seperator><tag value>.
+ Clients must use the embedded seperator to split the tags.
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleGetMetadata(const QString &id) const
+{
+    // Find image in DB
+    ImageList files, dirs;
+    if (DBFS::GetImages(id, files, dirs) != 1)
+        RESULT_ERR("Image not found", QString("Unknown image %1").arg(id))
+
+    ImagePtr im = files.isEmpty() ? dirs[0] : files[0];
+
+    QString absPath = DBFS::GetAbsFilePath(im);
+    if (absPath.isEmpty())
+        RESULT_ERR("Image not found",
+                   QString("File %1 not found").arg(im->m_filePath))
+
+    ReadMetaThread *worker = new ReadMetaThread(im, absPath);
+
+    MThreadPool::globalInstance()->start(worker, "ImageMetaData");
+
+    RESULT_OK(QString("Fetching metadata for %1").arg(id))
+}
+
+
+/*!
+ \brief Change name of an image/dir
+ \details Renames file, updates db and thumbnail
+ \param id File/dir id
+ \param newBase New file basename
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleRename(const QString &id,
+                                             const QString &newBase) const
+{
+    // Sanity check new name
+    if (newBase.isEmpty() || newBase.contains("/") || newBase.contains("\\"))
+        RESULT_ERR("Invalid name", QString("Invalid name %1").arg(newBase))
+
+    // Find image in DB
+    ImageList files, dirs;
+    if (DBFS::GetImages(id, files, dirs) != 1)
+        RESULT_ERR("Image not found", QString("Image %1 not in Db").arg(id))
+
+    ImagePtr im = files.isEmpty() ? dirs[0] : files[0];
+
+    // Find file
+    QString oldPath = DBFS::GetAbsFilePath(im);
+    if (oldPath.isEmpty())
+        RESULT_ERR("Image not found",
+                   QString("File %1 not found").arg(im->m_filePath))
+
+    // Generate new filename
+    QFileInfo oldFi = QFileInfo(oldPath);
+    QString newName = im->IsDirectory()
+            ? newBase : QString("%1.%2").arg(newBase, oldFi.suffix());
+
+    im->m_filePath = DBFS::ConstructPath(DBFS::PathOf(im->m_filePath), newName);
+
+    // Ensure no SG duplicate files are created. (Creating clone dirs is ok)
+    if (im->IsFile())
+    {
+        QString existPath = DBFS::GetAbsFilePath(im);
+        if (!existPath.isEmpty())
+            RESULT_ERR("Filename already used",
+                       QString("Renaming %1 to %2 will create a duplicate of %3")
+                          .arg(oldPath, im->m_filePath, existPath))
+    }
+
+    // Rename file or directory
+    QString newPath = oldFi.dir().absoluteFilePath(newName);
+    if (!QFile::rename(oldPath, newPath))
+        RESULT_ERR("Rename failed",
+                   QString("Rename of %1 -> %2 failed").arg(oldPath, newPath))
+
+    if (im->IsDirectory())
+    {
+        // Dir name change affects path of all sub-dirs & files and their thumbs
+        HandleScanRequest("START");
+    }
+    else // file
+    {
+        // Update db
+        DBFS::UpdateDbImage(*im);
+
+        // Image is modified, not deleted
+        QStringList mesg("");
+        mesg << QString::number(im->m_id);
+
+        // Rename thumbnail.
+        m_thumbGen->MoveThumbnail(im);
+
+        // Notify clients of changed image
+        DBFS::Notify("IMAGE_DB_CHANGED", mesg);
+    }
+    RESULT_OK(QString("Renamed %1 -> %2").arg(oldPath, newPath))
+}
+
+
+/*!
+ \brief Deletes images/dirs
+ \details Removes files and dirs, updates db and thumbnails. Dirs containing
+ other files will not be deleted. Only fails if nothing is deleted.
+ \param ids Csv list of dir/file ids
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleDelete(const QString &ids) const
+{
+    // Get subtree of all files
+    ImageList files, dirs;
+    // Dirs will be in depth-first order, (subdirs after parent)
+    DBFS::GetDescendants(ids, files, dirs);
+
+    // Remove files from filesystem first
+    RemoveFiles(files);
+    // ... then dirs, which should now be empty
+    RemoveFiles(dirs);
+
+    // Fail if nothing deleted
+    if (files.isEmpty() && dirs.isEmpty())
+        RESULT_ERR("Delete failed", QString("Delete of %1 failed").arg(ids))
+
+    // Update Db
+    DBFS::RemoveFromDB(files + dirs);
+
+    // Clean up thumbnails
+    QStringList mesg(m_thumbGen->DeleteThumbs(files));
+
+    // Notify clients of deleted ids
+    DBFS::Notify("IMAGE_DB_CHANGED", mesg);
+
+    return QStringList("OK");
+}
+
+
+/*!
+ \brief Creates images for files created by a copy operation
+ \details Creates skeleton database entries from image state definitions in order
+ to retain state of the copied images. Initiates a scan to populate them fully
+ and generate thumbnails. This retains
+ \param defs A list of image definitions in the form
+ <id><sep><type><sep><filepath><sep><hidden><sep><orientation><sep><cover id>
+ where <sep> is the first list item
+ Dirs must follow their children (files & subdirs)
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleDbCreate(QStringList defs) const
+{
+    if (defs.isEmpty())
+        RESULT_ERR("Copy Failed", "Empty defs")
+
+    // First item is the field seperator
+    const QString separator = defs.takeFirst();
+
+    // Convert cover ids to their new equivalent. Map<source id, new id>
+    // Dirs follow their children so new cover ids will be defined before they
+    // are used
+    QHash<QString, int> idMap;
+
+    // Create skeleton Db images using copied settings.
+    // Scanner will update other attributes
+    ImageItem im;
+    foreach (const QString &def, defs)
+    {
+        QStringList aDef = def.split(separator);
+
+        // Expects id, type, path, hidden, orientation, cover
+        if (aDef.size() != 6)
+        {
+            // Coding error
+            LOG(VB_GENERAL, LOG_ERR,
+                LOC + QString("Bad definition: (%1)").arg(def));
+            continue;
+        }
+
+        LOG(VB_FILE, LOG_DEBUG, LOC + QString("Creating %1").arg(aDef.join(",")));
+
+        im.m_type          = aDef[1].toInt();
+        im.m_filePath      = aDef[2];
+        im.m_isHidden      = aDef[3].toInt();
+        im.m_orientation   = aDef[4].toInt();
+        im.m_userThumbnail = idMap.value(aDef[5]);
+
+        // Don't insert duplicate filepaths
+        int newId = DBFS::InsertDbImage(im, true);
+
+        // Record old->new id map in case it's being used as a cover
+        idMap.insert(aDef[0], newId);
+    }
+    HandleScanRequest("START");
+
+    RESULT_OK("Created Db images")
+}
+
+
+/*!
+ \brief Updates images that have been renamed.
+ \details Updates filepaths of moved images, renames thumbnail and initiates
+ scanner to repair other attributes
+ \param ids Csv of image ids to rename
+ \param srcPath Images current parent path
+ \param destPath Images new parent path
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleDbMove(const QString &ids,
+                                             const QString &srcPath,
+                                             QString destPath) const
+{
+    // Sanity check new path
+    if (destPath.contains(".."))
+        RESULT_ERR("Invalid path", QString("Invalid path %1").arg(destPath))
+
+    // Get subtrees of renamed files
+    ImageList images, dirs, files;
+    bool ok = DBFS::GetDescendants(ids, files, dirs);
+    images << dirs << files;
+
+    if (!ok || images.isEmpty())
+        RESULT_ERR("Image not found", QString("Images %1 not in Db").arg(ids))
+
+    if (!destPath.isEmpty() && !destPath.endsWith("/"))
+        destPath.append("/");
+
+    // Update path of images only. Scanner will repair parentId
+    foreach (const ImagePtr &im, images)
+    {
+        QString old = im->m_filePath;
+
+        if (srcPath.isEmpty())
+        {
+            // Image in SG root
+            im->m_filePath.prepend(destPath);
+        }
+        else if (im->m_filePath.startsWith(srcPath))
+        {
+            // All other images
+            im->m_filePath.replace(srcPath, destPath);
+        }
+        else
+        {
+            // Coding error
+            LOG(VB_GENERAL, LOG_ERR,
+                LOC + QString("Bad image: (%1 -> %2)").arg(srcPath, destPath));
+            continue;
+        }
+
+        LOG(VB_FILE, LOG_DEBUG,
+            LOC + QString("Db Renaming %1 -> %2").arg(old, im->m_filePath));
+
+        DBFS::UpdateDbImage(*im);
+
+        // Rename thumbnail
+        if (im->IsFile())
+            m_thumbGen->MoveThumbnail(im);
+    }
+    HandleScanRequest("START");
+
+    RESULT_OK(QString("Moved %1 from %2 -> %3").arg(ids).arg(srcPath, destPath))
+}
+
+
+/*!
+ \brief Hides/unhides images/dirs
+ \details Updates hidden status in db and updates clients
+ \param hide hide flag: 0 = Show, 1 = Hide
+ \param fids Csv list of file/dir ids
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleHide(bool hide, const QString &ids) const
+{
+    if (!DBFS::SetHidden(hide, ids))
+        RESULT_ERR("Hide failed", QString("Db hide failed for %1").arg(ids))
+
+    // Send changed ids only (none deleted)
+    QStringList mesg = QStringList("") << ids;
+    DBFS::Notify("IMAGE_DB_CHANGED", mesg);
+
+    RESULT_OK(QString("Images %1 now %2hidden").arg(ids, hide ? "" : "un"))
+}
+
+
+/*!
+ \brief Change orientation of pictures by applying a transformation
+ \details Updates orientation in Db and thumbnail. Does not update file Exif data.
+ Only fails if nothing is modified.
+ \param transform transformation id,
+ \param ids Csv list of file ids
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleTransform(int transform,
+                                                const QString &ids) const
+{
+    if (transform < kResetToExif || transform > kFlipVertical)
+        RESULT_ERR("Transform failed", QString("Bad transform %1").arg(transform))
+
+    ImageList files, dirs;
+    if (DBFS::GetImages(ids, files, dirs) < 1 || files.isEmpty())
+        RESULT_ERR("Image not found", QString("Images %1 not in Db").arg(ids))
+
+    // Update db
+    foreach (ImagePtr im, files)
+    {
+        int old           = im->m_orientation;
+        im->m_orientation = Orientation(im->m_orientation).Transform(transform);
+
+        // Update Db
+        if (DBFS::SetOrientation(im->m_id, im->m_orientation))
+        {
+            LOG(VB_FILE, LOG_DEBUG, LOC + QString("Transformed %1 from %2 to %3")
+                .arg(im->m_filePath).arg(old).arg(im->m_orientation));
+        }
+    }
+
+    // Images are changed, not deleted
+    QStringList mesg("");
+
+    // Clean up thumbnails
+    mesg << m_thumbGen->DeleteThumbs(files);
+
+    // Notify clients of changed images
+    DBFS::Notify("IMAGE_DB_CHANGED", mesg);
+
+    return QStringList("OK");
+}
+
+
+/*!
+ \brief Creates new image directories
+ \details Creates dirs in filesystem and optionally updates Db.
+ \param destId Parent dir
+ \param rescan Whether to start a scan after creating the dirs
+ \param relPaths List of relative paths of new dirs
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleDirs(const QString &destId,
+                                           bool rescan,
+                                           const QStringList &relPaths) const
+{
+    // Find image in DB
+    ImageList files, dirs;
+    if (DBFS::GetImages(destId, files, dirs) != 1 || dirs.isEmpty())
+        RESULT_ERR("Destination not found",
+                   QString("Image %1 not in Db").arg(destId))
+
+    // Find dir. SG device (Photographs) uses most-free filesystem
+    QString destPath = DBFS::GetAbsFilePath(dirs[0]);
+    if (destPath.isEmpty())
+        RESULT_ERR("Destination not found",
+                   QString("Dest dir %1 not found").arg(dirs[0]->m_filePath))
+
+    QDir destDir(destPath);
+    bool succeeded = false;
+    foreach (const QString &relPath, relPaths)
+    {
+        // Validate dir name
+        if (relPath.isEmpty() || relPath.contains("..") || relPath.startsWith('/'))
+            continue;
+
+        QString newPath = DBFS::ConstructPath(destDir.absolutePath(), relPath);
+        if (!destDir.mkpath(relPath))
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                LOC + QString("Failed to create dir %1").arg(newPath));
+            continue;
+        }
+        LOG(VB_FILE, LOG_DEBUG, LOC + QString("Dir %1 created").arg(newPath));
+        succeeded = true;
+    }
+
+    if (!succeeded)
+        // Failures should only occur due to user input
+        RESULT_ERR("Invalid Name", QString("Invalid name %1")
+                   .arg(relPaths.join(",")))
+
+    if (rescan)
+        // Rescan to detect new dir
+        HandleScanRequest("START");
+
+    return QStringList("OK");
+}
+
+
+/*!
+ \brief Updates/resets cover thumbnail for an image dir
+ \param dir Directory id
+ \param cover Id to use as cover. 0 resets dir to use its own thumbnail
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleCover(int dir, int cover) const
+{
+    if (!DBFS::SetCover(dir, cover))
+        RESULT_ERR("Set Cover failed",
+                   QString("Failed to set %1 to cover %2").arg(dir).arg(cover))
+
+    // Image has changed, nothing deleted
+    QStringList mesg = QStringList("") << QString::number(dir);
+    DBFS::Notify("IMAGE_DB_CHANGED", mesg);
+
+    RESULT_OK(QString("Cover of %1 is now %2").arg(dir).arg(cover));
+}
+
+
+/*!
+ \brief Updates exclusion list for images
+ \details Stores new exclusions setting & rescans. Exclusions is a global setting
+ that dictates which files the scanner ignores. However it is set by any client
+ (last writer wins). Glob characters * and ? are valid.
+ \param exclusions Csv list of exclusion patterns
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleIgnore(const QString &exclusions) const
+{
+    // Save new setting. FE will have already saved it but not cleared the cache
+    gCoreContext->SaveSettingOnHost("GalleryIgnoreFilter", exclusions, NULL);
+
+    // Rescan
+    HandleScanRequest("START");
+
+    RESULT_OK(QString("Using exclusions '%1'").arg(exclusions))
+}
+
+
+/*!
+ \brief Process scan requests.
+ \details Handles start scan, stop scan, clear Db and scan progress queries
+ \param command IMAGE_SCAN, START | STOP | QUERY | CLEAR
+ \param devId Device id. Only used for CLEAR
+ \return QStringList Error message or "OK"
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleScanRequest(const QString &command,
+                                                  int devId) const
+{
+    if (!m_scanner)
+        RESULT_ERR("Missing Scanner", "Missing Scanner");
+
+    if (command == "START")
+    {
+        // Must be dormant to start a scan
+        if (m_scanner->IsScanning())
+            RESULT_ERR("", tr("Scanner is busy"));
+
+        m_scanner->ChangeState(true);
+        RESULT_OK("Scan requested");
+    }
+    else if (command == "STOP")
+    {
+        // Must be scanning to interrupt
+        if (!m_scanner->IsScanning())
+            RESULT_ERR("Scanner not running", "Scanner not running");
+
+        m_scanner->ChangeState(false);
+        RESULT_OK("Terminate scan requested");
+    }
+    else if (command == "QUERY")
+    {
+        return QStringList("OK") << m_scanner->GetProgress();
+    }
+    else if (command.startsWith("DEVICE"))
+    {
+        m_scanner->EnqueueClear(devId, command);
+        RESULT_OK(QString("Clearing device %1 %2").arg(command).arg(devId))
+    }
+    RESULT_ERR("Unknown command", QString("Unknown command %1").arg(command));
+}
+
+
+/*!
+ \brief Creates thumbnails on-demand
+ \details Display requests are the highest priority. Thumbnails required for an
+image node will be created before those that are part of a directory thumbnail.
+A THUMBNAIL_CREATED event is broadcast for each image.
+ \param message For Directory flag, image id
+*/
+template <class DBFS>
+QStringList ImageHandler<DBFS>::HandleCreateThumbnails
+(const QStringList &message) const
+{
+    if (message.size() != 2)
+        RESULT_ERR("Unknown Command",
+                   QString("Bad request: %1").arg(message.join("|")))
+
+    int priority = message.at(0).toInt()
+                ? kDirRequestPriority : kPicRequestPriority;
+
+    // get specific image details from db
+    ImageList files, dirs;
+    DBFS::GetImages(message.at(1), files, dirs);
+
+    foreach (const ImagePtrK &im, files)
+        // notify clients when done; highest priority
+        m_thumbGen->CreateThumbnail(im, priority, true);
+
+    return QStringList("OK");
+}
+
+
+/*!
+ \brief Deletes images and dirs from the filesystem
+ \details Dirs will only be deleted if empty. Items are deleted in reverse
+ order so that parent dirs at front of list will be empty once their subdirs
+ at back of list have been deleted. Files/dirs that failed to delete
+ are removed from the list.
+ \param[in,out] images List of images/dirs to delete. On return the files that
+ were successfully deleted.
+*/
+template <class DBFS>
+void ImageHandler<DBFS>::RemoveFiles(ImageList &images) const
+{
+    QMutableListIterator<ImagePtr> it(images);
+    it.toBack();
+    while (it.hasPrevious())
+    {
+        ImagePtrK im = it.previous();
+
+        // Remove file or directory
+        QString absFilename = DBFS::GetAbsFilePath(im);
+
+        bool success = !absFilename.isEmpty()
+                && (im->IsFile() ? QFile::remove(absFilename)
+                                 : QDir::root().rmdir(absFilename));
+        if (success)
+            LOG(VB_FILE, LOG_DEBUG, LOC + QString("Deleted %1").arg(absFilename));
+        else
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("Can't delete %1").arg(absFilename));
+            // Remove from list
+            it.remove();
+        }
+    }
+}
+
+
+/*!
+ \brief Generate SQL type filter clause
+ \param type Filter pic/video/both
+ \return QString SQL filter clause
+*/
+QString ImageDbReader::TypeSelector(int type)
+{
+    switch (type)
+    {
+    case kPicOnly:     return QString("AND type != %1").arg(kVideoFile);
+    case kVideoOnly:   return QString("AND type != %1").arg(kImageFile);
+    case kPicAndVideo: return "";
+    }
+    return "";
+}
+
+
+/*!
+ \brief Sets filter/ordering SQL clause used when reading database according
+ to current filter/sort settings
+ \details Filters by 'show hidden' & 'show pics/vids/all'. Orders files & dirs
+*/
+void ImageDbReader::SetRefinementClause()
+{
+    m_refineClause = QString("%2 %3 "
+                             "ORDER BY "
+                             "CASE WHEN type <= %1 THEN %4, "
+                             "CASE WHEN type >  %1 THEN %5 ")
+            .arg(kDirectory)
+            .arg(m_showHidden ? "" : "AND hidden = 0",
+                 TypeSelector(m_showType),
+                 OrderSelector(m_dirOrder),
+                 OrderSelector(m_fileOrder));
+}
+
+
+/*!
+ \brief Generate SQL ordering clause
+ \param order Order criteria
+ \return QString SQL order caluse
+*/
+QString ImageDbReader::OrderSelector(int order)
+{
+    // prepare the sorting statement
+    switch (order)
+    {
+    default:
+    case kSortByNameAsc:     return "name END ASC";
+    case kSortByNameDesc:    return "name END DESC";
+    case kSortByModTimeAsc:  return "modtime END ASC";
+    case kSortByModTimeDesc: return "modtime END DESC";
+    case kSortByExtAsc:      return "extension END ASC,  name ASC";
+    case kSortByExtDesc:     return "extension END DESC, name DESC";
+    case kSortBySizeAsc:     return "size END ASC,  name ASC";
+    case kSortBySizeDesc:    return "size END DESC, name DESC";
+    case kSortByDateAsc:     return "IF(date=0, modtime, date) END ASC";
+    case kSortByDateDesc:    return "IF(date=0, modtime, date) END DESC";
+    }
+}
+
+
+/*!
+ \brief Return images (local and/or remote) for a dir and its direct children
+ \param[in] id Dir id
+ \param[out] parent Parent image
+ \param[in out] subdirs Child dirs, filtered & ordered iaw current settings.
+ \param[in out] files Child files, filtered & ordered iaw current settings.
+ \return int Number of images, including parent
+*/
+int ImageDbReader::GetDirectory(int id, ImagePtr &parent,
+                                ImageList &files, ImageList &dirs) const
+{
+    // Only Root node will invoke both Db queries but result set will be small
+    // For Root the SG is always ordered before local devices
+    // Root node has no Db entry so the 2 queries will not overwrite the parent.
+    int count = 0;
+    if (!ImageItem::IsLocalId(id))
+        count = m_remote->GetDirectory(id, parent, files, dirs, m_refineClause);
+    if (m_DbExists && ImageItem::IsLocalParent(id))
+        count += ImageHandler::GetDirectory(id, parent, files, dirs, m_refineClause);
+
+    if (id == GALLERY_DB_ID)
+    {
+        // Add a Root node
+        parent = ImagePtr(new ImageItem(GALLERY_DB_ID));
+        parent->m_parentId = GALLERY_DB_ID;
+        parent->m_type     = kDevice;
+
+        ++count;
+    }
+    return count;
+}
+
+
+/*!
+ \brief Returns images (local or remote but not a combination)
+ \param[in] ids Image ids
+ \param[in out] images List of images, filtered & ordered iaw current settings.
+ \return int Number of images
+*/
+int ImageDbReader::GetImages(ImageIdList ids,
+                             ImageList &files, ImageList &dirs) const
+{
+    // Ids are either all local or all remote. GALLERY_DB_ID not valid
+    StringPair lists = ImageItem::PartitionIds(ids);
+
+    if (!lists.second.isEmpty())
+        return m_remote->GetImages(lists.second, files, dirs, m_refineClause);
+    if (m_DbExists && !lists.first.isEmpty())
+        return ImageHandler::GetImages(lists.first, files, dirs, m_refineClause);
+    return 0;
+}
+
+
+/*!
+ \brief Return (local or remote) images that are direct children of a dir
+ \param[in] id Directory id
+ \param[in out] files List of files, filtered & ordered iaw current settings.
+ \param[in out] dirs List of dirs, filtered & ordered iaw current settings.
+ \return int Number of Images
+*/
+int ImageDbReader::GetChildren(int id, ImageList &files, ImageList &dirs) const
+{
+    int count = 0;
+    if (!ImageItem::IsLocalId(id))
+        count = m_remote->GetChildren(QString::number(id), files, dirs,
+                                      m_refineClause);
+    if (m_DbExists && ImageItem::IsLocalParent(id))
+        count += ImageHandler::GetChildren(QString::number(id), files, dirs,
+                                           m_refineClause);
+    return count;
+}
+
+
+/*!
+ \brief Return all (local or remote) images that are direct children of a dir
+ \param[in] id Directory id, GALLERY_DB_ID not valid
+ \param[in out] files List of files, unfiltered & unordered
+ \param[in out] dirs List of dirs, unfiltered & unordered
+*/
+void ImageDbReader::GetDescendants(const ImageIdList &ids,
+                                   ImageList &files, ImageList &dirs) const
+{
+    // Ids are either all local or all remote
+    StringPair lists = ImageItem::PartitionIds(ids);
+
+    if (!lists.second.isEmpty())
+        m_remote->GetDescendants(lists.second, files, dirs);
+    if (m_DbExists && !lists.first.isEmpty())
+        ImageHandler::GetDescendants(lists.first, files, dirs);
+}
+
+
+/*!
+ \brief Return all files (local or remote) in the sub-trees of a dir
+ \param[in] id Dir id
+ \param[in out] files List of images within sub-tree. Ordered & filtered iaw current
+ settings
+*/
+void ImageDbReader::GetImageTree(int id, ImageList &files) const
+{
+    if (!ImageItem::IsLocalId(id))
+        m_remote->GetImageTree(id, files, m_refineClause);
+    if (m_DbExists && ImageItem::IsLocalParent(id))
+        ImageHandler::GetImageTree(id, files, m_refineClause);
+}
+
+
+/*!
+ \brief Return counts of dirs, pics and videos in the subtree of a dir. Also dir size
+ \param[in] id Dir id
+ \param[in out] dirs Number of dirs in parent sub-tree
+ \param[in out] pics Number of pictures in parent sub-tree
+ \param[in out] videos Number of videos in parent sub-tree
+ \param[in out] sizeKb Size in KiB of parent sub-tree
+*/
+void ImageDbReader::GetDescendantCount(int id, int &dirs, int &pics,
+                                       int &videos, int &sizeKb) const
+{
+    if (id == GALLERY_DB_ID)
+    {
+        // Sum both unfiltered tables
+        m_remote->GetDescendantCount(id, true, dirs, pics, videos, sizeKb);
+        if (m_DbExists)
+            ImageHandler::GetDescendantCount(id, true, dirs, pics, videos, sizeKb);
+    }
+    else if (!ImageItem::IsLocalId(id))
+    {
+        // Don't filter on SG path (it's blank)
+        m_remote->GetDescendantCount(id, id == PHOTO_DB_ID,
+                                     dirs, pics, videos, sizeKb);
+    }
+    else if (m_DbExists)
+    {
+        // Always filter on device/dir
+        ImageHandler::GetDescendantCount(id, false, dirs, pics, videos, sizeKb);
+    }
+}
+
+
+//! Backend Gallery instance
+ImageManagerBe *ImageManagerBe::m_instance = NULL;
+//! Frontend Gallery instance
+ImageManagerFe *ImageManagerFe::m_instance = NULL;
+
+
+/*!
+ \brief Get Backend Gallery
+ \return Backend Gallery singleton
+*/
+ImageManagerBe* ImageManagerBe::getInstance()
+{
+    if (!m_instance)
+        m_instance = new ImageManagerBe();
+    return m_instance;
+}
+
+
+/*!
+ \brief Get Frontend Gallery
+ \return Frontend Gallery singleton
+*/
+ImageManagerFe& ImageManagerFe::getInstance()
+{
+    if (!m_instance)
+        // Use saved settings
+        m_instance = new ImageManagerFe
+                (gCoreContext->GetNumSetting("GalleryImageOrder"),
+                 gCoreContext->GetNumSetting("GalleryDirOrder"),
+                 gCoreContext->GetNumSetting("GalleryShowHidden"),
+                 gCoreContext->GetNumSetting("GalleryShowType"),
+                 gCoreContext->GetSetting("GalleryDateFormat"));
+    return *m_instance;
+}
+
+
+/*!
+ \brief Create thumbnails or verify that they already exist
+ \details A THUMB_AVAILABLE event will be generated for each thumbnail as
+  soon as it exists.
+ \param ids Images requiring thumbnails
+ \param forFolder True if thumbnail is required for a directory image. UI
+ aesthetics consider this to be lower priority than picture/video thumbnails.
+*/
+void ImageManagerFe::CreateThumbnails(const ImageIdList &ids, bool forFolder)
+{
+    // Split images into <locals, remotes>
+    StringPair lists = ImageItem::PartitionIds(ids);
+
+    if (!lists.second.isEmpty())
+    {
+        LOG(VB_FILE, LOG_DEBUG, LOC +
+            QString("Sending CREATE_THUMBNAILS %1 (forFolder %2)")
+            .arg(lists.second).arg(forFolder));
+
+        QStringList message;
+        message << QString::number(forFolder) << lists.second;
+        gCoreContext->SendEvent(MythEvent("CREATE_THUMBNAILS", message));
+    }
+
+    if (!lists.first.isEmpty())
+    {
+        LOG(VB_FILE, LOG_DEBUG, LOC +
+            QString("Creating local thumbnails %1 (forFolder %2)")
+            .arg(lists.first).arg(forFolder));
+
+        QStringList message;
+        message << QString::number(forFolder) << lists.first;
+        HandleCreateThumbnails(message);
+    }
+}
+
+
+/*!
+ \brief Handle scanner start/stop commands
+ \param start True to start a scan, False to stop a scan
+ \param local True to start scan of local devices, False to scan storage group
+ \return QString Error message or empty
+*/
+QString ImageManagerFe::ScanImagesAction(bool start, bool local)
+{
+    QStringList command;
+    command << (start ? "START" : "STOP");
+
+    if (!local)
+    {
+        command.push_front("IMAGE_SCAN");
+        bool ok = gCoreContext->SendReceiveStringList(command, true);
+        return ok ? "" : command[1];
+    }
+
+    // Create database on first scan
+    if (!CreateTable())
+        return "Couldn't create database";
+
+    QStringList err = HandleScanRequest(command[0]);
+    return err[0] == "OK" ? "" : err[1];
+}
+
+
+/*!
+ * \brief Returns storage group scanner status
+ * \return QStringList State ("ERROR" | "OK"), SG scanner id "1",
+ * Progress count, Total
+ */
+QStringList ImageManagerFe::ScanQuery()
+{
+    QStringList strList;
+    strList << "IMAGE_SCAN" << "QUERY";
+
+    if (!gCoreContext->SendReceiveStringList(strList))
+    {
+        LOG(VB_GENERAL, LOG_ERR, LOC + QString("Scan query failed : %1")
+            .arg(strList.join(",")));
+    }
+    return strList;
+}
+
+
+/*!
+ * \brief Hide/unhide images
+ * \param hidden True to hide, False to show images
+ * \param ids List of image ids
+ * \return QString Error message, if not empty
+ */
+QString ImageManagerFe::HideFiles(bool hidden, const ImageIdList &ids)
+{
+    // Split images into <locals, remotes>
+    StringPair lists = ImageItem::PartitionIds(ids);
+    QString result = "";
+
+    if (!lists.second.isEmpty())
+    {
+        QStringList message;
+        message << "IMAGE_HIDE" << QString::number(hidden) << lists.second;
+
+        if (!gCoreContext->SendReceiveStringList(message, true))
+            result = message[1];
+    }
+
+    if (!lists.first.isEmpty())
+    {
+        QStringList err = HandleHide(hidden, lists.first);
+        if (err[0] != "OK")
+            result = err[1];
+    }
+    return result;
+}
+
+
+/*!
+ * \brief Apply an orientation transform to images
+ * \param  transform Transformation to apply
+ * \param  ids List of image ids
+ * \return QString Error message, if not empty
+ */
+QString ImageManagerFe::ChangeOrientation(ImageFileTransform transform,
+                                          const ImageIdList &ids)
+{
+    // Split images into <locals, remotes>
+    StringPair lists = ImageItem::PartitionIds(ids);
+    QString result = "";
+
+    if (!lists.second.isEmpty())
+    {
+        QStringList message;
+        message << "IMAGE_TRANSFORM" << QString::number(transform) << lists.second;
+
+        if (!gCoreContext->SendReceiveStringList(message, true))
+            result = message[1];
+    }
+
+    if (!lists.first.isEmpty())
+    {
+        QStringList err = HandleTransform(transform, lists.first);
+        if (err[0] != "OK")
+            result = err[1];
+    }
+    return result;
+}
+
+
+/*!
+ * \brief Set image to use as a cover thumbnail(s)
+ * \param  parent Id of directory to change
+ * \param  cover Image id to use as cover
+ * \return QString Error message, if not empty
+ */
+QString ImageManagerFe::SetCover(int parent, int cover)
+{
+    if (!ImageItem::IsLocalId(parent))
+    {
+        QStringList message;
+        message << "IMAGE_COVER" << QString::number(parent) << QString::number(cover);
+
+        bool ok = gCoreContext->SendReceiveStringList(message, true);
+        return ok ? "" : message[1];
+    }
+
+    QStringList err = HandleCover(parent, cover);
+    return err[0] == "OK" ? "" : err[1];
+}
+
+
+/*!
+ * \brief Requests all exif/ffmpeg tags for an image, which returns by event
+ * \param  id An image id
+ */
+void ImageManagerFe::RequestMetaData(int id)
+{
+    if (ImageItem::IsLocalId(id))
+        HandleGetMetadata(QString::number(id));
+    else
+        gCoreContext->SendEvent(MythEvent("IMAGE_GET_METADATA", QString::number(id)));
+}
+
+
+//! Clear database & thumbnails of Storage Group images
+void ImageManagerFe::ClearStorageGroup()
+{
+    QStringList message("IMAGE_SCAN");
+    message << "DEVICE CLEAR ALL";
+    gCoreContext->SendReceiveStringList(message, true);
+}
+
+
+/*!
+ * \brief Set directories to ignore during scans of the storage group
+ * \param excludes Comma separated list of dir names/patterns to exclude. Glob
+ * characters * and ? permitted.
+ * \return QString Error message, if not empty
+ */
+QString ImageManagerFe::IgnoreDirs(const QString &excludes)
+{
+    QStringList message("IMAGE_IGNORE");
+    message << excludes;
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+/*!
+ \brief Create directories
+ \param parent Dir in which to create new dirs
+ \param names List of dir names
+ \param Whether to scan after creating dirs
+ \return QString Error message, if not empty
+*/
+QString ImageManagerFe::MakeDir(int parent, const QStringList &names, bool rescan)
+{
+    QString destId = QString::number(parent);
+
+    if (!ImageItem::IsLocalId(parent))
+    {
+        QStringList message("IMAGE_CREATE_DIRS");
+        message << destId << QString::number(rescan) << names;
+        bool ok = gCoreContext->SendReceiveStringList(message, true);
+        return ok ? "" : message[1];
+    }
+    QStringList err = HandleDirs(destId, rescan, names);
+    return (err[0] == "OK") ? "" : err[1];
+}
+
+
+/*!
+ * \brief Rename an image
+ * \param  im An image
+ * \param  name New name of the file/dir (basename only, no path or extension)
+ * \return QString Error message, if not empty
+ */
+QString ImageManagerFe::RenameFile(ImagePtrK im, const QString &name)
+{
+    if (!im->IsLocal())
+    {
+        QStringList message("IMAGE_RENAME");
+        message << QString::number(im->m_id) << name;
+        bool ok = gCoreContext->SendReceiveStringList(message, true);
+        return ok ? "" : message[1];
+    }
+    QStringList err = HandleRename(QString::number(im->m_id), name);
+    return (err[0] == "OK") ? "" : err[1];
+}
+
+
+/*!
+ * \brief Copies database images (but not the files themselves).
+ * \param destId Id of an image directory
+ * \param images List of images to copy
+ * \return QString Error message
+ */
+QString ImageManagerFe::CreateImages(int destId, const ImageListK &images)
+{
+    if (images.isEmpty())
+        return "";
+
+    // Define field seperator & include it in message
+    const QString seperator("...");
+    QStringList imageDefs(seperator);
+    ImageIdList ids;
+    foreach (const ImagePtrK &im, images)
+    {
+        ids << im->m_id;
+
+        // Copies preserve hide state, orientation & cover
+        QStringList aDef;
+        aDef << QString::number(im->m_id)
+             << QString::number(im->m_type)
+             << im->m_filePath
+             << QString::number(im->m_isHidden)
+             << QString::number(im->m_orientation)
+             << QString::number(im->m_userThumbnail);
+
+        imageDefs << aDef.join(seperator);
+    }
+
+    // Images are either all local or all remote
+    if (ImageItem::IsLocalId(destId))
+    {
+        QStringList err = HandleDbCreate(imageDefs);
+        return (err[0] == "OK") ? "" : err[1];
+    }
+    imageDefs.prepend("IMAGE_COPY");
+    bool ok = gCoreContext->SendReceiveStringList(imageDefs, true);
+    return ok ? "" : imageDefs[1];
+}
+
+
+/*!
+ * \brief Moves database images (but not the files themselves).
+ * \param destDir Destination image directory
+ * \param images List of images to copy
+ * \param srcPath Original parent path
+ * \return QString Error message
+ */
+QString ImageManagerFe::MoveDbImages(ImagePtrK destDir, ImageListK &images,
+                                     const QString &srcPath)
+{
+    QStringList idents;
+    foreach (const ImagePtrK &im, images)
+        idents << QString::number(im->m_id);
+
+    // Images are either all local or all remote
+    if (destDir->IsLocal())
+    {
+        QStringList err = HandleDbMove(idents.join(","), srcPath,
+                                       destDir->m_filePath);
+        return (err[0] == "OK") ? "" : err[1];
+    }
+
+    QStringList message("IMAGE_MOVE");
+    message << idents.join(",") << srcPath << destDir->m_filePath;
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+/*!
+ * \brief Delete images
+ * \param  ids List of image ids
+ * \return QString Error message, if not empty
+ */
+QString ImageManagerFe::DeleteFiles(const ImageIdList &ids)
+{
+    StringPair lists = ImageItem::PartitionIds(ids);
+
+    QString result = "";
+    if (!lists.second.isEmpty())
+    {
+        QStringList message("IMAGE_DELETE");
+        message << lists.second;
+
+        bool ok = gCoreContext->SendReceiveStringList(message, true);
+        if (!ok)
+            result = message[1];
+    }
+    if (!lists.first.isEmpty())
+    {
+        QStringList err = HandleDelete(lists.first);
+        if (err[0] != "OK")
+            result = err[1];
+    }
+    return result;
+}
+
+
+/*!
+ \brief Return a timestamp/datestamp for an image or dir
+ \details Uses exif timestamp if defined, otherwise file modified date
+ \param im Image or dir
+ \return QString Time or date string formatted as per Myth general settings
+*/
+QString ImageManagerFe::LongDateOf(ImagePtrK im) const
+{
+    if (im->m_id == GALLERY_DB_ID)
+        return "";
+
+    uint secs = 0;
+    uint format = MythDate::kDateFull | MythDate::kAddYear;
+
+    if (im->m_date > 0)
+    {
+        secs = im->m_date;
+        format |= MythDate::kTime;
+    }
+    else
+        secs = im->m_modTime;
+
+    return MythDate::toString(QDateTime::fromTime_t(secs), format);
+}
+
+
+/*!
+ \brief Return a short datestamp for thumbnail captions
+ \details Uses exif date if defined, otherwise file modified date
+ \param im Image or dir
+ \return QString Date formatted as per Gallery caption date format.
+*/
+QString ImageManagerFe::ShortDateOf(ImagePtrK im) const
+{
+    if (im->m_id == GALLERY_DB_ID)
+        return "";
+
+    uint secs(im->m_date > 0 ? im->m_date : im->m_modTime);
+    return QDateTime::fromTime_t(secs).date().toString(m_dateFormat);
+}
+
+
+/*!
+ \brief Return a displayable name (with optional path) for an image.
+ \details Uses device name rather than mount path for local devices
+ \param im Image
+ \param path If true, name will include path. Otherwise only the basename
+ \return QString Filepath for display
+*/
+QString ImageManagerFe::CrumbName(ImagePtrK im, bool path) const
+{
+    if (im->IsDevice())
+    {
+        if (im->m_id == GALLERY_DB_ID)
+            return ImageHandler::tr("Gallery");
+        else
+            return im->IsLocal() ? DeviceName(im->m_device)
+                                 : m_remote->DeviceName(im->m_device);
+    }
+    if (!path)
+        return im->m_baseName;
+    if (!im->IsLocal())
+        // Remote path always relative
+        return im->m_filePath;
+    // Replace mount path with device name
+    int mountLen = DeviceMount(im->m_device).size();
+    return DeviceName(im->m_device) + im->m_filePath.mid(mountLen);
+}
+
+
+void ImageManagerFe::CloseDevices(int devId, bool eject)
+{
+    QString reason = (devId == DEVICE_INVALID)
+            ? "DEVICE CLOSE ALL"
+            : eject ? "DEVICE EJECT" : "DEVICE REMOVE";
+    HandleScanRequest(reason, devId);
+}
+
+
+/*!
+ * \brief Detect and scan local devices
+ * \return True if local devices exist
+ */
+bool ImageManagerFe::DetectLocalDevices()
+{
+    MediaMonitor *monitor = MediaMonitor::GetMediaMonitor();
+    if (!monitor)
+        return false;
+
+    // Detect all local media
+    QList<MythMediaDevice*> devices = monitor->GetRemovable(true, true);
+
+    foreach (MythMediaDevice* dev, devices)
+    {
+        if (monitor->ValidateAndLock(dev) && dev->isUsable())
+            OpenDevice(dev->getDeviceModel(), dev->getMountPath(), dev);
+        else
+            monitor->Unlock(dev);
+    }
+
+    if (DeviceCount() > 0)
+    {
+        // Close devices that are no longer present
+        foreach (int devId, GetAbsentees())
+            CloseDevices(devId);
+
+        // Start local scan
+        QString err = ScanImagesAction(true, true);
+        if (!err.isEmpty())
+            LOG(VB_GENERAL, LOG_ERR, LOC + err);
+    }
+    return DeviceCount() > 0;
+}
+
+
+/*!
+ * \brief Manage events for local devices
+ * \param event Appeared/disappeared events
+ */
+void ImageManagerFe::DeviceEvent(MythMediaEvent *event)
+{
+    MediaMonitor *monitor = MediaMonitor::GetMediaMonitor();
+
+    if (!event || !monitor)
+        return;
+
+    MythMediaDevice *dev = event->getDevice();
+    if (!dev)
+        return;
+
+    MythMediaType   type   = dev->getMediaType();
+    MythMediaStatus status = dev->getStatus();
+
+    LOG(VB_FILE, LOG_DEBUG, LOC +
+        QString("Media event for %1 (%2) at %3, type %4, status %5 (was %6)")
+        .arg(dev->getDeviceModel(), dev->getVolumeID(), dev->getMountPath())
+        .arg(type).arg(status).arg(event->getOldStatus()));
+
+    if (!(type & (MEDIATYPE_DATA | MEDIATYPE_MIXED | MEDIATYPE_MGALLERY)))
+    {
+        LOG(VB_FILE, LOG_DEBUG, LOC +
+            QString("Ignoring event - wrong type %1").arg(type));
+        return;
+    }
+
+    if (status == MEDIASTAT_USEABLE || status == MEDIASTAT_MOUNTED)
+    {
+        // New device. Lock it & scan
+        if (monitor->ValidateAndLock(dev))
+        {
+            OpenDevice(dev->getDeviceModel(), dev->getMountPath(), dev);
+            ScanImagesAction(true, true);
+        }
+        else
+            monitor->Unlock(dev);
+        return;
+    }
+
+    // Device has disappeared
+    int devId = LocateMount(dev->getMountPath());
+    if (devId != DEVICE_INVALID)
+        CloseDevices(devId);
+}
+
+
+QString ImageManagerFe::CreateImport()
+{
+    QTemporaryDir *tmp = new QTemporaryDir(QDir::tempPath() % "/Import-XXXXXX");
+    if (!tmp->isValid())
+    {
+        delete tmp;
+        return "";
+    }
+
+    QString time(QDateTime::currentDateTime().toString("mm:ss"));
+    OpenDevice("Import " + time, tmp->path(), NULL, tmp);
+    return tmp->path();
+}
+
+
+// Must define the valid template implementations to generate code for the
+// instantiations (as they are defined in the cpp rather than header).
+// Otherwise the linker will fail with undefined references...
+template class ImageDb<ImageAdapterSg>;
+template class ImageDb<ImageAdapterLocal>;
+template class ImageHandler<ImageDbSg>;
+template class ImageHandler<ImageDbLocal>;
diff --git a/mythtv/libs/libmythmetadata/imagemanager.h b/mythtv/libs/libmythmetadata/imagemanager.h
new file mode 100644
index 0000000..837353a
--- /dev/null
+++ b/mythtv/libs/libmythmetadata/imagemanager.h
@@ -0,0 +1,508 @@
+//! \file
+//! \brief Manages a collection of images
+//! \details Provides a generic Gallery comprising;
+//! a database API for reading images,
+//! a scanner to synchronise the database to a filesystem
+//! a thumbnail generator to manage thumbnails for each database image
+//! handlers for image operations
+
+/* Myth uses two Gallery instances;
+ *
+ * One runs on the BE to manage the 'Photographs' Storage Group. The (permanent)
+ * database table is synchronised to SG files, thumbnails are generated and stored
+ * in the Temp SG, and BE messages for these images are handled.
+ *
+ * A separate instance runs on each FE to manage local/removeable media. This uses
+ * a temporary, memory Db table that is synchronised to images on USB/CDs etc,
+ * as they are mounted. Thumbnails are generated/stored on the FE and operations on
+ * these images are handled locally. The Db table and all thumbnails are removed
+ * when the FE exits.
+ *
+ * The UI integrates images/functions from both instances seamlessly.
+ *
+ * Commonality is provided by using an adapter layer for database and filesystem access.
+ * Functionality is segregated into local classes, which are layered on an
+ * adapter to assemble singletons for a BE manager & FE manager - the only
+ * elements intended for external use.
+ *
+ *                              Device manager
+ *                                    |
+ *                              Common Adapter
+ *                              /             \
+ *                  BE adapter                  FE adapter
+ *                       |      Common Db API       |
+ *                       |      /             \     |
+ *                  BE Db functions             FE Db functions
+ *                       |      Common Handler      |
+ *                       |      /             \     |
+ *                  BE manager                  UI Db API
+ *                                                  |
+ *                                              FE manager
+ *
+ * Implemented using templates rather than polymorphism for speed/efficiency.
+ */
+
+#ifndef IMAGEMANAGER_H
+#define IMAGEMANAGER_H
+
+#include <QTemporaryDir>
+
+#include "mythcorecontext.h"
+#include "storagegroup.h"
+#include "mythdirs.h"
+
+#include "imagescanner.h"
+#include "imagemetadata.h"
+
+
+// Builtin storage groups as per storagegroup.cpp
+#define IMAGE_STORAGE_GROUP         "Photographs"
+#define THUMBNAIL_STORAGE_GROUP     "Temp"
+
+// Filesystem dir within config dir used by TEMP SG
+#define TEMP_SUBDIR                 "tmp"
+// Filesystem dir within tmp config dir where thumbnails reside
+#define THUMBNAIL_SUBDIR            "Images"
+
+#define DEVICE_INVALID -1
+
+
+class MythMediaDevice;
+class MythMediaEvent;
+
+//! Display filter
+enum ImageDisplayType {
+    kPicAndVideo = 0, //!< Show Pictures & Videos
+    kPicOnly     = 1, //!< Hide videos
+    kVideoOnly   = 2  //!< Hide pictures
+};
+
+class Device;
+
+//! Manages image sources, ie. SG, local media (USBs, CDs etc), import directories.
+//! A single SG device is opened on first use & never closed (no cleanup) .
+//! Imports are created by user & deleted when 'ejected' or FE exits, which cleans
+//! up thumbnails and imported images.
+//! Gallery scans local devices (MediaMonitor) whenever the UI starts.
+//! A local device is opened when first detected, closed when Gallery UI exits
+//! (to allow unmounting) but persists for subsequent Gallery use.
+//! It and its thumbnails are deleted by FE exit, user 'eject', system unmount
+//! or if it is no longer present when Gallery re-starts
+class META_PUBLIC DeviceManager
+{
+public:
+    QStringList CloseDevices(int devId, const QString &action);
+    QString DeviceMount(int devId) const;
+    QString DeviceName(int devId) const;
+    int     DeviceCount() const   { return m_devices.size(); }
+    QString     ThumbDir(int fs) const;
+
+protected:
+    int     OpenDevice(const QString &name, const QString &mount,
+                       MythMediaDevice *media = NULL,
+                       QTemporaryDir   *dir = NULL);
+
+    int         LocateMount(const QString &mount) const;
+    StringMap   GetDeviceDirs() const;
+    QList<int>  GetAbsentees();
+
+    DeviceManager() : m_devices() {}
+    ~DeviceManager();
+
+private:
+    typedef QMap<int, Device*> DeviceMap;
+
+    //! Device store
+    DeviceMap m_devices;
+};
+
+
+//! Common filesystem facilities
+class ImageAdapterBase : public DeviceManager
+{
+public:
+    //! Assembles a canonical file path without corrupting its absolute/relative nature.
+    static QString ConstructPath(const QString &path, const QString &name)
+    {  return path.isEmpty() ? name : path + "/" + name; }
+
+    //! Extracts file name (incl extension) from a filepath
+    static QString BaseNameOf(const QString &path)
+    { QString result = path.section('/', -1); return result.isNull() ? "" : result; }
+
+    //! Extracts path from a filepath
+    static QString PathOf(const QString &path)
+    { QString result = path.section('/', 0, -2); return result.isNull() ? "" : result; }
+
+    static QString FormatSize(int sizeKib)
+    {  return (sizeKib < 10000) ? QString("%L1 KiB").arg(sizeKib)
+                                : QString("%L1 MiB").arg(sizeKib / 1024.0, 0, 'f', 1); }
+
+    //! Get absolute filepath for thumbnail of an image
+    static QString GetAbsThumbPath(const QString &devPath, const QString &path)
+    { return QString("%1/" TEMP_SUBDIR "/%2/%3").arg(GetConfDir(), devPath, path); }
+
+    //! Thumbnails of videos are a JPEG snapshot with jpg suffix appended
+    static QString ThumbPath(const ImageItem &im)
+    { return im.m_type != kVideoFile ? im.m_filePath : im.m_filePath + ".jpg"; }
+
+    /*!
+     * \brief Get filters for detecting recognised images/videos
+     * \details Supported pictures are determined by QImage; supported videos
+     * are determined from the mythplayer settings (Video Associations)
+     * \sa http://qt-project.org/doc/qt-4.8/qimagereader.html#supportedImageFormats
+     * \return QDir A QDir initialised with filters for detecting images/videos
+     */
+    QDir GetImageFilters() const { return m_dirFilter; }
+
+    //! Determine file type from its extension
+    ImageNodeType GetImageType(const QString &ext) const
+    { return m_imageFileExt.contains(ext)
+                ? kImageFile
+                : m_videoFileExt.contains(ext) ? kVideoFile : kUnknown; }
+protected:
+    ImageAdapterBase();
+
+private:
+    //! A pre-configured dir for reading image/video files
+    QDir        m_dirFilter;
+    //! List of file extensions recognised as pictures
+    QStringList m_imageFileExt;
+    //! List of file extensions recognised as videos
+    QStringList m_videoFileExt;
+};
+
+
+/*!
+ \brief Filesystem adapter for Frontend, managing local devices iaw MediaMonitor
+ \details Scanner will scan these devices.
+ Creates images with negative ids and absolute filepaths
+ Thumbnails are stored locally and deleted when FE exits.
+*/
+class ImageAdapterLocal : public ImageAdapterBase
+{
+public:
+    ImageAdapterLocal() : ImageAdapterBase() {}
+
+    ImageItem *CreateItem(const QFileInfo &fi, int parentId, int devId,
+                          const QString &base) const;
+
+    //! Returns local device dirs to scan
+    StringMap GetScanDirs() const  { return GetDeviceDirs(); }
+
+    //! Get absolute filepath for a local image
+    QString GetAbsFilePath(const ImagePtrK &im) const
+    { return im->m_filePath; }
+
+    //! Construct URL of a local image, which is an absolute path
+    QString MakeFileUrl(const QString &path) const { return path; }
+
+    //! Construct URL of the thumbnail of a local image (An absolute path)
+    QString MakeThumbUrl(const QString &devPath, const QString &path = "") const
+    { return GetAbsThumbPath(devPath, path); }
+
+    void Notify(const QString &mesg, const QStringList &extra) const;
+
+protected:
+    // Adapter functions used by Database for local images. Negate ids in & out
+    int     ImageId(int id) const            { return ImageItem::ToLocalId(id); }
+    QString ImageId(const QString &id) const { return ImageItem::ToLocalId(id); }
+    int     DbId(int id) const               { return ImageItem::ToDbId(id); }
+    QString DbIds(const QString &ids) const  { return ImageItem::ToDbId(ids); }
+};
+
+
+/*!
+ \brief Filesystem adapter for Backend, managing Photographs storage group.
+ \details Scanner will scan SG. Creates images with positive ids and relative filepaths
+ Thumbnails are stored in Temp SG.
+*/
+class ImageAdapterSg : public ImageAdapterBase
+{
+public:
+    ImageAdapterSg() : ImageAdapterBase(),
+        m_hostname(gCoreContext->GetMasterHostName()),
+        m_hostport(gCoreContext->GetMasterServerPort()),
+        m_sg(StorageGroup(IMAGE_STORAGE_GROUP, m_hostname, false)) {}
+
+    ImageItem *CreateItem(const QFileInfo &fi, int parentId, int devId,
+                          const QString &base) const;
+    StringMap  GetScanDirs() const;
+    QString    GetAbsFilePath(const ImagePtrK &im) const;
+
+    //! Construct URL of a remote image.
+    QString MakeFileUrl(const QString &path) const
+    { return gCoreContext->GenMythURL(m_hostname, m_hostport, path,
+                                      IMAGE_STORAGE_GROUP); }
+
+    //! Construct URL of the thumbnail of a remote image
+    QString MakeThumbUrl(const QString &devPath, const QString &path = "") const
+    { return gCoreContext->GenMythURL(m_hostname, m_hostport,
+                                      devPath + "/" + path,
+                                      THUMBNAIL_STORAGE_GROUP); }
+
+    void Notify(const QString &mesg, const QStringList &extra) const;
+
+protected:
+    // Adapter functions used by Database for remote images. Do nothing
+    int     ImageId(int id) const            { return id; }
+    QString ImageId(const QString &id) const { return id; }
+    int     DbId(int id) const               { return id; }
+    QString DbIds(const QString &ids) const  { return ids; }
+
+private:
+    //! Host of SG
+    QString m_hostname, m_hostport;
+    //! Images storage group.
+    // Marked mutable as storagegroup.h does not enforce const-correctness
+    mutable StorageGroup m_sg;
+};
+
+
+//! Database API. Requires a filesystem adapter
+//! Only handles a single id format, ie. local ids or remote ids
+//! Provides ordering & filters (SQL does the work)
+template <class FS>
+class META_PUBLIC ImageDb : public FS
+{
+public:
+    // Handler support
+    int         GetImages(const QString &ids, ImageList &files, ImageList &dirs,
+                          const QString &refine = "") const;
+    bool        GetDescendants(const QString &ids,
+                               ImageList &files, ImageList &dirs) const;
+    int         InsertDbImage(ImageItemK &im, bool checkForDuplicate = false) const;
+    bool        UpdateDbImage(ImageItemK &im) const;
+    QStringList RemoveFromDB(const ImageList &imList) const;
+
+    bool SetHidden(bool hide, QString ids) const;
+    bool SetCover(int dir, int id) const;
+    bool SetOrientation(int id, int orientation) const;
+
+    // Scanner support
+    bool ReadAllImages(ImageHash &files, ImageHash &dirs) const;
+    void ClearDb(int fsId, const QString &action);
+
+    // ImageReader support
+    int  GetChildren(QString ids, ImageList &files, ImageList &dirs,
+                     const QString &refine = "") const;
+    bool GetImageTree(int id, ImageList &files, const QString &refine) const;
+    int  GetDirectory(int id, ImagePtr &parent, ImageList &files, ImageList &dirs,
+                      const QString &refine) const;
+    void GetDescendantCount(int id, bool all, int &dirs, int &pics,
+                            int &videos, int &sizeKb) const;
+
+protected:
+    ImageDb(const QString &table) : FS(), m_table(table) {}
+
+    ImageItem *CreateImage(const MSqlQuery &query) const;
+    int        ReadImages(ImageList &dirs, ImageList &images,
+                          const QString &selector) const;
+    //! Db table name
+    QString m_table;
+};
+
+
+//! A Database API with SG adapter for remote images
+class META_PUBLIC ImageDbSg : public ImageDb<ImageAdapterSg>
+{
+public:
+    ImageDbSg();
+};
+
+
+//! A Database with device adapter for local images
+class META_PUBLIC ImageDbLocal : public ImageDb<ImageAdapterLocal>
+{
+protected:
+    ImageDbLocal();
+    ~ImageDbLocal()          { DropTable(); }
+    bool CreateTable();
+    bool m_DbExists;
+
+private:
+    void DropTable();
+};
+
+
+//! A handler for image operations. Requires a database/filesystem adapter
+template <class DBFS>
+class META_PUBLIC ImageHandler : protected DBFS
+{
+    Q_DECLARE_TR_FUNCTIONS()
+public:
+    QStringList HandleRename(const QString &, const QString &) const;
+    QStringList HandleDelete(const QString &) const;
+    QStringList HandleDbCreate(QStringList) const;
+    QStringList HandleDbMove(const QString &, const QString &, QString) const;
+    QStringList HandleHide(bool, const QString &ids) const;
+    QStringList HandleTransform(int, const QString &) const;
+    QStringList HandleDirs(const QString &, bool rescan,
+                           const QStringList &relPaths) const;
+    QStringList HandleCover(int, int) const;
+    QStringList HandleIgnore(const QString &) const;
+    QStringList HandleScanRequest(const QString &, int devId = DEVICE_INVALID) const;
+    QStringList HandleCreateThumbnails(const QStringList &) const;
+    QStringList HandleGetMetadata(const QString &) const;
+
+protected:
+    ImageHandler() : DBFS(),
+        m_thumbGen(new ImageThumb<DBFS>(this)),
+        m_scanner(new ImageScanThread<DBFS>(this, m_thumbGen)) {}
+
+    ~ImageHandler()
+    {
+        delete m_scanner;
+        delete m_thumbGen;
+    }
+
+    void RemoveFiles(ImageList &) const;
+
+    ImageThumb<DBFS>      *m_thumbGen; //!< Thumbnail generator
+    ImageScanThread<DBFS> *m_scanner;  //!< File scanner
+};
+
+
+/*!
+ \brief The image manager to be used by the Backend
+ \details A singleton created on first use and deleted when BE exits.
+ Manages all storage group (remote) images
+*/
+class META_PUBLIC ImageManagerBe : protected QObject, public ImageHandler<ImageDbSg>
+{
+public:
+    static ImageManagerBe* getInstance();
+
+protected:
+    ImageManagerBe() :QObject(), ImageHandler()
+    {
+        // Cleanup & terminate child threads before application exits
+        connect(qApp, SIGNAL(aboutToQuit()), this, SLOT(deleteLater()));
+    }
+
+    //! BE Gallery instance
+    static ImageManagerBe *m_instance;
+};
+
+
+/*!
+ \brief Provides read access to local & remote images
+ \details Also manages UI filters (show hidden, show pics/vids) and UI ordering.
+ All filtering and sorting is performed by SQL as images are retrieved.
+*/
+class META_PUBLIC ImageDbReader : protected ImageHandler<ImageDbLocal>
+{
+public:
+    ~ImageDbReader() { delete m_remote; }
+
+    int  GetType()        { return m_showType; }
+    bool GetVisibility()  { return m_showHidden; }
+
+    void SetType(int showType)
+    { m_showType = showType; SetRefinementClause(); }
+
+    void SetSortOrder(int order, int dirOrder)
+    { m_dirOrder = dirOrder; m_fileOrder = order; SetRefinementClause(); }
+
+    void SetVisibility(bool showHidden)
+    { m_showHidden = showHidden; SetRefinementClause(); }
+
+    int  GetImages(ImageIdList ids, ImageList &files, ImageList &dirs) const;
+    int  GetChildren(int id, ImageList &files, ImageList &dirs) const;
+    int  GetDirectory(int id, ImagePtr &parent,
+                      ImageList &files, ImageList &dirs) const;
+    void GetDescendants(const ImageIdList &ids,
+                        ImageList &files, ImageList &dirs) const;
+    void GetImageTree(int id, ImageList &files) const;
+    void GetDescendantCount(int id, int &dirs, int &pics, int &videos,
+                            int &sizeKb) const;
+protected:
+    ImageDbReader(int order, int dirOrder, bool showAll, int showType)
+        : ImageHandler(),        m_remote(new ImageDbSg()),
+          m_dirOrder(dirOrder),  m_fileOrder(order),
+          m_showHidden(showAll), m_showType(showType)
+    { SetRefinementClause(); }
+
+    void SetRefinementClause();
+
+    static QString TypeSelector(int type);
+    static QString OrderSelector(int order);
+
+    ImageDbSg* m_remote;    //!< Remote database access
+
+    int     m_dirOrder;     //!< Display ordering of dirs
+    int     m_fileOrder;    //!< Display ordering of pics/videos
+    bool    m_showHidden;   //!< Whether hidden images are displayed
+    int     m_showType;     //!< Type of images to display - pic only/video only/both
+    QString m_refineClause; //!< SQL clause for image filtering/ordering
+};
+
+
+/*!
+ \brief The image manager for use by Frontends
+ \details A singleton created on first use and deleted when FE exits.
+ As sole API for UI, it handles local & remote images. Actions for local images
+ are processed internally; actions for remote images are delegated to the Backend.
+ Incorporates a remote Db adapter for read-only access to remote images.
+ Manages all local images (on removeable media) locally.
+*/
+class META_PUBLIC ImageManagerFe : protected QObject, public ImageDbReader
+{
+public:
+    static ImageManagerFe &getInstance();
+
+    // UI actions on all images
+    void        CreateThumbnails(const ImageIdList &ids, bool forFolder);
+    QString     ScanImagesAction(bool start, bool local = false);
+    QStringList ScanQuery();
+    QString     HideFiles(bool hidden, const ImageIdList &ids);
+    QString     ChangeOrientation(ImageFileTransform transform, const ImageIdList &ids);
+    QString     SetCover(int parent, int cover);
+    void        RequestMetaData(int id);
+    QString     IgnoreDirs(const QString &excludes);
+    QString     MakeDir(int, const QStringList &names, bool rescan = true);
+    QString     RenameFile(ImagePtrK im, const QString &name);
+    QString     CreateImages(int, const ImageListK &transfers);
+    QString     MoveDbImages(ImagePtrK destDir, ImageListK &images, const QString &);
+    QString     DeleteFiles(const ImageIdList &);
+    void        ClearStorageGroup();
+    void        CloseDevices(int devId = DEVICE_INVALID, bool eject = false);
+
+    using ImageAdapterBase::ConstructPath;
+
+    // Local Device management
+    bool    DetectLocalDevices();
+    void    DeviceEvent(MythMediaEvent *event);
+    QString CreateImport();
+    using  DeviceManager::DeviceCount;
+    using  DeviceManager::OpenDevice;
+
+    // UI helper functions
+    void SetDateFormat(const QString &format)    { m_dateFormat = format; }
+    QString LongDateOf(ImagePtrK) const;
+    QString ShortDateOf(ImagePtrK) const;
+    QString CrumbName(ImagePtrK im, bool path = false) const;
+
+    //! Generate Myth URL for a local or remote path
+    QString BuildTransferUrl(const QString &path, bool local) const
+    { return local ? ImageDbReader::MakeFileUrl(path)
+                   : m_remote->MakeFileUrl(path); }
+
+protected:
+    ImageManagerFe(int order, int dirOrder, bool showAll, int showType,
+                   QString dateFormat)
+        : ImageDbReader(order, dirOrder, showAll, showType),
+          m_dateFormat(dateFormat)
+    {
+        // Cleanup & terminate child threads before application exits
+        connect(qApp, SIGNAL(aboutToQuit()), this, SLOT(deleteLater()));
+    }
+
+    //! FE Gallery instance
+    static ImageManagerFe *m_instance;
+
+    //! UI format for thumbnail date captions
+    QString    m_dateFormat;
+};
+
+
+#endif // IMAGEMANAGER_H
diff --git a/mythtv/libs/libmythmetadata/imagemetadata.cpp b/mythtv/libs/libmythmetadata/imagemetadata.cpp
index ed58834..f4ebbb2 100644
--- a/mythtv/libs/libmythmetadata/imagemetadata.cpp
+++ b/mythtv/libs/libmythmetadata/imagemetadata.cpp
@@ -1,11 +1,12 @@
 #include "imagemetadata.h"
 
-#include <QRegExp>
-#include <QMap>
-#include <QPair>
-#include <QDateTime>
-#include <QMutexLocker>
-#include <QByteArray>
+#include <QImage>
+
+#include "mythlogging.h"
+#include "mythcorecontext.h"  // for avcodeclock
+#include "mythdirs.h"         // for ffprobe
+#include "mythsystemlegacy.h" // for ffprobe
+#include "exitcodes.h"        // for ffprobe
 
 // libexiv2 for Exif metadata
 #include <exiv2/exiv2.hpp>
@@ -17,59 +18,77 @@
 #include <exiv2/image.hpp>
 #endif
 
-#include <mythlogging.h>
+// To read FFMPEG Metadata
+extern "C" {
+#include "libavformat/avformat.h"
+}
+
+// Uncomment this to log raw metadata from exif/ffmpeg
+//#define DUMP_METADATA_TAGS yes
+
+#define LOC QString("ImageMetaData: ")
 
 
 /*!
- \brief Convert degree rotation into orientation code
- \param degrees Rotation required to show video correctly
- \return QString Code as per Exif spec.
-*/
-QString ExifOrientation::FromRotation(QString degrees)
+ * \brief Adjust orientation to apply a transform to an image
+ * \param transform Rotation/flip/reset to apply
+ * \return int Adjusted composite orientation of the image
+ */
+int Orientation::Transform(int transform)
 {
-    if      (degrees ==   "0") return "1";
-    else if (degrees ==  "90") return "6";
-    else if (degrees == "180") return "3";
-    else if (degrees == "270") return "8";
-    return "0";
+    m_current = Apply(transform);
+    return Composite();
 }
 
 
-/*!
- \brief Converts orientation code to text description
- \param orientation Exif code
- \return QString Description text
-*/
-QString ExifOrientation::Description(QString orientation)
+QImage Orientation::ApplyExifOrientation(QImage &image, int orientation)
 {
-    if      (orientation == "0") return tr("0 - Unset");
-    else if (orientation == "1") return tr("1 - Normal");
-    else if (orientation == "2") return tr("2 - Horizontally Reflected");
-    else if (orientation == "3") return tr("3 - Rotated 180");
-    else if (orientation == "4") return tr("4 - Vertically Reflected");
-    else if (orientation == "5") return tr("5 - Rotated 90, Horizontally Reflected");
-    else if (orientation == "6") return tr("6 - Rotated 270");
-    else if (orientation == "7") return tr("7 - Rotated 90, Vertically Reflected");
-    else if (orientation == "8") return tr("8 - Rotated 90");
-    return orientation;
+    QTransform transform;
+
+    switch (orientation)
+    {
+    case 1: // normal
+        return image;
+    case 2: // mirror horizontal
+        return image.mirrored(true, false);
+    case 3: // rotate 180
+        transform.rotate(180);
+        return image.transformed(transform);
+    case 4: // mirror vertical
+        return image.mirrored(false, true);
+    case 5: // mirror horizontal and rotate 270 CCW
+        transform.rotate(270);
+        return image.mirrored(true, false).transformed(transform);
+    case 6: // rotate 90 CW
+        transform.rotate(90);
+        return image.transformed(transform);
+    case 7: // mirror horizontal and rotate 90 CW
+        transform.rotate(90);
+        return image.mirrored(true, false).transformed(transform);
+    case 8: // rotate 270 CW
+        transform.rotate(270);
+        return image.transformed(transform);
+    }
+    return image;
 }
 
 
 /*!
- * \brief Determines effect of applying a transform to an image
+ * \brief Adjust current orientation code to apply a transform to an image
+ * \details When displayed the image will be orientated iaw its orientation
+ * code. The transform is effected by applying the reverse transform to the
+ * orientation code.
  * \sa http://jpegclub.org/exif_orientation.html
- * \details These transforms are not intuitive!
- * For rotations the orientation is adjusted in the opposite direction.
- * The transform is applied from the user perspective (as the image will be displayed),
- * not the current orientation. When rotated 90 horizontal/vertical flips are
- * reversed, and when flipped rotations are reversed.
- * \param im Image
- * \param transform Rotation/flip
- * \return int New orientation after applying transform
+ * \param transform Rotation/flip to apply
+ * \return int New orientation code that will apply the transform to the image
  */
-int ExifOrientation::Transformed(int orientation, int transform)
+int Orientation::Apply(int transform)
 {
-    switch (orientation)
+    if (transform == kResetToExif)
+        return m_file;
+
+    // https://github.com/recurser/exif-orientation-examples is a useful resource.
+    switch (m_current)
     {
     case 0: // The image has no orientation info
     case 1: // The image is in its original state
@@ -79,7 +98,6 @@ int ExifOrientation::Transformed(int orientation, int transform)
         case kRotateCCW:      return 8;
         case kFlipHorizontal: return 2;
         case kFlipVertical:   return 4;
-        default:              return orientation;
         }
 
     case 2: // The image is horizontally flipped
@@ -89,7 +107,6 @@ int ExifOrientation::Transformed(int orientation, int transform)
         case kRotateCCW:      return 5;
         case kFlipHorizontal: return 1;
         case kFlipVertical:   return 3;
-        default:              return orientation;
         }
 
     case 3: // The image is rotated 180
@@ -99,7 +116,6 @@ int ExifOrientation::Transformed(int orientation, int transform)
         case kRotateCCW:      return 6;
         case kFlipHorizontal: return 4;
         case kFlipVertical:   return 2;
-        default:              return orientation;
         }
 
     case 4: // The image is vertically flipped
@@ -109,17 +125,15 @@ int ExifOrientation::Transformed(int orientation, int transform)
         case kRotateCCW:      return 7;
         case kFlipHorizontal: return 3;
         case kFlipVertical:   return 1;
-        default:              return orientation;
         }
 
-    case 5: // The image is transposed (rotated 90 CW flipped horizontally)
+    case 5: // The image is rotated 90 CW and flipped horizontally
         switch (transform)
         {
         case kRotateCW:       return 2;
         case kRotateCCW:      return 4;
         case kFlipHorizontal: return 6;
         case kFlipVertical:   return 8;
-        default:              return orientation;
         }
 
     case 6: // The image is rotated 90 CCW
@@ -129,18 +143,15 @@ int ExifOrientation::Transformed(int orientation, int transform)
         case kRotateCCW:      return 1;
         case kFlipHorizontal: return 5;
         case kFlipVertical:   return 7;
-        default:              return orientation;
         }
 
-    case 7: // The image is transversed  (rotated 90 CW and flipped
-        // vertically)
+    case 7: // The image is rotated 90 CW and flipped vertically
         switch (transform)
         {
         case kRotateCW:       return 4;
         case kRotateCCW:      return 2;
         case kFlipHorizontal: return 8;
         case kFlipVertical:   return 6;
-        default:              return orientation;
         }
 
     case 8: // The image is rotated 90 CW
@@ -150,325 +161,549 @@ int ExifOrientation::Transformed(int orientation, int transform)
         case kRotateCCW:      return 3;
         case kFlipHorizontal: return 7;
         case kFlipVertical:   return 5;
-        default:              return orientation;
         }
-
-    default: return orientation;
     }
+    return m_current;
 }
 
 
 /*!
- \brief Sets orientation, datestamp & comment from file metadata
- \details Reads Exif for pictures, metadata tags from FFMPEG for videos
- \param im The image item to set
- \return bool True if metadata found
+ \brief Convert degrees of rotation into Exif orientation code
+ \param degrees CW rotation required to show video correctly
+ \return QString Orientation code as per Exif spec.
 */
-bool ImageMetaData::PopulateMetaValues(ImageItem *im)
+int Orientation::FromRotation(const QString &degrees)
 {
-    QString absPath = ImageSg::getInstance()->GetFilePath(im);
-    TagMap tags;
+    if      (degrees ==   "0") return 1;
+    else if (degrees ==  "90") return 6;
+    else if (degrees == "180") return 3;
+    else if (degrees == "270") return 8;
+    return 0;
+}
 
-    // Only require orientation, date, comment
-    QPair<QString, QString> toBeFilled = qMakePair(QString(), QString());
-    tags.insert(EXIF_TAG_ORIENTATION, toBeFilled);
-    tags.insert(EXIF_TAG_DATETIME, toBeFilled);
-    tags.insert(EXIF_TAG_USERCOMMENT, toBeFilled);
-    tags.insert(EXIF_TAG_IMAGEDESCRIPTION, toBeFilled);
 
-    bool ok = false;
-    if (im->m_type == kImageFile)
+/*!
+ * \brief Generate text description of orientation
+ * \details Reports code & its interpretation of file orientation and, if
+ * different, the Db orientation
+ * \return Text description of orientation
+ */
+QString Orientation::Description()
+{
+    return (m_file == m_current)
+            ? AsText(m_file)
+            : tr("File: %1, Db: %2").arg(AsText(m_file),
+                                         AsText(m_current));
+}
+
+
+/*!
+ \brief Converts orientation code to text description for info display
+ \param orientation Exif code
+ \return QString Description text
+*/
+QString Orientation::AsText(int orientation)
+{
+    switch (orientation)
     {
-        ok = ReadExifTags(absPath, tags);
+    case 1:  return tr("1 (Normal)");
+    case 2:  return tr("2 (H Mirror)");
+    case 3:  return tr("3 (Rotate 180)");
+    case 4:  return tr("4 (V Mirror)");
+    case 5:  return tr("5 (H Mirror, Rot 270)");
+    case 6:  return tr("6 (Rotate 90)");
+    case 7:  return tr("7 (H Mirror, Rot 90)");
+    case 8:  return tr("8 (Rotate 270)");
+    default: return tr("%1 (Undefined)").arg(orientation);
     }
-    else if (im->m_type == kVideoFile)
-    {
-        ok = ReadVideoTags(absPath, tags);
+}
+
+
+//! Reads Exif metadata from a picture using libexiv2
+class PictureMetaData : public ImageMetaData
+{
+public:
+    PictureMetaData(const QString &filePath);
+    ~PictureMetaData()
+    { // libexiv2 closes file, cleans up via autoptrs
     }
 
-    if (ok)
+    virtual bool        IsValid()                  { return m_image.get(); }
+    virtual QStringList GetAllTags();
+    virtual int         GetOrientation(bool *exists = NULL);
+    virtual QDateTime   GetOriginalDateTime(bool *exists = NULL);
+    virtual QString     GetComment(bool *exists = NULL);
+
+protected:
+    static QString DecodeComment(std::string rawValue);
+
+    std::string GetTag(const QString &key, bool *exists = NULL);
+
+    Exiv2::Image::AutoPtr m_image;
+    Exiv2::ExifData       m_exifData;
+};
+
+
+/*!
+   \brief Constructor. Reads metadata from image.
+   \param filePath Absolute image path
+ */
+PictureMetaData::PictureMetaData(const QString &filePath)
+    : ImageMetaData(filePath), m_image(NULL), m_exifData()
+{
+    try
     {
-        // Extract orientation
-        if (tags.contains(EXIF_TAG_ORIENTATION))
-        {
-            QString orient = tags.value(EXIF_TAG_ORIENTATION).first;
-            bool valid;
-            int orientation = orient.toInt(&valid);
-            im->m_orientation = (valid ? orientation : 0);
-        }
-        else
-        {
-            im->m_orientation = 0;
-            LOG(VB_FILE, LOG_DEBUG,
-                QString("Image: No Orientation metadata in %1").arg(im->m_name));
-        }
+        m_image = Exiv2::ImageFactory::open(filePath.toLocal8Bit().constData());
 
-        // Extract Datetime
-        if (tags.contains(EXIF_TAG_DATETIME))
+        if (IsValid())
         {
-            QString date = tags.value(EXIF_TAG_DATETIME).first;
-            // Exif time has no timezone
-            QDateTime dateTime = QDateTime::fromString(date, "yyyy:MM:dd hh:mm:ss");
-            if (dateTime.isValid())
-                im->m_date = dateTime.toTime_t();
+            m_image->readMetadata();
+            m_exifData = m_image->exifData();
         }
         else
-        {
-            im->m_date = 0;
-            LOG(VB_FILE, LOG_DEBUG,
-                QString("Image: No DateStamp metadata in %1").arg(im->m_name));
-        }
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("Exiv2 error: Could not open file %1").arg(filePath));
+    }
+    catch (Exiv2::Error &e)
+    {
+        LOG(VB_GENERAL, LOG_ERR, LOC + QString("Exiv2 exception %1").arg(e.what()));
+    }
+}
+
+
+/*!
+   \brief Returns all metadata tags
+   \details Ignores "Exif.Image.PrintImageMatching" and lengthy tag values,
+   which are probably proprietary/binary
+   \return List of encoded strings
+   \sa ImageMetaData::FromString()
+ */
+QStringList PictureMetaData::GetAllTags()
+{
+    QStringList tags;
+    if (!IsValid())
+        return tags;
+
+    LOG(VB_FILE, LOG_DEBUG, LOC + QString("Found %1 tag(s) for file %2")
+        .arg(m_exifData.count()).arg(m_filePath));
+
+    Exiv2::ExifData::const_iterator i;
+    for (i = m_exifData.begin(); i != m_exifData.end(); ++i)
+    {
+        QString label = QString::fromStdString(i->tagLabel());
+
+        // Ignore empty labels
+        if (label.isEmpty())
+            continue;
 
-        // Extract User Comment or else Image Description
-        QString comment = "";
-        if (tags.contains(EXIF_TAG_USERCOMMENT))
+        QString key = QString::fromStdString(i->key());
+
+        // Ignore large values (binary/private tags)
+        if (i->size() >= 256)
         {
-            comment = tags.value(EXIF_TAG_USERCOMMENT).first;
+            LOG(VB_FILE, LOG_DEBUG, LOC +
+                QString("Ignoring %1 (%2, %3) : Too big")
+                .arg(key, i->typeName()).arg(i->size()));
         }
-        else if (tags.contains(EXIF_TAG_IMAGEDESCRIPTION))
+        // Ignore 'Print Image Matching'
+        else if (i->tag() == EXIF_PRINT_IMAGE_MATCHING)
         {
-            comment = tags.value(EXIF_TAG_IMAGEDESCRIPTION).first;
+            LOG(VB_FILE, LOG_DEBUG, LOC +
+                QString("Ignoring %1 (%2, %3) : Undecodable")
+                .arg(key, i->typeName()).arg(i->size()));
         }
         else
         {
-            LOG(VB_FILE, LOG_DEBUG, QString("Image: No Comment metadata in %1")
-                .arg(im->m_name));
+            // Use interpreted values
+            std::string val = i->print(&m_exifData);
+
+            // Comment needs charset decoding
+            QString value = (key == EXIF_TAG_USERCOMMENT)
+                    ? DecodeComment(val) : QString::fromStdString(val);
+
+            // Nulls can arise from corrupt metadata (MakerNote)
+            // Remove them as they disrupt socket comms between BE & remote FE's
+            if (value.contains(QChar::Null))
+            {
+                LOG(VB_GENERAL, LOG_NOTICE, LOC +
+                    QString("Corrupted Exif detected in %1").arg(m_filePath));
+                value = "????";
+            }
+
+            // Encode tag
+            QString str = ToString(key, label, value);
+            tags << str;
+
+#ifdef DUMP_METADATA_TAGS
+            LOG(VB_FILE, LOG_DEBUG, LOC + QString("%1 (%2, %3)")
+                .arg(str, i->typeName()).arg(i->size()));
+#endif
         }
-        im->m_comment = comment.simplified();
     }
+    return tags;
+}
+
 
-    return ok;
+/*!
+   \brief Read a single Exif metadata tag
+   \param [in] key Exif tag key, as per http://www.exiv2.org/tags.html
+   \param [out] exists (Optional) True if key is found in metadata
+   \return Encoded tag
+   \sa ImageMetaData::FromString()
+ */
+std::string PictureMetaData::GetTag(const QString &key, bool *exists)
+{
+    std::string value;
+    if (exists)
+        *exists = false;
+
+    if (!IsValid())
+        return value;
+
+    Exiv2::ExifKey exifKey = Exiv2::ExifKey(key.toLocal8Bit().constData());
+    Exiv2::ExifData::iterator exifIt = m_exifData.findKey(exifKey);
+
+    if (exifIt == m_exifData.end())
+        return value;
+
+    if (exists)
+        *exists = true;
+
+    // Use raw value
+    return exifIt->value().toString();
 }
 
 
 /*!
- \brief Reads all metadata for an image
- \param im The image
- \param tags Map of metadata tags. Map values = Pair< camera value, camera tag label >
-For pictures: key = Exif standard tag name; for videos: key = Exif tag name for
-orientation, date & comment only and an arbitrary, unique int for all other tags.
- \return bool True if metadata exists & could be read
-*/
-bool ImageMetaData::GetMetaData(ImageItem *im, TagMap &tags)
+   \brief Read Exif orientation
+   \param [out] exists (Optional) True if orientation is defined by metadata
+   \return Exif orientation code
+ */
+int PictureMetaData::GetOrientation(bool *exists)
 {
-    QString absPath = ImageSg::getInstance()->GetFilePath(im);
+    std::string value = GetTag(EXIF_TAG_ORIENTATION, exists);
+    return QString::fromStdString(value).toInt();
+}
 
-    if (absPath.isEmpty())
-        return false;
 
-    //
-    bool ok = false;
-    if (im->m_type == kImageFile)
-    {
-        ok = ReadExifTags(absPath, tags);
-    }
-    else if (im->m_type == kVideoFile)
-    {
-        ok = ReadVideoTags(absPath, tags);
-    }
+/*!
+   \brief Read Exif timestamp of image capture
+   \param [out] exists (Optional) True if date exists in metadata
+   \return Timestamp (possibly invalid) in camera timezone
+ */
+QDateTime PictureMetaData::GetOriginalDateTime(bool *exists)
+{
+    std::string value = GetTag(EXIF_TAG_DATETIME, exists);
+    QString dt = QString::fromStdString(value);
+
+    // Exif time has no timezone
+    return QDateTime::fromString(dt, EXIF_TAG_DATE_FORMAT);
+}
+
+
+/*!
+   \brief Read Exif comments from metadata
+   \details Returns UserComment, if not empty. Otherwise returns ImageDescription
+   \param [out] exists (Optional) True if either comment is found in metadata
+   \return Comment as a string
+ */
+QString PictureMetaData::GetComment(bool *exists)
+{
+    // Use User Comment or else Image Description
+    bool comExists, desExists = false;
+
+    std::string comment = GetTag(EXIF_TAG_USERCOMMENT, &comExists);
 
-    if (ok && tags.contains(EXIF_TAG_ORIENTATION))
+    if (comment.empty())
+        comment = GetTag(EXIF_TAG_IMAGEDESCRIPTION, &desExists);
+
+    if (exists)
+        *exists = comExists || desExists;
+
+    return DecodeComment(comment);
+}
+
+
+/*!
+   \brief Decodes charset of UserComment
+   \param rawValue Metadata value with optional "[charset=...]" prefix
+   \return Decoded comment
+ */
+QString PictureMetaData::DecodeComment(std::string rawValue)
+{
+    // Decode charset
+    Exiv2::CommentValue comVal = Exiv2::CommentValue(rawValue);
+    if (comVal.charsetId() != Exiv2::CommentValue::undefined)
+        rawValue = comVal.comment();
+    return QString::fromStdString(rawValue.c_str());
+}
+
+
+//! Reads video metadata tags using FFmpeg
+//! Raw values for Orientation & Date are read quickly via FFmpeg API.
+//! However, as collating and interpreting other tags is messy and dependant on
+//! internal FFmpeg changes, informational data is derived via mythffprobe
+//! (a slow operation)
+class VideoMetaData : public ImageMetaData
+{
+public:
+    VideoMetaData(const QString &filePath);
+    ~VideoMetaData();
+
+    virtual bool        IsValid()                        { return m_dict; }
+    virtual QStringList GetAllTags();
+    virtual int         GetOrientation(bool *exists = NULL);
+    virtual QDateTime   GetOriginalDateTime(bool *exists = NULL);
+    virtual QString     GetComment(bool *exists = NULL);
+
+protected:
+    QString GetTag(const QString &key, bool *exists = NULL);
+
+    AVFormatContext *m_context;
+    //! FFmpeg tag dictionary
+    AVDictionary    *m_dict;
+};
+
+
+/*!
+   \brief Constructor. Opens best video stream from video
+   \param filePath Absolute video path
+ */
+VideoMetaData::VideoMetaData(const QString &filePath)
+    : ImageMetaData(filePath), m_context(NULL), m_dict(NULL)
+{
     {
-        TagPair val = tags.value(EXIF_TAG_ORIENTATION);
-        tags.insert(EXIF_TAG_ORIENTATION,
-                    qMakePair(ExifOrientation::Description(val.first), val.second));
+        QMutexLocker locker(avcodeclock);
+        av_register_all();
     }
-    return ok;
+
+    AVInputFormat* p_inputformat = NULL;
+    QByteArray local8bit = filePath.toLocal8Bit();
+
+    // Open file
+    if (avformat_open_input(&m_context, local8bit.constData(),
+                            p_inputformat, NULL) < 0)
+        return;
+
+    // Locate video stream
+    int vidStream = av_find_best_stream(m_context, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
+    if (vidStream >= 0)
+        m_dict  = m_context->streams[vidStream]->metadata;
+
+    if (!IsValid())
+        avformat_close_input(&m_context);
 }
 
 
 /*!
- \brief Get Exif tags for an image
- \param filePath Image file
- \param exif Map of exif tags & values requested and/or returned.
- For each key the corresponding exif value is populated.
- If empty it is populated with all exif key/values from the image.
- \return bool False on exif error
-*/
-bool ImageMetaData::ReadExifTags(QString filePath, TagMap &tags)
+   \brief Destructor. Closes file
+ */
+VideoMetaData::~VideoMetaData()
 {
-    try
+    if (IsValid())
+        avformat_close_input(&m_context);
+}
+
+
+/*!
+   \brief Reads relevant video metadata by running mythffprobe.
+   \warning Blocks for up to 5 secs
+   \details As video tags are unstructured they are massaged into groups of format,
+   stream0, streamN to segregate them and permit reasonable display ordering.
+   The stream indices reflect the stream order returned by mythffprobe and do not
+   necessarily correlate with FFmpeg streams
+   \return List of encoded video metadata tags
+   \sa ImageMetaData::FromString()
+ */
+QStringList VideoMetaData::GetAllTags()
+{
+    QStringList tags;
+    if (!IsValid())
+        return tags;
+
+    // Only extract interesting fields:
+    // For list use: mythffprobe -show_format -show_streams <file>
+    QString cmd = GetAppBinDir() + MYTH_APPNAME_MYTHFFPROBE;
+    QStringList args;
+    args << "-loglevel quiet"
+         << "-print_format compact" // Returns "section|key=value|key=value..."
+         << "-pretty"               // Add units etc
+         << "-show_entries "
+            "format=format_long_name,duration,bit_rate:format_tags:"
+            "stream=codec_long_name,codec_type,width,height,pix_fmt,color_space,avg_frame_rate"
+            ",codec_tag_string,sample_rate,channels,channel_layout,bit_rate:stream_tags"
+         << m_filePath;
+
+    MythSystemLegacy ffprobe(cmd, args, kMSRunShell | kMSStdOut);
+
+    ffprobe.Run(5);
+
+    if (ffprobe.Wait() != GENERIC_EXIT_OK)
     {
-        Exiv2::Image::AutoPtr image =
-            Exiv2::ImageFactory::open(filePath.toLocal8Bit().constData());
+        LOG(VB_GENERAL, LOG_ERR, LOC +
+            QString("Timeout or Failed: %2 %3").arg(cmd, args.join(" ")));
+        return tags;
+    }
 
-        if (!image.get())
-        {
-            LOG(VB_GENERAL, LOG_ERR,
-                QString("Image: Exiv2 error: Could not open file %1").arg(
-                    filePath));
-            return false;
-        }
+    QByteArray result = ffprobe.ReadAll();
+    QTextStream ostream(result);
+    int stream = 0;
+    while (!ostream.atEnd())
+    {
+        QStringList fields = ostream.readLine().split('|');
 
-        image->readMetadata();
-        Exiv2::ExifData &exifData = image->exifData();
+        if (fields.size() <= 1)
+            // Empty section
+            continue;
 
-        if (exifData.empty())
+        // First fields should be "format" or "stream"
+        QString prefix = "";
+        QString group  = fields.takeFirst();
+        if (group == "stream")
         {
-            LOG(VB_FILE, LOG_NOTICE,
-                QString("Image: Exiv2 error: No exif data for file %1").arg(filePath));
-            return false;
+            // Streams use index as group
+            prefix = QString::number(stream++) + ":";
+            group.append(prefix);
         }
 
-        if (tags.isEmpty())
+        foreach (const QString &field, fields)
         {
-            // No specific tags requested - extract all exif data
-            LOG(VB_FILE, LOG_DEBUG,
-                QString("Image: Found %1 tag(s) for file %2")
-                .arg(exifData.count())
-                .arg(filePath));
-
-            Exiv2::ExifData::const_iterator i;
-            for (i = exifData.begin(); i != exifData.end(); ++i)
-            {
-                QString label = QString::fromStdString(i->tagLabel());
-
-                // Ignore empty labels
-                if (!label.isEmpty())
-                {
-                    QString key   = QString::fromStdString(i->key());
-                    std::string rawValue = i->value().toString();
-                    QString value;
-
-                    if (key == EXIF_TAG_USERCOMMENT)
-                    {
-                        // Decode charset
-                        Exiv2::CommentValue comVal = Exiv2::CommentValue(rawValue);
-                        value = QString::fromStdString(comVal.comment());
-                    }
-                    else
-                        value = QString::fromStdString(rawValue);
-
-                    // Remove control chars from malformed exif values.
-                    // They can pervert the myth message response mechanism
-                    value.replace(QRegExp("[\\0000-\\0037]"), "");
-
-#if 0
-                    LOG(VB_FILE, LOG_DEBUG,
-                        QString("Image: Exif %1/\"%2\" (Type %3) : %4")
-                        .arg(key, label, i->typeName(), value));
+            // Expect label=value
+            QStringList parts = field.split('=');
+            if (parts.size() != 2)
+                continue;
+
+            // Remove ffprobe "tag:" prefix
+            QString label = parts[0].remove("tag:");
+            QString value = parts[1];
+
+            // Construct a pseudo-key for FFMPEG tags
+            QString key = QString("FFmpeg.%1.%2").arg(group, label);
+
+            // Add stream id to labels
+            QString str = ToString(key, prefix + label, value);
+            tags << str;
+
+#ifdef DUMP_METADATA_TAGS
+            LOG(VB_FILE, LOG_DEBUG, LOC + str);
 #endif
-                    tags.insert(key, qMakePair(value, label));
-                }
-            }
         }
-        else
+    }
+    return tags;
+}
+
+
+/*!
+   \brief Read a single video tag
+   \param [in] key FFmpeg tag name
+   \param [out] exists (Optional) True if tag exists in metadata
+   \return Tag value as a string
+ */
+QString VideoMetaData::GetTag(const QString &key, bool *exists)
+{
+    if (m_dict)
+    {
+        AVDictionaryEntry *tag = NULL;
+        while ((tag = av_dict_get(m_dict, "\0", tag, AV_DICT_IGNORE_SUFFIX)))
         {
-            // Extract requested tags only
-            QMap<QString, QPair<QString, QString> >::iterator it;
-            for (it = tags.begin(); it != tags.end(); ++it)
+            if (QString(tag->key) == key)
             {
-                Exiv2::ExifKey            key =
-                        Exiv2::ExifKey(it.key().toLocal8Bit().constData());
-                Exiv2::ExifData::iterator exifIt = exifData.findKey(key);
-
-                if (exifIt != exifData.end())
-                {
-                    QString value;
-                    std::string rawValue = exifIt->value().toString();
-                    if (key.key() == EXIF_TAG_USERCOMMENT)
-                    {
-                        // Decode charset
-                        Exiv2::CommentValue comVal = Exiv2::CommentValue(rawValue);
-                        value = QString::fromStdString(comVal.comment());
-                    }
-                    else
-                        value = QString::fromStdString(rawValue);
-
-                    it.value() = qMakePair(value, QString());
-                }
+                if (exists)
+                    *exists = true;
+                return QString::fromUtf8(tag->value);
             }
         }
-        return true;
     }
-    catch (Exiv2::Error &e)
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("Image: Exiv2 exception %1").arg(e.what()));
-    }
-    return false;
+    if (exists)
+        *exists = false;
+    return QString();
 }
 
 
 /*!
- \brief Extract metadata tags from FFMPEG dict
- \param[in,out] tags Extracted tags
- \param[in,out] arbKey Used as a map key for tags other than Orientation or Date
- \param dict    FFMPEG metdata dict containing video metadata
-*/
-void ImageMetaData::ExtractVideoTags(TagMap &tags, int &arbKey, AVDictionary *dict)
+   \brief Read FFmpeg video orientation tag
+   \param [out] exists (Optional) True if orientation is defined by metadata
+   \return Exif orientation code
+ */
+int VideoMetaData::GetOrientation(bool *exists)
 {
-    AVDictionaryEntry *avTag = av_dict_get(dict, "\0", NULL, AV_DICT_IGNORE_SUFFIX);
-    while (avTag)
-    {
-        QString key;
-        QString label = QString(avTag->key);
-        QString value = QString::fromUtf8(avTag->value);
+    QString angle = GetTag(FFMPEG_TAG_ORIENTATION, exists);
+    return Orientation::FromRotation(angle);
+}
 
-        if (label == "rotate")
-        {
-            // Flag orientation & convert to Exif code
-            key   = EXIF_TAG_ORIENTATION;
-            label = "Orientation";
-            value = ExifOrientation::FromRotation(value);
-        }
-        else if (label == "creation_time")
-        {
-            // Flag date & convert to Exif date format "YYYY:MM:DD"
-            key   = EXIF_TAG_DATETIME;
-            label = "Date and Time";
-            value.replace("-", ":");
-        }
-        else
-            key = QString::number(arbKey++);
 
-        tags.insert(key, qMakePair(value, label));
-#if 0
-        LOG(VB_FILE, LOG_DEBUG,
-            QString("Image: Video %1/\"%2\" : %3").arg(key, avTag->key, value));
-#endif
-        avTag = av_dict_get(dict, "\0", avTag, AV_DICT_IGNORE_SUFFIX);
-    }
+/*!
+   \brief Read video datestamp
+   \param [out] exists (Optional) True if datestamp is defined by metadata
+   \return Timestamp (possibly invalid) in camera timezone
+ */
+QDateTime VideoMetaData::GetOriginalDateTime(bool *exists)
+{
+    QString dt = GetTag(FFMPEG_TAG_DATETIME, exists);
+
+    // Video time has no timezone
+    return QDateTime::fromString(dt, FFMPEG_TAG_DATE_FORMAT);
 }
 
 
 /*!
- \brief Get metadata tags from a video file
- \param filePath Video file
- \param[in,out] tags Map of extracted tags
- \return bool True if metadata exists and could be read
-*/
-bool ImageMetaData::ReadVideoTags(QString filePath, TagMap &tags)
+   \brief Read Video comment from metadata
+   \details Always empty
+   \param [out] exists (Optional) Always false
+   \return Empty comment
+ */
+QString VideoMetaData::GetComment(bool *exists)
 {
-    {
-        QMutexLocker locker(avcodeclock);
-        av_register_all();
-    }
+    if (exists)
+        *exists = false;
+    return QString();
+}
 
-    AVFormatContext* p_context = NULL;
-    AVInputFormat* p_inputformat = NULL;
-    QByteArray local8bit = filePath.toLocal8Bit();
 
-    // Open file
-    if ((avformat_open_input(&p_context, local8bit.constData(),
-                             p_inputformat, NULL) < 0))
-        return false;
+/*!
+   \brief Factory to retrieve metadata from pictures
+   \param filePath Image path
+   \return Picture metadata reader
+*/
+ImageMetaData* ImageMetaData::FromPicture(const QString &filePath)
+{ return new PictureMetaData(filePath); }
 
-    // Locate video stream
-    int vidStream = av_find_best_stream(p_context, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
-    if (vidStream < 0)
-        return false;
 
-    // Cannot search tags so must extract them all
-    // No tag classification for video so use arbitrary, unique keys
+/*!
+   \brief Factory to retrieve metadata from videos
+   \param filePath Image path
+   \return Video metadata reader
+ */
+ImageMetaData* ImageMetaData::FromVideo(const QString &filePath)
+{ return new VideoMetaData(filePath); }
+
+
+const QString ImageMetaData::kSeparator = "|-|";
 
-    int arbKey = 1;
-    // Extract file tags
-    ExtractVideoTags(tags, arbKey, p_context->metadata);
-    // Extract video tags
-    ExtractVideoTags(tags, arbKey, p_context->streams[vidStream]->metadata);
 
-    avformat_close_input(&p_context);
+/*!
+   \brief Creates a map of metadata tags as
+   \param tagStrings List of strings containing encoded metadata
+   \return multimap<key group, list<key, label, value>>
+ */
+ImageMetaData::TagMap ImageMetaData::ToMap(const QStringList &tagStrings)
+{
+    TagMap tags;
+    foreach (const QString &token, tagStrings)
+    {
+        QStringList parts = FromString(token);
+        // Expect Key, Label, Value.
+        if (parts.size() == 3)
+        {
+            // Map tags by Family.Group to keep them together
+            // Within each group they will preserve list ordering
+            QString group = parts[0].section('.', 0, 1);
+            tags.insertMulti(group, parts);
 
-    return true;
+#ifdef DUMP_METADATA_TAGS
+            LOG(VB_FILE, LOG_DEBUG, LOC + QString("%1 = %2").arg(group, token));
+#endif
+        }
+    }
+    return tags;
 }
diff --git a/mythtv/libs/libmythmetadata/imagemetadata.h b/mythtv/libs/libmythmetadata/imagemetadata.h
index 42222e7..79da608 100644
--- a/mythtv/libs/libmythmetadata/imagemetadata.h
+++ b/mythtv/libs/libmythmetadata/imagemetadata.h
@@ -1,32 +1,45 @@
 //! \file
-//! \brief Reads metadata (Exif & video tags) from an image file
+//! \brief Handles Exif/FFMpeg metadata tags for images
+//! \details For pictures, Exif tags are read using libexiv2 on demand
+//! For videos, tags are requested from mythffprobe
+//! Common tags (used by Gallery) are Orientation, Image Comment & Capture timestamp;
+//! all others are for information only. Videos have no comments; their orientation
+//! & timestamp are mutated into Exif format.
 
 #ifndef IMAGEMETADATA_H
 #define IMAGEMETADATA_H
 
-#include <QCoreApplication>
-#include <QMap>
-#include <QPair>
+#include <QCoreApplication> // for tr()
+#include <QStringBuilder>
+#include <QStringList>
 
-#include <mythmetaexp.h>
+#include "mythmetaexp.h"
 
-// FFMPEG Metadata
-extern "C" {
-#include <libavformat/avformat.h>
-}
 
-#include "imageutils.h"
-
-
-// Exif 2.2 standard tag names, see http://www.exiv2.org/tags.html
+// Exif 2.3 standard tag names, see http://www.exiv2.org/tags.html
 #define EXIF_TAG_ORIENTATION      "Exif.Image.Orientation"
 #define EXIF_TAG_DATETIME         "Exif.Image.DateTime"
+#define EXIF_TAG_DATE_FORMAT      "yyyy:MM:dd hh:mm:ss"
 #define EXIF_TAG_IMAGEDESCRIPTION "Exif.Image.ImageDescription"
 #define EXIF_TAG_USERCOMMENT      "Exif.Photo.UserComment"
+#define EXIF_PRINT_IMAGE_MATCHING 0xc4a5
+
+// ffmpeg video tags
+#define FFMPEG_TAG_ORIENTATION    "rotate"
+#define FFMPEG_TAG_DATETIME       "creation_time"
+#define FFMPEG_TAG_DATE_FORMAT    "yyyy-MM-dd hh:mm:ss"
 
+// Pseudo keys for passing Myth data as metadata tags.
+#define EXIF_MYTH_HOST   "Myth.host"
+#define EXIF_MYTH_PATH   "Myth.path"
+#define EXIF_MYTH_NAME   "Myth.name"
+#define EXIF_MYTH_SIZE   "Myth.size"
+#define EXIF_MYTH_ORIENT "Myth.orient"
 
+
+//! Image transformations
 enum ImageFileTransform {
-    kResetExif      = 0, //!< Reset to Exif value
+    kResetToExif    = 0, //!< Reset to Exif value
     kRotateCW       = 1, //!< Rotate clockwise
     kRotateCCW      = 2, //!< Rotate anti-clockwise
     kFlipHorizontal = 3, //!< Reflect about vertical axis
@@ -34,31 +47,80 @@ enum ImageFileTransform {
 };
 
 
-//! Manages Exif orientation code
-class META_PUBLIC ExifOrientation
+//! \brief Encapsulates Exif orientation processing
+//! \details The exif code indicates how the raw image should be rotated/mirrored
+//! in order to display correctly. This manipulation is expensive, so done once only.
+//! User transformations are applied to the code to achieve the required effect.
+//! Both file orientation and current orientation are stored in the Db (together)
+//! to cope with deviant Qt versions. This composite code is 2-digits where
+//! 1st = current orientation, 2nd = original file orientation
+class META_PUBLIC Orientation
 {
-    Q_DECLARE_TR_FUNCTIONS(ExifOrientation)
+    Q_DECLARE_TR_FUNCTIONS(Orientation)
 public:
-    static QString FromRotation(QString);
-    static QString Description(QString);
-    static int     Transformed(int, int);
+    Orientation(int composite) : m_current(composite / 10), m_file(composite % 10) {}
+    Orientation(int current, int file) : m_current(current), m_file(file) {}
+
+    //! Encode original & current orientation to a single Db field
+    int Composite() { return m_current * 10 + m_file; }
+    int Transform(int);
+    int GetCurrent()   { return m_current; }
+    QString Description();
+
+    static int FromRotation(const QString &degrees);
+    static QImage ApplyExifOrientation(QImage &image, int orientation);
+
+private:
+    static QString AsText(int orientation);
+
+    int Apply(int);
+
+    typedef QHash<int, QHash<int, int> > Matrix;
+
+    //! The orientation to use: the file orientation with user transformations applied.
+    int m_current;
+    //! The orientation of the raw file image, as specified by the camera.
+    int m_file;
 };
 
 
-//! Reads metadata from image files
+//! Abstract class for image metadata
 class META_PUBLIC ImageMetaData
 {
+    Q_DECLARE_TR_FUNCTIONS(ImageMetaData)
 public:
-    typedef QPair<QString, QString> TagPair;
-    typedef QMap<QString, TagPair>  TagMap;
+    static ImageMetaData* FromPicture(const QString &filePath);
+    static ImageMetaData* FromVideo(const QString &filePath);
 
-    static bool PopulateMetaValues(ImageItem *);
-    static bool GetMetaData(ImageItem *, TagMap &);
+    virtual ~ImageMetaData() {}
 
-private:
-    static bool ReadExifTags(QString, TagMap &);
-    static bool ReadVideoTags(QString, TagMap &);
-    static void ExtractVideoTags(TagMap &tags, int &arbKey, AVDictionary *dict);
+    //! Unique separator to delimit fields within a string
+    static const QString kSeparator;
+
+    //! Encodes metadata into a string as <tag name><tag label><tag value>
+    static QString ToString(const QString &name, const QString &label, const QString &value)
+    { return name % kSeparator % label % kSeparator % value; }
+
+    //! Decodes metadata name, label, value from a string
+    static QStringList FromString(const QString &str)
+    { return str.split(kSeparator); }
+
+    typedef QMap<QString, QStringList> TagMap;
+    static TagMap ToMap(const QStringList &tags);
+
+    virtual bool        IsValid()                                = 0;
+    virtual QStringList GetAllTags()                             = 0;
+    virtual int         GetOrientation(bool *exists = NULL)      = 0;
+    virtual QDateTime   GetOriginalDateTime(bool *exists = NULL) = 0;
+    virtual QString     GetComment(bool *exists = NULL)          = 0;
+
+protected:
+    ImageMetaData(const QString &filePath) : m_filePath(filePath) {}
+
+    //! Image filepath
+    QString m_filePath;
 };
 
+
 #endif // IMAGEMETADATA_H
+
diff --git a/mythtv/libs/libmythmetadata/imagescanner.cpp b/mythtv/libs/libmythmetadata/imagescanner.cpp
index b8389b7..7525224 100644
--- a/mythtv/libs/libmythmetadata/imagescanner.cpp
+++ b/mythtv/libs/libmythmetadata/imagescanner.cpp
@@ -1,34 +1,33 @@
 #include "imagescanner.h"
 
-#include <QtAlgorithms>
+#include "mythlogging.h"
+#include "mythcorecontext.h"  // for events
 
-#include <imagethumbs.h>
-#include <imagemetadata.h>
-#include <imageutils.h>
+#include "imagemetadata.h"
 
 /*!
- \brief  Constructor
-*/
-ImageScanThread::ImageScanThread() :
-    MThread("ImageScanner"),
-    m_db(),
-    m_sg(ImageSg::getInstance()),
-    m_dbDirMap(NULL),
-    m_dbFileMap(NULL),
-    m_progressCount(0),
-    m_progressTotalCount(0),
-    m_dir(ImageSg::getInstance()->GetImageFilters()),
-    m_exclusions()
-{
-    QMutexLocker locker(&m_mutexState);
-    m_state = kDormant;
-}
-
-
-/*!
- \brief  Destructor
+ \brief Constructor
+ \param dbfs Database/filesystem adapter
+ \param thumbGen Companion thumbnail generator
 */
-ImageScanThread::~ImageScanThread()
+template <class DBFS>
+ImageScanThread<DBFS>::ImageScanThread(DBFS *const dbfs, ImageThumb<DBFS> *thumbGen)
+    : MThread("ImageScanner"),
+      m_scanning(false), m_mutexState(),
+      m_clearQueue(),    m_mutexQueue(),
+      m_dbfs(*dbfs),
+      m_thumb(*thumbGen),
+      m_dbDirMap(), m_dbFileMap(), m_seenDir(), m_seenFile(),
+      m_changedImages(),
+      m_bcastTimer(),
+      m_progressCount(0), m_progressTotalCount(0), m_mutexProgress(),
+      m_dir(m_dbfs.GetImageFilters()),
+      m_exclusions()
+{ }
+
+
+template <class DBFS>
+ImageScanThread<DBFS>::~ImageScanThread()
 {
     cancel();
     wait();
@@ -36,325 +35,264 @@ ImageScanThread::~ImageScanThread()
 
 
 /*!
- \brief  Clears the thumbnail list so that the thread can exit.
+ \brief Clears queued items so that the thread can exit.
 */
-void ImageScanThread::cancel()
+template <class DBFS>
+void ImageScanThread<DBFS>::cancel()
 {
-    QMutexLocker locker(&m_mutexState);
-    m_state = kInterrupt;
-}
+    m_mutexQueue.lock();
+    m_clearQueue.clear();
+    m_mutexQueue.unlock();
 
-
-/*!
- \brief Return current scanner status
- \return ScannerState
-*/
-ScannerState ImageScanThread::GetState()
-{
     QMutexLocker locker(&m_mutexState);
-    return m_state;
+    m_scanning = false;
 }
 
 
 /*!
- \brief Request scan start/stop, clear Db
- \param to New state
+ \brief Return current scanner status
+ \return bool True if requested state is "scan"
 */
-void ImageScanThread::ChangeState(ScannerState to)
+template <class DBFS>
+bool ImageScanThread<DBFS>::IsScanning()
 {
     QMutexLocker locker(&m_mutexState);
-    m_state = to;
-
-    // Restart thread if not already running
-    if (!this->isRunning())
-        this->start();
+    return m_scanning;
 }
 
 
 /*!
- \brief Returns number of images scanned & total number to scan
- \return QStringList "done/total"
+ \brief Get status of 'clear device' queue
+ \return bool True if pending 'clear' requests exist
 */
-QStringList ImageScanThread::GetProgress()
+template <class DBFS>
+bool ImageScanThread<DBFS>::ClearsPending()
 {
-    QMutexLocker locker(&m_mutexProgress);
-    return QStringList() << QString::number(m_progressCount)
-                         << QString::number(m_progressTotalCount);
+    QMutexLocker locker(&m_mutexQueue);
+    return !m_clearQueue.isEmpty();
 }
 
 
 /*!
- \brief Notify listeners of mode & progress
- \param mode Mode to broadcast
+ \brief Run or interrupt scanner
+ \details Clear requests are actioned before and after every scan
+ \param scan If true, scan will start after pending clears are actioned
+ If false, a running scan is interrupted. Pending clear requests will be
+ actioned.
 */
-void ImageScanThread::BroadcastStatus(QString mode)
+template <class DBFS>
+void ImageScanThread<DBFS>::ChangeState(bool scan)
 {
-    QStringList status;
-
-    { // Release lock before sending message
-        QMutexLocker locker(&m_mutexProgress);
-
-        status << mode
-               << QString::number(m_progressCount)
-               << QString::number(m_progressTotalCount);
-    }
+    QMutexLocker locker(&m_mutexState);
+    m_scanning = scan;
 
-    MythEvent me = MythEvent("IMAGE_SCAN_STATUS", status);
-    gCoreContext->SendEvent(me);
+    // Restart thread if not already running
+    if (!isRunning())
+        start();
 }
 
 
 /*!
- \brief Counts images in a dir subtree
- \details Ignores files/dirs that match exclusions regexp
- \param dir Parent of subtree
+ \brief Queues a 'Clear Device' request, which will be actioned immediately.
+ \details If scanner is already running, any scan will be aborted to process the
+clear.
+ \param devId Device id
 */
-void ImageScanThread::CountTree(QDir &dir)
+template <class DBFS>
+void ImageScanThread<DBFS>::EnqueueClear(int devId, const QString &action)
 {
-    QFileInfoList files = dir.entryInfoList();
+    m_mutexQueue.lock();
+    m_clearQueue << qMakePair(devId, action);
+    m_mutexQueue.unlock();
 
-    foreach(const QFileInfo &fileInfo, files)
-    {
-        if (fileInfo.isFile())
-            ++m_progressTotalCount;
-        else if (m_exclusions.exactMatch(fileInfo.fileName()))
-            LOG(VB_GENERAL, LOG_INFO, QString("%1: Excluding %2")
-                .arg(objectName(), fileInfo.filePath()));
-        else
-        {
-            dir.cd(fileInfo.fileName());
-            CountTree(dir);
-            dir.cdUp();
-        }
-    }
+    ChangeState(false);
 }
 
 
 /*!
- \brief Counts images in a list of subtrees
- \param paths List of dirs
+ \brief Returns number of images scanned & total number to scan
+ \return QStringList (scanner id, #done, #total)
 */
-void ImageScanThread::CountFiles(QStringList paths)
+template <class DBFS>
+QStringList ImageScanThread<DBFS>::GetProgress()
 {
-    // Get exclusions as comma-seperated list using glob chars * and ?
-    QString excPattern = gCoreContext->GetSetting("GalleryIgnoreFilter", "");
-
-    // Combine into a single regexp
-    excPattern.replace(".", "\\."); // Preserve "."
-    excPattern.replace("*", ".*");  // Convert glob wildcard "*"
-    excPattern.replace("?", ".");  // Convert glob wildcard "?"
-    excPattern.replace(",", "|");   // Convert list to OR's
-
-    QString pattern = QString("^(%1)$").arg(excPattern);
-    m_exclusions = QRegExp(pattern);
-
-    LOG(VB_FILE, LOG_DEBUG, QString("%1: Exclude regexp is \"%2\"")
-        .arg(objectName(), pattern));
-
     QMutexLocker locker(&m_mutexProgress);
-    m_progressCount       = 0;
-    m_progressTotalCount  = 0;
-
-    // Release lock to broadcast
-    locker.unlock();
-    BroadcastStatus("SCANNING");
-    locker.relock();
-
-    // Use global image filters
-    QDir dir = m_dir;
-    foreach(const QString &sgDir, paths)
-    {
-        dir.cd(sgDir);
-        CountTree(dir);
-    }
+    return QStringList() << QString::number(gCoreContext->IsBackend())
+                         << QString::number(m_progressCount)
+                         << QString::number(m_progressTotalCount);
 }
 
 
 /*!
  \brief Synchronises database to the storage group
- \details Reads all dirs and files in storage group and populates database with
- metadata for each. Broadcasts progress events whilst scanning and initiates
- thumbnail generation when finished.
+ \details Scans all dirs and files and populates database with
+ metadata for each. Broadcasts progress events whilst scanning, initiates
+ thumbnail generation and notifies clients when finished.
 */
-void ImageScanThread::run()
+template <class DBFS>
+void ImageScanThread<DBFS>::run()
 {
     RunProlog();
 
     setPriority(QThread::LowPriority);
 
-    QStringList removed;
-
-    // Scan requested ?
-    if (m_state == kScan)
+    do
     {
-        LOG(VB_GENERAL, LOG_INFO, objectName() + ": Starting scan");
+        // Process all clears before scanning
+        while (ClearsPending())
+        {
+            m_mutexQueue.lock();
+            if (m_clearQueue.isEmpty())
+                break;
+            ClearTask task = m_clearQueue.takeFirst();
+            m_mutexQueue.unlock();
 
-        // Known files/dirs in the Db. Objects are either;
-        // - deleted explicitly (when matched to the filesystem),
-        // - or passed to the Thumbnail Generator (old dirs/files that have disappeared)
-        m_dbDirMap = new ImageMap();
-        m_dbFileMap = new ImageMap();
+            int devId      = task.first;
+            QString action = task.second;
 
-        // Scan all SG dirs
-        QStringList paths = m_sg->GetStorageDirs();
+            LOG(VB_GENERAL, LOG_INFO,
+                QString("Clearing Filesystem: %1 %2").arg(action).arg(devId));
 
-        CountFiles(paths);
+            // Clear Db
+            m_dbfs.ClearDb(devId, action);
 
-        // Load all available directories and files from the database so that
-        // they can be compared against the ones on the filesystem.
-        // Ignore root dir, which is notional
-        m_db.ReadDbItems(*m_dbFileMap, *m_dbDirMap,
-                           QString("file_id != %1").arg(ROOT_DB_ID));
+            // Pass on to thumb generator now scanning has stopped
+            m_thumb.ClearThumbs(devId, action);
+        }
 
-        // Ensure Root dir exists as first db entry and update last scan time
-        ImageItem root;
-        root.m_id            = ROOT_DB_ID;
-        root.m_name          = QString("");
-        root.m_parentId      = 0;
-        root.m_type          = kBaseDirectory;
-        root.m_modTime       = QDateTime::currentMSecsSinceEpoch() / 1000;
+        // Scan requested ?
+        if (IsScanning())
+        {
+            LOG(VB_GENERAL, LOG_INFO,  "Starting scan");
 
-        m_db.UpdateDbFile(&root);
+            // Load known directories and files from the database
+            if (!m_dbfs.ReadAllImages(m_dbFileMap, m_dbDirMap))
+                // Abort on any Db error
+                break;
 
-        // Now start the actual syncronization
-        foreach(const QString &path, paths)
-        {
-            QString base = path;
-            if (!base.endsWith('/'))
-                base.append('/');
+            bool firstScan = m_dbFileMap.isEmpty();
 
-            LOG(VB_FILE, LOG_INFO,
-                QString("%1: Syncing from SG dir %2").arg(objectName(), path));
+            // Pause thumb generator so that scans are fast as possible
+            m_thumb.PauseBackground(true);
 
-            SyncFilesFromDir(path, ROOT_DB_ID, base);
-        }
+            // Adapter determines list of dirs to scan
+            StringMap paths = m_dbfs.GetScanDirs();
 
-        // Adding or updating directories has been completed.
-        // The maps now only contain old directories & files that are not
-        // in the filesystem anymore. Remove them from the database
-        ImageList files = m_dbDirMap->values() + m_dbFileMap->values();
-        m_db.RemoveFromDB(files);
+            CountFiles(paths.values());
 
-        // Cleanup thumbnails
-        removed = ImageThumb::getInstance()->DeleteThumbs(m_dbFileMap->values(),
-                                                          m_dbDirMap->values());
+            // Now start the actual syncronization
+            m_seenFile.clear();
+            m_changedImages.clear();
+            StringMap::const_iterator i = paths.constBegin();
+            while (i != paths.constEnd() && IsScanning())
+            {
+                SyncSubTree(QFileInfo(i.value()), GALLERY_DB_ID, i.key(), i.value());
+                ++i;
+            }
 
-        LOG(VB_GENERAL, LOG_INFO, objectName() + ": Finished scan");
+            // Release thumb generator asap
+            m_thumb.PauseBackground(false);
 
-        // Clean up containers & contents
-        delete m_dbFileMap;
-        delete m_dbDirMap;
+            // Adding or updating directories has been completed.
+            // The maps now only contain old directories & files that are not
+            // in the filesystem anymore. Remove them from the database
+            m_dbfs.RemoveFromDB(m_dbDirMap.values());
+            m_dbfs.RemoveFromDB(m_dbFileMap.values());
 
-        // Wait for 'urgent' thumbs to be generated before notifying clients.
-        // Otherwise they'd have nothing to draw...
-        WaitForThumbs();
-    }
+            // Cleanup thumbnails
+            QStringList mesg(m_thumb.DeleteThumbs(m_dbFileMap.values()));
+            mesg << m_changedImages.join(",");
 
-    // Scan has completed or been interrupted. Now process any Clear request
-    if (m_state == kClear)
-    {
-        LOG(VB_GENERAL, LOG_INFO, objectName() + ": Clearing Database");
+            // Cleanup dirs
+            m_dbFileMap.clear();
+            m_dbDirMap.clear();
+            m_seenDir.clear();
 
-        m_db.ClearDb();
-        ImageThumb::getInstance()->ClearAllThumbs();
+            m_mutexProgress.lock();
+            // (count == total) signals scan end
+            Broadcast(m_progressTotalCount);
+            // Must reset counts for scan queries
+            m_progressCount = m_progressTotalCount = 0;
+            m_mutexProgress.unlock();
 
-        removed = QStringList("ALL");
-    }
+            LOG(VB_GENERAL, LOG_INFO,  "Finished scan");
 
-    ChangeState(kDormant);
+            // For initial scans pause briefly to give thumb generator a headstart
+            // before being deluged by client requests
+            if (firstScan)
+                msleep(1000);
 
-    // Notify scan has finished
-    BroadcastStatus("");
+            // Notify clients of completion with removed & changed images
+            m_dbfs.Notify("IMAGE_DB_CHANGED", mesg);
 
-    // Notify clients of Db update
-    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", removed));
+            ChangeState(false);
+        }
+    }
+    while (ClearsPending());
 
     RunEpilog();
 }
 
 
 /*!
- \brief Blocks until all urgent thumbnails have been generated. Time-outs after
- 10 secs
+ \brief Scans a dir subtree
+ \details Uses a recursive depth-first scan to detect all files matching
+ image/video filters. Dirs that match exclusions regexp are ignored.
+ \param dirInfo Dir info at root of this subtree
+ \param parentId Id of parent dir
+ \param devId Device id being scanned
+ \param base Root device path
 */
-void ImageScanThread::WaitForThumbs()
+template <class DBFS>
+void ImageScanThread<DBFS>::SyncSubTree(const QFileInfo &dirInfo, int parentId,
+                                  int devId, const QString &base)
 {
-    // Wait up to 10s for queue to empty.
-    int remaining = ImageThumb::getInstance()->GetQueueSize(kScannerUrgentPriority);
-
-    { // Counts now represent pending thumbnails
-        QMutexLocker locker(&m_mutexProgress);
-        m_progressCount       = 0;
-        m_progressTotalCount  = remaining;
+    // Ignore excluded dirs
+    if (m_exclusions.match(dirInfo.fileName()).hasMatch())
+    {
+        LOG(VB_FILE, LOG_INFO,
+            QString("Excluding dir %1").arg(dirInfo.absoluteFilePath()));
+        return;
     }
 
-    int timeout = 100;
-    while (remaining > 0 && --timeout > 0)
+    // Use global image filters
+    QDir dir = m_dir;
+    if (!dir.cd(dirInfo.absoluteFilePath()))
     {
-        BroadcastStatus("THUMBNAILS");
-        msleep(1000);
-        remaining = ImageThumb::getInstance()->GetQueueSize(kScannerUrgentPriority);
-        QMutexLocker locker(&m_mutexProgress);
-        m_progressCount = std::max(m_progressTotalCount - remaining, 0);
+        LOG(VB_FILE, LOG_INFO,
+            QString("Failed to open dir %1").arg(dirInfo.absoluteFilePath()));
+        return;
     }
-    BroadcastStatus("THUMBNAILS");
-}
 
+    // Create directory node
+    int id = SyncDirectory(dirInfo, devId, base, parentId);
 
-/*!
- \brief Scans a dir subtree and updates/populates db metadata to match filesystem
- \details Detects all files that match image/video filters. Files/dirs that
- match exclusions regexp are ignored.
- \param path Dir that is subtree root
- \param parentId Db id of the dir's parent dir
- \param baseDirectory The storage group root dir path
-*/
-void ImageScanThread::SyncFilesFromDir(QString path,
-                                       int parentId,
-                                       QString baseDirectory)
-{
-    // Use global image filters
-    QDir dir = m_dir;
-    dir.cd(path);
+    // Sync its contents
     QFileInfoList list = dir.entryInfoList();
-
     foreach(const QFileInfo &fileInfo, list)
     {
-        // Ignore excluded files
-        if (m_exclusions.exactMatch(fileInfo.fileName()))
-            continue;
-
-        { // Release lock before continuing
-            QMutexLocker locker(&m_mutexState);
-            if (m_state != kScan)
-            {
-                LOG(VB_GENERAL, LOG_INFO,
-                    QString("%1: Scan interrupted in %2").arg(objectName(), path));
-                return;
-            }
+        if (!IsScanning())
+        {
+            LOG(VB_GENERAL, LOG_INFO,
+                QString("Scan interrupted in %2").arg(dirInfo.absoluteFilePath()));
+            return;
         }
 
         if (fileInfo.isDir())
         {
-            // Get the id. This will be new parent id
-            // when we traverse down the current directory.
-            int id = SyncDirectory(fileInfo, parentId, baseDirectory);
-
-            // Get new files within this directory
-            QString fileName = fileInfo.absoluteFilePath();
-            SyncFilesFromDir(fileName, id, baseDirectory);
+            // Scan this directory
+            SyncSubTree(fileInfo, id, devId, base);
         }
         else
         {
-            SyncFile(fileInfo, parentId, baseDirectory);
+            SyncFile(fileInfo, devId, base, id);
 
-            // Update progress count
-            { // Release lock quickly
-                QMutexLocker locker(&m_mutexProgress);
-                ++m_progressCount;
-            }
-            // report status on completion of every dir
-            BroadcastStatus("SCANNING");
+            QMutexLocker locker(&m_mutexProgress);
+            ++m_progressCount;
+
+            // Throttle updates
+            if (m_bcastTimer.elapsed() > 250)
+                Broadcast(m_progressCount);
         }
     }
 }
@@ -362,284 +300,314 @@ void ImageScanThread::SyncFilesFromDir(QString path,
 
 /*!
  \brief Updates/populates db for a dir
- \details Dir is updated if dir modified time has changed since last scan.
- \param fileInfo Dir info
- \param parentId Db id of the dir's parent dir
- \param baseDirectory The storage group root dir path
+ \details Db is updated if dir modified time has changed since last scan.
+ Contents are scanned even if dir is unchanged.
+ Clones are dirs within the Storage Group with the same path (relative to SG).
+ They resolve to a single Db dir - their contents are amalgamated.
+ ie. <SG dir 1>/somePath/dirName and <SG dir 2>/somePath/dirName result in a
+ single Gallery dir of "somePath/dirName"
+ \param dirInfo Dir info
+ \param devId Id of device containing dir
+ \param base Device path
+ \param parentId Db id of the dir's parent
  \return int Db id of this dir in db
 */
-int ImageScanThread::SyncDirectory(QFileInfo fileInfo,
-                                   int parentId,
-                                   QString baseDirectory)
+template <class DBFS>
+ int ImageScanThread<DBFS>::SyncDirectory(const QFileInfo &dirInfo, int devId, const QString &base, int parentId)
 {
-    LOG(VB_FILE, LOG_DEBUG, QString("%1: Syncing directory %2")
-        .arg(objectName(), fileInfo.absoluteFilePath()));
+    QString absFilePath = dirInfo.absoluteFilePath();
 
-    // Load all required information of the directory
-    ImageItem *dir = LoadDirectoryData(fileInfo, parentId, baseDirectory);
+    LOG(VB_FILE, LOG_DEBUG, QString("Syncing directory %1").arg(absFilePath));
 
-    ImageItem *dbDir = m_dbDirMap->value(dir->m_fileName);
-    int id;
+    ImagePtr dir(m_dbfs.CreateItem(dirInfo, parentId, devId, base));
 
-    if (dbDir)
+    // Is dir already in Db ?
+    if (m_dbDirMap.contains(dir->m_filePath))
     {
+        ImagePtr dbDir = m_dbDirMap.value(dir->m_filePath);
+
         // The directory already exists in the db. Retain its id
-        id = dir->m_id = dbDir->m_id;
+        dir->m_id = dbDir->m_id;
 
-        // Check for change of contents
-        if (dir->m_modTime != dbDir->m_modTime)
+        // Parent may have changed due to a move
+        if (dir->m_modTime != dbDir->m_modTime
+                || dir->m_parentId != dbDir->m_parentId)
         {
-            LOG(VB_FILE, LOG_INFO, QString("%1: Changed directory %2")
-                .arg(objectName(), fileInfo.absoluteFilePath()));
-            m_db.UpdateDbFile(dir);
+            LOG(VB_FILE, LOG_INFO,
+                QString("Changed directory %1").arg(absFilePath));
+
+            // Retain existing id & settings
+            dir->m_isHidden      = dbDir->m_isHidden;
+            dir->m_userThumbnail = dbDir->m_userThumbnail;
+
+            m_dbfs.UpdateDbImage(*dir);
+            // Note modified images
+            m_changedImages << QString::number(dir->m_id);
         }
 
         // Remove the entry from the dbList
-        m_dbDirMap->remove(dir->m_fileName);
-        delete dbDir;
+        m_dbDirMap.remove(dir->m_filePath);
+    }
+    // Detect clones (same path in different SG dir)
+    else if (m_seenDir.contains(dir->m_filePath))
+    {
+        ImagePtr cloneDir = m_seenDir.value(dir->m_filePath);
+
+        // All clones point to same Db dir. Use latest
+        if (cloneDir->m_modTime >= dir->m_modTime )
+        {
+            LOG(VB_FILE, LOG_INFO, QString("Directory %1 is an older clone of %2")
+                .arg(absFilePath, cloneDir->m_filePath));
+
+            // Use previous version
+            dir = cloneDir;
+        }
+        else
+        {
+            LOG(VB_FILE, LOG_INFO,
+                QString("Directory %1 is a more recent clone of %2")
+                .arg(absFilePath, cloneDir->m_filePath));
+
+            // Use new version
+            dir->m_id = cloneDir->m_id;
+            // Note modified time
+            m_changedImages << QString::number(dir->m_id);
+        }
+
+        // Mark non-devices as cloned (for info display only)
+        if (!dir->IsDevice())
+        {
+            dir->m_type = kCloneDir;
+            m_dbfs.UpdateDbImage(*dir);
+        }
     }
     else
     {
-        LOG(VB_FILE, LOG_INFO, QString("%1: New directory %2")
-            .arg(objectName(), fileInfo.absoluteFilePath()));
+        LOG(VB_FILE, LOG_INFO, QString("New directory %1").arg(absFilePath));
 
-        // The directory is not in the database list
-        // add it to the database and get the new id. This
-        // will be the new parent id for the subdirectories
-        id = m_db.InsertDbDirectory(*dir);
+        // Create new Db dir with new id
+        dir->m_id = m_dbfs.InsertDbImage(*dir);
     }
-    delete dir;
-    return id;
+
+    // Note it for clone detection
+    m_seenDir.insert(dir->m_filePath, dir);
+
+    return dir->m_id;
 }
 
 
+/*!
+  \brief Read image date, orientation, comment from metadata
+  \param[in] path Image filepath
+  \param[in] type Picture or Video
+  \param[out] comment Image comment
+  \param[out] time Time/date of image capture
+  \param[out] orientation Exif orientation code
+ */
+template <class DBFS>
+void ImageScanThread<DBFS>::PopulateMetadata
+(const QString &path, int type, QString &comment, uint &time, int &orientation)
+{
+    // Set orientation, date, comment from file meta data
+    ImageMetaData *metadata = (type == kImageFile)
+            ? ImageMetaData::FromPicture(path)
+            : ImageMetaData::FromVideo(path);
+
+    orientation  = metadata->GetOrientation();
+    comment      = metadata->GetComment();
+    QDateTime dt = metadata->GetOriginalDateTime();
+    time         = (dt.isValid()) ? dt.toTime_t() : 0;
+
+    delete metadata;
+}
+
 
 /*!
  \brief Updates/populates db for an image/video file
- \details Image is updated if file modified time has changed since last scan.
-Extracts orientation, date and 2 comments from exif data
+ \details Db is updated if file modified time has changed since last scan.
+ Extracts orientation, date and 2 comments from exif/video metadata.
+ Duplicates are files within the Storage Group with the same path (relative to SG).
+ They are invalid (user error?) - only the first is accepted; others are ignored.
+ ie. <SG dir 1>/somePath/fileName and <SG dir 2>/somePath/fileName result in a
+ single image from <SG dir 1>. This is consistent with StorageGroup::FindFile(),
+ which will never find the second file.
  \param fileInfo File info
- \param parentId Db id of the file's parent dir
- \param baseDirectory The storage group root dir path
+ \param devId Id of device containing dir
+ \param base Device path
+ \param parentId Db id of the dir's parent
 */
-void ImageScanThread::SyncFile(QFileInfo fileInfo,
-                               int parentId,
-                               QString baseDirectory)
+template <class DBFS>
+void ImageScanThread<DBFS>::SyncFile(const QFileInfo &fileInfo, int devId,
+                               const QString &base, int parentId)
 {
-    // Load all required information of the file
-    ImageItem *im = LoadFileData(fileInfo, baseDirectory);
+    QString absFilePath = fileInfo.absoluteFilePath();
 
+    ImagePtr im(m_dbfs.CreateItem(fileInfo, parentId, devId, base));
     if (!im)
-    {
-        LOG(VB_FILE, LOG_DEBUG, QString("%1: Ignoring unknown file %2")
-            .arg(objectName(), fileInfo.absoluteFilePath()));
+        // Ignore unknown file type
         return;
-    }
-
-    // get db version of this file
-    ImageItem* oldim = m_dbFileMap->value(im->m_fileName);
 
-    if (oldim && oldim->m_modTime == im->m_modTime)
+    if (m_dbFileMap.contains(im->m_filePath))
     {
-        // File already known & hasn't changed
-        // Remove the entry from the dbList
-        m_dbFileMap->remove(im->m_fileName);
-        delete oldim;
-        delete im;
-        return;
-    }
+        ImagePtrK dbIm = m_dbFileMap.value(im->m_filePath);
 
-    if (oldim)
-    {
-        LOG(VB_FILE, LOG_INFO, QString("%1: Modified file %2")
-            .arg(objectName(), fileInfo.absoluteFilePath()));
+        // Parent may have changed due to a move
+        if (im->m_modTime == dbIm->m_modTime && im->m_parentId == dbIm->m_parentId)
+        {
+            // File already known & hasn't changed
+            // Remove it from removed list
+            m_dbFileMap.remove(im->m_filePath);
+            // Detect duplicates
+            m_seenFile.insert(im->m_filePath, absFilePath);
+            return;
+        }
 
-        // changed images retain their existing id
-        im->m_id = oldim->m_id;
+        LOG(VB_FILE, LOG_INFO, QString("Modified file %1").arg(absFilePath));
 
-        // Remove the entry from the dbList
-        m_dbFileMap->remove(oldim->m_fileName);
-        delete oldim;
+        // Retain existing id & settings
+        im->m_id       = dbIm->m_id;
+        im->m_isHidden = dbIm->m_isHidden;
+
+        // Set date, comment from file meta data
+        int fileOrient;
+        PopulateMetadata(absFilePath, im->m_type,
+                         im->m_comment, im->m_date, fileOrient);
+
+        // Reset file orientation, retaining existing setting
+        int currentOrient = Orientation(dbIm->m_orientation).GetCurrent();
+        im->m_orientation = Orientation(currentOrient, fileOrient).Composite();
+
+        // Remove it from removed list
+        m_dbFileMap.remove(im->m_filePath);
+        // Note modified images
+        m_changedImages << QString::number(im->m_id);
+
+        // Update db
+        m_dbfs.UpdateDbImage(*im);
+    }
+    else if (m_seenFile.contains(im->m_filePath))
+    {
+        LOG(VB_GENERAL, LOG_WARNING, QString("Ignoring %1 (Duplicate of %2)")
+            .arg(absFilePath, m_seenFile.value(im->m_filePath)));
+        return;
     }
     else
     {
-        LOG(VB_FILE, LOG_INFO, QString("%1: New file %2")
-            .arg(objectName(), fileInfo.absoluteFilePath()));
+        // New images will be assigned an id by the db AUTO-INCREMENT
+        LOG(VB_FILE, LOG_INFO,  QString("New file %1").arg(absFilePath));
 
-        // new images will be assigned an id by the db AUTO-INCREMENT
-        im->m_id = 0;
-    }
+        // Set date, comment from file meta data
+        int fileOrient;
+        PopulateMetadata(absFilePath, im->m_type,
+                         im->m_comment, im->m_date, fileOrient);
 
-    // Set the parent.
-    im->m_parentId = parentId;
+        // Set file orientation
+        im->m_orientation = Orientation(fileOrient, fileOrient).Composite();
 
-    // Set orientation, date, comment from file meta data
-    ImageMetaData::PopulateMetaValues(im);
+        // Update db (Set id for thumb generator)
+        im->m_id = m_dbfs.InsertDbImage(*im);
+    }
 
-    // Update db
-    m_db.UpdateDbFile(im);
+    // Detect duplicate filepaths in SG
+    m_seenFile.insert(im->m_filePath, absFilePath);
 
-    // Ensure thumbnail exists.
-    // Do all top level images asap (they may be needed when scan finishes)
-    // Thumb generator now owns image
-    ImageThumbPriority thumbPriority = (parentId == ROOT_DB_ID
-                         ? kScannerUrgentPriority : kBackgroundPriority);
+    // Populate absolute filename so that thumbgen doesn't need to locate file
+    im->m_filePath = absFilePath;
 
-    ImageThumb::getInstance()->CreateThumbnail(im, thumbPriority);
+    // Ensure thumbnail exists.
+    m_thumb.CreateThumbnail(im);
 }
 
 
 /*!
- \brief Creates metadata from directory info
- \param fileInfo Dir info
- \param parentId Db id of the dir's parent dir
- \param baseDirectory The storage group root dir path
- \return ImageItem New metadata object
+ \brief Counts images in a dir subtree
+ \details Ignores dirs that match exclusions regexp
+ \param dir Root of subtree
 */
-ImageItem* ImageScanThread::LoadDirectoryData(QFileInfo fileInfo,
-                                              int parentId,
-                                              QString baseDirectory)
+template <class DBFS>
+void ImageScanThread<DBFS>::CountTree(QDir &dir)
 {
-    ImageItem *dirIm = new ImageItem();
-
-    QDir dir(baseDirectory);
-    dirIm->m_parentId    = parentId;
-    dirIm->m_fileName    = dir.relativeFilePath(fileInfo.absoluteFilePath());
-    dirIm->m_name        = fileInfo.fileName();
-    dirIm->m_path        = dir.relativeFilePath(fileInfo.absolutePath());
-    if (dirIm->m_path.isNull())
-        dirIm->m_path = "";
-    dirIm->m_modTime     = fileInfo.lastModified().toTime_t();
-    dirIm->m_type        = kSubDirectory;
-
-    return dirIm;
+    QFileInfoList files = dir.entryInfoList();
+
+    foreach(const QFileInfo &fileInfo, files)
+    {
+        if (fileInfo.isFile())
+            ++m_progressTotalCount;
+        // Ignore excluded dirs and missing dirs
+        else if (!m_exclusions.match(fileInfo.fileName()).hasMatch()
+                 && dir.cd(fileInfo.fileName()))
+        {
+            CountTree(dir);
+            dir.cdUp();
+        }
+    }
 }
 
 
 /*!
- \brief Creates an item for an image file
- \param fileInfo File info
- \param parentId Db id of the file's parent dir
- \param baseDirectory The storage group root dir path
- \return ImageItem New metadata object
+ \brief Counts images in a list of subtrees
+ \param paths List of dir trees to scan
 */
-ImageItem* ImageScanThread::LoadFileData(QFileInfo fileInfo,
-                                         QString baseDirectory)
+template <class DBFS>
+void ImageScanThread<DBFS>::CountFiles(const QStringList &paths)
 {
-    QString extension = fileInfo.suffix().toLower();
-    int type = m_sg->GetImageType(extension);
-    if (type == kUnknown)
-        return NULL;
-
-    ImageItem *image = new ImageItem();
-
-    QDir baseDir(baseDirectory);
-    image->m_fileName  = baseDir.relativeFilePath(fileInfo.absoluteFilePath());
-    image->m_name      = fileInfo.fileName();
-    image->m_path      = baseDir.relativeFilePath(fileInfo.absolutePath());
-    image->m_modTime   = fileInfo.lastModified().toTime_t();
-    image->m_size      = fileInfo.size();
-    image->m_type      = type;
-    image->m_extension = extension;
-    image->m_thumbPath = ImageUtils::ThumbPathOf(image);
-
-    return image;
-}
+    // Get exclusions as comma-seperated list using glob chars * and ?
+    QString excPattern = gCoreContext->GetSetting("GalleryIgnoreFilter", "");
 
+    // Combine into a single regexp
+    excPattern.replace(".", "\\."); // Preserve "."
+    excPattern.replace("*", ".*");  // Convert glob wildcard "*"
+    excPattern.replace("?", ".");   // Convert glob wildcard "?"
+    excPattern.replace(",", "|");   // Convert list to OR's
 
-ImageScan* ImageScan::m_instance = NULL;
+    QString pattern = QString("^(%1)$").arg(excPattern);
+    m_exclusions = QRegularExpression(pattern);
 
-/*!
- \brief Constructor
-*/
-ImageScan::ImageScan()
-{
-    m_imageScanThread = new ImageScanThread();
-}
+    LOG(VB_FILE, LOG_DEBUG, QString("Exclude regexp is \"%1\"").arg(pattern));
 
+    // Lock counts until counting complete
+    QMutexLocker locker(&m_mutexProgress);
+    m_progressCount       = 0;
+    m_progressTotalCount  = 0;
 
-/*!
- \brief Destructor
-*/
-ImageScan::~ImageScan()
-{
-    if (m_imageScanThread)
+    // Use global image filters
+    QDir dir = m_dir;
+    foreach(const QString &sgDir, paths)
     {
-        delete m_imageScanThread;
-        m_imageScanThread = NULL;
+        // Ignore missing dirs
+        if (dir.cd(sgDir))
+            CountTree(dir);
     }
+    // 0 signifies a scan start
+    Broadcast(0);
 }
 
 
 /*!
- \brief Get singleton
- \return ImageScan Scanner object
+ \brief Notify listeners of scan progress
+ \details
+ \note Count mutex must be held before calling this
+ \param progress Number of images processed
 */
-ImageScan* ImageScan::getInstance()
+template <class DBFS>
+void ImageScanThread<DBFS>::Broadcast(int progress)
 {
-    if (!m_instance)
-        m_instance = new ImageScan();
-
-    return m_instance;
-}
-
-
-/*!
- \brief Process client requests for start scan, stop scan, clear Db and scan
-  progress queries
- \param command Start, stop, clear or query
- \return QStringList ("ERROR", Error message) or
-("OK", "SCANNING" | "", "done/total")
-*/
-QStringList ImageScan::HandleScanRequest(QStringList command)
-{
-    // Expects command & a single qualifier
-    if (command.size() != 2)
-        return QStringList("ERROR") << "Bad IMAGE_SCAN";
-
-    if (!m_imageScanThread)
-        // Should never happen
-        return QStringList("ERROR") << "Scanner is missing";
-
-    if (command[1] == "START")
-    {
-        // Must be dormant to start a scan
-        bool valid = (m_imageScanThread->GetState() == kDormant);
-
-        if (valid)
-            m_imageScanThread->ChangeState(kScan);
-
-        return valid ? QStringList("OK") : QStringList("ERROR") << "Scanner is busy";
-    }
-    else if (command[1] == "STOP")
-    {
-        // Must be scanning to interrupt
-        bool valid = (m_imageScanThread->GetState() == kScan);
-
-        if (valid)
-            m_imageScanThread->ChangeState(kInterrupt);
+    // Only 2 scanners are ever visible (FE & BE) so use bool as scanner id
+    QStringList status;
+    status << QString::number(gCoreContext->IsBackend())
+           << QString::number(progress)
+           << QString::number(m_progressTotalCount);
 
-        return valid ? QStringList("OK") : QStringList("ERROR") << "Scan not in progress";
-    }
-    else if (command[1] == "CLEAR")
-    {
-        // Must not be already clearing
-        bool valid = (m_imageScanThread->GetState() != kClear);
+    m_dbfs.Notify("IMAGE_SCAN_STATUS", status);
 
-        if (valid)
-            m_imageScanThread->ChangeState(kClear);
+    // Reset broadcast throttle
+    m_bcastTimer.start();
+}
 
-        return valid ? QStringList("OK") : QStringList("ERROR") << "Clear already in progress";
 
-    }
-    else if (command[1] == "QUERY")
-    {
-        QStringList reply;
-        reply << "OK"
-              << (m_imageScanThread->isRunning() ? "SCANNING" : "")
-              << m_imageScanThread->GetProgress();
-        return reply;
-    }
-    LOG(VB_GENERAL, LOG_ERR, "ImageScanner: Unknown command");
-    return QStringList("ERROR") << "Unknown command";
-}
+// Must define the valid template implementations to generate code for the
+// instantiations (as they are defined in the cpp rather than header).
+// Otherwise the linker will fail with undefined references...
+#include "imagemanager.h"
+template class ImageScanThread<ImageDbLocal>;
+template class ImageScanThread<ImageDbSg>;
diff --git a/mythtv/libs/libmythmetadata/imagescanner.h b/mythtv/libs/libmythmetadata/imagescanner.h
index 72a6b8a..4f9fd54 100644
--- a/mythtv/libs/libmythmetadata/imagescanner.h
+++ b/mythtv/libs/libmythmetadata/imagescanner.h
@@ -1,110 +1,86 @@
 //! \file
-//! \brief Synchronises image database to storage group
-//! \details Detects supported pictures and videos within storage group and populates
+//! \brief Synchronises image database to filesystem
+//! \details Detects supported pictures and videos and populates
 //! the image database with metadata for each, including directory structure.
-//! After a scan completes, a background task then creates thumbnails for each new image
-//! to improve client performance.
+//! All images are passed to the associated thumbnail generator.
+//! Db images that have disappeared are notified to frontends so that they can clean up.
+//! Also clears database & removes devices (to prevent contention with running scans).
+//!
+//! Clone directories & duplicate files can only occur in a Storage Group/Backend scanner.
+//! They can never occur with local devices/Frontend scanner
 
-#ifndef IMAGESCAN_H
-#define IMAGESCAN_H
+#ifndef IMAGESCANNER_H
+#define IMAGESCANNER_H
 
 #include <QFileInfo>
-#include <QMap>
 #include <QDir>
-#include <QRegExp>
-#include <QMutex>
+#include <QRegularExpression>
+#include <QElapsedTimer>
 
-#include <mthread.h>
-#include <imageutils.h>
+#include "imagethumbs.h"
 
 
-//! \brief Current/last requested scanner state
-//! \details Valid state transitions are:
-//!  Scan -> Dormant : Scan requested
-//!  Clear -> Dormant : Clear db requested
-//!  Scan -> Interrupt -> Dormant : Scan requested, then interrupted
-//!  Scan -> Clear -> Dormant : Clear db requested during scan
-//!  Scan -> Interrupt -> Clear -> Dormant : Scan interrupted, then Clear Db requested
-enum ScannerState
-{
-    kScan,      //!< sync is pending/in effect
-    kInterrupt, //!< cancelled sync is pending/in effect
-    kClear,     //!< clear db is pending/in effect
-    kDormant    //!< doing nothing
-};
-
-
-//! Scanner worker thread
+//! Image Scanner thread requires a database/filesystem adapter
+template <class DBFS>
 class META_PUBLIC ImageScanThread : public MThread
 {
 public:
-    ImageScanThread();
+    ImageScanThread(DBFS *const dbfs, ImageThumb<DBFS> *thumbGen);
     ~ImageScanThread();
 
-    void cancel();
+    void        cancel();
+    bool        IsScanning();
+    bool        ClearsPending();
+    void        ChangeState(bool scan);
+    void        EnqueueClear(int devId, const QString &action);
     QStringList GetProgress();
-    ScannerState GetState();
-    void ChangeState(ScannerState to);
 
 protected:
     void run();
 
 private:
-    ImageItem* LoadDirectoryData(QFileInfo, int, QString);
-    ImageItem* LoadFileData(QFileInfo, QString);
-
-    void SyncFilesFromDir(QString, int, QString);
-    int  SyncDirectory(QFileInfo, int, QString);
-    void SyncFile(QFileInfo, int, QString);
-    void WaitForThumbs();
-    void BroadcastStatus(QString);
-    void CountFiles(QStringList paths);
-    void CountTree(QDir &);
-
-    //! The latest state from all clients.
-    ScannerState m_state;
-    //! Mutex protecting state
-    QMutex m_mutexState;
-
-    // Global working vars
-    ImageDbWriter  m_db;
-    ImageSg       *m_sg;
-
-    //! Maps dir paths (relative to SG) to dir metadata
-    ImageMap *m_dbDirMap;
-    //! Maps file paths (relative to SG) to file metadata
-    ImageMap *m_dbFileMap;
-
-    //! Number of images scanned
-    int  m_progressCount;
-    //! Total number of images to scan
-    int  m_progressTotalCount;
-    //! Progress counts mutex
-    QMutex m_mutexProgress;
+    void SyncSubTree(const QFileInfo &dirInfo, int parentId, int devId,
+                     const QString &base);
+    int  SyncDirectory(const QFileInfo &dirInfo, int devId,
+                       const QString &base, int parentId);
+    void PopulateMetadata(const QString &path, int type,
+                          QString &comment, uint &time, int &orientation);
+    void SyncFile(const QFileInfo &fileInfo, int devId,
+                  const QString &base, int parentId);
+    void CountTree(QDir &dir);
+    void CountFiles(const QStringList &paths);
+    void Broadcast(int progress);
+
+    typedef QPair<int, QString> ClearTask;
+
+    bool              m_scanning;   //!< The requested scan state
+    QMutex            m_mutexState; //!< Mutex protecting scan state
+    QList<ClearTask>  m_clearQueue; //!< Queue of pending Clear requests
+    QMutex            m_mutexQueue; //!< Mutex protecting Clear requests
+    DBFS             &m_dbfs;       //!< Database/filesystem adapter
+    ImageThumb<DBFS> &m_thumb;      //!< Companion thumbnail generator
+
+    //! Dirs in the Db from last scan, Map<Db filepath, Db Image>
+    ImageHash   m_dbDirMap;
+    //! Files in the Db from last scan, Map<Db filepath, Db Image>
+    ImageHash   m_dbFileMap;
+    //! Dirs seen by current scan, Map<Db filepath, Earlier Image>
+    ImageHash   m_seenDir;
+    //! Files seen by current scan Map <Db filepath, Earlier abs filepath>
+    NameHash    m_seenFile;
+    //! Ids of dirs/files that have been updates/modified.
+    QStringList m_changedImages;
+
+    //! Elapsed time since last progress event generated
+    QElapsedTimer m_bcastTimer;
+    int           m_progressCount;      //!< Number of images scanned
+    int           m_progressTotalCount; //!< Total number of images to scan
+    QMutex        m_mutexProgress;      //!< Progress counts mutex
 
     //! Global working dir for file detection
     QDir m_dir;
     //! Pattern of dir names to ignore whilst scanning
-    QRegExp m_exclusions;
-};
-
-
-//! Synchronises database to the filesystem
-class META_PUBLIC ImageScan
-{
-public:
-    static ImageScan*    getInstance();
-
-    QStringList HandleScanRequest(QStringList);
-
-private:
-    ImageScan();
-    ~ImageScan();
-
-    //! Scanner singleton
-    static ImageScan    *m_instance;
-    //! Internal thread
-    ImageScanThread     *m_imageScanThread;
+    QRegularExpression m_exclusions;
 };
 
-#endif // IMAGESCAN_H
+#endif // IMAGESCANNER_H
diff --git a/mythtv/libs/libmythmetadata/imagethumbs.cpp b/mythtv/libs/libmythmetadata/imagethumbs.cpp
index d361bce..f7b4b7e 100644
--- a/mythtv/libs/libmythmetadata/imagethumbs.cpp
+++ b/mythtv/libs/libmythmetadata/imagethumbs.cpp
@@ -1,92 +1,135 @@
 #include "imagethumbs.h"
 
-#include <exitcodes.h> // for previewgen
-
-#include <QFile>
 #include <QDir>
-#include <QtAlgorithms>
-#include <QImage>
-#include <QThread>
-#include <QMutexLocker>
-#include <QMatrix>
+#include <QStringList>
 
-#include <mythdirs.h>
-#include <mythsystemlegacy.h>
+#include "mythlogging.h"
+#include "mythcorecontext.h"  // for events
+#include "mythsystemlegacy.h" // for previewgen
+#include "mythdirs.h"         // for previewgen
+#include "exitcodes.h"        // for previewgen
+#include "mythimage.h"
 
+#include "imagemetadata.h"
 
 /*!
- \brief Contstruct request for a single image
- \param action Request action
- \param im Image object that will be deleted.
- \param priority Request priority
- \param notify If true a 'thumbnail exists' event will be broadcast when done.
+ \brief Constructor
+ \param name Thread name
+ \param dbfs Filesystem/Database adapter
 */
-ThumbTask::ThumbTask(QString action, ImageItem *im,
-                     ImageThumbPriority priority, bool notify)
-    : m_action(action),
-      m_priority(priority),
-      m_notify(notify)
+template <class DBFS>
+ThumbThread<DBFS>::ThumbThread(const QString &name, DBFS *const dbfs)
+    : MThread(name), m_dbfs(*dbfs),
+      m_requestQ(), m_backgroundQ(), m_doBackground(true)
+{}
+
+
+/*!
+ \brief Destructor
+*/
+template <class DBFS>
+ThumbThread<DBFS>::~ThumbThread()
 {
-    append(im);
+    cancel();
+    wait();
 }
 
 
 /*!
- \brief Contstruct request for a list of images/dirs
- \param action Request action
- \param list Image objects that will be deleted.
- \param priority Request priority
- \param notify If true a 'thumbnail exists' event will be broadcast when done.
+ \brief Clears all queues so that the thread will terminate.
 */
-ThumbTask::ThumbTask(QString action, ImageList &list,
-                     ImageThumbPriority priority, bool notify)
-    : ImageList(list),
-      m_action(action),
-      m_priority(priority),
-      m_notify(notify)
+template <class DBFS>
+void ThumbThread<DBFS>::cancel()
 {
-    // Assume ownership of list contents
-    list.clear();
+    // Clear all queues
+    QMutexLocker locker(&m_mutex);
+    m_requestQ.clear();
+    m_backgroundQ.clear();
 }
 
 
 /*!
- \brief  Construct worker thread
+ \brief Queues a Create request
+ \param task The request
 */
-ThumbThread::ThumbThread(QString name)
-    : MThread(name), m_sg(ImageSg::getInstance())
+template <class DBFS>
+void ThumbThread<DBFS>::Enqueue(const TaskPtr &task)
 {
-    m_tempDir = QString("%1/%2").arg(GetConfDir(), TEMP_DIR);
-    m_thumbDir = m_tempDir.absoluteFilePath(THUMBNAIL_DIR);
-    m_tempDir.mkdir(THUMBNAIL_DIR);
+    if (task)
+    {
+        bool background = task->m_priority > kBackgroundPriority;
 
-    // Use priorities: 0 = image requests, 1 = video requests, 2 = urgent, 3 = background
-    for (int i = 0; i <= kBackgroundPriority; ++i)
-        m_thumbQueue.insert(static_cast<ImageThumbPriority>(i), new ThumbQueue());
+        QMutexLocker locker(&m_mutex);
+        if (background)
+            m_backgroundQ.insert(task->m_priority, task);
+        else
+            m_requestQ.insert(task->m_priority, task);
 
-    if (!gCoreContext->IsBackend())
-        LOG(VB_GENERAL, LOG_ERR, "Thumbnail Generators MUST be run on a backend");
+        // restart if not already running
+        if ((m_doBackground || !background) && !this->isRunning())
+            this->start();
+    }
 }
 
 
 /*!
- \brief  Destructor
+ \brief Clears thumbnail request queue
+ \warning May block for several seconds
 */
-ThumbThread::~ThumbThread()
+template <class DBFS>
+void ThumbThread<DBFS>::AbortDevice(int devId, const QString &action)
 {
-    cancel();
-    wait();
-    qDeleteAll(m_thumbQueue);
+    if (action == "DEVICE CLOSE ALL" || action == "DEVICE CLEAR ALL")
+    {
+        if (isRunning())
+            LOG(VB_FILE, LOG_INFO,
+                QString("Aborting all thumbnails %1").arg(action));
+
+        // Abort thumbnail generation for all devices
+        cancel();
+        return;
+    }
+
+    LOG(VB_FILE, LOG_INFO, QString("Aborting thumbnails (%1) for '%2'")
+        .arg(action).arg(m_dbfs.DeviceName(devId)));
+
+    // Remove all tasks for specific device from every queue
+    QMutexLocker locker(&m_mutex);
+    RemoveTasks(m_requestQ, devId);
+    RemoveTasks(m_backgroundQ, devId);
+    if (isRunning())
+        // Wait until current task is complete - it may be using the device
+        m_taskDone.wait(&m_mutex, 3000);
+}
+
+
+/*!
+  /brief Removes all tasks for a device from a task queue
+ */
+template <class DBFS>
+void ThumbThread<DBFS>::RemoveTasks(ThumbQueue &queue, int devId)
+{
+    QMutableMapIterator<int, TaskPtr> it(queue);
+    while (it.hasNext())
+    {
+        it.next();
+        TaskPtr task = it.value();
+        // All thumbs in a task come from same device
+        if (task && !task->m_images.isEmpty()
+                && task->m_images.at(0)->m_device == devId)
+            it.remove();
+    }
 }
 
 
 /*!
  \brief  Handles thumbnail requests by priority
  \details Repeatedly processes next request from highest priority queue until all
- queues are empty, then quits. For Create requests an event is broadcast once the
- thumbnail exists. Dirs are only deleted if empty
- */
-void ThumbThread::run()
+  queues are empty, then quits. For Create requests an event is broadcast once the
+  thumbnail exists. Dirs are only deleted if empty
+*/
+template <class DBFS>
+void ThumbThread<DBFS>::run()
 {
     RunProlog();
 
@@ -94,105 +137,101 @@ void ThumbThread::run()
 
     while (true)
     {
+        // Signal previous task is complete (its files have been closed)
+        m_taskDone.wakeAll();
+
+        // Do all we can to run in background
+        QThread::yieldCurrentThread();
+
         // process next highest-priority task
-        ThumbTask *task = NULL;
+        TaskPtr task;
         {
             QMutexLocker locker(&m_mutex);
-            foreach(ThumbQueue *q, m_thumbQueue)
-                if (!q->isEmpty())
-                {
-                    task = q->takeFirst();
-                    break;
-                }
+            if (!m_requestQ.isEmpty())
+                task = m_requestQ.take(m_requestQ.firstKey());
+            else if (m_doBackground && !m_backgroundQ.isEmpty())
+                task = m_backgroundQ.take(m_backgroundQ.firstKey());
+            else
+                // quit when both queues exhausted
+                break;
         }
-        // quit when all queues exhausted
-        if (!task)
-            break;
 
         // Shouldn't receive empty requests
-        if (task->isEmpty())
+        if (task->m_images.isEmpty())
             continue;
 
         if (task->m_action == "CREATE")
         {
-            ImageItem *im = task->at(0);
-
-            LOG(VB_FILE, LOG_DEBUG, objectName()
-                + QString(": Creating %1 (Id %2, priority %3)")
-                .arg(im->m_fileName).arg(im->m_id).arg(task->m_priority));
-
-            // Shouldn't receive any dirs or empty thumb lists
-            if (im->m_thumbPath.isEmpty())
-                continue;
-
-            if (m_tempDir.exists(im->m_thumbPath))
-
-                LOG(VB_FILE, LOG_DEBUG, objectName()
-                    + QString(": Thumbnail %1 already exists")
-                    .arg(im->m_thumbPath));
+            ImagePtrK im = task->m_images.at(0);
 
-            else if (im->m_type == kImageFile)
+            QString err = CreateThumbnail(im, task->m_priority);
 
-                CreateImageThumbnail(im);
-
-            else if (im->m_type == kVideoFile)
-
-                CreateVideoThumbnail(im);
-
-            else
-                LOG(VB_FILE, LOG_ERR, objectName()
-                    + QString(": Can't create thumbnail for type %1 : image %2")
-                    .arg(im->m_type).arg(im->m_fileName));
-
-            // notify clients when done
-            if (task->m_notify)
+            if (!err.isEmpty())
             {
-                QString id = QString::number(im->m_id);
-
-                // Return requested thumbnails - FE uses it as a message signature
-                MythEvent me = MythEvent("THUMB_AVAILABLE", id);
+                LOG(VB_GENERAL, LOG_ERR,  QString("%1").arg(err));
+            }
+            else if (task->m_notify)
+            {
+                // notify clients when done
+                MythEvent me("THUMB_AVAILABLE", QString::number(im->m_id));
                 gCoreContext->SendEvent(me);
             }
         }
         else if (task->m_action == "DELETE")
         {
-            foreach(const ImageItem *im, *task)
+            foreach(ImagePtrK im, task->m_images)
             {
-                if (m_tempDir.remove(im->m_thumbPath))
-
-                    LOG(VB_FILE, LOG_DEBUG, objectName()
-                        + QString(": Deleted thumbnail %1")
-                        .arg(im->m_fileName));
-                else
-                    LOG(VB_FILE, LOG_WARNING, objectName()
-                        + QString(": Couldn't delete thumbnail %1")
-                        .arg(im->m_thumbPath));
+                QString thumbnail = im->m_thumbPath;
+                if (!QDir::root().remove(thumbnail))
+                {
+                    LOG(VB_FILE, LOG_WARNING,
+                        QString("Failed to delete thumbnail %1").arg(thumbnail));
+                    continue;
+                }
+                LOG(VB_FILE, LOG_DEBUG,
+                    QString("Deleted thumbnail %1").arg(thumbnail));
+
+                // Clean up empty dirs
+                QString path = QFileInfo(thumbnail).path();
+                if (QDir::root().rmpath(path))
+                    LOG(VB_FILE, LOG_DEBUG,
+                        QString("Cleaned up path %1").arg(path));
             }
         }
-        else if (task->m_action == "DELETE_DIR")
+        else if (task->m_action == "MOVE")
         {
-            ImageList::const_iterator it = (*task).constEnd();
-            while (it != (*task).constBegin())
+            foreach(ImagePtrK im, task->m_images)
             {
-                ImageItem *im = *(--it);
-
-                if (m_tempDir.rmdir(im->m_thumbPath))
-
-                    LOG(VB_FILE, LOG_DEBUG, objectName()
-                        + QString(": Deleted thumbdir %1")
-                        .arg(im->m_fileName));
+                // Build new thumb path
+                QString newThumbPath =
+                        m_dbfs.GetAbsThumbPath(m_dbfs.ThumbDir(im->m_device),
+                                               m_dbfs.ThumbPath(*im.data()));
+
+                // Ensure path exists
+                if (QDir::root().mkpath(QFileInfo(newThumbPath).path())
+                        && QFile::rename(im->m_thumbPath, newThumbPath))
+                {
+                    LOG(VB_FILE, LOG_DEBUG, QString("Moved thumbnail %1 -> %2")
+                        .arg(im->m_thumbPath, newThumbPath));
+                }
                 else
-                    LOG(VB_FILE, LOG_WARNING, objectName()
-                        + QString(": Couldn't delete thumbdir %1")
-                        .arg(im->m_thumbPath));
+                {
+                    LOG(VB_FILE, LOG_WARNING,
+                        QString("Failed to rename thumbnail %1 -> %2")
+                        .arg(im->m_thumbPath, newThumbPath));
+                    continue;
+                }
+
+                // Clean up empty dirs
+                QString path = QFileInfo(im->m_thumbPath).path();
+                if (QDir::root().rmpath(path))
+                    LOG(VB_FILE, LOG_DEBUG,
+                        QString("Cleaned up path %1").arg(path));
             }
         }
         else
-            LOG(VB_FILE, LOG_ERR, objectName() + QString(": Unknown task %1")
-                .arg(task->m_action));
-
-        qDeleteAll(*task);
-        delete task;
+            LOG(VB_GENERAL, LOG_ERR,
+                QString("Unknown task %1").arg(task->m_action));
     }
 
     RunEpilog();
@@ -200,415 +239,267 @@ void ThumbThread::run()
 
 
 /*!
- \brief Rotates/reflects an image iaw its orientation
- \note Duplicates MythImage::Orientation
- \param im Image details
- \param image Image to be transformed
-*/
-void ThumbThread::Orientate(ImageItem *im, QImage &image)
+ \brief Generate thumbnail for an image
+ \param im Image
+ \param int priority
+ */
+template <class DBFS>
+QString ThumbThread<DBFS>::CreateThumbnail(ImagePtrK im, int thumbPriority)
 {
-    QMatrix matrix;
-    switch (im->m_orientation)
+    if (QDir::root().exists(im->m_thumbPath))
     {
-    case 1: // If the image is in its original state
-        break;
-
-    case 2: // The image is horizontally flipped
-        image = image.mirrored(true, false);
-        break;
-
-    case 3: // The image is rotated 180
-        matrix.rotate(180);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        break;
-
-    case 4: // The image is vertically flipped
-        image = image.mirrored(false, true);
-        break;
-
-    case 5: // The image is transposed (flipped horizontally, then rotated 90 CCW)
-        matrix.rotate(90);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        image = image.mirrored(true, false);
-        break;
-
-    case 6: // The image is rotated 90 CCW
-        matrix.rotate(90);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        break;
-
-    case 7: // The image is transversed (flipped horizontally, then rotated 90 CW)
-        matrix.rotate(270);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        image = image.mirrored(true, false);
-        break;
-
-    case 8: // The image is rotated 90 CW
-        matrix.rotate(270);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        break;
-
-    default:
-        break;
+        LOG(VB_FILE, LOG_DEBUG,  QString("[%3] Thumbnail %2 already exists")
+            .arg(im->m_thumbPath).arg(thumbPriority));
+        return QString(); // Notify anyway
     }
-}
 
-/*!
- \brief  Creates a picture thumbnail with the correct size and rotation
- \param  im The image
-*/
-void ThumbThread::CreateImageThumbnail(ImageItem *im)
-{
-    QString imagePath = m_sg->GetFilePath(im);
-
-    if (!im->m_path.isEmpty())
-        m_thumbDir.mkpath(im->m_path);
+    // Local filenames are always absolute
+    // Remote filenames are absolute from the scanner only
+    // UI requests (derived from Db) are relative
+    QString imagePath = m_dbfs.GetAbsFilePath(im);
+    if (imagePath.isEmpty())
+        return QString("Empty image path: %1").arg(im->m_filePath);
 
-    // Absolute path of the BE thumbnail
-    QString thumbPath = m_tempDir.absoluteFilePath(im->m_thumbPath);
+    // Ensure path exists
+    QDir::root().mkpath(QFileInfo(im->m_thumbPath).path());
 
     QImage image;
-    if (!image.load(imagePath))
+    if (im->m_type == kImageFile)
     {
-        LOG(VB_FILE, LOG_ERR, QString("%1: Failed to open image %2")
-            .arg(objectName(), imagePath));
-        return;
-    }
-
-    // Resize & orientate now to optimise load/display time by FE's
-    image = image.scaled(QSize(240,180), Qt::KeepAspectRatio, Qt::SmoothTransformation);
-    Orientate(im, image);
+        if (!image.load(imagePath))
+            return QString("Failed to open image %1").arg(imagePath);
 
-    // create the thumbnail
-    if (image.save(thumbPath))
+        // Resize to optimise load/display time by FE's
+        image = image.scaled(QSize(240,180), Qt::KeepAspectRatio, Qt::SmoothTransformation);
+    }
+    else if (im->m_type == kVideoFile)
+    {
+        // Run Preview Generator in foreground
+        QString cmd = GetAppBinDir() + MYTH_APPNAME_MYTHPREVIEWGEN;
+        QStringList args;
+        args << "--size 320x240"; // Video thumbnails are also shown in slideshow
+        args << QString("--infile '%1'").arg(imagePath);
+        args << QString("--outfile '%1'").arg(im->m_thumbPath);
+
+        MythSystemLegacy ms(cmd, args,
+                            kMSRunShell           |
+                            kMSDontBlockInputDevs |
+                            kMSDontDisableDrawing |
+                            kMSProcessEvents      |
+                            kMSAutoCleanup        |
+                            kMSPropagateLogs);
+        ms.SetNice(10);
+        ms.SetIOPrio(7);
+        ms.Run(30);
+        if (ms.Wait() != GENERIC_EXIT_OK)
+        {
+            LOG(VB_GENERAL, LOG_ERR,  QString("Failed to run %2 %3")
+                .arg(cmd, args.join(" ")));
+            return QString("Preview Generator failed for %1").arg(imagePath);
+        }
 
-        LOG(VB_FILE, LOG_INFO, QString("%1: Created thumbnail for %2")
-            .arg(objectName(), imagePath));
+        if (!image.load(im->m_thumbPath))
+            return QString("Failed to open preview %1").arg(im->m_thumbPath);
+    }
     else
-        LOG(VB_FILE, LOG_ERR, QString("%1: Failed to create thumbnail for %2")
-            .arg(objectName(), imagePath));
-}
+        return QString("Can't create thumbnail for type %1 (image %2)")
+                .arg(im->m_type).arg(imagePath);
 
+    int orientBy = Orientation(im->m_orientation).GetCurrent();
 
-/*!
- \brief  Creates a video preview image with the correct size using mythpreviewgen
- \param  im The image
-*/
-void ThumbThread::CreateVideoThumbnail(ImageItem *im)
-{
-    QString videoPath = m_sg->GetFilePath(im);
-
-    if (!im->m_path.isEmpty())
-        m_thumbDir.mkpath(im->m_path);
-
-    // Absolute path of the BE thumbnail
-    QString thumbPath = m_tempDir.absoluteFilePath(im->m_thumbPath);
-
-    QString cmd = "mythpreviewgen";
-    QStringList args;
-    args << logPropagateArgs.split(" ", QString::SkipEmptyParts);
-    args << "--size 320x240"; // Video thumbnails are shown in slideshow
-    args << "--infile"  << QString("\"%1\"").arg(videoPath);
-    args << "--outfile" << QString("\"%1\"").arg(thumbPath);
-
-    MythSystemLegacy ms(cmd, args, kMSRunShell);
-    ms.SetDirectory(m_thumbDir.absolutePath());
-    ms.Run();
-
-    // If the process exited successful
-    // then try to load the thumbnail
-    if (ms.Wait() != GENERIC_EXIT_OK)
-    {
-        LOG(VB_FILE, LOG_ERR, QString("%1: Preview Generator failed for %2")
-            .arg(objectName(), videoPath));
-        return;
-    }
-
-    QImage image;
-    if (image.load(thumbPath))
-    {
-        Orientate(im, image);
+    // Orientate now to optimise load/display time - no orientation
+    // is required when displaying thumbnails
+    image = Orientation::ApplyExifOrientation(image, orientBy);
 
-        image.save(thumbPath);
+    // Create the thumbnail
+    if (!image.save(im->m_thumbPath))
+        return QString("Failed to create thumbnail %1").arg(im->m_thumbPath);
 
-        LOG(VB_FILE, LOG_INFO, QString("%1: Created thumbnail for %2")
-            .arg(objectName(), videoPath));
-    }
-    else
-        LOG(VB_FILE, LOG_ERR, QString("%1: Failed to create thumbnail for %2")
-            .arg(objectName(), videoPath));
+    LOG(VB_FILE, LOG_INFO,  QString("Created thumbnail [%2] %1")
+        .arg(im->m_thumbPath).arg(thumbPriority));
+    return QString();
 }
 
 
 /*!
- \brief Queues a Create request
- \param task The request
+  \brief Pauses or restarts processing of background tasks (scanner requests)
  */
-void ThumbThread::QueueThumbnails(ThumbTask *task)
+template <class DBFS>
+void ThumbThread<DBFS>::PauseBackground(bool pause)
 {
-    // null tasks will terminate the thread prematurely
-    if (task)
-    {
-        QMutexLocker locker(&m_mutex);
-        m_thumbQueue.value(task->m_priority)->append(task);
+    QMutexLocker locker(&m_mutex);
+    m_doBackground = !pause;
 
-        // restart if not already running
-        if (!this->isRunning())
-            this->start();
-    }
+    // restart if not already running
+    if (m_doBackground && !this->isRunning())
+        this->start();
 }
 
 
 /*!
- \brief Return size of a specific queue
- \param priority The queue of interest
- \return int Number of requests pending
-*/
-int ThumbThread::GetQueueSize(ImageThumbPriority priority)
-{
-    QMutexLocker locker(&m_mutex);
-    ThumbQueue *thumbQueue = m_thumbQueue.value(priority);
+ \brief Constructor
+ */
+template <class DBFS>
+ImageThumb<DBFS>::ImageThumb(DBFS *const dbfs)
+    : m_dbfs(*dbfs),
+      m_imageThread(new ThumbThread<DBFS>("ImageThumbs", dbfs)),
+      m_videoThread(new ThumbThread<DBFS>("VideoThumbs", dbfs))
+{}
 
-    if (thumbQueue)
-        return m_thumbQueue.value(priority)->size();
 
-    return 0;
+/*!
+ \brief Destructor
+ \*/
+template <class DBFS>
+ImageThumb<DBFS>::~ImageThumb()
+{
+    delete m_imageThread;
+    delete m_videoThread;
+    m_imageThread = m_videoThread = NULL;
 }
 
 
 /*!
- \brief Clears thumbnail cache
+ \brief Clears thumbnails for a device
+ \param devId Device identity
+ \param deleteFiles If true, the device thumbnails will be deleted
+ \warning May block for several seconds
 */
-void ThumbThread::ClearThumbnails()
+template <class DBFS>
+void ImageThumb<DBFS>::ClearThumbs(int devId, const QString &action)
 {
-    LOG(VB_FILE, LOG_INFO, objectName() + ": Removing all thumbnails");
-
-    // Clear all queues & wait for generator thread to terminate
-    cancel();
-    wait();
-
-    // Remove all thumbnails
-    RemoveDirContents(m_thumbDir.absolutePath());
+    // Cancel pending requests for the device
+    // Waits for current generator task to complete
+    if (m_imageThread)
+        m_imageThread->AbortDevice(devId, action);
+    if (m_videoThread)
+        m_videoThread->AbortDevice(devId, action);
+
+    // Remove devices now they are not in use
+    QStringList mountPaths = m_dbfs.CloseDevices(devId, action);
+//    if (mountPaths.isEmpty())
+//        return;
+
+    // Generate file & thumbnail urls (as per image cache) of mountpoints
+    QStringList mesg;
+    foreach (const QString &mount, mountPaths)
+        mesg << m_dbfs.MakeFileUrl(mount)
+             << m_dbfs.MakeThumbUrl(mount);
+
+    // Notify clients to clear cache
+    m_dbfs.Notify("IMAGE_DEVICE_CHANGED", mesg);
 }
 
 
 /*!
- \brief Clears all files and sub-dirs within a directory
- \param dirName Dir to clear
- \return bool True on success
+ \brief Remove specific thumbnails
+ \param images List of obselete images
+ \return QString Csv list of deleted ids
 */
-bool ThumbThread::RemoveDirContents(QString dirName)
+template <class DBFS>
+QString ImageThumb<DBFS>::DeleteThumbs(const ImageList &images)
 {
-    // Delete all files
-    QDir dir = QDir(dirName);
-    bool result = true;
+    // Determine affected images and redundant images/thumbnails
+    QStringList ids;
 
-    foreach(const QFileInfo &info, dir.entryInfoList(QDir::AllEntries
-                                                     | QDir::NoDotAndDotDot))
+    // Pictures & videos are deleted by their own threads
+    ImageListK pics, videos;
+    foreach (ImagePtrK im, images)
     {
-        if (info.isDir())
-        {
-            RemoveDirContents(info.absoluteFilePath());
-            result = dir.rmdir(info.absoluteFilePath());
-        }
+        if (im->m_type == kVideoFile)
+            videos.append(im);
         else
-            result = QFile::remove(info.absoluteFilePath());
+            pics.append(im);
 
-        if (!result)
-            LOG(VB_FILE, LOG_ERR, QString("%1: Can't delete %2")
-                .arg(objectName(), info.absoluteFilePath()));
+        ids << QString::number(im->m_id);
     }
-    return result;
-}
-
 
-/*!
- \brief Clears all queues so that the thread can terminate.
-*/
-void ThumbThread::cancel()
-{
-    // Clear all queues
-    QMutexLocker locker(&m_mutex);
-    foreach(ThumbQueue *q, m_thumbQueue)
-    {
-        qDeleteAll(*q);
-        q->clear();
-    }
+    if (!pics.isEmpty() && m_imageThread)
+        m_imageThread->Enqueue(TaskPtr(new ThumbTask("DELETE", pics)));
+    if (!videos.isEmpty() && m_videoThread)
+        m_videoThread->Enqueue(TaskPtr(new ThumbTask("DELETE", videos)));
+    return ids.join(",");
 }
 
 
-//////////////////////////////////////////////////////////////////////////
-
-
-//! Thumbnail generator singleton
-ImageThumb* ImageThumb::m_instance = NULL;
-
-
 /*!
- \brief Constructor
-*/
-ImageThumb::ImageThumb()
-{
-    m_imageThumbThread = new ThumbThread("ImageThumbGen");
-    m_videoThumbThread = new ThumbThread("VideoThumbGen");
-}
-
-
-/*!
- \brief Destructor
+ \brief Creates a thumbnail
+ \param im Image
+ \param priority Request priority
+ \param notify If true a THUMB_AVAILABLE event will be generated
 */
-ImageThumb::~ImageThumb()
+template <class DBFS>
+void ImageThumb<DBFS>::CreateThumbnail(const ImagePtrK &im, int priority,
+                                       bool notify)
 {
-    delete m_imageThumbThread;
-    m_imageThumbThread = NULL;
-    delete m_videoThumbThread;
-    m_videoThumbThread = NULL;
-}
+    if (!im)
+        return;
 
+    // Allocate task a (hopefully) unique priority
+    if (priority == kBackgroundPriority)
+        priority = Priority(*im);
 
-/*!
- \brief Get generator
- \return ImageThumb Generator singleton
-*/
-ImageThumb* ImageThumb::getInstance()
-{
-    if (!m_instance)
-        m_instance = new ImageThumb();
+    TaskPtr task(new ThumbTask("CREATE", im, priority, notify));
 
-    return m_instance;
-}
+    if (im->m_type == kImageFile && m_imageThread)
 
+        m_imageThread->Enqueue(task);
 
-/*!
- \brief Return size of specific queue
- \param priority Queue of interest
- \return int Number of requests pending
-*/
-int ImageThumb::GetQueueSize(ImageThumbPriority priority)
-{
-    // Ignore video thread
-    if (m_imageThumbThread)
-        return m_imageThumbThread->GetQueueSize(priority);
-    return 0;
-}
+    else if (im->m_type == kVideoFile && m_videoThread)
 
+        m_videoThread->Enqueue(task);
 
-/*!
- \brief Clears thumbnail cache, blocking until generator thread terminates
-*/
-void ImageThumb::ClearAllThumbs()
-{
-    // Image task will clear videos as well
-    if (m_imageThumbThread)
-        m_imageThumbThread->ClearThumbnails();
+    else
+        LOG(VB_FILE, LOG_INFO, QString("Ignoring create thumbnail %1, type %2")
+            .arg(im->m_id).arg(im->m_type));
 }
 
 
 /*!
- \brief Creates thumbnails on-demand from clients
- \details Display requests are the highest priority. Thumbnails required for an image
-node will be created before those that are part of a directory thumbnail.
-A THUMBNAIL_CREATED event is broadcast for each image.
- \param imList List of images requiring thumbnails
+ \brief Renames a thumbnail
+ \param im Image
+ \param priority Request priority
 */
-void ImageThumb::HandleCreateThumbnails(QStringList imList)
+template <class DBFS>
+void ImageThumb<DBFS>::MoveThumbnail(const ImagePtrK &im)
 {
-    if (imList.size() != 2)
+    if (!im)
         return;
 
-    bool isForFolder = imList[1].toInt();
+    TaskPtr task(new ThumbTask("MOVE", im));
 
-    // get specific image details from db
-    ImageList images;
-    ImageDbWriter db;
-    db.ReadDbItemsById(images, imList[0]);
+    if (im->m_type == kImageFile && m_imageThread)
 
-    foreach (ImageItem *im, images)
-    {
-        ImageThumbPriority priority = isForFolder
-                ? kFolderRequestPriority : kPicRequestPriority;
+        m_imageThread->Enqueue(task);
 
-        // notify clients when done; highest priority
+    else if (im->m_type == kVideoFile && m_videoThread)
 
-        if (im->m_type == kVideoFile)
-        {
-            ThumbTask *task = new ThumbTask("CREATE", im, priority, true);
+        m_videoThread->Enqueue(task);
 
-            if (m_videoThumbThread)
-                m_videoThumbThread->QueueThumbnails(task);
-        }
-        else if (im->m_type == kImageFile)
-        {
-            ThumbTask *task = new ThumbTask("CREATE", im, priority, true);
-
-            if (m_imageThumbThread)
-                m_imageThumbThread->QueueThumbnails(task);
-        }
-    }
+    else
+        LOG(VB_FILE, LOG_INFO, QString("Ignoring move thumbnail %1, type %2")
+            .arg(im->m_id).arg(im->m_type));
 }
 
 
 /*!
- \brief Remove thumbnails from cache
- \param images List of obselete images
- \param dirs List of obselete dirs
- \return QStringList Csv list of deleted ids, empty (no modified ids), csv list of
- deleted thumbnail and image urls (compatible with FE cache)
-*/
-QStringList ImageThumb::DeleteThumbs(ImageList images, ImageList dirs)
+  \brief Pauses or restarts processing of background tasks (scanner requests)
+ */
+template <class DBFS>
+void ImageThumb<DBFS>::PauseBackground(bool pause)
 {
-    // Determine affected images and redundant images/thumbnails
-    QStringList mesg = QStringList(""); // Empty item (no modified ids)
-    QStringList ids;
-    ImageSg *isg = ImageSg::getInstance();
+    LOG(VB_FILE, LOG_INFO,  QString("Paused %1").arg(pause));
 
-    foreach (const ImageItem *im, images)
-    {
-        ids << QString::number(im->m_id);
-        // Remove thumbnail
-        mesg << isg->GenerateThumbUrl(im->m_thumbPath);
-        // Remove cached image
-        mesg << isg->GenerateUrl(im->m_fileName);
-    }
-    // Insert deleted ids at front
-    mesg.insert(0, ids.join(","));
-
-    if (!m_imageThumbThread)
-        return QStringList();
-
-    // FIXME: Video thread could be affected
-    if (!images.isEmpty())
-        // Delete BE thumbs with high priority to prevent future client
-        // requests from usurping the Delete and using the old thumbs.
-        // Thumb generator now owns the image objects
-        m_imageThumbThread->QueueThumbnails(new ThumbTask("DELETE",
-                                                          images,
-                                                          kPicRequestPriority));
-    if (!dirs.isEmpty())
-        // Clean up thumbdirs as low priority
-        m_imageThumbThread->QueueThumbnails(new ThumbTask("DELETE_DIR", dirs));
-
-    return mesg;
+    if (m_imageThread)
+        m_imageThread->PauseBackground(pause);
+    if (m_videoThread)
+        m_videoThread->PauseBackground(pause);
 }
 
 
-/*!
- \brief Creates thumbnails for new images/dirs detected by scanner
- \param im Image
- \param priority Request priority
-*/
-void ImageThumb::CreateThumbnail(ImageItem *im, ImageThumbPriority priority)
-{
-    ThumbTask *task = new ThumbTask("CREATE", im, priority);
-
-    if (im->m_type == kVideoFile)
-    {
-        if (m_videoThumbThread)
-            m_videoThumbThread->QueueThumbnails(task);
-    }
-    else if (im->m_type == kImageFile)
-    {
-        if (m_imageThumbThread)
-            m_imageThumbThread->QueueThumbnails(task);
-    }
-}
+// Must define the valid template implementations to generate code for the
+// instantiations (as they are defined in the cpp rather than header).
+// Otherwise the linker will fail with undefined references...
+#include "imagemanager.h"
+template class ImageThumb<ImageDbLocal>;
+template class ImageThumb<ImageDbSg>;
diff --git a/mythtv/libs/libmythmetadata/imagethumbs.h b/mythtv/libs/libmythmetadata/imagethumbs.h
index e28e043..0a27df2 100644
--- a/mythtv/libs/libmythmetadata/imagethumbs.h
+++ b/mythtv/libs/libmythmetadata/imagethumbs.h
@@ -1,125 +1,145 @@
 //! \file
-//! \brief Creates and manages thumbnails in the cache
-//! \details Uses two worker threads to process thumbnail requests that are queued.
-//! One for pictures and a one for videos, which are off-loaded to previewgenerator,
-//! and time-consuming. Both background threads are low-priority to avoid recording issues.
-//! Requests are handled by client-assigned priority so that on-demand display requests
-//! are serviced before background pre-generation requests.
+//! \brief Creates and manages thumbnails
+//! \details Uses two worker threads to process thumbnail requests that are queued
+//! from the scanner and UI.
+//! One thread generates picture thumbs; the other video thumbs, which are delegated
+//! to previewgenerator and time-consuming.
+//! Both background threads are low-priority to avoid recording issues.
+//! Requests are handled by client-assigned priority so that UI display requests
+//! are serviced before background scanner requests.
 //! When images are removed, their thumbnails are also deleted (thumbnail cache is
-//! synchronised to database). Obselete thumbnails are broadcast to enable clients to
-//! also manage/synchronise their caches.
+//! synchronised to database). Obsolete images are broadcast to enable clients to
+//! also cleanup/synchronise their caches.
 
-#ifndef IMAGETHUMBGEN_H
-#define IMAGETHUMBGEN_H
+#ifndef IMAGETHUMBS_H
+#define IMAGETHUMBS_H
 
-// Qt headers
-#include <QMutex>
-#include <QList>
 #include <QMap>
-#include <QDir>
-#include <QImage>
-
-// MythTV headers
-#include <mthread.h>
-#include <imageutils.h>
+#include <QMutex>
+#include <QWaitCondition>
 
+#include "imagetypes.h"
+#include "mthread.h"
 
 //! \brief Priority of a thumbnail request. First/lowest are handled before later/higher
 //! \details Ordered to optimise perceived client performance, ie. pictures will be
 //! displayed before directories (4 thumbnails), then videos (slow to generate) are filled
 //! in last.
-typedef enum priorities {
-    kPicRequestPriority    = 0, //!< Client request to display an image thumbnail
-    kFolderRequestPriority = 1, //!< Client request to display a directory thumbnail
-    kVideoRequestPriority  = 2, //!< Client request to display a video preview
-    kScannerUrgentPriority = 3, //!< Scanner request needed to complete a scan
-    kBackgroundPriority    = 4  //!< Scanner background request
-} ImageThumbPriority;
+enum ImageThumbPriority {
+    kUrgentPriority     = -10, //!< Scanner request needed to complete a scan
+    kPicRequestPriority =  -7, //!< Client request to display an image thumbnail
+    kDirRequestPriority =  -3, //!< Client request to display a directory thumbnail
+    kBackgroundPriority =   0  //!< Scanner background request
+};
 
 
 //! A generator request that is queued
-class META_PUBLIC ThumbTask : public ImageList
+class META_PUBLIC ThumbTask
 {
 public:
-    ThumbTask(const QString &,
-              ImageThumbPriority = kBackgroundPriority, bool = false);
-    ThumbTask(QString, ImageItem*,
-              ImageThumbPriority = kBackgroundPriority, bool = false);
-    ThumbTask(const QString &, ImageMap&,
-              ImageThumbPriority = kBackgroundPriority, bool = false);
-    ThumbTask(QString, ImageList&,
-              ImageThumbPriority = kBackgroundPriority, bool = false);
 
+    /*!
+     \brief Construct request for a single image
+     \param action Request action
+     \param im Image object that will be deleted.
+     \param priority Request priority
+     \param notify If true a 'thumbnail exists' event will be broadcast when done.
+    */
+    ThumbTask(QString action, ImagePtrK im,
+              int priority = kUrgentPriority, bool notify = false)
+        : m_action(action), m_priority(priority), m_notify(notify)
+    { m_images.append(im); }
+
+    /*!
+     \brief Construct request for a list of images/dirs
+     \details Assumes ownership of list contents. Items will be deleted after processing
+     \param action Request action
+     \param list Image objects that will be deleted.
+     \param priority Request priority
+     \param notify If true a 'thumbnail exists' event will be broadcast when done.
+    */
+    ThumbTask(QString action, const ImageListK &list,
+              int priority = kUrgentPriority, bool notify = false)
+        : m_images(list),
+          m_action(action),
+          m_priority(priority),
+          m_notify(notify)      {}
+
+    //! Images for thumbnail task
+    ImageListK m_images;
     //! Request action: Create, delete etc.
     QString m_action;
     //! Request reason/priority
-    ImageThumbPriority m_priority;
+    int m_priority;
     //! If true, a "THUMBNAIL_CREATED" event is broadcast
     bool m_notify;
 };
 
+typedef QSharedPointer<ThumbTask> TaskPtr;
+
 
 //! A generator worker thread
-class META_PUBLIC ThumbThread : public MThread
+template <class DBFS>
+class ThumbThread : public MThread
 {
-  public:
-    ThumbThread(QString name);
+public:
+    ThumbThread(const QString &name, DBFS *const dbfs);
     ~ThumbThread();
 
-    void QueueThumbnails(ThumbTask *);
-    void ClearThumbnails();
-    int GetQueueSize(ImageThumbPriority);
-
-  protected:
-    void run();
     void cancel();
+    void Enqueue(const TaskPtr &task);
+    void AbortDevice(int devId, const QString &action);
+    void PauseBackground(bool pause);
 
-  private:
-    void CreateImageThumbnail(ImageItem *);
-    void CreateVideoThumbnail(ImageItem *);
-    bool RemoveDirContents(QString);
-    void Orientate(ImageItem *im, QImage &image);
+protected:
+    void run();
 
-    //! A queue of generator requests
-    typedef QList<ThumbTask *> ThumbQueue;
+private:
     //! A priority queue where 0 is highest priority
-    QMap<ImageThumbPriority, ThumbQueue *> m_thumbQueue;
-    //! Queue protection
-    QMutex m_mutex;
+    typedef QMultiMap<int, TaskPtr> ThumbQueue;
 
-    //! Storage Group accessor
-    ImageSg *m_sg;
+    QString CreateThumbnail(ImagePtrK im, int thumbPriority);
+    static void RemoveTasks(ThumbQueue &queue, int devId);
 
-    //! Path of backend thumbnail cache
-    QDir m_thumbDir;
-    //! Path of backend temp
-    QDir m_tempDir;
+    DBFS &m_dbfs;               //!< Database/filesystem adapter
+    QWaitCondition m_taskDone;  //! Synchronises completed tasks
+
+    ThumbQueue m_requestQ;   //!< Priority queue of requests
+    ThumbQueue m_backgroundQ;   //!< Priority queue of background tasks
+    bool m_doBackground;       //!< Whether to process background tasks
+    QMutex m_mutex;            //!< Queue protection
 };
 
 
-//! Singleton creating/managing image thumbnails
+template <class DBFS>
 class META_PUBLIC ImageThumb
 {
-  public:
-    static ImageThumb* getInstance();
-
-    void        CreateThumbnail(ImageItem *, ImageThumbPriority);
-    void        HandleCreateThumbnails(QStringList imlist);
-    int         GetQueueSize(ImageThumbPriority);
-    void        ClearAllThumbs();
-    QStringList DeleteThumbs(ImageList, ImageList);
-
-  private:
-    ImageThumb();
+public:
+    ImageThumb(DBFS *const dbfs);
     ~ImageThumb();
 
-    //! Singleton
-    static ImageThumb *m_instance;
-
-    //! Worker thread generating picture thumbnails
-    ThumbThread       *m_imageThumbThread;
-    //! Worker thread generating video previews
-    ThumbThread       *m_videoThumbThread;
+    void    ClearThumbs(int devId, const QString &action);
+    QString DeleteThumbs(const ImageList &images);
+    void    CreateThumbnail(const ImagePtrK &im,
+                            int priority = kBackgroundPriority,
+                            bool notify = false);
+    void    MoveThumbnail(const ImagePtrK &im);
+    void    PauseBackground(bool pause);
+
+private:
+    //! Assign priority to a background task.
+    // Major element = tree depth, so shallow thumbs are created before deep ones
+    // Minor element = id, so thumbs are created in order they were scanned
+    // If not unique, QMultiMap will process later requests before earlier ones
+    int Priority(ImageItemK &im)
+    { return im.m_filePath.count('/') * 1000 + im.m_id; }
+
+    //! Db/filesystem adapter
+    DBFS              &m_dbfs;
+    //! Thread generating picture thumbnails
+    ThumbThread<DBFS> *m_imageThread;
+    //! Thread generating video previews
+    ThumbThread<DBFS> *m_videoThread;
 };
 
-#endif // IMAGETHUMBGEN_H
+#endif // IMAGETHUMBS_H
diff --git a/mythtv/libs/libmythmetadata/imagetypes.h b/mythtv/libs/libmythmetadata/imagetypes.h
new file mode 100644
index 0000000..aee9281
--- /dev/null
+++ b/mythtv/libs/libmythmetadata/imagetypes.h
@@ -0,0 +1,171 @@
+//! \file
+//! \brief Common types used by Gallery
+
+#ifndef IMAGETYPES_H
+#define IMAGETYPES_H
+
+#include <QStringList>
+#include <QSharedPointer>
+
+#include "mythmetaexp.h"
+
+// Define this to log/count creation/deletion of ImageItem heap objects.
+// These are created liberally when processing images and are liable to leak.
+// At idle there should be precisely 1 ImageItem for every image/dir displayed.
+//#define MEMORY_DEBUG active
+#ifdef MEMORY_DEBUG
+#include <QDebug>
+#endif
+
+// Id of the (virtual) Gallery root node
+#define GALLERY_DB_ID 0
+// Id of the Storage Group (Photographs) node
+#define PHOTO_DB_ID 1
+
+
+//! Type of image node
+// We need to use other names to avoid getting coflicts with the videolist.h file
+enum ImageNodeType {
+    kUnknown   = 0, //!< Unprocessable file type
+    kDevice    = 1, //!< Storage Group and local mounted media
+    kCloneDir  = 2, //!< A device sub dir comprised from multiple SG dirs
+    kDirectory = 3, //!< A device sub directory
+    kImageFile = 4, //!< A picture
+    kVideoFile = 5  //!< A video
+};
+
+
+//! Image ordering
+enum ImageSortOrder {
+    kSortByNameAsc     = 1, //!< Name A-Z
+    kSortByNameDesc    = 2, //!< Name Z-A
+    kSortByModTimeAsc  = 3, //!< File modified time Earliest -> Latest
+    kSortByModTimeDesc = 4, //!< File modified time Latest -> Earliest
+    kSortByExtAsc      = 5, //!< Extension A-Z
+    kSortByExtDesc     = 6, //!< Extension Z-A
+    kSortBySizeAsc     = 7, //!< File size Smallest -> Largest
+    kSortBySizeDesc    = 8, //!< File size Largest -> Smallest
+    kSortByDateAsc     = 9, //!< Exif date Earliest -> Latest
+    kSortByDateDesc    = 10 //!< Exif date Latest -> Earliest
+};
+
+
+// Convenience types
+typedef QList<int>                ImageIdList;
+typedef QPair<QString, QString>   StringPair;
+typedef QHash<QString, QString>   NameHash;
+typedef QMap<int, QString>        StringMap;
+typedef QPair<int, QString>       ThumbPair;
+
+
+//! Represents a picture, video or directory
+class META_PUBLIC ImageItem
+{
+public:
+    ImageItem(int id = 0)
+        : m_id(id),
+          m_baseName(""),    m_filePath(""),     m_extension(""),
+          m_device(0),       m_parentId(0),
+          m_type(0),
+          m_modTime(0),      m_size(0),
+          m_date(0),         m_orientation(0),   m_comment(""),
+          m_isHidden(false), m_userThumbnail(0),
+          m_url(""),         m_thumbPath(""),
+          m_dirCount(0),     m_fileCount(0)
+#ifndef MEMORY_DEBUG
+    {}
+#else
+    { qDebug() << QString("Created %1 (%2)").arg(m_id).arg(++GetItemCount()); }
+
+    ~ImageItem()
+    { qDebug() << QString("Deleted %1 (%2)").arg(m_id).arg(--GetItemCount()); }
+
+    // Embeds a static var in header to avoid the need for a cpp
+    static int& GetItemCount() { static int count; return count; }
+#endif
+
+
+    //! Uniquely identifies an image (file/dir). Assigned by Db auto-incremnent
+    //! Remote (Storage Group) images are positive - as in Db.
+    //! Local images are negative - the negated Db id
+    int              m_id;
+
+    // Db File attributes
+    QString          m_baseName;    //!< File/Dir name with extension (no path)
+    QString          m_filePath;    //!< Absolute for local images. Usually SG-relative for remotes
+    QString          m_extension;   //!< Image file extension
+    int              m_device;      //!< Id of media device. Always 0 (SG) for remotes, 1+ for local devices
+    int              m_parentId;    //!< Id of parent dir
+    int              m_type;        //!< Type of node: dir, video etc
+    uint             m_modTime;     //!< Filesystem modified datestamp
+    int              m_size;        //!< Filesize (files only)
+    uint             m_date;        //!< Image creation date, from Exif metadata
+    int              m_orientation; //!< Image orientation
+    QString          m_comment;     //!< User comment, from Exif metadata
+
+    // Db User attributes
+    bool             m_isHidden;      //!< If true, image won't be shown
+    int              m_userThumbnail; //!< Id of thumbnail to use as cover (dirs only)
+
+    // Derived attributes
+    QString          m_url;        //! Myth URL of image (abs filepath for locals)
+    QString          m_thumbPath;  //!< Absolute path of thumbnail
+    QList<ThumbPair> m_thumbNails; //! Id & URLs of thumbnail(s). 1 for a file, 4 for dirs
+    int              m_dirCount;   //!< Number of child sub-dirs (dirs only)
+    int              m_fileCount;  //!< Number of child images (dirs only)
+
+    // Convenience functions
+    bool IsDevice()     const { return m_type == kDevice; }
+    bool IsDirectory()  const { return m_type <= kDirectory; }
+    bool IsFile()       const { return m_type >  kDirectory; }
+    bool IsLocal()      const { return IsLocalId(m_id); }
+
+    //! Determine image type (local/remote) from its id. Root/Gallery is remote
+    static bool    IsLocalId(int id)     { return id < GALLERY_DB_ID; }
+    //! Parents of locals are locals or root
+    static bool    IsLocalParent(int id) { return id <= GALLERY_DB_ID; }
+
+    //! Converts a DB id (positive) to an id of a local image (negative)
+    static int     ToLocalId(int id)     { return -id; }
+    static QString ToLocalId(const QString &id) { return "-" + id; }
+
+    //! Converts local image ids (negative) to Db ids (positive)
+    static int     ToDbId(int id)        { return abs(id); }
+    static QString ToDbId(QString ids)   { return ids.remove("-"); }
+
+
+    /*!
+     \brief Separates list of ids into a list of local ids and a list of remote ids
+     \param ids List of local/remote image ids
+     \return StringPair Pair <CSV of local ids, CSV of remote ids>
+    */
+    static StringPair PartitionIds(const ImageIdList &ids)
+    {
+        QStringList local, remote;
+        foreach(int id, ids)
+        {
+            if (ImageItem::IsLocalId(id))
+                local << QString::number(id);
+            else
+                remote << QString::number(id);
+        }
+        return qMakePair(local.join(","), remote.join(","));
+    }
+
+private:
+    Q_DISABLE_COPY(ImageItem)
+};
+
+// Convenience containers
+typedef QSharedPointer<ImageItem>  ImagePtr;
+typedef QList<ImagePtr>            ImageList;
+typedef QHash<QString, ImagePtr>   ImageHash;
+
+// Read-only images alias
+typedef const ImageItem            ImageItemK;
+typedef QSharedPointer<ImageItemK> ImagePtrK;
+typedef QList<ImagePtrK>           ImageListK;
+
+Q_DECLARE_METATYPE(ImagePtrK)
+
+#endif // IMAGETYPES_H
diff --git a/mythtv/libs/libmythmetadata/imageutils.cpp b/mythtv/libs/libmythmetadata/imageutils.cpp
deleted file mode 100644
index 4b44a89..0000000
--- a/mythtv/libs/libmythmetadata/imageutils.cpp
+++ /dev/null
@@ -1,655 +0,0 @@
-#include "imageutils.h"
-
-#include <QByteArray>
-#include <QMutableListIterator>
-#include <QImageReader>
-
-#include <dbaccess.h>
-#include <mythdirs.h>
-
-
-/**
- *  \brief  Constructor
- */
-ImageItem::ImageItem() :
-    m_id(0),
-    m_name(""),
-    m_path(""),
-    m_parentId(0),
-    m_type(0),
-    m_modTime(0),
-    m_size(0),
-    m_extension(""),
-    m_date(0),
-    m_orientation(0),
-    m_comment(""),
-    m_isHidden(false),
-    m_userThumbnail(0),
-    m_fileName(""),
-    m_thumbPath(""),
-    m_dirCount(0),
-    m_fileCount(0)
-{
-}
-
-
-ImageItem::ImageItem(const ImageItem &im) :
-    m_id(im.m_id),
-    m_name(im.m_name),
-    m_path(im.m_path),
-    m_parentId(im.m_parentId),
-    m_type(im.m_type),
-    m_modTime(im.m_modTime),
-    m_size(im.m_size),
-    m_extension(im.m_extension),
-    m_date(im.m_date),
-    m_orientation(im.m_orientation),
-    m_comment(im.m_comment),
-    m_isHidden(im.m_isHidden),
-    m_userThumbnail(im.m_userThumbnail),
-    m_fileName(im.m_fileName),
-    m_thumbPath(im.m_thumbPath),
-    m_thumbNails(im.m_thumbNails),
-    m_thumbIds(im.m_thumbIds),
-    m_dirCount(im.m_dirCount),
-    m_fileCount(im.m_fileCount)
-{
-}
-
-
-/*!
- * \brief Get path for an image thumbnail
- * \param im The image
- * \return QString Thumbnail path
- */
-QString ImageUtils::ThumbPathOf(ImageItem *im)
-{
-    // Thumbnails of videos are a JPEG snapshot with jpg suffix appended
-    QString ext = im->m_type == kVideoFile ? ".jpg" : "";
-
-    // Create the relative path and filename to the thumbnail image or thumbdir
-    return QString("%1/%2%3").arg(THUMBNAIL_DIR, im->m_fileName, ext);
-}
-
-
-/*!
- \brief Return a timestamp/datestamp for an image or dir
- \details Uses exif timestamp if defined, otherwise file modified date
- \param im Image or dir
- \return QString Exif Timestamp text for images, file modified datestamp text
- for dirs and images with no exif
-*/
-QString ImageUtils::ImageDateOf(ImageItem *im)
-{
-    return im->m_date > 0
-            ? QDateTime::fromTime_t(im->m_date)
-              .toString(Qt::DefaultLocaleShortDate)
-            : QDateTime::fromTime_t(im->m_modTime).date()
-              .toString(Qt::DefaultLocaleShortDate);
-}
-
-
-/*!
- \brief Constructor
-*/
-ImageSg::ImageSg()
-    : m_hostname(gCoreContext->GetMasterHostName()),
-      m_hostport(gCoreContext->GetMasterServerPort())
-{
-    m_sgImages = StorageGroup(IMAGE_STORAGE_GROUP, m_hostname, false);
-}
-
-
-//! Storage Group singleton
-ImageSg* ImageSg::m_instance = NULL;
-
-
-/*!
- \brief Return singleton
- \return ImageSg Images SG object
-*/
-ImageSg* ImageSg::getInstance()
-{
-    if (!m_instance)
-        m_instance = new ImageSg();
-    return m_instance;
-}
-
-
-/*!
- * \brief Get filters for detecting recognised images/videos
- * \details Supported pictures are determined by QImage; supported videos
- * are determined from the mythplayer settings (Video Associations)
- * \sa http://qt-project.org/doc/qt-4.8/qimagereader.html#supportedImageFormats
- * \return QDir A QDir initialised with filters for detecting images/videos
- */
-QDir ImageSg::GetImageFilters()
-{
-    QStringList glob;
-
-    // Determine supported picture formats
-    m_imageFileExt.clear();
-    foreach (const QByteArray &ext, QImageReader::supportedImageFormats())
-    {
-        m_imageFileExt << QString(ext);
-        glob << "*." + ext;
-    }
-
-    // Determine supported video formats
-    m_videoFileExt.clear();
-    const FileAssociations::association_list faList =
-        FileAssociations::getFileAssociation().getList();
-    for (FileAssociations::association_list::const_iterator p =
-             faList.begin(); p != faList.end(); ++p)
-    {
-        if (!p->use_default && p->playcommand == "Internal")
-        {
-            m_videoFileExt << QString(p->extension);
-            glob << "*." + p->extension;
-        }
-    }
-
-    QDir dir;
-
-    // Apply filters to only detect image files
-    dir.setNameFilters(glob);
-    dir.setFilter(QDir::AllDirs | QDir::Files | QDir::Readable |
-                  QDir::NoDotAndDotDot | QDir::NoSymLinks);
-
-    // Sync files before dirs to improve thumb generation response
-    // Order by time (oldest first) - this determines the order thumbs appear
-    dir.setSorting(QDir::DirsLast | QDir::Time | QDir::Reversed);
-
-    return dir;
-}
-
-
-/*!
- * \brief Get paths for a list of images
- * \param images List of images
- * \return ImagePaths Map of image names & their paths
- */
-QString ImageSg::GetFilePath(ImageItem *im)
-{
-    QString path = m_sgImages.FindFile(im->m_fileName);
-    if (path.isEmpty())
-        LOG(VB_FILE, LOG_NOTICE,
-            QString("Image: File %1 not found in Storage Group %2")
-            .arg(im->m_fileName).arg(IMAGE_STORAGE_GROUP));
-    return path;
-}
-
-
-/*!
- \brief Moves images and dirs within the storage group (filesystem)
- \details Uses renaming. Files never move filesystems within the Storage Group
- \param images List of images/dirs to move
- \param parent New parent directory
- \return bool True if at least 1 file was moved
-*/
-bool ImageSg::MoveFiles(ImageList &images, ImageItem *parent)
-{
-    bool changed = false;
-    foreach (const ImageItem * im, images)
-    {
-        // Get SG dir of this file
-        QString sgDir = m_sgImages.FindFileDir(im->m_fileName);
-        if (sgDir.isEmpty())
-        {
-            LOG(VB_FILE, LOG_NOTICE,
-                QString("Image: File %1 not found in Storage Group %2")
-                .arg(im->m_fileName).arg(IMAGE_STORAGE_GROUP));
-            continue;
-        }
-
-        // Use existing fs & name with destination path
-        QString oldPath = QString("%1/%2").arg(sgDir, im->m_fileName);
-        QString newPath = QString("%1/%2/%3").arg(sgDir, parent->m_fileName, im->m_name);
-
-        // Move file
-        if (QFile::rename(oldPath, newPath))
-        {
-            changed = true;
-            LOG(VB_FILE, LOG_DEBUG, QString("Image: Moved %1 -> %2")
-                .arg(oldPath, newPath));
-        }
-        else
-            LOG(VB_FILE, LOG_ERR, QString("Image: Failed to move %1 to %2")
-                .arg(oldPath, newPath));
-    }
-    return changed;
-}
-
-
-/*!
- * \brief Deletes images and dirs from the storage group (filesystem)
- * \details Dirs will only be deleted if empty. Files/dirs that failed
- * to delete will be removed from the list.
- * \param[in,out] images List of images/dirs to delete. On return the files that
- * were successfully deleted.
- */
-void ImageSg::RemoveFiles(ImageList &images)
-{
-    QMutableListIterator<ImageItem *> it(images);
-    it.toBack();
-    while (it.hasPrevious())
-    {
-        ImageItem *im = it.previous();
-
-        // Find file
-        QString absFilename = m_sgImages.FindFile(im->m_fileName);
-
-        if (absFilename.isEmpty())
-        {
-            LOG(VB_FILE, LOG_ERR,
-                QString("Image: File %1 not found in Storage Group %2")
-                .arg(im->m_fileName).arg(IMAGE_STORAGE_GROUP));
-            it.remove();
-            delete im;
-            continue;
-        }
-
-        // Remove file
-        bool ok;
-        if (im->IsFile())
-            ok = QFile::remove(absFilename);
-        else
-        {
-            QDir dir;
-            ok = dir.rmdir(absFilename);
-        }
-        if (!ok)
-        {
-            LOG(VB_FILE, LOG_ERR, QString("Can't delete %1").arg(im->m_fileName));
-            // Remove from list
-            it.remove();
-            delete im;
-        }
-    }
-}
-
-
-// Standard query to be parsed by CreateImage
-const QString dbQuery =
-    "SELECT "
-    "file_id, name, path, dir_id, type, modtime, size, extension, "
-    "date, hidden, orientation, angle, filename FROM gallery_files "
-    "WHERE %1 %2 %3";
-
-
-//! Initialise static constant
-QMap<int, QString> ImageDbReader::InitQueries()
-{
-    QMap<int, QString> map;
-    map.insert(kPicOnly,     QString("type = %1").arg(kImageFile));
-    map.insert(kVideoOnly,   QString("type = %1").arg(kVideoFile));
-    map.insert(kPicAndVideo, QString("type > %1").arg(kSubDirectory));
-    return map;
-}
-
-
-// Db query clauses to distinguish between pictures, videos & dirs
-const QMap<int, QString> ImageDbReader::queryFiles = ImageDbReader::InitQueries();
-const QString ImageDbReader::queryDirs = QString("type <= %1").arg(kSubDirectory);
-
-
-/*!
- * \brief Generate Db query clause for sort order
- * \return QString Db clause
- */
-void ImageDbReader::SetSortOrder(int order)
-{
-    m_order = order;
-
-    // prepare the sorting statement
-    switch (order)
-    {
-        case kSortByNameAsc:
-            m_orderSelector = "ORDER BY name ASC"; break;
-        case kSortByNameDesc:
-            m_orderSelector = "ORDER BY name DESC"; break;
-        case kSortByModTimeAsc:
-            m_orderSelector = "ORDER BY modtime ASC, name ASC"; break;
-        case kSortByModTimeDesc:
-            m_orderSelector = "ORDER BY modtime DESC, name ASC"; break;
-        case kSortByExtAsc:
-            m_orderSelector = "ORDER BY extension ASC, name ASC"; break;
-        case kSortByExtDesc:
-            m_orderSelector = "ORDER BY extension DESC, name ASC"; break;
-        case kSortBySizeAsc:
-            m_orderSelector = "ORDER BY size ASC, name ASC"; break;
-        case kSortBySizeDesc:
-            m_orderSelector = "ORDER BY size DESC, name ASC"; break;
-        case kSortByDateAsc:
-            m_orderSelector = "ORDER BY date ASC, name ASC"; break;
-        case kSortByDateDesc:
-            m_orderSelector = "ORDER BY date DESC, name ASC"; break;
-        case kSortByNone:
-        default:
-            m_orderSelector = "";
-    }
-}
-
-
-/*!
- * \brief Create image metadata
- * \param query Db query result
- * \return ImageItem An image
- */
-ImageItem *ImageDbReader::CreateImage(MSqlQuery &query)
-{
-    ImageItem *im = new ImageItem();
-
-    im->m_id            = query.value(0).toInt();
-    im->m_name          = query.value(1).toString();
-    im->m_path          = query.value(2).toString();
-    im->m_parentId      = query.value(3).toInt();
-    im->m_type          = query.value(4).toInt();
-    im->m_modTime       = query.value(5).toInt();
-    im->m_size          = query.value(6).toInt();
-    im->m_extension     = query.value(7).toString();
-    im->m_date          = query.value(8).toUInt();
-    im->m_isHidden      = query.value(9).toInt();
-    im->m_orientation   = query.value(10).toInt();
-    im->m_userThumbnail = query.value(11).toInt();
-    im->m_comment       = query.value(12).toString();
-    im->m_fileName      =
-        QDir::cleanPath(QDir(im->m_path).filePath(im->m_name));
-
-    im->m_thumbPath = ImageUtils::ThumbPathOf(im);
-
-    return im;
-}
-
-
-/*!
- * \brief Read database images/dirs as list
- * \details Get selected database items (mixed files/dirs) in prescribed order,
- * optionally including currently hidden items.
- * \param[out] images List of images/dirs from Db
- * \param[in] selector Db selection query clause
- * \param[in] showAll If true, all items are extracted. Otherwise only items matching
- * the visibility filter are returned
- * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
- * setting. Otherwise they are in undefined (database) order.
- * \return int Number of items matching query.
- */
-int ImageDbReader::ReadDbItems(ImageList &images, QString selector,
-                               bool showAll, bool ordered)
-{
-    QString   orderSelect  = ordered ? m_orderSelector : "";
-    QString   hiddenSelect = showAll || m_showHidden ? "" : "AND hidden = 0";
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(dbQuery.arg(selector, hiddenSelect, orderSelect));
-    if (!query.exec())
-    {
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-        return 0;
-    }
-
-    while (query.next())
-    {
-        ImageItem *im = CreateImage(query);
-
-        // Initialise image thumbnail
-        if (im->IsFile())
-        {
-            im->m_thumbNails.append(im->m_thumbPath);
-            im->m_thumbIds.append(im->m_id);
-        }
-        images.append(im);
-    }
-    return query.size();
-}
-
-
-/*!
- * \brief Read sub-tree of database images and dirs as lists
- * \details Returns database files and dirs contained in the sub-tree of
- * specific dirs. Optionally ordered and including currently hidden items.
- * \param[out] files List of images within sub-tree
- * \param[out] dirs List of dirs within sub-tree
- * \param[in] idList Comma-separated list of parent dir ids
- * \param[in] showAll If true, all items are extracted. Otherwise only items matching
- * the visibility filter are returned
- * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
- * setting. Otherwise they are in undefined (database) order.
- */
-void ImageDbReader::ReadDbTree(ImageList &files,
-                            ImageList &dirs,
-                            QStringList idList,
-                            bool showAll,
-                            bool ordered)
-{
-    // Load starting files
-    QString ids = idList.join(",");
-    ReadDbFilesById(files, ids, showAll, ordered);
-    ReadDbDirsById(dirs, ids, showAll, ordered);
-
-    // Add all descendants
-    ImageList subdirs;
-    while (!idList.isEmpty())
-    {
-        QString selector =
-            QString("dir_id IN (%1) AND %2").arg(idList.join(","));
-        ReadDbItems(files, selector.arg(queryFiles[m_showType]), showAll, ordered);
-        ReadDbItems(subdirs, selector.arg(queryDirs), showAll, ordered);
-        dirs += subdirs;
-        idList.clear();
-        foreach (const ImageItem * im, subdirs)
-        {
-            if (im->IsDirectory())
-                idList.append(QString::number(im->m_id));
-        }
-        subdirs.clear();
-    }
-}
-
-
-/*!
- * \brief Read database images and dirs as map
- * \details Returns selected database items, separated into files and dirs. Results contain
- * no thumbnails (paths nor urls) and are mapped to item name and thus unordered.
- * \param[out] files Map of image names and metadata from Db
- * \param[out] dirs Map of dir names and metadata from Db
- * \param[in] selector Db selection query
- */
-void ImageDbWriter::ReadDbItems(ImageMap &files, ImageMap &dirs,
-                                const QString &selector)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(dbQuery.arg(selector, "", ""));
-
-    if (!query.exec())
-    {
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-        return;
-    }
-
-    while (query.next())
-    {
-        ImageItem *im = CreateImage(query);
-
-        if (im->IsDirectory())
-            dirs.insert(im->m_fileName, im);
-        else
-            files.insert(im->m_fileName, im);
-    }
-}
-
-
-/*!
- * \brief Clear image database
- * \note Only backends should modify the database
- */
-void ImageDbWriter::ClearDb()
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(QString("TRUNCATE gallery_files;"));
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-}
-
-
-/*!
- * \brief Adds new dir to database.
- * \details Dir should not already exist.
- * \param im Image data for dir
- * \return int Database id for new dir
- * \note Only backends should modify the database
- */
-int ImageDbWriter::InsertDbDirectory(ImageItem &im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("INSERT INTO gallery_files ("
-                  "name, path, dir_id, type, modtime, hidden "
-                  ") VALUES ("
-                  ":NAME, :PATH, :PARENT_ID, :TYPE, :MODTIME, :HIDDEN);");
-    query.bindValue(":NAME", im.m_name);
-    query.bindValue(":PATH", im.m_path);
-    query.bindValue(":PARENT_ID", im.m_parentId);
-    query.bindValue(":TYPE", im.m_type);
-    query.bindValue(":MODTIME", im.m_modTime);
-    query.bindValue(":HIDDEN", im.m_isHidden);
-
-    if (!query.exec())
-        MythDB::DBError("Error inserting, query: ", query);
-
-    return query.lastInsertId().toInt();
-}
-
-
-/*!
- * \brief Updates or creates database image or dir
- * \details Item does not need to pre-exist
- * \sa ImageUtils::InsertDbDirectory
- * \param im Image or dir
- * \return bool False if db update failed
- * \note Only backends should modify the database
- */
-bool ImageDbWriter::UpdateDbFile(ImageItem *im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(QString("REPLACE INTO gallery_files ("
-                          "file_id, name, path, dir_id, type, "
-                          "modtime, size, extension, date, orientation, filename) "
-                          "VALUES ("
-                          ":ID, :NAME, :PATH, :DIR, :TYPE, :MODTIME, "
-                          ":SIZE, :EXT, :DATE, :ORIENT, :COMMENT )"));
-    query.bindValue(":ID", im->m_id);
-    query.bindValue(":NAME", im->m_name);
-    query.bindValue(":PATH", im->m_path.isNull() ? "" : im->m_path);
-    query.bindValue(":DIR", im->m_parentId);
-    query.bindValue(":TYPE", im->m_type);
-    query.bindValue(":MODTIME", im->m_modTime);
-    query.bindValue(":SIZE", im->m_size);
-    query.bindValue(":EXT", im->m_extension);
-    query.bindValue(":DATE", im->m_date);
-    query.bindValue(":ORIENT", im->m_orientation);
-    query.bindValue(":COMMENT", im->m_comment.isNull() ? "" : im->m_comment);
-    // hidden & user thumb will be preserved for existing files
-    // & initialised using db defaults (0/false/not set) for new files
-
-    bool ok = query.exec();
-    if (!ok)
-        MythDB::DBError("Error updating, query: ", query);
-    return ok;
-}
-
-
-/*!
- * \brief Remove images/dirs from database
- * \details Item does not need to exist in db
- * \param imList List of items to delete
- * \return QStringList List of item ids that were successfully removed
- * \note Only backends should modify the database
- */
-QStringList ImageDbWriter::RemoveFromDB(const ImageList imList)
-{
-    QStringList ids;
-    if (!imList.isEmpty())
-    {
-        foreach (const ImageItem * im, imList)
-            ids << QString::number(im->m_id);
-
-        MSqlQuery query(MSqlQuery::InitCon());
-        query.prepare(QString("DELETE IGNORE FROM gallery_files "
-                              "WHERE file_id IN (%2);")
-                      .arg(ids.join(",")));
-
-        if (!query.exec())
-        {
-            MythDB::DBError("Error deleting, query: ", query);
-            return QStringList();
-        }
-    }
-    return ids;
-}
-
-
-/*!
- * \brief Sets hidden status of an image/dir in database
- * \param hide True = hidden, False = unhidden
- * \param ids List of item ids
- * \return bool False if db update failed
- * \note Only backends should modify the database
- */
-bool ImageDbWriter::SetHidden(bool hide, QStringList &ids)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-
-    if (!ids.isEmpty())
-    {
-        query.prepare(QString("UPDATE gallery_files SET "
-                              "hidden = :HIDDEN "
-                              "WHERE file_id IN (%1);").arg(ids.join(",")));
-        query.bindValue(":HIDDEN", hide ? 1 : 0);
-\
-        if (!query.exec())
-        {
-            MythDB::DBError("Error updating, query: ", query);
-            return false;
-        }
-    }
-    return true;
-}
-
-
-/*!
- * \brief Assign the thumbnails to be used for a dir in database
- * \param dir Dir id
- * \param id Image or dir id to use as cover/thumbnail
- * \note Only backends should modify the database
- */
-void ImageDbWriter::SetCover(int dir, int id)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-
-    query.prepare("UPDATE gallery_files SET "
-                  "angle = :COVER "
-                  "WHERE file_id = :DIR");
-    query.bindValue(":COVER", id);
-    query.bindValue(":DIR", dir);
-    \
-    if (!query.exec())
-        MythDB::DBError("Error updating, query: ", query);
-}
-
-
-void ImageDbWriter::SetOrientation(ImageItem *im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-
-    query.prepare("UPDATE gallery_files SET "
-                  "orientation = :ORIENTATION "
-                  "WHERE file_id = :ID");
-    query.bindValue(":ORIENTATION", im->m_orientation);
-    query.bindValue(":ID", im->m_id);
-    \
-    if (!query.exec())
-        MythDB::DBError("Error updating, query: ", query);
-}
-
-
diff --git a/mythtv/libs/libmythmetadata/imageutils.h b/mythtv/libs/libmythmetadata/imageutils.h
deleted file mode 100644
index 1077b4c..0000000
--- a/mythtv/libs/libmythmetadata/imageutils.h
+++ /dev/null
@@ -1,366 +0,0 @@
-//! \file
-//! \brief Provides access to database and storage group files for images
-//! \details Encapsulates (most) database and storage group dependencies
-
-#ifndef IMAGEUTILS_H
-#define IMAGEUTILS_H
-
-// Qt headers
-#include <QDir>
-#include <QMap>
-
-// MythTV headers
-#include <mythcontext.h>
-#include <mythdbcon.h>
-#include <mythmetaexp.h>
-#include <storagegroup.h>
-
-
-// Builtin storage groups
-#define IMAGE_STORAGE_GROUP         "Photographs"
-#define THUMBNAIL_STORAGE_GROUP     "Temp"
-// Filesystem dir used by TEMP SG
-#define TEMP_DIR                    "tmp"
-// Subdir within BE Myth tmp to be used for thumbnails
-#define THUMBNAIL_DIR               IMAGE_STORAGE_GROUP
-
-// Id of the root node representing the Storage Group
-#define ROOT_DB_ID 1
-
-//! Image ordering
-enum ImageSortOrder {
-    kSortByNone        = 0, //!< Undefined order
-    kSortByNameAsc     = 1, //!< Name A-Z
-    kSortByNameDesc    = 2, //!< Name Z-A
-    kSortByModTimeAsc  = 3, //!< File modified time Earliest - Latest
-    kSortByModTimeDesc = 4, //!< File modified time Latest - Earliest
-    kSortByExtAsc      = 5, //!< Extension A-Z
-    kSortByExtDesc     = 6, //!< Extension Z-A
-    kSortBySizeAsc     = 7, //!< File size Smallest - Largest
-    kSortBySizeDesc    = 8, //!< File size Largest - Smallest
-    kSortByDateAsc     = 9, //!< Exif date Earliest - Latest
-    kSortByDateDesc    = 10 //!< Exif date Latest - Earliest
-};
-
-//! Type of image to display
-enum ImageDisplayType {
-    kPicAndVideo = 0, //!< Show Pictures & Videos
-    kPicOnly     = 1, //!< Hide videos
-    kVideoOnly   = 2  //!< Hide pictures
-};
-
-
-//! Type of image node
-// We need to use other names to avoid getting coflicts with the videolist.h file
-enum ImageNodeType {
-    kUnknown        = 0, //!< Shouldn't occur
-    kBaseDirectory  = 1, //!< "Gallery" root node of all images
-    kUpDirectory    = 2, //!< Dir/Parent currently viewed
-    kSubDirectory   = 3, //!< Child sub-dirs
-    kImageFile      = 4, //!< A picture
-    kVideoFile      = 5  //!< A video
-};
-
-
-//! Represents a picture, video or directory
-class META_PUBLIC ImageItem
-{
-public:
-    ImageItem();
-    ImageItem(const ImageItem &);
-
-    // Db key
-    int         m_id;            //!< Uniquely identifies an image or dir. Assigned by db
-
-    // Db File attributes
-    QString     m_name;          //!< File/Dir name (no path)
-    QString     m_path;          //!< Path relative to storage group
-    int         m_parentId;      //!< Id of parent dir
-    int         m_type;          //!< Type of node
-    int         m_modTime;       //!< Filesystem modified datestamp
-    int         m_size;          //!< Filesize (images only)
-    QString     m_extension;     //!< File extension (images only)
-    uint32_t    m_date;          //!< Image creation date, from metadata
-    int         m_orientation;   //!< Camera orientation, from metadata
-    QString     m_comment;       //!< User comment, from metadata
-
-    // Db User attributes
-    bool        m_isHidden;      //!< If true, image won't be shown
-    int         m_userThumbnail; //!< Id of an image/dir to use as thumbnail (dirs only)
-
-    // Derived attributes
-    QString     m_fileName;      //!< File path relative to storage group
-    QString     m_thumbPath;     //!< Path of thumbnail, relative to BE cache
-    QStringList m_thumbNails;    //!< BE URLs to use for thumbnails
-    QList<int>  m_thumbIds;      //!< Image ids corresponding to above thumbnails
-    int         m_dirCount;      //!< Number of child sub-dirs (dirs only)
-    int         m_fileCount;     //!< Number of child images (dirs only)
-
-    bool IsDirectory()  const { return m_type <= kSubDirectory; }
-    bool IsFile()       const { return m_type >  kSubDirectory; }
-};
-
-Q_DECLARE_METATYPE(ImageItem*)
-
-
-// Convenience containers
-typedef QMap<QString, ImageItem *>  ImageMap;
-typedef QList<ImageItem *>          ImageList;
-typedef QList<int>                  ImageIdList;
-
-
-//! General functions
-class META_PUBLIC ImageUtils
-{
-public:
-
-    static QString ThumbPathOf(ImageItem *);
-    static QString ImageDateOf(ImageItem *);
-};
-
-
-//! Wrapped Images Storage Group providing filesystem access
-class META_PUBLIC ImageSg
-{
-public:
-    static ImageSg *getInstance();
-    QDir            GetImageFilters();
-    QString         GetFilePath(ImageItem*);
-    QStringList     GetStorageDirs() { return m_sgImages.GetDirList(); }
-
-    //! Generate URL of a thumbnail
-    QString         GenerateThumbUrl(const QString &path)
-    { return gCoreContext->GenMythURL(m_hostname, m_hostport, path, THUMBNAIL_STORAGE_GROUP);}
-
-    //! Generate URL of an image
-    QString         GenerateUrl(const QString &path)
-    { return gCoreContext->GenMythURL(m_hostname, m_hostport, path, IMAGE_STORAGE_GROUP); }
-
-    //! Determine type from an extension
-    ImageNodeType   GetImageType(const QString &ext)
-    {
-        return m_imageFileExt.contains(ext)
-                ? kImageFile
-                : m_videoFileExt.contains(ext) ? kVideoFile : kUnknown;
-    }
-
-    bool MoveFiles(ImageList &, ImageItem *parent);
-    void RemoveFiles(ImageList &);
-
-    //! Images storage group
-    StorageGroup       m_sgImages;
-
-private:
-    // A singleton as creating SGs is laborious
-    ImageSg();
-    static ImageSg *m_instance;
-    QString         m_hostname, m_hostport;
-
-    //! List of file extensions recognised as pictures
-    QStringList    m_imageFileExt;
-    //! List of file extensions recognised as videos
-    QStringList    m_videoFileExt;
-
-};
-
-
-//! Provides read-only access to image database (for FE/clients).
-//! Returned items are optionally filtered and sorted
-class META_PUBLIC ImageDbReader
-{
-public:
-    ImageDbReader(int order, bool showAll, int showType)
-        : m_showHidden(showAll), m_showType(showType) { SetSortOrder(order); }
-
-    void SetSortOrder(int order);
-    int  GetSortOrder()                 { return m_order; }
-    void SetVisibility(bool showHidden) { m_showHidden = showHidden; }
-    bool GetVisibility()                { return m_showHidden; }
-    void SetType(int showType)          { m_showType = showType; }
-    int  GetType()                      { return m_showType; }
-
-    int ReadDbItems(ImageList &images,
-                    QString selector,
-                    bool showAll = true,
-                    bool ordered = false);
-
-    /*!
-     * \brief Read selected database images/dirs by id
-     * \details Returns database items (mixed files/dirs) selected by id with options
-     * for sort order and including currently hidden items.
-     * \param[out] images List of images/dirs from Db
-     * \param[in] ids Comma-separated list of image ids
-     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
-     * the visibility filter are returned
-     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
-     * setting. Otherwise they are in undefined (database) order.
-     * \param[in] selector Db selection query clause
-     * \return int Number of items matching query.
-     */
-    int ReadDbItemsById(ImageList &images,
-                        const QString &ids,
-                        bool showAll = true,
-                        bool ordered = false,
-                        const QString &selector = "TRUE")
-    {
-        QString idSelector = QString("file_id IN (%1) AND %2").arg(ids, selector);
-        return ReadDbItems(images, idSelector, showAll, ordered);
-    }
-
-    /*!
-     * \brief Read selected database images (no dirs) by id
-     * \details Returns database images selected by id with options
-     * for sort order and including currently hidden items.
-     * \param[out] files List of images from Db
-     * \param[in] ids Comma-separated list of image ids
-     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
-     * the visibility filter are returned
-     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
-     * setting. Otherwise they are in undefined (database) order.
-     * \return int Number of items matching query.
-     */
-    int ReadDbFilesById(ImageList &files,
-                        const QString &ids,
-                        bool showAll = true,
-                        bool ordered = false)
-    { return ReadDbItemsById(files, ids, showAll, ordered, queryFiles[m_showType]); }
-
-    /*!
-     * \brief Read selected database dirs (no images) by id
-     * \details Returns database dirs selected by id with options
-     * for sort order and including currently hidden items.
-     * \param[out] dirs List of dirs from Db
-     * \param[in] ids Comma-separated list of image ids
-     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
-     * the visibility filter are returned
-     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
-     * setting. Otherwise they are in undefined (database) order.
-     * \return int Number of items matching query.
-     */
-    int ReadDbDirsById(ImageList &dirs,
-                       const QString &ids,
-                       bool showAll = true,
-                       bool ordered = false)
-    { return ReadDbItemsById(dirs, ids, showAll, ordered, queryDirs); }
-
-    /*!
-     * \brief Read database images (no dirs) that are children of dirs
-     * \details Returns database images that are direct children of specific dirs with
-     * options for sort order and including currently hidden items.
-     * \param[out] files List of images from Db
-     * \param[in] ids Comma-separated list of parent dir ids
-     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
-     * the visibility filter are returned
-     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
-     * setting. Otherwise they are in undefined (database) order.
-     * \return int Number of items matching query.
-     */
-    int ReadDbChildFiles(ImageList &files,
-                         const QString &ids,
-                         bool showAll = true,
-                         bool ordered = false)
-    {
-        QString selector = QString("dir_id IN (%1) AND %2").arg(ids, queryFiles[m_showType]);
-        return ReadDbItems(files, selector, showAll, ordered);
-    }
-
-    /*!
-     * \brief Read database dirs (no images) that are children of dirs
-     * \details Returns database dirs that are direct sub-directories of specific dirs with
-     * options for sort order and including currently hidden items.
-     * \param[out] dirs List of sub-dirs from Db
-     * \param[in] ids Comma-separated list of parent dir ids
-     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
-     * the visibility filter are returned
-     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
-     * setting. Otherwise they are in undefined (database) order.
-     * \return int Number of items matching query.
-     */
-    int ReadDbChildDirs(ImageList &dirs,
-                        const QString &ids,
-                        bool showAll = true,
-                        bool ordered = false)
-    {
-        QString selector = QString("dir_id IN (%1) AND %2").arg(ids, queryDirs);
-        return ReadDbItems(dirs, selector, showAll, ordered);
-    }
-
-    void ReadDbTree(ImageList &files,
-                    ImageList &dirs,
-                    QStringList ids,
-                    bool showAll = true,
-                    bool ordered = false);
-
-protected:
-    ImageItem *CreateImage(MSqlQuery &query);
-
-    //! Db query clauses to distinguish between images & dirs
-    static const QString queryDirs;
-    static const QMap<int, QString> queryFiles;
-    static QMap<int, QString> InitQueries();
-
-    //! Filter for hidden files
-    bool m_showHidden;
-    //! Filter for pictures/videos
-    int m_showType;
-    //! Sort order for returned items
-    int m_order;
-    //! SQL clause for sort order
-    QString m_orderSelector;
-};
-
-
-//! Provides read-write access to image database (for backends only).
-//! Returned items are not filtered or sorted
-class META_PUBLIC ImageDbWriter : private ImageDbReader
-{
-public:
-
-    ImageDbWriter() : ImageDbReader(kSortByNone, true, kPicAndVideo) {}
-
-    void ReadDbItems(ImageMap &files,
-                     ImageMap &dirs,
-                     const QString &selector = "TRUE");
-
-    //! \sa ImageDbReader::ReadDbItems
-    int ReadDbItems(ImageList &images, const QString &selector)
-    { return ImageDbReader::ReadDbItems(images, selector, true, false); }
-
-    //! \sa ImageDbReader::ReadDbItemsById
-    int ReadDbItemsById(ImageList &images,
-                        const QString &ids,
-                        const QString &selector = "TRUE")
-    { return ReadDbItems(images, QString("file_id IN (%1) AND %2").arg(ids, selector)); }
-
-    //! \sa ImageDbReader::ReadDbFilesById
-    int ReadDbFilesById(ImageList &files, const QString &ids)
-    { return ReadDbItemsById(files, ids, queryFiles[kPicAndVideo]); }
-
-    //! \sa ImageDbReader::ReadDbDirsById
-    int ReadDbDirsById(ImageList &dirs, const QString &ids)
-    { return ReadDbItemsById(dirs, ids, queryDirs); }
-
-    //! \sa ImageDbReader::ReadDbChildFiles
-    int ReadDbChildFiles(ImageList &files, const QString &ids)
-    { return ImageDbReader::ReadDbChildFiles(files, ids, true, false); }
-
-    //! \sa ImageDbReader::ReadDbChildDirs
-    int ReadDbChildDirs(ImageList &dirs, const QString &ids)
-    { return ImageDbReader::ReadDbChildDirs(dirs, ids, true, false); }
-
-    //! \sa ImageDbReader::ReadDbTree
-    void ReadDbTree(ImageList &files,
-                    ImageList &dirs,
-                    QStringList ids)
-    { ImageDbReader::ReadDbTree(files, dirs, ids, true, false); }
-
-    void        ClearDb();
-    int         InsertDbDirectory(ImageItem &);
-    bool        UpdateDbFile(ImageItem *);
-    QStringList RemoveFromDB(const ImageList);
-    bool        SetHidden(bool hide, QStringList &);
-    void        SetCover(int dir, int id);
-    void        SetOrientation(ImageItem *im);
-};
-
-#endif // IMAGEUTILS_H
diff --git a/mythtv/libs/libmythmetadata/libmythmetadata.pro b/mythtv/libs/libmythmetadata/libmythmetadata.pro
index 1a2e8aa..1b22654 100644
--- a/mythtv/libs/libmythmetadata/libmythmetadata.pro
+++ b/mythtv/libs/libmythmetadata/libmythmetadata.pro
@@ -25,8 +25,8 @@ HEADERS += mythuiimageresults.h
 HEADERS += musicmetadata.h musicutils.h metaio.h metaiotaglib.h
 HEADERS += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
 HEADERS += metaiowavpack.h metaioid3.h metaiooggvorbis.h
-HEADERS += imagemetadata.h imageutils.h imagescanner.h
-HEADERS += imagethumbs.h musicfilescanner.h metadatagrabber.h
+HEADERS += imagetypes.h imagemetadata.h imagethumbs.h imagescanner.h imagemanager.h
+HEADERS += musicfilescanner.h metadatagrabber.h
 
 SOURCES += cleanup.cpp  dbaccess.cpp  dirscan.cpp  globals.cpp
 SOURCES += parentalcontrols.cpp  videoscan.cpp  videoutils.cpp
@@ -37,8 +37,8 @@ SOURCES += mythuiimageresults.cpp
 SOURCES += musicmetadata.cpp musicutils.cpp metaio.cpp metaiotaglib.cpp
 SOURCES += metaioflacvorbis.cpp metaioavfcomment.cpp metaiomp4.cpp
 SOURCES += metaiowavpack.cpp metaioid3.cpp metaiooggvorbis.cpp
-SOURCES += imagemetadata.cpp imageutils.cpp imagescanner.cpp
-SOURCES += imagethumbs.cpp musicfilescanner.cpp metadatagrabber.cpp
+SOURCES += imagemetadata.cpp imagethumbs.cpp imagescanner.cpp imagemanager.cpp
+SOURCES += musicfilescanner.cpp metadatagrabber.cpp
 
 INCLUDEPATH += ../libmythbase ../libmythtv
 INCLUDEPATH += ../.. ../ ./ ../libmythui
@@ -92,8 +92,8 @@ inc.files += musicmetadata.h musicutils.h
 inc.files += metaio.h metaiotaglib.h
 inc.files += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
 inc.files += metaiowavpack.h metaioid3.h metaiooggvorbis.h
-inc.files += imagemetadata.h imageutils.h imagescanner.h
-inc.files += imagethumbs.h musicfilescanner.h metadatagrabber.h
+inc.files += imagetypes.h imagemetadata.h imagemanager.h
+inc.files += musicfilescanner.h metadatagrabber.h
 
 INSTALLS += inc
 
diff --git a/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h b/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h
index fab5147..2b6242b 100644
--- a/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h
+++ b/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h
@@ -17,18 +17,12 @@ class SERVICE_PUBLIC ImageMetadataInfo : public QObject
     Q_CLASSINFO( "version"    , "1.00" )
 
     Q_PROPERTY( int             Number      READ Number         WRITE setNumber     )
-//    Q_PROPERTY( QString         Family      READ Family         WRITE setFamily     )
-//    Q_PROPERTY( QString         Group       READ Group          WRITE setGroup      )
     Q_PROPERTY( QString         Tag         READ Tag            WRITE setTag        )
-//    Q_PROPERTY( QString         Key         READ Key            WRITE setKey        )
     Q_PROPERTY( QString         Label       READ Label          WRITE setLabel      )
     Q_PROPERTY( QString         Value       READ Value          WRITE setValue      )
 
     PROPERTYIMP    ( int        , Number       )
-//    PROPERTYIMP    ( QString    , Family       )
-//    PROPERTYIMP    ( QString    , Group        )
     PROPERTYIMP    ( QString    , Tag          )
-//    PROPERTYIMP    ( QString    , Key          )
     PROPERTYIMP    ( QString    , Label        )
     PROPERTYIMP    ( QString    , Value        )
 
@@ -52,10 +46,7 @@ class SERVICE_PUBLIC ImageMetadataInfo : public QObject
         void Copy( const ImageMetadataInfo &src )
         {
             m_Number    = src.m_Number;
-//            m_Family    = src.m_Family;
-//            m_Group     = src.m_Group;
             m_Tag       = src.m_Tag;
-//            m_Key       = src.m_Key;
             m_Label     = src.m_Label;
             m_Value     = src.m_Value;
         }
diff --git a/mythtv/libs/libmythservicecontracts/services/hackimageServices.h b/mythtv/libs/libmythservicecontracts/services/hackimageServices.h
deleted file mode 100644
index e5c08c7..0000000
--- a/mythtv/libs/libmythservicecontracts/services/hackimageServices.h
+++ /dev/null
@@ -1,70 +0,0 @@
-#ifndef IMAGESERVICES_H_
-#define IMAGESERVICES_H_
-
-#include <QFileInfo>
-#include <QStringList>
-
-#include "service.h"
-#include "datacontracts/imageMetadataInfoList.h"
-#include "datacontracts/imageSyncInfo.h"
-
-
-
-class SERVICE_PUBLIC ImageServices : public Service
-{
-    Q_OBJECT
-    Q_CLASSINFO( "version"    , "2.0" )
-//    Q_CLASSINFO( "SetImageInfo_Method",             "POST" )
-    Q_CLASSINFO( "RemoveImageFromDB_Method",        "POST" )
-    Q_CLASSINFO( "RemoveImage_Method",              "POST" )
-    Q_CLASSINFO( "RenameImage_Method",              "POST" )
-    Q_CLASSINFO( "StartSync_Method",                "POST" )
-    Q_CLASSINFO( "StopSync_Method",                 "POST" )
-    Q_CLASSINFO( "CreateThumbnail_Method",          "POST" )
-
-    public:
-
-        // Must call InitializeCustomTypes for each unique
-        // Custom Type used in public slots below.
-        ImageServices( QObject *parent = 0 ) : Service( parent )
-        {
-            // Must call InitializeCustomTypes for each
-            // unique Custom Type used in public slots below.
-            DTC::ImageMetadataInfoList::InitializeCustomTypes();
-            DTC::ImageSyncInfo::InitializeCustomTypes();
-        }
-
-    public slots:
-
-//        virtual bool                        SetImageInfo                ( int   Id,
-//                                                                          const QString &Tag,
-//                                                                          const QString &Value ) = 0;
-
-//        virtual bool                        SetImageInfoByFileName      ( const QString &FileName,
-//                                                                          const QString &Tag,
-//                                                                          const QString &Value ) = 0;
-
-        virtual QString                     GetImageInfo                ( int   Id,
-                                                                          const QString &Tag ) = 0;
-
-//        virtual QString                     GetImageInfoByFileName      ( const QString &FileName,
-//                                                                          const QString &Tag ) = 0;
-
-        virtual DTC::ImageMetadataInfoList* GetImageInfoList            ( int   Id ) = 0;
-
-//        virtual DTC::ImageMetadataInfoList* GetImageInfoListByFileName  ( const QString &FileName ) = 0;
-
-//        virtual bool                        RemoveImageFromDB  ( int   Id ) = 0;
-        virtual bool                        RemoveImage        ( int   Id ) = 0;
-        virtual bool                        RenameImage        ( int Id,
-                                                                 const QString &NewName ) = 0;
-
-        virtual bool                        StartSync          ( void ) = 0;
-        virtual bool                        StopSync           ( void ) = 0;
-        virtual DTC::ImageSyncInfo*         GetSyncStatus      ( void ) = 0;
-
-        virtual bool                        CreateThumbnail    ( int  Id,
-                                                                 bool Recreate) = 0;
-};
-
-#endif
diff --git a/mythtv/libs/libmythservicecontracts/services/imageServices.h b/mythtv/libs/libmythservicecontracts/services/imageServices.h
index 201defb..e0cbc6d 100644
--- a/mythtv/libs/libmythservicecontracts/services/imageServices.h
+++ b/mythtv/libs/libmythservicecontracts/services/imageServices.h
@@ -14,7 +14,6 @@ class SERVICE_PUBLIC ImageServices : public Service
 {
     Q_OBJECT
     Q_CLASSINFO( "version"    , "2.0" )
-    Q_CLASSINFO( "SetImageInfo_Method",             "POST" )
     Q_CLASSINFO( "RemoveImage_Method",              "POST" )
     Q_CLASSINFO( "RenameImage_Method",              "POST" )
     Q_CLASSINFO( "StartSync_Method",                "POST" )
@@ -35,26 +34,13 @@ class SERVICE_PUBLIC ImageServices : public Service
 
     public slots:
 
-        virtual bool                        SetImageInfo                ( int   Id,
-                                                                          const QString &Tag,
-                                                                          const QString &Value ) = 0;
+        virtual QString                     GetImageInfo       ( int   Id,
+                                                                 const QString &Tag ) = 0;
 
-        virtual bool                        SetImageInfoByFileName      ( const QString &FileName,
-                                                                          const QString &Tag,
-                                                                          const QString &Value ) = 0;
-
-        virtual QString                     GetImageInfo                ( int   Id,
-                                                                          const QString &Tag ) = 0;
-
-        virtual QString                     GetImageInfoByFileName      ( const QString &FileName,
-                                                                          const QString &Tag ) = 0;
-
-        virtual DTC::ImageMetadataInfoList* GetImageInfoList            ( int   Id ) = 0;
-
-        virtual DTC::ImageMetadataInfoList* GetImageInfoListByFileName  ( const QString &FileName ) = 0;
+        virtual DTC::ImageMetadataInfoList* GetImageInfoList   ( int   Id ) = 0;
 
         virtual bool                        RemoveImage        ( int   Id ) = 0;
-        virtual bool                        RenameImage        ( int Id,
+        virtual bool                        RenameImage        ( int   Id,
                                                                  const QString &NewName ) = 0;
 
         virtual bool                        StartSync          ( void ) = 0;
diff --git a/mythtv/libs/libmythui/libmythui.pro b/mythtv/libs/libmythui/libmythui.pro
index 3c10b68..afd5b73 100644
--- a/mythtv/libs/libmythui/libmythui.pro
+++ b/mythtv/libs/libmythui/libmythui.pro
@@ -43,7 +43,6 @@ HEADERS += mythuiexp.h mythuisimpletext.h mythuistatetracker.h
 HEADERS += mythuianimation.h mythuiscrollbar.h
 HEADERS += mythnotificationcenter.h mythnotificationcenter_private.h
 HEADERS += mythuicomposite.h mythnotification.h mythuidefines.h
-HEADERS += mythuimultifilebrowser.h
 
 SOURCES  = mythmainwindow.cpp mythpainter.cpp mythimage.cpp mythrect.cpp
 SOURCES += myththemebase.cpp  mythpainter_qimage.cpp mythpainter_yuva.cpp
@@ -64,7 +63,7 @@ SOURCES += mythdisplay.cpp mythuivideo.cpp mythudplistener.cpp
 SOURCES += mythuisimpletext.cpp mythuistatetracker.cpp
 SOURCES += mythuianimation.cpp mythuiscrollbar.cpp
 SOURCES += mythnotificationcenter.cpp mythnotification.cpp
-SOURCES += mythuicomposite.cpp mythuimultifilebrowser.cpp
+SOURCES += mythuicomposite.cpp
 SOURCES += mythuiwebbrowser.cpp
 
 inc.path = $${PREFIX}/include/mythtv/libmythui/
@@ -84,7 +83,6 @@ inc.files += mythuieditbar.h mythuifilebrowser.h mythuivideo.h
 inc.files += mythuiexp.h mythuisimpletext.h mythuiactions.h
 inc.files += mythuistatetracker.h mythuianimation.h mythuiscrollbar.h
 inc.files += mythnotificationcenter.h mythnotification.h mythuicomposite.h
-inc.files += mythuimultifilebrowser.h
 
 INSTALLS += inc
 
diff --git a/mythtv/libs/libmythui/mythuifilebrowser.cpp b/mythtv/libs/libmythui/mythuifilebrowser.cpp
index af690b8..45a37b7 100644
--- a/mythtv/libs/libmythui/mythuifilebrowser.cpp
+++ b/mythtv/libs/libmythui/mythuifilebrowser.cpp
@@ -156,7 +156,7 @@ MythUIFileBrowser::MythUIFileBrowser(MythScreenStack *parent,
         m_backButton(NULL),     m_homeButton(NULL),
         m_previewImage(NULL),   m_infoText(NULL),
         m_filenameText(NULL),   m_fullpathText(NULL),
-        m_retObject(NULL),      m_widgetName("MythFileBrowser")
+        m_retObject(NULL)
 {
     SetPath(startPath);
 
@@ -210,7 +210,7 @@ void MythUIFileBrowser::SetPath(const QString &startPath)
 
 bool MythUIFileBrowser::Create()
 {
-    if (!CopyWindowFromBase(m_widgetName, this))
+    if (!CopyWindowFromBase("MythFileBrowser", this))
         return false;
 
     m_fileList = dynamic_cast<MythUIButtonList *>(GetChild("filelist"));
diff --git a/mythtv/libs/libmythui/mythuifilebrowser.h b/mythtv/libs/libmythui/mythuifilebrowser.h
index 6a83695..7b16822 100644
--- a/mythtv/libs/libmythui/mythuifilebrowser.h
+++ b/mythtv/libs/libmythui/mythuifilebrowser.h
@@ -80,28 +80,28 @@ class MUI_PUBLIC MythUIFileBrowser : public MythScreenType
     MythUIFileBrowser(MythScreenStack *parent, const QString &startPath);
    ~MythUIFileBrowser();
 
-    virtual bool Create(void);
+    bool Create(void);
 
     void SetReturnEvent(QObject *retobject, const QString &resultid);
 
     void SetTypeFilter(QDir::Filters filter) { m_typeFilter = filter; }
     void SetNameFilter(QStringList filter) { m_nameFilter = filter; }
 
-  protected slots:
-    virtual void OKPressed(void);
+  private slots:
+    void OKPressed(void);
     void cancelPressed(void);
-    virtual void backPressed(void);
-    virtual void homePressed(void);
+    void backPressed(void);
+    void homePressed(void);
     void editLostFocus(void);
     void PathSelected(MythUIButtonListItem *item);
-    virtual void PathClicked(MythUIButtonListItem *item);
+    void PathClicked(MythUIButtonListItem *item);
     void LoadPreview(void);
 
-  protected:
+  private:
     void SetPath(const QString &startPath);
     bool GetRemoteFileList(const QString &url, const QString &sgDir,
                            QStringList &list);
-    virtual void updateFileList(void);
+    void updateFileList(void);
     void updateRemoteFileList(void);
     void updateLocalFileList(void);
     void updateSelectedList(void);
@@ -136,7 +136,6 @@ class MUI_PUBLIC MythUIFileBrowser : public MythScreenType
 
     QObject           *m_retObject;
     QString            m_id;
-    QString            m_widgetName;
 };
 
 #endif
diff --git a/mythtv/libs/libmythui/mythuimultifilebrowser.cpp b/mythtv/libs/libmythui/mythuimultifilebrowser.cpp
deleted file mode 100644
index 6c6b4d8..0000000
--- a/mythtv/libs/libmythui/mythuimultifilebrowser.cpp
+++ /dev/null
@@ -1,183 +0,0 @@
-#include "mythuimultifilebrowser.h"
-
-#include <QCoreApplication>
-
-#include <mythlogging.h>
-#include "mythdialogbox.h"
-#include "mythuibuttonlist.h"
-#include "mythuibutton.h"
-#include "mythuitext.h"
-
-
-/*!
- \brief Constructor
- \param parent Parent window
- \param startPath Dir to start browsing
-*/
-MythUIMultiFileBrowser::MythUIMultiFileBrowser(MythScreenStack *parent,
-                                               const QString &startPath)
-    : MythUIFileBrowser(parent, startPath),
-      m_selectButton(NULL),
-      m_clearButton(NULL),
-      m_selectCount(NULL)
-{
-    m_widgetName = "MythMultiFileBrowser";
-}
-
-
-/*!
- \brief Create dialog
- \return bool False if dialog couldn't be created
-*/
-bool MythUIMultiFileBrowser::Create()
-{
-    if (!MythUIFileBrowser::Create())
-        return false;
-
-    // Add selection buttons & selection count
-    m_selectButton = dynamic_cast<MythUIButton *>(GetChild("selectall"));
-    m_clearButton  = dynamic_cast<MythUIButton *>(GetChild("clearall"));
-    m_selectCount  = dynamic_cast<MythUIText *>(GetChild("selectcount"));
-
-    if (!m_selectButton || !m_clearButton)
-    {
-        LOG(VB_GENERAL, LOG_ERR, "MythUIMultiFileBrowser: Your theme is missing"
-            " some UI elements! Bailing out.");
-        return false;
-    }
-
-    connect(m_selectButton, SIGNAL(Clicked()), SLOT(selectPressed()));
-    connect(m_clearButton, SIGNAL(Clicked()), SLOT(clearPressed()));
-
-    return true;
-}
-
-
-/*!
- \brief Selects/deselects a file
- \param item Button clicked
-*/
-void MythUIMultiFileBrowser::PathClicked(MythUIButtonListItem *item)
-{
-    if (!item)
-        return;
-
-    MFileInfo finfo = item->GetData().value<MFileInfo>();
-
-    if (finfo.isFile())
-    {
-        QString name = finfo.absoluteFilePath();
-
-        // toggle selected state
-        if (m_selected.remove(name))
-        {
-            item->setChecked(MythUIButtonListItem::NotChecked);
-        }
-        else
-        {
-            m_selected.insert(name);
-            item->setChecked(MythUIButtonListItem::FullChecked);
-        }
-
-        // Update selection stats
-        if (m_selectCount)
-            m_selectCount->SetText(QString::number(m_selected.size()));
-    }
-
-    if (!finfo.isDir())
-        return;
-
-    // clear selections on every directory change
-    m_selected.clear();
-
-    MythUIFileBrowser::PathClicked(item);
-}
-
-
-/*!
- \brief Handle Back button
-*/
-void MythUIMultiFileBrowser::backPressed()
-{
-    m_selected.clear();
-    MythUIFileBrowser::backPressed();
-}
-
-
-/*!
- \brief Handle Home button
-*/
-void MythUIMultiFileBrowser::homePressed()
-{
-    m_selected.clear();
-    MythUIFileBrowser::homePressed();
-}
-
-
-/*!
- \brief Handle Accept button
-*/
-void MythUIMultiFileBrowser::OKPressed()
-{
-    if (m_retObject)
-    {
-        QStringList selectedPaths = m_selected.toList();
-        DialogCompletionEvent *dce = new DialogCompletionEvent(m_id, 0, "",
-                                                               selectedPaths);
-        QCoreApplication::postEvent(m_retObject, dce);
-    }
-    Close();
-}
-
-
-/*!
- \brief Handle Select All
-*/
-void MythUIMultiFileBrowser::selectPressed()
-{
-    // Select all files
-    for (int i=0; i < m_fileList->GetCount(); ++i)
-    {
-        MythUIButtonListItem *btn = m_fileList->GetItemAt(i);
-        MFileInfo finfo = btn->GetData().value<MFileInfo>();
-
-        if (finfo.isFile())
-            m_selected.insert(finfo.absoluteFilePath());
-    }
-
-    updateFileList();
-}
-
-
-/*!
- \brief Handle Clear button
-*/
-void MythUIMultiFileBrowser::clearPressed()
-{
-    m_selected.clear();
-    updateFileList();
-}
-
-
-/*!
- \brief Populates dialog
-*/
-void MythUIMultiFileBrowser::updateFileList()
-{
-    MythUIFileBrowser::updateFileList();
-
-    // Make buttonlist checkable & set selections
-    for (int i=0; i < m_fileList->GetCount(); ++i)
-    {
-        MythUIButtonListItem *btn = m_fileList->GetItemAt(i);
-        MFileInfo finfo = btn->GetData().value<MFileInfo>();
-        btn->setCheckable(true);
-        bool marked = m_selected.contains(finfo.absoluteFilePath());
-        btn->setChecked(marked ? MythUIButtonListItem::FullChecked
-                               : MythUIButtonListItem::NotChecked);
-    }
-
-    // Update selection stats
-    if (m_selectCount)
-        m_selectCount->SetText(QString::number(m_selected.size()));
-}
diff --git a/mythtv/libs/libmythui/mythuimultifilebrowser.h b/mythtv/libs/libmythui/mythuimultifilebrowser.h
deleted file mode 100644
index ad54897..0000000
--- a/mythtv/libs/libmythui/mythuimultifilebrowser.h
+++ /dev/null
@@ -1,38 +0,0 @@
-//! \file
-//! \brief File browser allowing multiple selections
-
-#ifndef MYTHUIMULTIFILEBROWSER_H
-#define MYTHUIMULTIFILEBROWSER_H
-
-#include <QSet>
-
-#include "mythuifilebrowser.h"
-
-
-//! File browser allowing multiple selections
-class MUI_PUBLIC MythUIMultiFileBrowser : public MythUIFileBrowser
-{
-    Q_OBJECT
-public:
-    MythUIMultiFileBrowser(MythScreenStack *parent, const QString &startPath);
-
-    bool Create(void);
-
-protected slots:
-    void OKPressed(void);
-    void backPressed(void);
-    void homePressed(void);
-    void selectPressed(void);
-    void clearPressed(void);
-    void PathClicked(MythUIButtonListItem *item);
-
-protected:
-    void updateFileList(void);
-
-    QSet<QString> m_selected;
-    MythUIButton  *m_selectButton;
-    MythUIButton  *m_clearButton;
-    MythUIText    *m_selectCount;
-};
-
-#endif // MYTHUIMULTIFILEBROWSER_H
diff --git a/mythtv/programs/mythbackend/imagehandlers.cpp b/mythtv/programs/mythbackend/imagehandlers.cpp
deleted file mode 100644
index 48281bc..0000000
--- a/mythtv/programs/mythbackend/imagehandlers.cpp
+++ /dev/null
@@ -1,388 +0,0 @@
-#include "imagehandlers.h"
-
-#include "imageutils.h"
-#include "imagemetadata.h"
-#include "imagescanner.h"
-#include "imagethumbs.h"
-
-
-/*!
- \brief Change name of an image/dir
- \details Renames image/dir in Photographs storage group, synchronises image database
- and thumbnail cache and notifies clients. A new thumbnail will be generated by next client
- request.
- \param id File/dir id
- \param newBase New filename
- \return QStringList Error message or "OK"
-*/
-QStringList ImageHandler::HandleRename(QString id, QString newBase)
-{
-    // Sanity check new name
-    if (newBase.isEmpty() || newBase.contains("/") || newBase.contains("\\"))
-        return QStringList("ERROR") << "Invalid name";
-
-    // Find image in DB
-    ImageDbWriter db;
-    ImageList images, dirs;
-    db.ReadDbItemsById(images, id);
-
-    // Either single id not found or multiple comma-delimited ids received
-    if (images.size() != 1)
-    {
-        LOG(VB_FILE, LOG_NOTICE,
-            QString("Image: Image %1 not found in Db").arg(id));
-        qDeleteAll(images);
-        return QStringList("ERROR") << "Unknown File";
-    }
-
-    // Get filepath for solitary image
-    ImageItem *im = images[0];
-    QString absFilename = ImageSg::getInstance()->GetFilePath(im);
-
-    if (absFilename.isEmpty())
-    {
-        delete im;
-        return QStringList("ERROR") << "File not found";
-    }
-
-    // Rename file
-    QFileInfo info = QFileInfo(absFilename);
-    QDir dir = info.absoluteDir();
-    QString newName = im->IsDirectory()
-            ? newBase : QString("%1.%2").arg(newBase, info.suffix());
-
-    if (!dir.rename(im->m_name, newName))
-    {
-        LOG(VB_FILE, LOG_ERR, QString("Image: Rename of %1 -> %2 failed")
-            .arg(im->m_name, newName));
-        delete im;
-        return QStringList("ERROR") << "Rename failed";
-    }
-
-    LOG(VB_FILE, LOG_DEBUG, QString("Image: Renamed %1 -> %2")
-        .arg(im->m_fileName, newName));
-
-    ImageList dummy;
-
-    if (im->IsDirectory())
-    {
-        // Cleanup thumbdir/thumbnails
-        // Thumb generator now owns the image object
-        QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(dummy, images);
-
-        // Notify clients of deleted ids, images, thumbs
-        gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
-
-        // Dir name change affects path of all sub-dirs & files and their thumbs
-        QStringList scan;
-        scan << "IMAGE_SCAN" << "START";
-        return ImageScan::getInstance()->HandleScanRequest(scan);
-    }
-
-    // Retain old image for cleanup
-    ImageItem *newIm = new ImageItem(*im);
-
-    // Update db
-    newIm->m_name = newName;
-    newIm->m_fileName = QDir::cleanPath(QDir(newIm->m_path).filePath(newName));
-    db.UpdateDbFile(newIm);
-    delete newIm;
-
-    // Clean up thumbnail
-    // Thumb generator now owns the images objects
-    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, dummy);
-    // Item is modified, not deleted
-    mesg.swap(0,1);
-
-    // New thumbnail will be created by client request
-
-    // Notify clients of changed image & thumbnail
-    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
-
-    return QStringList("OK");
-}
-
-
-/*!
- \brief Deletes images/dirs
- \details Removes images/dirs from Photographs storage group and image database.
- Dirs will only be deleted if empty. Synchronises thumbnail cache and broadcasts
- a 'db changed' event. Only fails if nothing is deleted.
- \param fileIds Csv list of dir/file ids
- \return QStringList Error message or "OK"
-*/
-QStringList ImageHandler::HandleDelete(QString fileIds)
-{
-    // Get subtree of files
-    ImageDbWriter db;
-    ImageList images, dirs;
-    db.ReadDbTree(images, dirs, fileIds.split(","));
-
-    // Remove files from filesystem first
-    ImageSg::getInstance()->RemoveFiles(images);
-    // ... then dirs, which should now be empty
-    ImageSg::getInstance()->RemoveFiles(dirs);
-
-    // Fail if nothing deleted
-    if (images.isEmpty() && dirs.isEmpty())
-        return QStringList("ERROR") << "Delete failed";
-
-    // Update Db
-    db.RemoveFromDB(images + dirs);
-
-    // Clean up thumbnails & update clients
-    // Thumb generator now owns the image objects
-    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, dirs);
-
-    // Notify clients of deleted ids, images, thumbs
-    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
-
-    return QStringList("OK");
-}
-
-
-/*!
- \brief Gets meta data for an image
- \details Reads exif tags from a picture or FFMPEG video tags
- \param id Image id
- \return QStringList Error message or "OK", seperator,
-list of <tag name><seperator><tag value>.
-Clients must use the embedded seperator to extract the data.
-*/
-QStringList ImageHandler::HandleGetMetadata(QString id)
-{
-    // Find image in DB
-    ImageDbWriter db;
-    ImageList images;
-    db.ReadDbFilesById(images, id);
-
-    // Either single id not found or multiple comma-delimited ids received
-    if (images.size() != 1)
-    {
-        LOG(VB_FILE, LOG_NOTICE,
-            QString("Image: Image %1 not found in Db").arg(id));
-        qDeleteAll(images);
-        return QStringList("ERROR") << "Unknown File";
-    }
-
-    // Read all metadata tags
-    ImageMetaData::TagMap tags;
-    QStringList result;
-
-    if (ImageMetaData::GetMetaData(images[0], tags))
-    {
-        // Each property is described by a pair of <tagvalue> : <taglabel>
-        // Combine label/value using a (hopefully unique) delimiter
-        // to return 1 string per property.
-        const QString seperator = ":|-|:";
-        result << "OK" << seperator;
-
-        foreach (const ImageMetaData::TagPair value, tags)
-        {
-            result.append(QString("%1%2%3")
-                          .arg(value.second).arg(seperator).arg(value.first));
-        }
-    }
-    else
-    {
-        result = QStringList("ERROR") << QString("No metadata");
-    }
-    qDeleteAll(images);
-
-    return result;
-}
-
-
-/*!
- \brief Moves image trees
- \details Moves a list of images/dirs to an existing image dir. Renames files in
- the Photographs storage group and rescans to synchronise db and thumbnail cache
- and update clients. Only fails if nothing is moved.
- \param destId destination dir id
- \param ids Csv list of dir/file ids
- \return QStringList Error message or "OK"
-*/
-QStringList ImageHandler::HandleMove(QString destId, QString ids)
-{
-    // Validate destination
-    ImageList destDir;
-    ImageDbWriter db;
-    db.ReadDbDirsById(destDir, destId);
-
-    // Either single id not found or multiple comma-delimited ids received
-    if (destDir.size() != 1)
-    {
-        LOG(VB_FILE, LOG_ERR,
-            QString("IMAGE_MOVE: Dir %1 not found in Db").arg(destId));
-        qDeleteAll(destDir);
-        return QStringList("ERROR") << "Missing destination";
-    }
-
-    // Get transferees
-    ImageList images;
-    db.ReadDbItemsById(images, ids);
-
-    bool changed = ImageSg::getInstance()->MoveFiles(images, destDir[0]);
-
-    delete destDir[0];
-    qDeleteAll(images);
-
-    if (!changed)
-        return QStringList("ERROR") << "Move failed";
-
-    // Rescan to update Db & clients
-    QStringList scan;
-    scan << "IMAGE_SCAN" << "START";
-    return ImageScan::getInstance()->HandleScanRequest(scan);
-}
-
-
-/*!
- \brief Hides/unhides images/dirs
- \details Updates hidden status in image database and updates clients
- \param hide hide flag: 0 = Show, 1 = Hide
- \param fids Csv list of file/dir ids
- \return QStringList Error message or "OK"
-*/
-QStringList ImageHandler::HandleHide(bool hide, QString fids)
-{
-    // Extract ids
-    QStringList fileIds = fids.split(",", QString::SkipEmptyParts);
-
-    ImageDbWriter db;
-    if (!db.SetHidden(hide, fileIds))
-        return QStringList("ERROR") << "Hide failed";
-
-    LOG(VB_FILE, LOG_DEBUG, QString("Image: Nodes %1 now %2hidden")
-        .arg(fids, hide ? "" : "un"));
-
-    // Send changed ids only (none deleted)
-    QStringList mesg = QStringList("") << fids;
-    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
-
-    return QStringList("OK");
-}
-
-/*!
- \brief Change orientation of pictures by applying a transformation
- \details Updates picture exif and image database, removes obselete thumbnails and
- updates clients. New thumbnails will be generated by client request. Only fails if
- nothing is modified.
- \param transform transformation id,
- \param fileIds Csv list of file ids
- \return QStringList Error message or "OK"
-*/
-QStringList ImageHandler::HandleTransform(int transform, QString fileIds)
-{
-    if (transform < kResetExif || transform > kFlipVertical)
-        return QStringList("ERROR") << "Bad IMAGE_TRANSFORM transform";
-
-    if (fileIds.isEmpty())
-        return QStringList("ERROR") << "Empty IMAGE_TRANSFORM";
-
-    ImageDbWriter db;
-    ImageList images;
-    db.ReadDbFilesById(images, fileIds);
-
-    // Update db
-    foreach (ImageItem *im, images)
-    {
-        if (transform == kResetExif)
-        {
-            ImageMetaData::PopulateMetaValues(im);
-        }
-        else
-        {
-            // Apply transform to this image
-            im->m_orientation = ExifOrientation::Transformed(im->m_orientation,
-                                                             transform);
-        }
-        db.SetOrientation(im);
-    }
-
-    // Clean up thumbnails & update clients
-    // Thumb generator now owns the image objects
-    ImageList noDirs;
-    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, noDirs);
-
-    // Swap ids from 'deleted' to 'changed'
-    mesg.swap(0,1);
-    // Notify clients of changed images, thumbs
-    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
-
-    return QStringList("OK");
-}
-
-/*!
- \brief Creates a new image dirs
- \details Creates dirs in Photographs storage group 'most free' path. Only fails if
- no new dirs are created. Other clients are not notified.
- \param names Csv list of dir names
- \return QStringList Error message or "OK"
-*/
-QStringList ImageHandler::HandleDirs(QStringList names)
-{
-    // Note: Could/should be implemented by RemoteFile
-
-    // Get SG dir
-    QString sgDir = ImageSg::getInstance()->m_sgImages.FindNextDirMostFree();
-    if (sgDir.isEmpty())
-        return QStringList("ERROR") << "Empty Storage Group";
-
-    bool success = false;
-    QDir dir;
-    for (int i = 0; i < names.size(); ++i)
-    {
-        if (dir.mkpath(QString("%1/%2").arg(sgDir, names[i])))
-            success = true;
-        else
-            LOG(VB_FILE, LOG_ERR, QString("Image: Failed to create dir %1")
-                .arg(names[i]));
-    }
-
-    return success ? QStringList("OK")
-                   : QStringList("ERROR") << "Create failed";
-}
-
-/*!
- \brief Updates/resets cover thumbnail for an image dir
- \details Notifies all clients of new cover
- \param dir Directory id
- \param Cover Id of 0 resets dir to use its own thumbnail
- \return QStringList Error message or "OK"
-*/
-QStringList ImageHandler::HandleCover(int dir, int cover)
-{
-    ImageDbWriter db;
-    db.SetCover(dir, cover);
-
-    LOG(VB_FILE, LOG_DEBUG, QString("Image: Cover of %1 is now %2")
-        .arg(dir).arg(cover));
-
-    // Id has changed, nothing deleted
-    QStringList mesg = QStringList("") << QString::number(dir);
-    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
-
-    return QStringList("OK");
-}
-
-/*!
- \brief Updates exclusion list for images
- \details Stores new exclusions setting & rescans. Exclusions is a global setting
- that dictates which files the scanner ignores. However it is set by any client
- (last writer wins). Glob characters * and ? are valid.
- \param exclusions Csv list of exclusion patterns
- \return QStringList Error message or "OK"
-*/
-QStringList ImageHandler::HandleIgnore(QString exclusions)
-{
-    // Save new setting. FE will have already saved it but not cleared the cache
-    gCoreContext->SaveSettingOnHost("GalleryIgnoreFilter", exclusions, NULL);
-
-    // Rescan
-    QStringList scan;
-    scan << "IMAGE_SCAN" << "START";
-    ImageScan *is = ImageScan::getInstance();
-    return is->HandleScanRequest(scan);
-}
-
diff --git a/mythtv/programs/mythbackend/imagehandlers.h b/mythtv/programs/mythbackend/imagehandlers.h
deleted file mode 100644
index ffa7ac6..0000000
--- a/mythtv/programs/mythbackend/imagehandlers.h
+++ /dev/null
@@ -1,25 +0,0 @@
-//! \file
-//! \brief Encapsulates BE
-
-#ifndef IMAGEHANDLERS_H
-#define IMAGEHANDLERS_H
-
-#include <QStringList>
-
-//! Processes BE requests regarding images
-class ImageHandler
-{
-public:
-
-    static QStringList HandleRename(QString, QString);
-    static QStringList HandleDelete(QString);
-    static QStringList HandleGetMetadata(QString);
-    static QStringList HandleMove(QString, QString);
-    static QStringList HandleHide(bool, QString);
-    static QStringList HandleTransform(int, QString);
-    static QStringList HandleDirs(QStringList);
-    static QStringList HandleCover(int, int);
-    static QStringList HandleIgnore(QString);
-};
-
-#endif // IMAGEHANDLERS_H
diff --git a/mythtv/programs/mythbackend/mainserver.cpp b/mythtv/programs/mythbackend/mainserver.cpp
index b76534d..5e13434 100644
--- a/mythtv/programs/mythbackend/mainserver.cpp
+++ b/mythtv/programs/mythbackend/mainserver.cpp
@@ -74,9 +74,7 @@ using namespace std;
 #include "filesysteminfo.h"
 #include "metaio.h"
 #include "musicmetadata.h"
-#include "imagescanner.h"
-#include "imagethumbs.h"
-#include "imagehandlers.h"
+#include "imagemanager.h"
 #include "cardutil.h"
 
 // mythbackend headers
@@ -914,15 +912,29 @@ void MainServer::ProcessRequestWork(MythSocket *sock)
     }
     else if (command == "IMAGE_SCAN")
     {
-        QStringList reply = ImageScan::getInstance()->HandleScanRequest(listline);
+        // Expects command
+        QStringList reply = (listline.size() == 2)
+                ? ImageManagerBe::getInstance()->HandleScanRequest(listline[1])
+                : QStringList("ERROR") << "Bad: " << listline;
+
+        SendResponse(pbs->getSocket(), reply);
+    }
+    else if (command == "IMAGE_COPY")
+    {
+        // Expects at least 1 comma-delimited image definition
+        QStringList reply = (listline.size() >= 2)
+                ? ImageManagerBe::getInstance()->HandleDbCreate(listline.mid(1))
+                : QStringList("ERROR") << "Bad: " << listline;
+
         SendResponse(pbs->getSocket(), reply);
     }
     else if (command == "IMAGE_MOVE")
     {
-        // Expects destination dir id, comma-delimited dir/file ids
-        QStringList reply = (listline.size() == 3)
-                         ? ImageHandler::HandleMove(listline[1], listline[2])
-                         : QStringList("ERROR") << "Bad IMAGE_MOVE";
+        // Expects comma-delimited dir/file ids, path to replace, new path
+        QStringList reply = (listline.size() == 4)
+                ? ImageManagerBe::getInstance()->
+                  HandleDbMove(listline[1], listline[2], listline[3])
+                : QStringList("ERROR") << "Bad: " << listline;
 
         SendResponse(pbs->getSocket(), reply);
     }
@@ -930,8 +942,8 @@ void MainServer::ProcessRequestWork(MythSocket *sock)
     {
         // Expects comma-delimited dir/file ids
         QStringList reply = (listline.size() == 2)
-                ? ImageHandler::HandleDelete(listline[1])
-                : QStringList("ERROR") << "Bad IMAGE_DELETE";
+                ? ImageManagerBe::getInstance()->HandleDelete(listline[1])
+                : QStringList("ERROR") << "Bad: " << listline;
 
         SendResponse(pbs->getSocket(), reply);
     }
@@ -939,8 +951,9 @@ void MainServer::ProcessRequestWork(MythSocket *sock)
     {
         // Expects hide flag, comma-delimited file/dir ids
         QStringList reply = (listline.size() == 3)
-                ? ImageHandler::HandleHide(listline[1].toInt(), listline[2])
-                : QStringList("ERROR") << "Bad IMAGE_HIDE";
+                ? ImageManagerBe::getInstance()->
+                  HandleHide(listline[1].toInt(), listline[2])
+                : QStringList("ERROR") << "Bad: " << listline;
 
         SendResponse(pbs->getSocket(), reply);
     }
@@ -948,8 +961,9 @@ void MainServer::ProcessRequestWork(MythSocket *sock)
     {
         // Expects transformation, write file flag,
         QStringList reply = (listline.size() == 3)
-                ? ImageHandler::HandleTransform(listline[1].toInt(), listline[2])
-                : QStringList("ERROR") << "Bad IMAGE_TRANSFORM";
+                ? ImageManagerBe::getInstance()->
+                  HandleTransform(listline[1].toInt(), listline[2])
+                : QStringList("ERROR") << "Bad: " << listline;
 
         SendResponse(pbs->getSocket(), reply);
     }
@@ -957,17 +971,18 @@ void MainServer::ProcessRequestWork(MythSocket *sock)
     {
         // Expects file/dir id, new basename
         QStringList reply = (listline.size() == 3)
-                ? ImageHandler::HandleRename(listline[1], listline[2])
-                : QStringList("ERROR") << "Bad IMAGE_RENAME";
+                ? ImageManagerBe::getInstance()->HandleRename(listline[1], listline[2])
+                : QStringList("ERROR") << "Bad: " << listline;
 
         SendResponse(pbs->getSocket(), reply);
     }
     else if (command == "IMAGE_CREATE_DIRS")
     {
-        // Expects list of dir names
-        QStringList reply = (listline.size() == 2)
-                ? ImageHandler::HandleDirs(listline[1].split(","))
-                : QStringList("ERROR") << "Bad IMAGE_CREATE_DIRS";
+        // Expects destination path, rescan flag, list of dir names
+        QStringList reply = (listline.size() >= 4)
+                ? ImageManagerBe::getInstance()->
+                  HandleDirs(listline[1], listline[2].toInt(), listline.mid(3))
+                : QStringList("ERROR") << "Bad: " << listline;
 
         SendResponse(pbs->getSocket(), reply);
     }
@@ -975,17 +990,9 @@ void MainServer::ProcessRequestWork(MythSocket *sock)
     {
         // Expects dir id, cover id. Cover id of 0 resets dir to use its own
         QStringList reply = (listline.size() == 3)
-                ? ImageHandler::HandleCover(listline[1].toInt(), listline[2].toInt())
-                : QStringList("ERROR") << "Bad IMAGE_COVER";
-
-        SendResponse(pbs->getSocket(), reply);
-    }
-    else if (command == "IMAGE_GET_METADATA")
-    {
-        // Expects "IMAGE_GET_METADATA", image id
-        QStringList reply = (listline.size() == 2)
-                ? ImageHandler::HandleGetMetadata(listline[1])
-                : QStringList("ERROR") << "Bad IMAGE_GET_METADATA";
+                ? ImageManagerBe::getInstance()->
+                  HandleCover(listline[1].toInt(), listline[2].toInt())
+                : QStringList("ERROR") << "Bad: " << listline;
 
         SendResponse(pbs->getSocket(), reply);
     }
@@ -993,8 +1000,8 @@ void MainServer::ProcessRequestWork(MythSocket *sock)
     {
         // Expects list of exclusion patterns
         QStringList reply = (listline.size() == 2)
-                ? ImageHandler::HandleIgnore(listline[1])
-                : QStringList("ERROR") << "Bad IMAGE_IGNORE";
+                ? ImageManagerBe::getInstance()->HandleIgnore(listline[1])
+                : QStringList("ERROR") << "Bad: " << listline;
 
         SendResponse(pbs->getSocket(), reply);
     }
@@ -1393,7 +1400,10 @@ void MainServer::customEvent(QEvent *e)
             return;
 
         if (me->Message() == "CREATE_THUMBNAILS")
-            ImageThumb::getInstance()->HandleCreateThumbnails(me->ExtraDataList());
+            ImageManagerBe::getInstance()->HandleCreateThumbnails(me->ExtraDataList());
+
+        if (me->Message() == "IMAGE_GET_METADATA")
+            ImageManagerBe::getInstance()->HandleGetMetadata(me->ExtraData());
 
         MythEvent mod_me("");
         if (me->Message().startsWith("MASTER_UPDATE_REC_INFO"))
diff --git a/mythtv/programs/mythbackend/mythbackend.pro b/mythtv/programs/mythbackend/mythbackend.pro
index e6549bb..0e300fc 100644
--- a/mythtv/programs/mythbackend/mythbackend.pro
+++ b/mythtv/programs/mythbackend/mythbackend.pro
@@ -30,7 +30,7 @@ QMAKE_CLEAN += $(TARGET)
 # Input
 HEADERS += autoexpire.h encoderlink.h filetransfer.h httpstatus.h mainserver.h
 HEADERS += playbacksock.h scheduler.h server.h backendhousekeeper.h
-HEADERS += backendutil.h imagehandlers.h
+HEADERS += backendutil.h
 HEADERS += upnpcdstv.h upnpcdsmusic.h upnpcdsvideo.h mediaserver.h
 HEADERS += internetContent.h main_helpers.h backendcontext.h
 HEADERS += httpconfig.h mythsettings.h commandlineparser.h
@@ -48,7 +48,7 @@ HEADERS += services/image.h
 
 SOURCES += autoexpire.cpp encoderlink.cpp filetransfer.cpp httpstatus.cpp
 SOURCES += main.cpp mainserver.cpp playbacksock.cpp scheduler.cpp server.cpp
-SOURCES += backendhousekeeper.cpp backendutil.cpp imagehandlers.cpp
+SOURCES += backendhousekeeper.cpp backendutil.cpp
 SOURCES += upnpcdstv.cpp upnpcdsmusic.cpp upnpcdsvideo.cpp mediaserver.cpp
 SOURCES += internetContent.cpp main_helpers.cpp backendcontext.cpp
 SOURCES += httpconfig.cpp mythsettings.cpp commandlineparser.cpp
diff --git a/mythtv/programs/mythbackend/services/hackimage.cpp b/mythtv/programs/mythbackend/services/hackimage.cpp
deleted file mode 100644
index 8baf2d6..0000000
--- a/mythtv/programs/mythbackend/services/hackimage.cpp
+++ /dev/null
@@ -1,372 +0,0 @@
-//////////////////////////////////////////////////////////////////////////////
-// Program Name: image.cpp
-// Created     : Jul. 27, 2012
-//
-// Copyright (c) 2012 Robert Siebert  <trebor_s@web.de>
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
-//
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <http://www.gnu.org/licenses/>.
-//
-//////////////////////////////////////////////////////////////////////////////
-
-#include <QFile>
-
-//#include "mythcorecontext.h"
-//#include "storagegroup.h"
-
-//#include <imagemetadata.h>
-//#include "imagescanner.h"
-//#include "imagethumbs.h"
-//#include "imageutils.h"
-#include "image.h"
-#include <imagehandlers.h>
-
-//QString Image::GetImage(int id, ImageItem* im, const QString &function)
-//{
-//    QString imageFileName = QString();
-
-//    ImageUtils *iu = ImageUtils::getInstance();
-//    iu->LoadFileFromDB(*im, id);
-
-//    if (im->m_fileName.isEmpty())
-
-//        LOG(VB_GENERAL, LOG_ERR, QString("%1 - Image %2 not found in DB.")
-//            .arg(function)
-//            .arg(id));
-//    else
-//    {
-//        QString sgName = IMAGE_STORAGE_GROUP;
-//        StorageGroup sg = StorageGroup(sgName, gCoreContext->GetHostName());
-//        imageFileName = sg.FindFile(im->m_fileName);
-
-//        if (imageFileName.isEmpty())
-
-//            LOG(VB_GENERAL, LOG_ERR,
-//                QString("%1 - Storage Group file %2 not found for image %3")
-//                .arg(function)
-//                .arg(im->m_fileName)
-//                .arg(id));
-//    }
-//    return imageFileName;
-//}
-
-
-///** \fn     Image::SetImageInfo( int id,
-//                                 const QString &tag,
-//                                 const QString &value )
-// *  \brief  Saves the given value into the exif tag of the filename.
-// *  \param  id The database id of the file
-// *  \param  tag The tag that shall be overwritten
-// *  \param  value The new value
-// *  \return bool True when saving was successful, otherwise false
-// */
-//bool Image::SetImageInfo( int id, const QString &tag, const QString &value )
-//{
-//    ImageItem *im = new ImageItem();
-//    QString fileName = GetImage(id, im, QString("SetImageInfo"));
-//    delete im;
-
-//    if (fileName.isEmpty())
-
-//        return false;
-
-//    // We got the file name from the ID, so use this method
-//    // which does the same but just on a filename basis.
-//    return SetImageInfoByFileName(fileName, tag, value);
-// }
-
-
-
-///** \fn     Image::SetImageInfoByFileName( const QString &fileName,
-//                                           const QString &tag,
-//                                           const QString &value )
-// *  \brief  Saves the given value into the exif tag of the filename.
-// *  \param  fileName The full filename
-// *  \param  tag The tag that shall be overwritten
-// *  \param  value The new value
-// *  \return bool True when saving was successful, otherwise false
-// */
-//bool Image::SetImageInfoByFileName( const QString &fileName,
-//                                    const QString &tag,
-//                                    const QString &value )
-//{
-//    if (!QFile::exists( fileName ))
-//    {
-//        LOG(VB_GENERAL, LOG_ERR, "SetImageInfoByFileName - File does not exist.");
-//        return false;
-//    }
-
-//    if (tag.isEmpty() || value.isEmpty())
-//    {
-//        LOG(VB_GENERAL, LOG_ERR, "SetImageInfoByFileName - Exif tag name or value is missing.");
-//        return false;
-//    }
-
-//    bool ok;
-//    ImageUtils *iu = ImageUtils::getInstance();
-//    iu->SetExifValue(fileName, tag, value, &ok);
-
-//    return false;
-//}
-
-
-
-/**
- *  \brief  Returns the value of the specified metadata tag from the image
-            file. If the filename or metadata do not exist, an empty value is returned.
- *  \param  id The database id of the file
- *  \param  tag The tag name, as per Exif 2.2 standard tag names,
- *          see http://www.exiv2.org/tags.html. For videos the Exif orientation and
- *          datetime tag names are recognised.
- *  \return QString The tag value if successful, otherwise empty
- */
-QString Image::GetImageInfo( int id, const QString &tag )
-{
-    ImageList items;
-    ImageDbWriter db;
-    db.ReadDbFilesById(items, QString::number(id));
-
-    if (items.isEmpty())
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Image %1 not found.")
-            .arg(id));
-        return QString();
-    }
-
-    ImageMetaData::TagMap tags;
-    tags.insert(tag, qMakePair(QString(), QString()));
-
-    if (!ImageMetaData::GetMetaData(items[0], tags))
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Tag %1 not found for image %2.")
-            .arg(tag).arg(id));
-        qDeleteAll(items);
-        return QString();
-    }
-
-    qDeleteAll(items);
-    return tags[tag].first;
-}
-
-
-
-///** \fn     Image::GetImageInfoByFileName( const QString &fileName,
-//                                           const QString &tag )
-// *  \brief  Returns the value of the specified exif tag from the image
-//            file. If the filename or exif tag do not
-//            exist or the tag has no contents, an empty value is returned.
-// *  \param  fileName The full filename
-// *  \param  tag The exif tag
-// *  \return QString The exif tag value if successful, otherwise empty
-// */
-//QString Image::GetImageInfoByFileName( const QString &fileName, const QString &tag )
-//{
-//    if (!QFile::exists( fileName ))
-//    {
-//        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - File does not exist.");
-//        return QString();
-//    }
-
-//    if (tag.isEmpty())
-//    {
-//        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Exif tag name is missing.");
-//        return QString();
-//    }
-
-//    bool ok;
-//    ImageUtils *iu = ImageUtils::getInstance();
-//    QString value = iu->GetExifValue(fileName, tag, &ok);
-
-//    if (!ok)
-//    {
-//        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Could not read exif tag");
-//        return QString();
-//    }
-
-//    return value;
-//    return QString();
-//}
-
-
-
-/**
- *  \brief  Returns all metadata tags
- *  \param  id The database id of the file
- *  \return DTC::ImageMetadataInfoList The list of metadata tags
- */
-DTC::ImageMetadataInfoList* Image::GetImageInfoList( int id )
-{
-    ImageList items;
-    ImageDbWriter db;
-    db.ReadDbFilesById(items, QString::number(id));
-
-    if (items.size() != 1)
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Image %1 not found.")
-            .arg(id));
-        return NULL;
-    }
-
-    ImageItem *im = items[0];
-    ImageMetaData::TagMap tags;
-    if (!ImageMetaData::GetMetaData(im, tags))
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("GetImageInfo - Could not read metadata for %1")
-            .arg(im->m_fileName));
-        return NULL;
-    }
-
-    // This holds the xml data structure from
-    // the returned stringlist with the exif data
-    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
-
-    // Set the general information of the image
-    imInfoList->setCount(tags.size());
-    imInfoList->setFile(im->m_fileName);
-    imInfoList->setPath(im->m_path);
-    imInfoList->setSize(im->m_size);
-    imInfoList->setExtension(im->m_extension);
-
-    // Each property is described by a pair of <tagvalue> : <taglabel>
-    int index = 0;
-    foreach (const QString &key, tags.keys())
-    {
-        DTC::ImageMetadataInfo *imInfo = imInfoList->AddNewImageMetadataInfo();
-
-        imInfo->setNumber( index++);
-        imInfo->setTag(    key);
-        imInfo->setLabel(  tags[key].second);
-        imInfo->setValue(  tags[key].first);
-    }
-
-    return imInfoList;
-}
-
-
-bool Image::RemoveImage( int id )
-{
-    QStringList result = ImageHandler::HandleDelete(QString::number(id));
-    return result[0] == "OK";
-}
-
-
-bool Image::RenameImage( int id, const QString &newName)
-{
-    QStringList result = ImageHandler::HandleRename(QString::number(id),
-                                                         newName);
-    return result[0] == "OK";
-}
-
-
-bool Image::MoveImage(int id, int destinationDir)
-{
-    QStringList result = ImageHandler::HandleMove(QString::number(destinationDir),
-                                                  QString::number(id));
-    return result[0] == "OK";
-}
-
-
-/** \fn     Image::StartSync(void)
- *  \brief  Starts the synchronization of the images with the database
- *  \return bool True if the sync has started, otherwise false
- */
-bool Image::StartSync( void )
-{
-    // TODO
-    // Check that the required image tables exist to avoid
-    // syncing against non existent tables in the database.
-//    if (gCoreContext->GetNumSetting("DBSchemaVer") < 1318)
-//    {
-//        LOG(VB_GENERAL, LOG_INFO,
-//            "Sync cannot start, the required database tables are missing."
-//            "Please upgrade your database schema to at least 1318.");
-//        return false;
-//    }
-
-//    ImageScan *is = ImageScan::getInstance();
-//    if (!is->SyncIsRunning())
-//        is->StartSync();
-
-//    return is->SyncIsRunning();
-    return false;
-}
-
-
-
-/** \fn     Image::StopSync(void)
- *  \brief  Stops the image synchronization if its running
- *  \return bool True if the sync has stopped, otherwise false
- */
-bool Image::StopSync( void )
-{
-    // TODO
-//    ImageScan *is = ImageScan::getInstance();
-//    if (is->SyncIsRunning())
-//        is->StopSync();
-
-//    return is->SyncIsRunning();
-    return false;
-}
-
-
-
-/** \fn     Image::GetSyncStatus(void)
- *  \brief  Returns a list with information if the synchronization is
-            currently running, the already synchronized images and
-            the total amount of images that shall be synchronized.
- *  \return DTC::ImageSyncInfo The status information
- */
-DTC::ImageSyncInfo* Image::GetSyncStatus( void )
-{
-    DTC::ImageSyncInfo *syncInfo = new DTC::ImageSyncInfo();
-
-    // TODO
-//    ImageScan *is = ImageScan::getInstance();
-
-//    LOG(VB_GENERAL, LOG_DEBUG,
-//        QString("Image: Sync status is running: %1, current: %2, total: %3")
-//        .arg(is->SyncIsRunning())
-//        .arg(is->GetCurrent())
-//        .arg(is->GetTotal()));
-
-//    syncInfo->setRunning(is->SyncIsRunning());
-//    syncInfo->setCurrent(is->GetCurrent());
-//    syncInfo->setTotal(is->GetTotal());
-
-    return syncInfo;
-}
-
-bool Image::CreateThumbnail(int id, bool recreate)
-{
-    // TODO
-//    ImageItem *im = new ImageItem();
-//    ImageUtils *iu = ImageUtils::getInstance();
-//    iu->LoadFileFromDB(*im, id);
-
-//    if (im->m_fileName.isEmpty())
-//    {
-//        LOG(VB_GENERAL, LOG_ERR,
-//            QString("CreateThumbnail - Image %1 not found in DB").arg(id));
-//        delete im;
-//        return false;
-//    }
-
-//    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
-//    return thumbGen->AddToThumbnailList(im, recreate);
-    return false;
-}
diff --git a/mythtv/programs/mythbackend/services/hackimage.h b/mythtv/programs/mythbackend/services/hackimage.h
deleted file mode 100644
index 8621504..0000000
--- a/mythtv/programs/mythbackend/services/hackimage.h
+++ /dev/null
@@ -1,208 +0,0 @@
-//////////////////////////////////////////////////////////////////////////////
-// Program Name: image.h
-// Created     : Jul. 27, 2012
-//
-// Copyright (c) 2012 Robert Siebert <trebor_s@web.de>
-//
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or at your option any later version of the LGPL.
-//
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-//
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
-//
-//////////////////////////////////////////////////////////////////////////////
-
-#ifndef IMAGE_H
-#define IMAGE_H
-
-#include <QScriptEngine>
-#include "services/imageServices.h"
-#include "imagemetadata.h"
-
-
-class Image : public ImageServices
-{
-    Q_OBJECT
-
-public:
-    Q_INVOKABLE Image( QObject *parent = 0 ) {}
-
-public:
-    QString                     GetImageInfo       ( int   id,
-                                                     const QString &Tag );
-
-    DTC::ImageMetadataInfoList* GetImageInfoList   ( int   id );
-
-    bool                        RemoveImage        ( int   id );
-
-    bool                        RenameImage        ( int   id,
-                                                     const QString &newName );
-
-    bool                        MoveImage          ( int   id,
-                                                     int   destinationDir);
-
-    bool                        HideImage          ( int   id,
-                                                     bool  show);
-
-    bool                        TransformImage     ( int   id,
-                                                     int   transform);
-
-    bool                        SetCover           ( int   dirId,
-                                                     int   thumbId );
-
-    bool                        CreateDir          ( int   id,
-                                                     const QString &name );
-
-    bool                        SetExclusionList   ( const QString &exclusions );
-
-    bool                        StartSync          ( void );
-    bool                        StopSync           ( void );
-    DTC::ImageSyncInfo*         GetSyncStatus      ( void );
-
-    bool                        CreateThumbnail    ( int   id );
-};
-
-// --------------------------------------------------------------------------
-// The following class wrapper is due to a limitation in Qt Script Engine.  It
-// requires all methods that return pointers to user classes that are derived from
-// QObject actually return QObject* (not the user class *).  If the user class pointer
-// is returned, the script engine treats it as a QVariant and doesn't create a
-// javascript prototype wrapper for it.
-//
-// This class allows us to keep the rich return types in the main API class while
-// offering the script engine a class it can work with.
-//
-// Only API Classes that return custom classes needs to implement these wrappers.
-//
-// We should continue to look for a cleaning solution to this problem.
-// --------------------------------------------------------------------------
-
-class ScriptableImage : public QObject
-{
-    Q_OBJECT
-
-    private:
-
-        Image          m_obj;
-        QScriptEngine *m_pEngine;
-
-    public:
-
-        Q_INVOKABLE ScriptableImage( QScriptEngine *pEngine, QObject *parent = 0 ) : QObject( parent )
-        {
-            m_pEngine = pEngine;
-        }
-
-    public slots:
-
-//        bool SetImageInfo ( int   Id,
-//                            const QString &Tag,
-//                            const QString &Value )
-//        {
-//            SCRIPT_CATCH_EXCEPTION( false,
-//                return m_obj.SetImageInfo( Id, Tag, Value );
-//            )
-//        }
-
-//        bool SetImageInfoByFileName ( const QString &FileName,
-//                                      const QString &Tag,
-//                                      const QString &Value )
-//        {
-//            SCRIPT_CATCH_EXCEPTION( false,
-//                return m_obj.SetImageInfoByFileName( FileName,
-//                                                     Tag,
-//                                                     Value );
-//            )
-//        }
-
-        QString GetImageInfo( int   Id,
-                              const QString &Tag )
-        {
-            SCRIPT_CATCH_EXCEPTION( QString(),
-                return m_obj.GetImageInfo( Id, Tag );
-            )
-        }
-
-//        QString GetImageInfoByFileName( const QString &FileName,
-//                                        const QString &Tag )
-//        {
-//            SCRIPT_CATCH_EXCEPTION( QString(),
-//                return m_obj.GetImageInfoByFileName( FileName, Tag );
-//            )
-//        }
-
-        QObject* GetImageInfoList( int   Id )
-        {
-            SCRIPT_CATCH_EXCEPTION( NULL,
-                return m_obj.GetImageInfoList( Id );
-            )
-        }
-
-//        QObject* GetImageInfoListByFileName ( const QString &FileName )
-//        {
-//            SCRIPT_CATCH_EXCEPTION( NULL,
-//                return m_obj.GetImageInfoListByFileName( FileName );
-//            )
-//        }
-
-//        bool RemoveImageFromDB( int Id )
-//        {
-//            SCRIPT_CATCH_EXCEPTION( false,
-//                return m_obj.RemoveImageFromDB( Id );
-//            )
-//        }
-
-        bool RemoveImage( int Id )
-        {
-            SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.RemoveImage( Id );
-            )
-        }
-
-        bool RenameImage( int   Id,
-                          const QString &NewName )
-        {
-            SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.RenameImage( Id, NewName );
-            )
-        }
-
-        bool StartSync( void )
-        {
-            SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.StartSync();
-            )
-        }
-
-        bool StopSync( void )
-        {
-            SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.StopSync();
-            )
-        }
-
-        QObject* GetSyncStatus( void )
-        {
-            SCRIPT_CATCH_EXCEPTION( NULL,
-                return m_obj.GetSyncStatus();
-            )
-        }
-
-        bool CreateThumbnail    ( int   Id, bool Recreate )
-        {
-            SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.CreateThumbnail( Id, Recreate );
-            )
-        }
-};
-
-Q_SCRIPT_DECLARE_QMETAOBJECT_MYTHTV( ScriptableImage, QObject*)
-
-#endif
diff --git a/mythtv/programs/mythbackend/services/image.cpp b/mythtv/programs/mythbackend/services/image.cpp
index eef2624..f81ac4a 100644
--- a/mythtv/programs/mythbackend/services/image.cpp
+++ b/mythtv/programs/mythbackend/services/image.cpp
@@ -23,104 +23,11 @@
 //
 //////////////////////////////////////////////////////////////////////////////
 
-#include <QFile>
+//#include "mythcorecontext.h"
 
-#include "mythcorecontext.h"
-#include "storagegroup.h"
-
-#include "imagescanner.h"
-#include "imagethumbs.h"
-#include "imagehandlers.h"
-#include "imageutils.h"
 #include "image.h"
 
-QString Image::GetImage(int id, ImageItem* im, const QString &function)
-{
-    QString imageFileName = QString();
-
-    ImageList items;
-    ImageDbWriter db;
-    db.ReadDbFilesById(items, QString::number(id));
-
-    if (items.isEmpty())
-
-        LOG(VB_GENERAL, LOG_ERR, QString("%1 - Image %2 not found in DB.")
-            .arg(function)
-            .arg(id));
-    else
-    {
-        im = items[0];
-        QString sgName = IMAGE_STORAGE_GROUP;
-        StorageGroup sg = StorageGroup(sgName, gCoreContext->GetHostName());
-        imageFileName = sg.FindFile(im->m_fileName);
-
-        if (imageFileName.isEmpty())
-
-            LOG(VB_GENERAL, LOG_ERR,
-                QString("%1 - Storage Group file %2 not found for image %3")
-                .arg(function)
-                .arg(im->m_fileName)
-                .arg(id));
-    }
-    return imageFileName;
-}
-
-/**
- *  \brief  Saves the given value into the exif tag of the filename.
- *  \param  id The database id of the file
- *  \param  tag The tag that shall be overwritten
- *  \param  value The new value
- *  \return bool True when saving was successful, otherwise false
- */
-bool Image::SetImageInfo( int id, const QString &tag, const QString &value )
-{
-    ImageItem *im = new ImageItem();
-    QString fileName = GetImage(id, im, QString("SetImageInfo"));
-    delete im;
-
-    if (fileName.isEmpty())
-
-        return false;
-
-    // We got the file name from the ID, so use this method
-    // which does the same but just on a filename basis.
-    return SetImageInfoByFileName(fileName, tag, value);
- }
-
-
-
-/**
- *  \brief  Saves the given value into the exif tag of the filename.
- *  \param  fileName The full filename
- *  \param  tag The tag that shall be overwritten
- *  \param  value The new value
- *  \return bool True when saving was successful, otherwise false
- */
-bool Image::SetImageInfoByFileName( const QString &fileName,
-                                    const QString &tag,
-                                    const QString &value )
-{
-    if (!QFile::exists( fileName ))
-    {
-        LOG(VB_GENERAL, LOG_ERR, "SetImageInfoByFileName - File does not exist.");
-        return false;
-    }
-
-    if (tag.isEmpty() || value.isEmpty())
-    {
-        LOG(VB_GENERAL, LOG_ERR, "SetImageInfoByFileName - Exif tag name or value is missing.");
-        return false;
-    }
-
-    // FIXME
-//    bool ok;
-//    ImageUtils *iu = ImageUtils::getInstance();
-//    iu->SetExifValue(fileName, tag, value, &ok);
-
-    return false;
-}
-
-
+#define LOC QString("ImageService: ")
 
 /**
  *  \brief  Returns the value of the specified exif tag from the image
@@ -132,68 +39,30 @@ bool Image::SetImageInfoByFileName( const QString &fileName,
  */
 QString Image::GetImageInfo( int id, const QString &tag )
 {
-    ImageList items;
-    ImageDbWriter db;
-    db.ReadDbFilesById(items, QString::number(id));
-
-    if (items.isEmpty())
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Image %1 not found.")
-            .arg(id));
-        return QString();
-    }
-
-    ImageMetaData::TagMap tags;
-    tags.insert(tag, qMakePair(QString(), QString()));
-
-    if (!ImageMetaData::GetMetaData(items[0], tags))
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Tag %1 not found for image %2.")
-            .arg(tag).arg(id));
-        qDeleteAll(items);
-        return QString();
-    }
+//    ImageManagerBe *mgr = ImageManagerBe::getInstance();
 
-    qDeleteAll(items);
-    return tags[tag].first;
-}
-
-
-
-/**
- *  \brief  Returns the value of the specified exif tag from the image
-            file. If the filename or exif tag do not
-            exist or the tag has no contents, an empty value is returned.
- *  \param  fileName The full filename
- *  \param  tag The exif tag
- *  \return QString The exif tag value if successful, otherwise empty
- */
-QString Image::GetImageInfoByFileName( const QString &fileName, const QString &tag )
-{
-    if (!QFile::exists( fileName ))
-    {
-        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - File does not exist.");
-        return QString();
-    }
+//    // Find image in DB
+//    ImageList images;
+//    if (mgr->GetFiles(images, QString::number(id)) != 1)
+//    {
+//        qDeleteAll(images);
+//        LOG(VB_FILE, LOG_NOTICE, LOC + QString("Image %1 not found").arg(id));
+//        return QString();
+//    }
 
-    if (tag.isEmpty())
-    {
-        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Exif tag name is missing.");
-        return QString();
-    }
+//    // Read all metadata tags
+//    ImageAdapterBase::TagMap tags;
+//    tags.insert(tag, qMakePair(QString(), QString()));
 
-    // FIXME
-//    bool ok;
-//    ImageUtils *iu = ImageUtils::getInstance();
-//    QString value = iu->GetExifValue(fileName, tag, &ok);
+//    ImageItem *im = images[0];
+//    bool found = mgr->HandleGetMetadata(id, tags);
+//    delete im;
 
-//    if (!ok)
-    {
-        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Could not read exif tag");
-        return QString();
-    }
+//    if (found)
+//        return tags[tag].first;
 
-//    return value;
+//    LOG(VB_FILE, LOG_DEBUG, LOC + QString("Tag %1 not found for %2").arg(tag).arg(id));
+    return QString();
 }
 
 
@@ -203,115 +72,56 @@ QString Image::GetImageInfoByFileName( const QString &fileName, const QString &t
  *  \param  id The database id of the file
  *  \return DTC::ImageMetadataInfoList The list with all exif values
  */
-DTC::ImageMetadataInfoList* Image::GetImageInfoList( int id )
+DTC::ImageMetadataInfoList* Image::GetImageInfoList(int id)
 {
-    ImageList items;
-    ImageDbWriter db;
-    db.ReadDbFilesById(items, QString::number(id));
+    // This holds the xml data structure from
+    // the returned stringlist with the exif data
+    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
 
-    if (items.size() != 1)
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Image %1 not found.")
-            .arg(id));
-        return NULL;
-    }
+    // Read all metadata tags
+//    ImageManagerBe *mgr = ImageManagerBe::getInstance();
+    QStringList tags; // = mgr->HandleGetMetadata(QString::number(id));
 
-    ImageItem *im = items[0];
-    ImageMetaData::TagMap tags;
-    if (!ImageMetaData::GetMetaData(im, tags))
+    if (tags.size() < 2 || tags[0] != "OK")
     {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("GetImageInfo - Could not read metadata for %1")
-            .arg(im->m_fileName));
-        return NULL;
+        LOG(VB_FILE, LOG_NOTICE, LOC +
+            QString("Image %1 - %2").arg(id).arg(tags.join(",")));
+        return imInfoList;
     }
-
-    // This holds the xml data structure from
-    // the returned stringlist with the exif data
-    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
+    tags.removeFirst();
 
     // Set the general information of the image
     imInfoList->setCount(tags.size());
-    imInfoList->setFile(im->m_fileName);
-    imInfoList->setPath(im->m_path);
-    imInfoList->setSize(im->m_size);
-    imInfoList->setExtension(im->m_extension);
+//    imInfoList->setFile(im->m_filePath);
+//    imInfoList->setPath(im->m_path);
+//    imInfoList->setSize(im->m_size);
+//    imInfoList->setExtension(im->m_extension);
 
-    // Each property is described by a pair of <tagvalue> : <taglabel>
+    // Each string contains a Name<seperator>Label<seperator>Value.
+    QString seperator = tags.takeFirst();
     int index = 0;
-    foreach (const QString &key, tags.keys())
+    foreach (const QString &token, tags)
     {
+        QStringList parts = token.split(seperator);
+        if (parts.size() != 3)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("Bad Metadata received: '%1' (%2)").arg(token, seperator));
+            continue;
+        }
         DTC::ImageMetadataInfo *imInfo = imInfoList->AddNewImageMetadataInfo();
 
-        imInfo->setNumber( index++);
-        imInfo->setTag(    key);
-        imInfo->setLabel(  tags[key].second);
-        imInfo->setValue(  tags[key].first);
-    }
+        imInfo->setNumber(index++);
+        imInfo->setTag(parts[0]);
+        imInfo->setLabel(parts[1]);
+        imInfo->setValue(parts[2]);
 
-    return imInfoList;
-}
-
-
-
-/**
- *  \brief  Returns all values from all available exif tags
- *  \param  fileName The name of the file
- *  \return DTC::ImageMetadataInfoList The list with all exif values
- */
-DTC::ImageMetadataInfoList* Image::GetImageInfoListByFileName( const QString &fileName )
-{
-    if (!QFile::exists(fileName))
-    {
-        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoListByFileName - File does not exist.");
-        return NULL;
-    }
-
-    // FIXME
-    // Read all available exif tag
-    // values from the given image file
-//    ImageUtils *iu = ImageUtils::getInstance();
-//    QList<QStringList> valueList = iu->GetAllExifValues(fileName);
-
-//    if (valueList.size() == 0)
-    {
-        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoListByFileName - Could not read exif tags");
-        return NULL;
+#if DUMP_METADATA_TAGS
+        LOG(VB_FILE, LOG_DEBUG, LOC +
+            QString("Metadata %1 : %2 : '%3'").arg(parts[0], parts[1], parts[2]));
+#endif
     }
-
-//    // This holds the xml data structure from
-//    // the returned stringlist with the exif data
-//    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
-
-//    // Set the general information of the image
-//    QFileInfo fi(fileName);
-//    imInfoList->setCount(valueList.size());
-//    imInfoList->setFile(fi.fileName());
-//    imInfoList->setPath(fi.path());
-//    imInfoList->setSize(fi.size());
-//    imInfoList->setExtension(fi.suffix());
-
-//    // The returned stringlist contents are
-//    // <familyname>, <groupname>, <tagname>, <taglabel>, <value>
-//    // Go through all list items and build the response. Create
-//    // a new tag and add the tagnames below it. Each tagname
-//    // has these children: family, group, name, label, value.
-//    for (int i = 0; i < valueList.size(); ++i)
-//    {
-//        QStringList values = valueList.at(i);
-
-//        DTC::ImageMetadataInfo *imInfo = imInfoList->AddNewImageMetadataInfo();
-
-//        imInfo->setNumber(  i);
-//        imInfo->setFamily(  values.at(0));
-//        imInfo->setGroup(   values.at(1));
-//        imInfo->setTag(     values.at(2));
-//        imInfo->setKey(     values.at(3));
-//        imInfo->setLabel(   values.at(4));
-//        imInfo->setValue(   values.at(5));
-//    }
-
-//    return imInfoList;
+    return imInfoList;
 }
 
 
@@ -323,7 +133,8 @@ DTC::ImageMetadataInfoList* Image::GetImageInfoListByFileName( const QString &fi
 */
 bool Image::RemoveImage( int id )
 {
-    QStringList result = ImageHandler::HandleDelete(QString::number(id));
+    QStringList result = ImageManagerBe::getInstance()->
+            HandleDelete(QString::number(id));
     return result[0] == "OK";
 }
 
@@ -336,8 +147,8 @@ bool Image::RemoveImage( int id )
  */
 bool Image::RenameImage( int id, const QString &newName)
 {
-    QStringList result = ImageHandler::HandleRename(QString::number(id),
-                                                         newName);
+    QStringList result = ImageManagerBe::getInstance()->
+            HandleRename(QString::number(id), newName);
     return result[0] == "OK";
 }
 
@@ -348,10 +159,7 @@ bool Image::RenameImage( int id, const QString &newName)
  */
 bool Image::StartSync( void )
 {
-    QStringList request;
-    request << "IMAGE_SCAN" << "START";
-
-    QStringList result = ImageScan::getInstance()->HandleScanRequest(request);
+    QStringList result = ImageManagerBe::getInstance()->HandleScanRequest("START");
     return result.size() >= 2 && !result[1].isEmpty();
 }
 
@@ -363,10 +171,7 @@ bool Image::StartSync( void )
  */
 bool Image::StopSync( void )
 {
-    QStringList request;
-    request << "IMAGE_SCAN" << "STOP";
-
-    QStringList result = ImageScan::getInstance()->HandleScanRequest(request);
+    QStringList result = ImageManagerBe::getInstance()->HandleScanRequest("STOP");
     return result.size() >= 2 && !result[1].isEmpty();
 }
 
@@ -380,27 +185,28 @@ bool Image::StopSync( void )
  */
 DTC::ImageSyncInfo* Image::GetSyncStatus( void )
 {
-    DTC::ImageSyncInfo *syncInfo = new DTC::ImageSyncInfo();
-
-    QStringList request;
-    request << "IMAGE_SCAN" << "QUERY";
-
-    QStringList result = ImageScan::getInstance()->HandleScanRequest(request);
-
-    if (result.size() < 4 || result[0] != "OK")
+    // Default to No Scan
+    bool running = false;
+    int  current = 0;
+    int  total   = 0;
+
+    // Expects OK, scanner id, current#, total#
+    QStringList result = ImageManagerBe::getInstance()->HandleScanRequest("QUERY");
+    if (result.size() == 4 && result[0] == "OK")
     {
-        // Default to no scan
-        result.clear();
-        result << "ERROR" << "" << "0" << "0";
+        current = result[2].toInt();
+        total   = result[3].toInt();
+        running = (current != total);
     }
 
     LOG(VB_GENERAL, LOG_DEBUG,
         QString("Image: Sync status is running: %1, current: %2, total: %3")
-        .arg(result[1], result[2], result[3]));
+        .arg(running).arg(current).arg(total));
 
-    syncInfo->setRunning(!result[1].isEmpty());
-    syncInfo->setCurrent(result[2].toInt());
-    syncInfo->setTotal(result[3].toInt());
+    DTC::ImageSyncInfo *syncInfo = new DTC::ImageSyncInfo();
+    syncInfo->setRunning(running);
+    syncInfo->setCurrent(current);
+    syncInfo->setTotal(total);
 
     return syncInfo;
 }
@@ -412,17 +218,8 @@ DTC::ImageSyncInfo* Image::GetSyncStatus( void )
 */
 bool Image::CreateThumbnail(int id)
 {
-    ImageList items;
-    ImageDbWriter db;
-    db.ReadDbFilesById(items, QString::number(id));
-
-    if (items.size() != 1)
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("CreateThumbnail: Image %1 not found.")
-            .arg(id));
-        return false;
-    }
-
-    ImageThumb::getInstance()->CreateThumbnail(items[0], kPicRequestPriority);
+    QStringList mesg("0");
+    mesg << QString::number(id);
+    ImageManagerBe::getInstance()->HandleCreateThumbnails(mesg);
     return true;
 }
diff --git a/mythtv/programs/mythbackend/services/image.h b/mythtv/programs/mythbackend/services/image.h
index d47bba7..4bec6d6 100644
--- a/mythtv/programs/mythbackend/services/image.h
+++ b/mythtv/programs/mythbackend/services/image.h
@@ -24,8 +24,7 @@
 
 #include <QScriptEngine>
 #include "services/imageServices.h"
-#include "imageutils.h"
-#include "imagemetadata.h"
+#include "imagemanager.h"
 
 
 class Image : public ImageServices
@@ -36,24 +35,11 @@ public:
     Q_INVOKABLE Image( QObject *parent = 0 ) {}
 
 public:
-    bool                        SetImageInfo                ( int   Id,
-                                                              const QString &Tag,
-                                                              const QString &Value );
-
-    bool                        SetImageInfoByFileName      ( const QString &FileName,
-                                                              const QString &Tag,
-                                                              const QString &Value );
-
     QString                     GetImageInfo                ( int   Id,
                                                               const QString &Tag );
 
-    QString                     GetImageInfoByFileName      ( const QString &FileName,
-                                                              const QString &Tag );
-
     DTC::ImageMetadataInfoList* GetImageInfoList            ( int   Id );
 
-    DTC::ImageMetadataInfoList* GetImageInfoListByFileName  ( const QString &FileName );
-
     bool                        RemoveImage        ( int   Id );
     bool                        RenameImage        ( int   Id,
                                                      const QString &NewName );
@@ -63,8 +49,6 @@ public:
     DTC::ImageSyncInfo*         GetSyncStatus      ( void );
 
     bool                        CreateThumbnail    (int   Id);
-private:
-    QString GetImage(int, ImageItem *, const QString & );
 
 };
 
@@ -101,26 +85,6 @@ class ScriptableImage : public QObject
 
     public slots:
 
-        bool SetImageInfo ( int   Id,
-                            const QString &Tag,
-                            const QString &Value )
-        {
-            SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.SetImageInfo( Id, Tag, Value );
-            )
-        }
-
-        bool SetImageInfoByFileName ( const QString &FileName,
-                                      const QString &Tag,
-                                      const QString &Value )
-        {
-            SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.SetImageInfoByFileName( FileName,
-                                                     Tag,
-                                                     Value );
-            )
-        }
-
         QString GetImageInfo( int   Id,
                               const QString &Tag )
         {
@@ -129,14 +93,6 @@ class ScriptableImage : public QObject
             )
         }
 
-        QString GetImageInfoByFileName( const QString &FileName,
-                                        const QString &Tag )
-        {
-            SCRIPT_CATCH_EXCEPTION( QString(),
-                return m_obj.GetImageInfoByFileName( FileName, Tag );
-            )
-        }
-
         QObject* GetImageInfoList( int   Id )
         {
             SCRIPT_CATCH_EXCEPTION( NULL,
@@ -144,13 +100,6 @@ class ScriptableImage : public QObject
             )
         }
 
-        QObject* GetImageInfoListByFileName ( const QString &FileName )
-        {
-            SCRIPT_CATCH_EXCEPTION( NULL,
-                return m_obj.GetImageInfoListByFileName( FileName );
-            )
-        }
-
         bool RemoveImage( int Id )
         {
             SCRIPT_CATCH_EXCEPTION( false,
diff --git a/mythtv/programs/mythfrontend/gallerycommhelper.cpp b/mythtv/programs/mythfrontend/gallerycommhelper.cpp
deleted file mode 100644
index 08a242a..0000000
--- a/mythtv/programs/mythfrontend/gallerycommhelper.cpp
+++ /dev/null
@@ -1,358 +0,0 @@
-#include "gallerycommhelper.h"
-
-#include <unistd.h> // for usleep
-
-#include <QApplication>
-
-#include <mythsystemlegacy.h>
-#include <remotefile.h>
-
-
-/*!
- * \brief Request BE to start/stop synchronising the image db to the storage group
- * \param start Start scan, if true. Otherwise stop scan
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::ScanImagesAction(bool start)
-{
-    QStringList strList;
-    strList << "IMAGE_SCAN" << (start ? "START" : "STOP");
-
-    bool ok = gCoreContext->SendReceiveStringList(strList, true);
-    return ok ? "" : strList[1];
-}
-
-
-/*!
- * \brief Returns BE scan status
- * \return QStringList State ("ERROR" | "OK"), Mode ("SCANNING" | ""),
- * Progress count, Total
- */
-QStringList GalleryBERequest::ScanQuery()
-{
-    QStringList strList;
-    strList << "IMAGE_SCAN" << "QUERY";
-
-    if (!gCoreContext->SendReceiveStringList(strList))
-    {
-        LOG(VB_GENERAL, LOG_ERR, QString("Image: Scan query failed : %1")
-            .arg(strList.join(",")));
-
-        // Default to no scan
-        strList.clear();
-        strList << "ERROR" << "" << "0" << "0";
-    }
-    return strList;
-}
-
-
-/*!
- * \brief Request BE to clear image db
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::ClearDatabase()
-{
-    QStringList strList;
-    strList << "IMAGE_SCAN" << "CLEAR";
-
-    bool ok = gCoreContext->SendReceiveStringList(strList, true);
-    return ok ? "" : strList[1];
-}
-
-
-/*!
- * \brief Request BE to create thumbnails for images
- * \param ids List of image ids
- * \param isForFolder Set if images are for a directory cover, which are generated
- * after images
- */
-void GalleryBERequest::CreateThumbnails(QStringList ids, bool isForFolder)
-{
-    LOG(VB_FILE, LOG_DEBUG, QString("Image: Sending CREATE_THUMBNAILS %1 (forFolder %2)")
-        .arg(ids.join(",")).arg(isForFolder));
-
-    QStringList message;
-    message << ids.join(",") << QString::number(isForFolder);
-    gCoreContext->SendEvent(MythEvent("CREATE_THUMBNAILS", message));
-}
-
-
-/*!
- * \brief Request BE to hide/unhide images
- * \param hidden Hide | unhide
- * \param ids List of image ids
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::HideFiles(bool hidden, ImageIdList ids)
-{
-    if (ids.isEmpty())
-        return "Bad Hide Request";
-
-    QStringList idents;
-    foreach (int id, ids)
-    {
-        idents.append(QString::number(id));
-    }
-
-    QStringList message;
-    message << "IMAGE_HIDE" << QString::number(hidden) << idents.join(",");
-
-    bool ok = gCoreContext->SendReceiveStringList(message, true);
-    return ok ? "" : message[1];
-}
-
-
-/*!
- * \brief Request BE to rename an image
- * \param  id An image id
- * \param  name New name of the file (only the filename, no path)
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::RenameFile(int id, QString name)
-{
-    QStringList message;
-    message << "IMAGE_RENAME" << QString::number(id) << name;
-
-    bool ok = gCoreContext->SendReceiveStringList(message, true);
-    return ok ? "" : message[1];
-}
-
-
-/*!
- * \brief Request BE to delete images
- * \param  ids List of image ids
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::RemoveFiles(ImageIdList ids)
-{
-    QStringList idents;
-    foreach (int id, ids)
-    {
-        idents.append(QString::number(id));
-    }
-
-    QStringList message;
-    message << "IMAGE_DELETE" << idents.join(",");
-
-    bool ok = gCoreContext->SendReceiveStringList(message, true);
-    return ok ? "" : message[1];
-}
-
-
-/*!
- * \brief Request BE to apply an orientation transform to images
- * \param  transform Transformation to apply
- * \param  ids List of image ids
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::ChangeOrientation(ImageFileTransform transform,
-                                            ImageIdList ids)
-{
-    QStringList idents;
-    foreach (int id, ids)
-    {
-        idents.append(QString::number(id));
-    }
-
-    QStringList message;
-    message << "IMAGE_TRANSFORM"
-         << QString::number(transform)
-         << idents.join(",");
-
-    bool ok = gCoreContext->SendReceiveStringList(message, true);
-    return ok ? "" : message[1];
-}
-
-
-/*!
- * \brief Request BE to set image to use as a cover thumbnail(s)
- * \param  parent Directory id
- * \param  to Image to use as cover
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::SetCover(int parent, int to)
-{
-    QStringList message;
-    message << "IMAGE_COVER"
-         << QString::number(parent)
-         << QString::number(to);
-
-    bool ok = gCoreContext->SendReceiveStringList(message, true);
-    return ok ? "" : message[1];
-}
-
-
-/*!
- * \brief Returns all exif tags and values from an image
- * \param  im An image
- * \return QString Error message, if not empty
- */
-NameMap GalleryBERequest::GetMetaData(const ImageItem *im)
-{
-    QMap<QString, QString> tags;
-    QStringList            strlist;
-    strlist << "IMAGE_GET_METADATA"
-            << QString::number(im->m_id);
-
-    if (gCoreContext->SendReceiveStringList(strlist))
-    {
-        // Each string contains a Label<seperator>Value
-        QString seperator = strlist[1];
-        for (int i = 2; i < strlist.size(); ++i)
-        {
-            QStringList parts = strlist[i].split(seperator);
-
-            LOG(VB_FILE, LOG_DEBUG,
-                QString("Image: Metadata %1 : %2").arg(parts[0], parts[1]));
-
-            tags.insert(parts[0], parts[1]);
-        }
-    }
-    return tags;
-}
-
-
-/*!
- * \brief Moves images to an image directory
- * \param destination Id of an image directory
- * \param ids Ids of images/dirs to move
- * \return QString Error message
- */
-QString GalleryBERequest::MoveFiles(int destination, ImageIdList ids)
-{
-    QStringList idents;
-    foreach (int id, ids)
-    {
-        idents.append(QString::number(id));
-    }
-
-    QStringList message("IMAGE_MOVE");
-    message << QString::number(destination) << idents.join(",");
-
-    bool ok = gCoreContext->SendReceiveStringList(message, true);
-    return ok ? "" : message[1];
-}
-
-
-/*!
- * \brief Create directories
- * \param names List of directory paths
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::MakeDirs(QStringList names)
-{
-    names.insert(0, "IMAGE_CREATE_DIRS");
-
-    bool ok = gCoreContext->SendReceiveStringList(names, true);
-    return ok ? "" : names[1];
-}
-
-
-/*!
- * \brief Set directories to ignore during scan & rescan
- * \param excludes Comma separated list of dir names/patterns to exclude. Glob
- * characters * and ? permitted.
- * \return QString Error message, if not empty
- */
-QString GalleryBERequest::IgnoreDirs(QString excludes)
-{
-    QStringList message("IMAGE_IGNORE");
-    message << excludes;
-
-    bool ok = gCoreContext->SendReceiveStringList(message, true);
-    return ok ? "" : message[1];
-}
-
-
-int RunWorker(WorkerThread *worker)
-{
-    worker->start();
-
-    // Wait for worker to complete
-    while (!worker->isFinished())
-    {
-        usleep(1000);
-        qApp->processEvents();
-    }
-
-    int result = worker->GetResult();
-    delete worker;
-
-    return result;
-}
-
-
-void ShellWorker::run()
-{
-    RunProlog();
-    LOG(VB_GENERAL, LOG_INFO, QString("Image: Executing \"%1\"").arg(m_command));
-    m_result = myth_system(m_command);
-    RunEpilog();
-}
-
-
-/*!
- * \brief Thread worker to copy/move files
- * \param deleteAfter Remove original file after copy, if set
- * \param files Map of source/destination filepaths
- * \param dialog Dialog that reflects progress
- */
-FileTransferWorker::FileTransferWorker(bool deleteAfter, NameMap files,
-                                       MythUIProgressDialog *dialog)
-    : WorkerThread("FileTransfer"),
-    m_delete(deleteAfter),
-    m_files(files),
-    m_dialog(dialog)
-{
-}
-
-
-void FileTransferWorker::run()
-{
-    RunProlog();
-
-    uint total    = m_files.size();
-    uint progress = 0;
-    m_result = 0;
-    QString action = m_delete ? tr("Moving %1") : tr("Copying %1");
-
-    foreach (const QString &src, m_files.keys())
-    {
-        // Update progress dialog
-        if (m_dialog)
-        {
-            QFileInfo            fi(src);
-            int size = fi.size() / 1024;
-            QString message = action.arg(fi.fileName())
-                    + (size > 0 ? QString(" (%2 Kb)").arg(size) : "");
-            ProgressUpdateEvent *pue     =
-                new ProgressUpdateEvent(++progress, total, message);
-
-            QApplication::postEvent(m_dialog, pue);
-        }
-
-        LOG(VB_FILE, LOG_INFO, action.arg(src) + QString(" -> %1").arg(m_files[src]));
-
-        // Copy file
-        if (RemoteFile::CopyFile(src, m_files[src]))
-        {
-            ++m_result;
-            if (m_delete)
-            {
-                // Delete source file
-                QFile file(src);
-                if (!file.remove())
-                    LOG(VB_FILE, LOG_ERR, QString("Image: Failed to delete %1")
-                        .arg(src));
-            }
-        }
-        else
-            LOG(VB_FILE, LOG_ERR, QString("Image: Failed to copy %1 to %2")
-                .arg(src, m_files[src]));
-    }
-
-    if (m_dialog)
-        m_dialog->Close();
-
-    RunEpilog();
-}
diff --git a/mythtv/programs/mythfrontend/gallerycommhelper.h b/mythtv/programs/mythfrontend/gallerycommhelper.h
deleted file mode 100644
index 9502ef8..0000000
--- a/mythtv/programs/mythfrontend/gallerycommhelper.h
+++ /dev/null
@@ -1,85 +0,0 @@
-//! \file
-//! \brief Encapsulates BE requests that originate from FE or services client
-
-#ifndef GALLERYCOMMHELPER_H
-#define GALLERYCOMMHELPER_H
-
-#include <QMap>
-#include <QStringList>
-#include <QString>
-
-#include <mthread.h>
-#include <imagemetadata.h>
-#include <imageutils.h>
-#include <mythprogressdialog.h>
-
-
-typedef QMap<QString, QString> NameMap;
-
-//! BE Requests
-class GalleryBERequest
-{
-public:
-    static QString     ScanImagesAction(bool);
-    static QStringList ScanQuery();
-    static void        CreateThumbnails(QStringList, bool);
-    static QString     HideFiles(bool, ImageIdList);
-    static QString     RemoveFiles(ImageIdList);
-    static QString     RenameFile(int, QString);
-    static QString     ChangeOrientation(ImageFileTransform transform,
-                                         ImageIdList);
-    static QString     ClearDatabase();
-    static QString     SetCover(int, int);
-    static NameMap     GetMetaData(const ImageItem *);
-    static QString     MoveFiles(int, ImageIdList);
-    static QString     MakeDirs(QStringList);
-    static QString     IgnoreDirs(QString);
-};
-
-
-//! Base thread returning a result
-class WorkerThread: public MThread
-{
-public:
-    WorkerThread(QString name) : MThread(name), m_result(0) {}
-    int GetResult(void) { return m_result; }
-protected:
-    int m_result;
-};
-
-
-//! Worker thread for running commands
-class ShellWorker: public WorkerThread
-{
-public:
-    ShellWorker(QString cmd) : WorkerThread("import"), m_command(cmd) {}
-    virtual void run();
-private:
-    QString m_command;
-};
-
-
-//! Worker thread for copying/moving files
-class FileTransferWorker : public WorkerThread
-{
-    Q_DECLARE_TR_FUNCTIONS(FileTransferWorker)
-public:
-    FileTransferWorker(bool, NameMap, MythUIProgressDialog *);
-    virtual void run();
-
-private:
-    //! Whether to delete files after they have been copied
-    bool m_delete;
-
-    //! Maps source filepath to destination filepath
-    NameMap m_files;
-
-    //! Progress dialog for transfer
-    MythUIProgressDialog *m_dialog;
-};
-
-
-int RunWorker(WorkerThread *);
-
-
-#endif // GALLERYCOMMHELPER_H
diff --git a/mythtv/programs/mythfrontend/galleryconfig.cpp b/mythtv/programs/mythfrontend/galleryconfig.cpp
index d26c234..0cafacc 100644
--- a/mythtv/programs/mythfrontend/galleryconfig.cpp
+++ b/mythtv/programs/mythfrontend/galleryconfig.cpp
@@ -1,7 +1,13 @@
 #include "galleryconfig.h"
 
+#include <QStringBuilder>
+
+#include "mythcorecontext.h"
+#include "mythdate.h"
 #include "gallerytransitions.h"
 
+#define ADD_FORMAT(date, format) fmt->addSelection(gCoreContext->GetQLocale().toString(date, format), format)
+
 
 /*!
  \brief Settings for Thumbnail view
@@ -13,10 +19,10 @@ public:
     {
         setLabel(tr("Thumbnails"));
 
-        HostComboBox *order = new HostComboBox("GallerySortOrder");
+        HostComboBox *order = new HostComboBox("GalleryImageOrder");
         order->setLabel(tr("Image Order"));
-        order->setHelpText(tr("The order that images are shown in thumbnail view "
-                              "and (ordered) slideshows."));
+        order->setHelpText(tr("The order that pictures/videos are shown in thumbnail "
+                              "view and ordered slideshows."));
         order->addSelection(tr("Filename (A-Z)"), QString::number(kSortByNameAsc));
         order->addSelection(tr("Reverse Filename (Z-A)"), QString::number(kSortByNameDesc));
         order->addSelection(tr("Exif Date (oldest first)"), QString::number(kSortByDateAsc));
@@ -28,6 +34,38 @@ public:
         order->addSelection(tr("File Size (smallest first)"), QString::number(kSortBySizeAsc));
         order->addSelection(tr("Reverse File Size (largest first)"), QString::number(kSortBySizeDesc));
         addChild(order);
+
+        HostComboBox *orderDir = new HostComboBox("GalleryDirOrder");
+        orderDir->setLabel(tr("Directory Order"));
+        orderDir->setHelpText(tr("The order that dirctories are shown and traversed "
+                                 "in recursive slideshows."));
+        orderDir->addSelection(tr("Filename (A-Z)"), QString::number(kSortByNameAsc));
+        orderDir->addSelection(tr("Reverse Filename (Z-A)"), QString::number(kSortByNameDesc));
+        orderDir->addSelection(tr("File Modified Time (oldest first)"), QString::number(kSortByModTimeAsc));
+        orderDir->addSelection(tr("Reverse File Modified Time (newest first)"), QString::number(kSortByModTimeDesc));
+        addChild(orderDir);
+
+        HostComboBox *fmt = new HostComboBox("GalleryDateFormat");
+        fmt->setLabel(tr("Date Format"));
+
+        QDateTime sampdate = MythDate::fromString("2002-05-03");
+
+        ADD_FORMAT(sampdate, "dd/MM/yy");
+        ADD_FORMAT(sampdate, "dd-MM-yy");
+        ADD_FORMAT(sampdate, "d/M/yy");
+        ADD_FORMAT(sampdate, "d-M-yy");
+        ADD_FORMAT(sampdate, "MM/dd/yy");
+        ADD_FORMAT(sampdate, "MM-dd-yy");
+        ADD_FORMAT(sampdate, "M/d/yy");
+        ADD_FORMAT(sampdate, "M-d-yy");
+        ADD_FORMAT(sampdate, "yyyy/MM/dd");
+        ADD_FORMAT(sampdate, "yyyy-MM-dd");
+        ADD_FORMAT(sampdate, QString("yyyy") % QChar(0x5E74) %
+                   "M" % QChar(0x6708) % "d" % QChar(0x65E5)); // yyyyMd
+
+        fmt->setHelpText(tr("Format of thumbnail captions only. Other places use the system date format. "
+                            "Sample shows 3rd May 2002 (Myth's birth date))."));
+        addChild(fmt);
     }
 };
 
@@ -53,7 +91,7 @@ public:
         while (i.hasNext())
         {
             i.next();
-            tranBox->addSelection(i.value()->GetName(), QString::number(i.key()));
+            tranBox->addSelection(i.value()->objectName(), QString::number(i.key()));
         }
         addChild(tranBox);
 
@@ -95,41 +133,19 @@ public:
         setLabel(tr("Import"));
         setEnabled(enable);
 
-        HostLineEdit *import = new HostLineEdit("GalleryImportLocation", true);
-        import->setLabel(tr("Import Path"));
-        import->setHelpText(tr("The path where the Import dialog usually starts."));
-        import->setEnabled(enable);
-        addChild(import);
-
-        TriggeredConfigurationGroup *group = new TriggeredConfigurationGroup(false, false);
-        group->SetVertical(false);
-        addChild(group);
-
-        HostCheckBox *useScript = new HostCheckBox("GalleryUseImportCmd");
-        useScript->setLabel(tr("Use Import Command"));
-        useScript->setHelpText(tr("Defines a command/script to aid importing. "
-                                  "Useful if a camera doesn't provide a mountable filesystem "
-                                  "and you need an alternative way of transferring images."));
-        useScript->setEnabled(enable);
-        group->addChild(useScript);
-
         HostLineEdit *script = new HostLineEdit("GalleryImportCmd", true);
-        script->setLabel(tr(""));
+        script->setLabel(tr("Import Command"));
         script->setHelpText(tr("Command/script that can be run from the menu. "
-                               "%DIR% will be replaced by the Import Path."
                                "\n%TMPDIR% will be replaced by a new temporary directory, "
                                "which the import dialog will show automatically. The "
                                "directory will be removed when Gallery exits."));
 
         script->setEnabled(enable);
-        group->setTrigger(useScript);
-        group->addTarget("0", new HorizontalConfigurationGroup(false, false));
-        group->addTarget("1", script);
+        addChild(script);
     }
 };
 
 
-
 /*!
  \brief Settings Page 2
  \param enable True if password has been entered
@@ -153,18 +169,30 @@ DatabaseSettings::DatabaseSettings(bool enable)
     exclusions->setEnabled(enable);
     group1->addChild(exclusions);
 
+    // Autorun - Use stacked to preserve spacing
+    StackedConfigurationGroup *group4 = new StackedConfigurationGroup(false, false);
+    addChild(group4);
+
+    HostCheckBox *autorun = new HostCheckBox("GalleryAutoLoad");
+    autorun->setLabel(tr("Start Gallery when media inserted"));
+    autorun->setHelpText(tr("Set to automatically start Gallery when media "
+                            "(USB/CD's containing images) are inserted."));
+    autorun->setEnabled(enable);
+    group4->addChild(autorun);
+
     // Password - Use stacked to preserve spacing
     StackedConfigurationGroup *group2 = new StackedConfigurationGroup(false, false);
     addChild(group2);
 
-    HostLineEdit *password = new HostLineEdit("GalleryPassword");
+    GlobalLineEdit *password = new GlobalLineEdit("GalleryPassword");
     password->setLabel(tr("Password"));
     password->SetPasswordEcho(true);
-    password->setHelpText(tr("If set then all actions that modify the filesystem or "
-                             "database are password-protected (copy, move, import, "
-                             "transform, hiding, set covers). Protection is disabled "
-                             "by an empty password.\nPrivileges persist until "
-                             "Gallery exits to main menu."));
+    password->setHelpText(tr("When set all actions that modify the filesystem or "
+                             "database are protected (copy, move, transform, "
+                             "hiding, covers). Hidden items cannot be viewed. "
+                             "Applies to all frontends. "
+                             "\nDisabled by an empty password. "
+                             "Privileges persist until Gallery exits to main menu."));
     password->setEnabled(enable);
     group2->addChild(password);
 
@@ -175,8 +203,8 @@ DatabaseSettings::DatabaseSettings(bool enable)
 
     TransCheckBoxSetting *clear = new TransCheckBoxSetting();
     clear->setLabel(tr("Reset Image Database"));
-    clear->setHelpText(tr("Clears the Image Database and all thumbnails. A rescan "
-                          "will be required."));
+    clear->setHelpText(tr("Clears the database and thumbnails for the Image Storage Group. "
+                          "A rescan will be required. Images for local media will persist."));
     clear->setEnabled(enable);
     group3->addChild(clear);
 
@@ -185,9 +213,9 @@ DatabaseSettings::DatabaseSettings(bool enable)
     TransButtonSetting *confirm = new TransButtonSetting("clearDb");
     confirm->setLabel(tr("Clear Now!"));
     confirm->setHelpText(tr("Warning! This will erase settings for: hidden images, "
-                            "directory covers and modified orientations. "
+                            "directory covers and re-orientations. "
                             "You will have to set them again after re-scanning."));
-    connect(confirm, SIGNAL(pressed()), this, SLOT(ClearDb()));
+    connect(confirm, SIGNAL(pressed()), this, SIGNAL(ClearDbPressed()));
     clrSub->addChild(confirm);
 
     group3->setTrigger(clear);
diff --git a/mythtv/programs/mythfrontend/galleryconfig.h b/mythtv/programs/mythfrontend/galleryconfig.h
index 6867944..cedb2a9 100644
--- a/mythtv/programs/mythfrontend/galleryconfig.h
+++ b/mythtv/programs/mythfrontend/galleryconfig.h
@@ -1,13 +1,11 @@
 //! \file
 //! \brief Provides Gallery configuration screens
-//!
 
 #ifndef GALLERYCONFIG_H
 #define GALLERYCONFIG_H
 
-#include <mythconfigdialogs.h>
-#include <mythconfiggroups.h>
-#include "gallerycommhelper.h"
+#include "mythconfigdialogs.h"
+#include "mythconfiggroups.h"
 
 
 //! Settings page 1
@@ -25,8 +23,8 @@ class DatabaseSettings : public VerticalConfigurationGroup
 public:
     DatabaseSettings(bool enable);
 
-private slots:
-    void ClearDb()    { GalleryBERequest::ClearDatabase(); }
+signals:
+    void ClearDbPressed();
 };
 
 
@@ -37,8 +35,14 @@ public:
     GalleryConfig(bool editMode)
     {
         addChild(new GallerySettings());
-        addChild(new DatabaseSettings(editMode));
+        m_dbGroup = new DatabaseSettings(editMode);
+        addChild(m_dbGroup);
     }
+
+    DatabaseSettings *GetClearPage() { return m_dbGroup; }
+
+private:
+    DatabaseSettings *m_dbGroup;
 };
 
 
diff --git a/mythtv/programs/mythfrontend/galleryinfo.cpp b/mythtv/programs/mythfrontend/galleryinfo.cpp
new file mode 100644
index 0000000..2006345
--- /dev/null
+++ b/mythtv/programs/mythfrontend/galleryinfo.cpp
@@ -0,0 +1,275 @@
+#include "galleryinfo.h"
+
+#include "mythcoreutil.h"
+#include "imagemetadata.h"
+
+
+// Only Used to initialise the QSet of keys
+static QStringList kBasicInfoFields = QStringList()
+        // Exif tags
+        << EXIF_TAG_USERCOMMENT
+        << EXIF_TAG_IMAGEDESCRIPTION
+        << EXIF_TAG_ORIENTATION
+        << EXIF_TAG_DATETIME
+        << "Exif.Image.Make"
+        << "Exif.Image.Model"
+        << "Exif.Photo.ExposureTime"
+        << "Exif.Photo.ShutterSpeedValue"
+        << "Exif.Photo.FNumber"
+        << "Exif.Photo.ApertureValue"
+        << "Exif.Photo.ExposureBiasValue"
+        << "Exif.Photo.Flash"
+        << "Exif.Photo.FocalLength"
+        << "Exif.Photo.FocalLengthIn35mmFilm"
+        << "ISO speed"
+        << "Exif.Photo.MeteringMode"
+        << "Exif.Photo.PixelXDimension"
+        << "Exif.Photo.PixelYDimension"
+           // Video tags
+        << "FFmpeg.format.format_long_name"
+        << "FFmpeg.format.duration"
+        << "FFmpeg.format.creation_time"
+        << "FFmpeg.format.model"
+        << "FFmpeg.format.make"
+           // Only detects tags within the first 2 streams for efficiency
+        << "FFmpeg.stream0:.codec_long_name"
+        << "FFmpeg.stream1:.codec_long_name"
+        << "FFmpeg.stream0:.width"
+        << "FFmpeg.stream1:.width"
+        << "FFmpeg.stream0:.height"
+        << "FFmpeg.stream1:.height"
+        << "FFmpeg.stream0:.sample_rate"
+        << "FFmpeg.stream1:.sample_rate"
+        << "FFmpeg.stream0:.rotate"
+        << "FFmpeg.stream1:.rotate";
+
+//! The exif/video tags comprising the Basic file info
+static QSet<QString> kBasicInfoSet = QSet<QString>::fromList(kBasicInfoFields);
+
+
+/*!
+ \brief Initialise buttonlist from XML
+ \param focusable Set if info list should be focusable (for scrolling)
+ \return bool True initialisation succeeds
+*/
+bool InfoList::Create(bool focusable)
+{
+    bool err = false;
+    UIUtilE::Assign(&m_screen, m_btnList, "infolist", &err);
+    if (err)
+        return false;
+
+    m_btnList->SetVisible(false);
+    m_btnList->SetCanTakeFocus(focusable);
+    return true;
+}
+
+
+/*!
+ \brief Toggle infolist state for an image. Focusable widgets toggle between
+ Basic & Full info. Non-focusable widgets toggle between Basic & Off.
+ \param im The image/dir for which info is shown
+*/
+void InfoList::Toggle(ImagePtrK im)
+{
+    if (!im)
+        return;
+
+    // Only focusable lists have an extra 'full' state as they can
+    // be scrolled to view it all
+    if (m_btnList->CanTakeFocus())
+
+        // Start showing basic info then toggle between basic/full
+        m_infoVisible = m_infoVisible == kBasicInfo ? kFullInfo : kBasicInfo;
+
+    // Toggle between off/basic
+    else if (m_infoVisible == kBasicInfo)
+    {
+        m_infoVisible = kNoInfo;
+        m_btnList->SetVisible(false);
+        return;
+    }
+    else
+        m_infoVisible = kBasicInfo;
+
+    Clear();
+    Update(im);
+
+    m_btnList->SetVisible(true);
+}
+
+
+/*!
+ \brief Remove infolist from display
+ \return bool True if buttonlist was displayed/removed
+*/
+bool InfoList::Hide()
+{
+    // Only handle event if info currently displayed
+    bool handled = (m_infoVisible != kNoInfo);
+    m_infoVisible = kNoInfo;
+
+    m_btnList->SetVisible(false);
+
+    return handled;
+}
+
+
+/*!
+ \brief Populate a buttonlist item with exif tag name & value
+ \param name Exif tag name
+ \param value Exif tag value
+*/
+void InfoList::CreateButton(QString name, QString value)
+{
+    if (value.isEmpty())
+        return;
+
+    MythUIButtonListItem *item = new MythUIButtonListItem(m_btnList, "");
+
+    InfoMap infoMap;
+    infoMap.insert("name", name);
+    infoMap.insert("value", value);
+
+    item->SetTextFromMap(infoMap);
+}
+
+
+/*!
+ \brief Creates buttons detailing dir counts & size
+ \param im Image dir
+*/
+void InfoList::CreateCount(ImageItemK &im)
+{
+    int dirCount = 0, imageCount = 0, videoCount = 0, size = 0;
+    m_mgr.GetDescendantCount(im.m_id, dirCount, imageCount, videoCount, size);
+
+    QStringList report;
+    if (imageCount > 0)
+        report << tr("%Ln image(s)", "", imageCount);
+    if (videoCount > 0)
+        report << tr("%Ln video(s)", "", videoCount);
+    if (dirCount > 0)
+        report << tr("%Ln directory(ies)", "", dirCount);
+
+    CreateButton(tr("Contains"), report.join(", "));
+    CreateButton(tr("Dir size"), ImageAdapterBase::FormatSize(size));
+
+    if (im.IsDevice() && im.IsLocal())
+    {
+        // Returns KiB
+        int64_t total, used;
+        int64_t free = getDiskSpace(im.m_filePath, total, used);
+        if (total > 0)
+            CreateButton(tr("Free space"), tr("%L1 (%L2\%) Used: %L3 / %L4")
+                         .arg(ImageAdapterBase::FormatSize(free))
+                         .arg(100 * free / total)
+                         .arg(ImageAdapterBase::FormatSize(used),
+                              ImageAdapterBase::FormatSize(total)));
+    }
+}
+
+
+/*!
+ \brief Populates available exif details for the current image/dir.
+ \param im An image or dir
+*/
+void InfoList::Update(ImagePtrK im)
+{
+    if (!im || m_infoVisible == kNoInfo)
+        return;
+
+    if (im->m_id == GALLERY_DB_ID)
+    {
+        Clear();
+        CreateButton(tr("Name"), tr("Gallery"));
+        CreateCount(*im);
+    }
+    else if (im->m_id == PHOTO_DB_ID)
+    {
+        // SG has no path
+        Clear();
+        CreateButton(tr("Name"), tr("Photographs"));
+        CreateButton(tr("Path"), tr("Storage Group"));
+        CreateButton(tr("Last scan"), QDateTime::fromTime_t(im->m_date).toString());
+        CreateCount(*im);
+    }
+    else
+    {
+        // Request metadata
+        m_mgr.RequestMetaData(im->m_id);
+        // Reduce flicker by waiting for new data before clearing list
+        m_timer.start();
+    }
+}
+
+
+/*!
+ * \brief Build list of metadata tags
+ * \param im Image
+ * \param tagStrings Metadata encoded as list of key<sep>label<sep>value
+ */
+void InfoList::Display(ImageItemK &im, const QStringList &tagStrings)
+{
+    // Cancel timer & build list
+    m_timer.stop();
+    Clear();
+
+    // Each tag has 3 elements: key, label, value
+    ImageMetaData::TagMap tags = ImageMetaData::ToMap(tagStrings);
+
+    QString tagHost = tags.take(EXIF_MYTH_HOST).value(2);
+    QString tagPath = tags.take(EXIF_MYTH_PATH).value(2);
+    QString tagName = tags.take(EXIF_MYTH_NAME).value(2);
+
+    CreateButton(tr("Name"), tagName);
+
+    // Only show non-local hostnames
+    QString host = (tagHost == gCoreContext->GetHostName()) ? "" : tagHost + ":";
+    QString clone = (im.m_type == kCloneDir) ? tr("(and others)") : "";
+    CreateButton(tr("Path"), QString("%1%2 %3").arg(host, tagPath, clone));
+
+    if (im.IsDevice())
+        CreateButton(tr("Last scan"), QDateTime::fromTime_t(im.m_date).toString());
+
+    if (im.IsDirectory())
+        CreateCount(im);
+
+    if (!im.IsDevice())
+        CreateButton(tr("Modified"), QDateTime::fromTime_t(im.m_modTime).toString());
+
+    if (im.IsFile())
+    {
+        CreateButton(tr("File size"),   tags.take(EXIF_MYTH_SIZE).value(2));
+        CreateButton(tr("Orientation"), tags.take(EXIF_MYTH_ORIENT).value(2));
+
+        // Create buttons for exif/video tags
+        // Multimap iterates each key latest->earliest so we must do it the long way
+        foreach (const QString &group, tags.uniqueKeys())
+        {
+            // Iterate earliest->latest to preserve tag order
+            typedef QList<QStringList> TagList;
+            TagList tagList = tags.values(group);
+            TagList::const_iterator i = tagList.constEnd();
+
+            if (m_infoVisible == kFullInfo)
+            {
+                // Show all tags
+                while (i-- != tagList.constBegin())
+                    CreateButton(i->at(1), i->at(2));
+            }
+            else
+            {
+                // Only show specific keys
+                while (i-- != tagList.constBegin())
+                    if (kBasicInfoSet.contains(i->at(0)))
+                        CreateButton(i->at(1), i->at(2));
+            }
+        }
+
+        // Only give list focus if requested
+        if (m_btnList->CanTakeFocus())
+            m_screen.SetFocusWidget(m_btnList);
+    }
+}
+
diff --git a/mythtv/programs/mythfrontend/galleryinfo.h b/mythtv/programs/mythfrontend/galleryinfo.h
new file mode 100644
index 0000000..65b020d
--- /dev/null
+++ b/mythtv/programs/mythfrontend/galleryinfo.h
@@ -0,0 +1,57 @@
+//! \file
+//! \brief The info/details overlay that shows image metadata
+
+#ifndef GALLERYINFO_H
+#define GALLERYINFO_H
+
+#include <QTimer>
+
+#include "mythuibuttonlist.h"
+#include "imagemanager.h"
+
+
+class MythScreenType;
+
+//! Displayed info/details about an image.
+enum InfoVisibleState { kNoInfo,    //!< Details not displayed
+                        kBasicInfo, //!< Shows just the most useful exif tags
+                        kFullInfo   //!< Shows all exif tags
+                      };
+
+//! The image info/details buttonlist overlay that displays exif tags
+class InfoList : QObject
+{
+    Q_OBJECT
+public:
+    InfoList(MythScreenType &screen)
+        : m_screen(screen), m_infoVisible(kNoInfo),
+          m_mgr(ImageManagerFe::getInstance())
+    {
+        m_timer.setSingleShot(true);
+        m_timer.setInterval(1000);
+        connect(&m_timer, SIGNAL(timeout()), this, SLOT(Clear()));
+    }
+
+    bool             Create(bool focusable);
+
+    void             Toggle(ImagePtrK);
+    bool             Hide();
+    void             Update(ImagePtrK);
+    void             Display(ImageItemK &im, const QStringList &tagStrings);
+    InfoVisibleState GetState() const   { return m_infoVisible; }
+
+private slots:
+    void Clear()   { m_btnList->Reset(); }
+
+private:
+    void CreateButton(QString, QString);
+    void CreateCount(ImageItemK &);
+
+    MythScreenType   &m_screen;      //!< Parent screen
+    MythUIButtonList *m_btnList;     //!< Overlay buttonlist
+    InfoVisibleState  m_infoVisible; //!< Info list state
+    ImageManagerFe   &m_mgr;         //!< Image Manager
+    QTimer            m_timer;       //!< Clears list if no new metadata arrives
+};
+
+#endif // GALLERYINFO_H
diff --git a/mythtv/programs/mythfrontend/galleryslide.cpp b/mythtv/programs/mythfrontend/galleryslide.cpp
index 1691288..b9ef101 100644
--- a/mythtv/programs/mythfrontend/galleryslide.cpp
+++ b/mythtv/programs/mythfrontend/galleryslide.cpp
@@ -1,22 +1,36 @@
 #include "galleryslide.h"
 
-#include <math.h>
+#include <math.h>       // for roundf
+#include "mythmainwindow.h"
+#include "mythlogging.h"
 
-#include <mythmainwindow.h>
+#include "imagemetadata.h"
+
+
+#define LOC QString("Slide: ")
+#define SBLOC QString("SlideBuffer: ")
+
+
+// Number of slides to use for buffering image requests.
+// When browsing quickly the buffer will load consecutive slides until it fills.
+// If too large, rapid browsing will be stodgy (sequential access) for images that
+// aren't cached (Cached images are always fast).
+// If too small, rapid browsing will result in skipping slides rather than flicking
+// quickly through them.
+// Minimum is 4: 3 for displaying a transition, 1 to handle load requests
+#define SLIDE_BUFFER_SIZE 9
 
 
 /*!
  \brief Initialise & start base animation
  \param forwards Direction
  \param speed Factor, 1 = real-time, 2 = double-time
- \return bool Always True
 */
-bool AbstractAnimation::Start(bool forwards, float speed)
+void AbstractAnimation::Start(bool forwards, float speed)
 {
     m_forwards = forwards;
     m_speed    = speed;
     m_running  = true;
-    return true;
 }
 
 
@@ -57,17 +71,16 @@ void Animation::Set(QVariant from, QVariant to, int duration,
  \brief Start a single animation
  \param forwards Direction
  \param speed Speed factor, 1x, 2x etc
- \return bool True if started
 */
-bool Animation::Start(bool forwards, float speed)
+void Animation::Start(bool forwards, float speed)
 {
     if (duration() == 0)
-        return false;
+        return;
 
     m_elapsed = forwards ? 0 : duration();
     setCurrentTime(m_elapsed);
 
-    return AbstractAnimation::Start(forwards, speed);
+    AbstractAnimation::Start(forwards, speed);
 }
 
 
@@ -86,7 +99,7 @@ void Animation::Pulse(int interval)
 
     // Detect completion
     if ((m_forwards && m_elapsed >= duration())
-        || (!m_forwards && m_elapsed <= 0))
+            || (!m_forwards && m_elapsed <= 0))
         Finished();
 }
 
@@ -103,15 +116,12 @@ void Animation::updateCurrentValue(const QVariant &value)
 
         switch (m_type)
         {
-            case Position: m_parent->SetPosition(value.toPoint()); break;
-            case Alpha: m_parent->SetAlpha(value.toInt()); break;
-            case Zoom: m_parent->SetZoom(value.toFloat()); break;
-            case HorizontalZoom: m_parent->SetHorizontalZoom(value.toFloat());
-                break;
-            case VerticalZoom: m_parent->SetVerticalZoom(value.toFloat());
-                break;
-            case Angle: m_parent->SetAngle(value.toFloat()); break;
-            case None:;
+        case Position:       m_parent->SetPosition(value.toPoint()); break;
+        case Alpha:          m_parent->SetAlpha(value.toInt()); break;
+        case Zoom:           m_parent->SetZoom(value.toFloat()); break;
+        case HorizontalZoom: m_parent->SetHorizontalZoom(value.toFloat()); break;
+        case VerticalZoom:   m_parent->SetVerticalZoom(value.toFloat()); break;
+        case Angle:          m_parent->SetAngle(value.toFloat()); break;
         }
     }
 }
@@ -157,19 +167,17 @@ void SequentialAnimation::Pulse(int interval)
  \brief Start sequential animation
  \param forwards Direction. If false, the last child will be played (backwards) first
  \param speed Factor, 1x, 2x etc
- \return bool Always true
 */
-bool SequentialAnimation::Start(bool forwards, float speed)
+void SequentialAnimation::Start(bool forwards, float speed)
 {
     if (m_group.size() == 0)
-        return false;
+        return;
 
     m_current = forwards ? 0 : m_group.size() - 1;
 
     // Start group, then first child
     AbstractAnimation::Start(forwards, speed);
     m_group.at(m_current)->Start(m_forwards, m_speed);
-    return true;
 }
 
 
@@ -197,7 +205,7 @@ void SequentialAnimation::Finished()
 {
     // Finish group when last child finishes
     if ((m_forwards && ++m_current == m_group.size())
-        || (!m_forwards && --m_current < 0))
+            || (!m_forwards && --m_current < 0))
         AbstractAnimation::Finished();
     else
         // Start next child
@@ -222,12 +230,11 @@ void ParallelAnimation::Pulse(int interval)
  \brief Start parallel group. All children play simultaneously
  \param forwards Direction
  \param speed Factor, 1x, 2x etc
- \return bool Always true
 */
-bool ParallelAnimation::Start(bool forwards, float speed)
+void ParallelAnimation::Start(bool forwards, float speed)
 {
     if (m_group.size() == 0)
-        return false;
+        return;
 
     m_finished = m_group.size();
 
@@ -235,8 +242,6 @@ bool ParallelAnimation::Start(bool forwards, float speed)
     AbstractAnimation::Start(forwards, speed);
     foreach(AbstractAnimation *animation, m_group)
         animation->Start(m_forwards, m_speed);
-
-    return true;
 }
 
 
@@ -286,17 +291,14 @@ void PanAnimation::updateCurrentValue(const QVariant &value)
 */
 Slide::Slide(MythUIType *parent, QString name, MythUIImage *image)
     : MythUIImage(parent, name),
-    m_ilt(new ImageLoadingThread(this)),
-    m_data(NULL),
-    m_waitingFor(NULL),
-    m_zoom(1.0),
-    m_isReady(false),
-    m_loadFailed(false),
-    m_locked(false),
-    m_direction(0),
-    m_zoomAnimation(NULL),
-    m_panAnimation(NULL),
-    m_pan(QPoint(0,0))
+      m_state(kEmpty),
+      m_data(NULL),
+      m_waitingFor(NULL),
+      m_zoom(1.0),
+      m_direction(0),
+      m_zoomAnimation(NULL),
+      m_panAnimation(NULL),
+      m_pan(QPoint(0,0))
 {
     // Clone from image
     CopyFrom(image);
@@ -308,32 +310,30 @@ Slide::Slide(MythUIType *parent, QString name, MythUIImage *image)
         // Slides sit on top of parent image area
         SetArea(MythRect(image->GetArea().toQRect()));
         m_Area.moveTo(0, 0);
+        setParent(image);
         m_Parent = image;
         image->AddChild(this);
     }
 
-    // Listen for "image completed load" signals
-    connect(m_ilt, SIGNAL(finished()), this, SLOT(LoadComplete()));
-
     // Provide animations for pan & zoom
     if (GetPainter()->SupportsAnimation())
     {
         m_zoomAnimation = new Animation(this, Animation::Zoom);
         m_panAnimation  = new PanAnimation(this);
     }
+
+    connect(this, SIGNAL(LoadComplete()), this, SLOT(SlideLoaded()));
 }
 
 
 /*!
- \brief Destroy slide
+ \brief Destructor
 */
 Slide::~Slide()
 {
-    if (m_ilt)
-        m_ilt->wait();
-    delete m_ilt;
     delete m_zoomAnimation;
     delete m_panAnimation;
+    LOG(VB_GUI, LOG_DEBUG, "Deleted Slide " + objectName());
 }
 
 
@@ -342,86 +342,108 @@ Slide::~Slide()
 */
 void Slide::Clear()
 {
-    m_isReady   = false;
-    m_loadFailed = false;
-    m_data       = NULL;
+    m_state = kEmpty;
+    m_data.clear();
+    m_waitingFor.clear();
+    SetCropRect(0, 0, 0, 0);
+    SetVisible(false);
+}
+
+
+/*!
+   \brief Return debug status
+   \return Char representing state
+ */
+QChar Slide::GetDebugState() const
+{
+    switch (m_state)
+    {
+    case kEmpty:   return 'e';
+    case kFailed:  return 'f';
+    case kLoaded:  return m_waitingFor ? 'r' : 'a';
+    case kLoading: return m_waitingFor ? 'l' : 'p';
+    }
+    return '?';
 }
 
 
 /*!
  \brief Load slide with an image
- \details If the requested image is already loaded (due to pre-load) then returns immediately.
- Otherwise it initiates an image load in a child thread, provided an image is not already loading
- (multiple requests due to skipping). If loader is busy then the most recent request is queued.
- Intervening requests are discarded.
+ \details If the requested image is already loaded (due to pre-load) then returns
+ immediately. Otherwise it initiates an image load in a child thread, provided
+ an image is not already loading (multiple requests due to skipping). If loader
+ is busy then the most recent request is queued. Intervening requests are discarded.
  \param im The image to load
  \param direction Navigation that caused this load. Determines transition direction
- \param notifyCompletion if True, emits a signal when the last requested image has loaded
+ \param notifyCompletion if True, emits a signal when the last requested image
+ has loaded
  \return bool True if the requested image is already loaded
 */
-bool Slide::Load(ImageItem *im, int direction, bool notifyCompletion)
+bool Slide::LoadSlide(ImagePtrK im, int direction, bool notifyCompletion)
 {
-    m_waitingFor = notifyCompletion ? im : NULL;
-    m_direction = direction;
+    m_direction  = direction;
+    m_waitingFor = notifyCompletion ? im : ImagePtrK();
 
     if (im == m_data)
     {
-        LOG(VB_FILE, LOG_DEBUG, QString("Slide: Already loading/loaded %1 in %2")
-            .arg(im->m_fileName, objectName()));
+        LOG(VB_FILE, LOG_DEBUG, LOC + QString("Already loading/loaded %1 in %2")
+            .arg(im->m_filePath, objectName()));
 
-        if (m_isReady && notifyCompletion)
+        if (m_state >= kLoaded && notifyCompletion)
             // Image has been pre-loaded
             emit ImageLoaded(this);
 
-        return m_isReady;
+        return (m_state >= kLoaded);
     }
 
     // Is a different image loading ?
-    if (m_ilt && m_ilt->isRunning())
+    if (m_state == kLoading)
     {
         // Can't abort image loads, so must wait for it to finish
         // before starting new load
         m_waitingFor = im;
 
-        LOG(VB_FILE, LOG_DEBUG, QString("Slide: Postponing load of %1 in %2")
-            .arg(im->m_fileName, objectName()));
+        LOG(VB_FILE, LOG_DEBUG, LOC + QString("Postponing load of %1 in %2")
+            .arg(im->m_filePath, objectName()));
 
         return false;
     }
 
     // Start load
-    m_data      = im;
-    m_isReady   = m_loadFailed = false;
-    ImageSg *sg = ImageSg::getInstance();
+    m_data  = im;
+    m_state = kLoading;
 
     if (im->m_type == kVideoFile)
     {
         // Use thumbnail, which has already been orientated
-        SetFilename(sg->GenerateThumbUrl(im->m_thumbNails.at(0)));
+        SetFilename(im->m_thumbNails.at(0).second);
         SetOrientation(1);
     }
     else
     {
-        SetFilename(sg->GenerateUrl(im->m_fileName));
-        SetOrientation(m_data->m_orientation);
+        // Load image and orientate
+        SetFilename(im->m_url);
+        SetOrientation(Orientation(m_data->m_orientation).GetCurrent());
     }
 
-    SetCropRect(0, 0, 0, 0);
-    m_ilt->start();
+    // Load in background
+    Load(true);
     return false;
 }
 
 
 /*!
  \brief An image has completed loading
- \details If the loaded image matches the most recently requested and client is waiting then
- signals that the slide is ready. Otherwise starts loading the latest requested image, if
- different. Superseded loads are discarded.
+ \details If the loaded image matches the most recently requested and client is
+ waiting then signals that the slide is ready. Otherwise starts loading the
+ latest requested image, if different. Superseded loads are discarded.
 */
-void Slide::LoadComplete()
+void Slide::SlideLoaded()
 {
-    m_isReady = true;
-    m_loadFailed = (m_Images[0] == NULL);
+    m_state = m_Images[0] ? kLoaded : kFailed;
+    if (m_state == kFailed)
+        LOG(VB_GENERAL, LOG_ERR, LOC +
+            QString("Failed to load %1").arg(m_data->m_filePath));
 
     // Ignore superseded requests and preloads
     if (m_data == m_waitingFor)
@@ -431,11 +453,11 @@ void Slide::LoadComplete()
     }
     else if (m_waitingFor)
     {
-        LOG(VB_FILE, LOG_DEBUG, QString("Slide: Starting delayed load %1")
-            .arg(m_waitingFor->m_fileName));
+        LOG(VB_FILE, LOG_DEBUG, LOC + QString("Starting delayed load %1")
+            .arg(m_waitingFor->m_filePath));
 
         // Start latest postponed load
-        Load(m_waitingFor, m_direction, true);
+        LoadSlide(m_waitingFor, m_direction, true);
     }
 }
 
@@ -449,9 +471,9 @@ void Slide::Zoom(int percentage)
 {
     // Sentinel indicates reset to default zoom
     float newZoom = (percentage == 0)
-                    ? 1.0
-                    : qMax(MIN_ZOOM,
-                           qMin(MAX_ZOOM, m_zoom * (1.0 + percentage / 100.0)));
+            ? 1.0
+            : qMax(MIN_ZOOM,
+                   qMin(MAX_ZOOM, m_zoom * (1.0 + percentage / 100.0)));
     if (newZoom != m_zoom)
     {
         if (m_zoomAnimation)
@@ -466,6 +488,26 @@ void Slide::Zoom(int percentage)
 
 
 /*!
+ \brief Sets slide zoom
+ \details Applies zoom immediately
+ \sa Slide::Zoom
+ \param zoom New zoom level, 1.0 = full-size
+*/
+void Slide::SetZoom(float zoom)
+{
+    m_zoom          = zoom;
+    m_Effects.hzoom = m_Effects.vzoom = zoom;
+
+    // TODO
+    // MythUIImage displaces widget or doesn't centre for some combinations of
+    // zoom centre/cropping so frig centre for now.
+    m_Effects.centre = zoom < 1.0 ? UIEffects::Middle : UIEffects::TopLeft;
+
+    SetPan(m_pan);
+}
+
+
+/*!
  \brief Initiate pan
  \param offset Offset to apply to current position. Sentinel (0,0) resets pan.
 */
@@ -494,26 +536,6 @@ void Slide::Pan(QPoint offset)
 
 
 /*!
- \brief Sets slide zoom
- \details Applies zoom immediately
- \sa Slide::Zoom
- \param zoom New zoom level, 1.0 = full-size
-*/
-void Slide::SetZoom(float zoom)
-{
-    m_zoom          = zoom;
-    m_Effects.hzoom = m_Effects.vzoom = zoom;
-
-    // TODO
-    // MythUIImage displaces widget or doesn't centre for some combinations of
-    // zoom centre/cropping so frig centre for now.
-    m_Effects.centre = zoom < 1.0 ? UIEffects::Middle : UIEffects::TopLeft;
-
-    SetPan(m_pan);
-}
-
-
-/*!
  \brief Sets slide pan
  \details Applies pan immediately
  \sa Slide::Pan
@@ -521,7 +543,7 @@ void Slide::SetZoom(float zoom)
 */
 void Slide::SetPan(QPoint pos)
 {
-    if (m_loadFailed)
+    if (m_state == kFailed)
     {
         m_pan = pos;
         return;
@@ -567,56 +589,77 @@ void Slide::Pulse()
 }
 
 
+SlideBuffer::~SlideBuffer()
+{
+    LOG(VB_GUI, LOG_DEBUG, "Deleted Slidebuffer");
+}
+
+
+void SlideBuffer::Teardown()
+{
+    QMutexLocker lock(&m_mutexQ);
+    foreach (Slide *s, m_queue)
+        s->Clear();
+    LOG(VB_GUI, LOG_DEBUG, "Aborted Slidebuffer");
+}
+
+
 /*!
  \brief Construct buffer
- \details Slides are cloned from an image and become children of it. Only the
- first is visible. Requires a minimum of 3 slides: 2 for a transition, 1 to handle
- requests
+ \details Slides are cloned from an XML image and become children of it.
  \param image Parent image used as a template for slides
- \param size Number of slides in buffer
 */
-SlideBuffer::SlideBuffer(MythUIImage *image, int size)
-    : m_nextLoad(1)
+void SlideBuffer::Initialise(MythUIImage &image)
 {
-    if (size < 3)
-        // Require at least 3 slides: 2 for transitions & 1 to handle further requests
-        return;
+    // Require at least 4 slides: 2 for transitions, 1 to handle further requests
+    // and 1 to prevent solitary slide from being used whilst it is loading
+    int size = qMax(SLIDE_BUFFER_SIZE, 4);
 
     // Fill buffer with slides cloned from the XML image widget
 
-    // Create first as a child of the image.
-    Slide *slide = new Slide(NULL, "slide0", image);
+    // Create first as a child of the XML image.
+    Slide *slide = new Slide(NULL, "slide0", &image);
 
     // Buffer is notified when it has loaded image
     connect(slide, SIGNAL(ImageLoaded(Slide *)),
-            this, SLOT(FlushAvailable(Slide *)));
+            this, SLOT(Flush(Slide *)));
 
     m_queue.enqueue(slide);
 
     // Rest are simple clones of first
     for (int i = 1; i < size; ++i)
     {
-        slide = new Slide(image, QString("slide%1").arg(i), slide);
+        slide = new Slide(&image, QString("slide%1").arg(i), slide);
 
         // All slides (except first) start off hidden
         slide->SetVisible(false);
 
         // Buffer is notified when it has loaded image
         connect(slide, SIGNAL(ImageLoaded(Slide *)),
-                this, SLOT(FlushAvailable(Slide *)));
+                this, SLOT(Flush(Slide *)));
 
         m_queue.enqueue(slide);
     }
+
+    m_nextLoad = 1;
 }
 
 
 /*!
- \brief Destructor
-*/
-SlideBuffer::~SlideBuffer()
+ * \brief Determines buffer state for debug logging
+ * \return String showing state of each slide
+ */
+QString SlideBuffer::BufferState()
 {
-    // TODO: Detach from parent
-    qDeleteAll(m_queue);
+    QMutexLocker lock(&m_mutexQ);
+
+    QString state;
+    for (int i = 0; i < m_queue.size(); ++i)
+    {
+        QChar code(m_queue.at(i)->GetDebugState());
+        state += (i == m_nextLoad ? code.toUpper() : code);
+    }
+    return QString("[%1] (%2)").arg(state, m_queue.head()->objectName());
 }
 
 
@@ -627,22 +670,24 @@ SlideBuffer::~SlideBuffer()
  \param direction Navigation causing the load
  \return bool True if image is already loaded
 */
-bool SlideBuffer::Load(ImageItem *im, int direction)
+bool SlideBuffer::Load(ImagePtrK im, int direction)
 {
+    if (!im)
+        return false;
+
+    QMutexLocker lock(&m_mutexQ);
+
     // Start loading image in next available slide
     Slide *slide = m_queue.at(m_nextLoad);
 
     // Further load requests will go to same slide if no free ones are available
-    QString extra = "";
     if (m_nextLoad < m_queue.size() - 1)
         ++m_nextLoad;
-    else
-        extra = "(No spare slides)";
 
-    LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: Loading %1 in %2, next load in slot %3 %4")
-        .arg(im->m_fileName, slide->objectName()).arg(m_nextLoad).arg(extra));
+    LOG(VB_FILE, LOG_DEBUG, SBLOC + QString("Loading %1 in %2, %3")
+        .arg(im->m_filePath, slide->objectName()).arg(BufferState()));
 
-    return slide->Load(im, direction, true);
+    return slide->LoadSlide(im, direction, true);
 }
 
 
@@ -650,63 +695,47 @@ bool SlideBuffer::Load(ImageItem *im, int direction)
  \brief Load an image in next available slide
  \param im Image to load
 */
-void SlideBuffer::Preload(ImageItem *im)
+void SlideBuffer::Preload(ImagePtrK im)
 {
-    if (im)
-    {
-        // Start loading image in next available slide
-        Slide *slide = m_queue.at(m_nextLoad);
-
-        LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: Preloading %1 in %2 in slot %3")
-            .arg(im->m_fileName, slide->objectName()).arg(m_nextLoad));
-
-        // Load silently
-        m_queue.at(m_nextLoad)->Load(im);
-    }
-}
-
+    if (!im)
+        return;
 
-/*!
- \brief Remove & return slide from head of queue
- \return Slide Next slide for display
-*/
-Slide* SlideBuffer::TakeNext()
-{
-    if (m_queue.isEmpty())
-        // Shouldn't happen unless init failed
-        return NULL;
+    QMutexLocker lock(&m_mutexQ);
 
-    // Dispense next slide & adjust load ptr to account for queue shuffling
-    Slide *next = m_queue.dequeue();
-    --m_nextLoad;
+    // Start loading image in next available slide
+    Slide *slide = m_queue.at(m_nextLoad);
 
-    ImageItem *im = next->GetImageData();
-    LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: Taking %1 in %2, next load in slot %3")
-        .arg(im ? im->m_fileName : "Empty", next->objectName()).arg(m_nextLoad));
+    LOG(VB_FILE, LOG_DEBUG, SBLOC + QString("Preloading %1 in %2, %3")
+        .arg(im->m_filePath, slide->objectName()).arg(BufferState()));
 
-    return next;
+    // Load silently
+    slide->LoadSlide(im);
 }
 
 
 /*!
- \brief Return slide to queue and flush next image, if it is waiting for display
- \param slide Unused slide for re-use
+ \brief Move head slide to back of queue and flush waiting slides
  \return int Number of slides waiting for display at head
 */
-int SlideBuffer::Release(Slide *slide)
+void SlideBuffer::ReleaseCurrent()
 {
-    LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: Releasing %1").arg(slide->objectName()));
+    QMutexLocker lock(&m_mutexQ);
 
     // Reset slide & return to buffer for re-use
+    Slide *slide = m_queue.dequeue();
     slide->Clear();
     m_queue.enqueue(slide);
 
+    QString name = slide->objectName();
+
     // Free constrained load ptr now a spare slide is available
-    if (m_queue.at(m_nextLoad)->IsAvailable())
+    if (!m_queue.at(--m_nextLoad)->IsEmpty())
         ++m_nextLoad;
 
+    LOG(VB_FILE, LOG_DEBUG, SBLOC + QString("Released %1").arg(name));
+
     // Flush any pending slides that originate from multiple requests (skipping)
-    return FlushAvailable(m_queue.head(), "Pending");
+    Flush(m_queue.head(), "Pending");
 }
 
 
@@ -716,23 +745,26 @@ int SlideBuffer::Release(Slide *slide)
  \param reason Debug text describing reason for test
  \return int Number of slides available for display
 */
-int SlideBuffer::FlushAvailable(Slide *slide, QString reason)
+void SlideBuffer::Flush(Slide *slide, QString reason)
 {
-    // Determine number of consecutive slides that are now available at head
-    // Ignore last slide: it can't be displayed because it may start handling a new request
-    int available = 0;
-    while (available < m_queue.size() - 1 && m_queue.at(available)->IsAvailable())
+    QMutexLocker lock(&m_mutexQ);
+
+    // Determine number of consecutive slides that are now available after head
+    // Include last slide to ensure transition speed is consistent: it will never
+    // be displayed because queue size is always > 2
+    int available = 1;
+    while (available < m_queue.size() && m_queue.at(available)->IsLoaded())
         ++available;
 
-    // Notify if slides are available
-    if (available > 0)
-    {
-        LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: %1 %2 in %3 (%4 available)")
-            .arg(reason, slide->GetImageData()->m_fileName, slide->objectName())
-            .arg(available));
+    if (available == 1)
+        return;
 
-        emit SlideReady(available);
-    }
+    // Notify that more slides are available
+    ImagePtrK im = slide->GetImageData();
+    QString   path = im ? im->m_filePath : "Unknown";
+
+    LOG(VB_FILE, LOG_DEBUG, SBLOC + QString("%1 %2 in %3, %4")
+        .arg(reason, path, slide->objectName()).arg(BufferState()));
 
-    return available;
+    emit SlideReady(--available);
 }
diff --git a/mythtv/programs/mythfrontend/galleryslide.h b/mythtv/programs/mythfrontend/galleryslide.h
index 2cda825..2c3255c 100644
--- a/mythtv/programs/mythfrontend/galleryslide.h
+++ b/mythtv/programs/mythfrontend/galleryslide.h
@@ -10,47 +10,30 @@
 #ifndef GALLERYSLIDE_H
 #define GALLERYSLIDE_H
 
-#include <QThread>
 #include <QQueue>
-#include <QVariantAnimation>
 
-#include <mythuiimage.h>
-#include <imageutils.h>
+#include "mythuiimage.h"
+#include "imagetypes.h"
+
 
 // Min/max zoom extents available in slideshow
 #define MIN_ZOOM 0.1
 #define MAX_ZOOM 20.0
 
-
-//! An wrapped image loader so that we can detect when it completes
-class ImageLoadingThread : public QThread
-{
-public:
-    ImageLoadingThread(MythUIImage *image) : QThread(), m_image(image) {}
-
-protected:
-    void run()   { if (m_image) m_image->Load(false); }
-
-    MythUIImage *m_image;
-};
-
-
 class Slide;
 
 //! \brief Base animation class that is driven by a Myth pulse and implements
 //! variable speed
-//! \note Although concrete, for convenience, this shouldn't be used directly
 class AbstractAnimation : public QObject
 {
     Q_OBJECT
 public:
     AbstractAnimation() : m_forwards(true), m_running(false), m_speed(0.0) {}
-    virtual bool Start(bool forwards, float speed = 1.0);
+    virtual void Start(bool forwards, float speed = 1.0);
     virtual void Stop()                { m_running = false; }
     virtual void SetSpeed(float speed) { m_speed = speed; }
     virtual void Pulse(int interval) = 0;
     virtual void Clear()               {}
-    bool         IsRunning() const     { return m_running; }
 
 protected slots:
     //! To be called when animation completes
@@ -61,11 +44,9 @@ signals:
     void         finished();
 
 protected:
-    // Play direction
-    bool  m_forwards;
-    bool  m_running;
-    // Real-time = 1.0, Double-speed = 2.0
-    float m_speed;
+    bool  m_forwards; //!< Play direction
+    bool  m_running;  //!< True whilst animation is active
+    float m_speed;    //!< Real-time = 1.0, Double-speed = 2.0
 };
 
 
@@ -78,7 +59,7 @@ public:
     enum Type {None, Alpha, Position, Zoom, HorizontalZoom, VerticalZoom, Angle};
 
     Animation(Slide *image, Type type = Alpha);
-    virtual bool Start(bool forwards = true, float speed = 1.0);
+    virtual void Start(bool forwards = true, float speed = 1.0);
     virtual void Pulse(int interval);
     void         Set(QVariant from, QVariant to,
                      int duration = 500,
@@ -89,7 +70,7 @@ public:
 protected:
     //! Image to be animated
     // Should be MythUItype but that impacts elsewhere: SetZoom must become
-    // virtual, which causes compiler warnings in subtitles (fn hiding)
+    // virtual, which causes compiler (fn hiding) warnings in subtitles
     Slide            *m_parent;
     Type              m_type;
     UIEffects::Centre m_centre;
@@ -103,10 +84,10 @@ protected:
 class GroupAnimation : public AbstractAnimation
 {
 public:
-    GroupAnimation() : AbstractAnimation()                 {}
-    virtual ~GroupAnimation()                              { Clear(); }
+    GroupAnimation() : AbstractAnimation()               {}
+    virtual ~GroupAnimation()                            { Clear(); }
     virtual void Pulse(int interval)                     = 0;
-    virtual bool Start(bool forwards, float speed = 1.0) = 0;
+    virtual void Start(bool forwards, float speed = 1.0) = 0;
     virtual void SetSpeed(float speed)                   = 0;
     virtual void Add(AbstractAnimation *child);
     virtual void Clear();
@@ -124,15 +105,14 @@ class SequentialAnimation : public GroupAnimation
 public:
     SequentialAnimation() : GroupAnimation(), m_current(-1)  {}
     virtual void Pulse(int interval);
-    virtual bool Start(bool forwards, float speed = 1.0);
+    virtual void Start(bool forwards, float speed = 1.0);
     virtual void SetSpeed(float speed);
 
 protected slots:
     virtual void Finished();
 
 protected:
-    //! Index of child currently playing
-    int m_current;
+    int m_current; //!< Index of child currently playing
 };
 
 
@@ -143,15 +123,14 @@ class ParallelAnimation : public GroupAnimation
 public:
     ParallelAnimation() : GroupAnimation(), m_finished(0)  {}
     virtual void Pulse(int interval);
-    virtual bool Start(bool forwards, float speed = 1.0);
+    virtual void Start(bool forwards, float speed = 1.0);
     virtual void SetSpeed(float speed);
 
 protected slots:
     virtual void Finished();
 
 protected:
-    //! Count of child animations that have finished
-    int m_finished;
+    int m_finished; //!< Count of child animations that have finished
 };
 
 
@@ -173,52 +152,43 @@ public:
     Slide(MythUIType *parent, QString name, MythUIImage *image);
     ~Slide();
 
-    bool       Load(ImageItem *im, int direction = 0, bool waiting = false);
-    bool       Display(ImageItem *im);
-    ImageItem *GetImageData() const  { return m_data; }
-    void       Zoom(int percentage);
-    void       SetZoom(float);
-    void       SetPan(QPoint value);
-    void       Pan(QPoint distance);
-    bool       CanZoomIn() const     { return m_zoom < MAX_ZOOM; }
-    bool       CanZoomOut() const    { return m_zoom > MIN_ZOOM; }
-    void       Clear();
-    bool       IsAvailable() const   { return m_isReady; }
-    bool       FailedLoad() const    { return m_loadFailed; }
-    int        GetDirection() const  { return m_direction; }
-    void       Lock(bool set = true) { m_locked = set; }
-    bool       IsLocked() const      { return m_locked; }
-    void       Pulse();
+    void      Clear();
+    bool      LoadSlide(ImagePtrK im, int direction = 0, bool waiting = false);
+    ImagePtrK GetImageData() const  { return m_data; }
+    void      Zoom(int percentage);
+    void      SetZoom(float);
+    void      Pan(QPoint distance);
+    void      SetPan(QPoint value);
+    bool      CanZoomIn() const     { return m_zoom < MAX_ZOOM; }
+    bool      CanZoomOut() const    { return m_zoom > MIN_ZOOM; }
+    bool      IsEmpty() const       { return m_state == kEmpty || !m_waitingFor; }
+    bool      IsLoaded() const      { return m_state >= kLoaded && m_waitingFor; }
+    bool      FailedLoad() const    { return m_state == kFailed; }
+    int       GetDirection() const  { return m_direction; }
+    void      Pulse();
+
+    QChar     GetDebugState() const;
 
 public slots:
-    void       LoadComplete();
+    void      SlideLoaded();
 
 signals:
     //! Generated when the last requested image has loaded
-    void       ImageLoaded(Slide*);
+    void      ImageLoaded(Slide*);
 
 private:
-    //! Separate thread loads images from BE
-    ImageLoadingThread *m_ilt;
-    //! The image currently loading/loaded
-    ImageItem      *m_data;
-    //! The most recently requested image. Differs from m_data when skipping
-    ImageItem      *m_waitingFor;
-    //! Current zoom, 1.0 = fullsize
-    float           m_zoom;
-    //! True when image is available for display
-    bool            m_isReady;
-    //! True when image load failed (it's disappeared or BE is down)
-    bool            m_loadFailed;
-    bool            m_locked;
+    enum SlideState { kEmpty, kLoading, kLoaded, kFailed }; // Order is significant
+
+    SlideState    m_state;        //!< Slide validity
+    ImagePtrK     m_data;         //!< The image currently loading/loaded
+    //! The most recently requested image. Null for preloads. Differs from m_data when skipping
+    ImagePtrK     m_waitingFor;
+    float         m_zoom;         //!< Current zoom, 1.0 = fullsize
     //! Navigation that created this image, -1 = Prev, 0 = Update, 1 = Next
-    int             m_direction;
-    //! Dedicated animation for zoom
-    Animation      *m_zoomAnimation;
-    //! Dedicated animation for panning
-    PanAnimation   *m_panAnimation;
-    //! Pan position (0,0) = no pan
-    QPoint          m_pan;
+    int           m_direction;
+    Animation    *m_zoomAnimation;//!< Dedicated animation for zoom, if supported
+    PanAnimation *m_panAnimation; //!< Dedicated animation for panning, if supported
+    QPoint        m_pan;          //!< Pan position (0,0) = no pan
 };
 
 
@@ -227,35 +197,51 @@ private:
  \details Slides are cloned from a theme-provided image definition, so are
  created at start-up and re-used (a pool).
  Image requests are assigned to successive slides. When loaded a slide becomes
- available for display in requested order (a queue). When displayed the head
- slide is removed from the queue and returned to the tail for re-use only when
- it is no longer displayed. If a rapid batch of requests fill the buffer then
- subsequent requests overwrite the last slide, discarding the previous image
- (jumping behaviour)
+ available for display in requested order (a queue).
+ The head slide is the one displayed, its successor is also displayed during a
+ transition. When a transition completes the head slide is removed and returned
+ to the tail for re-use.
+ If a rapid batch of requests fill the buffer then subsequent requests overwrite
+ the last slide, discarding the previous image (jumping behaviour).
 */
 class SlideBuffer : public QObject
 {
     Q_OBJECT
 public:
-    SlideBuffer(MythUIImage *image, int size);
+    SlideBuffer() : m_mutexQ(QMutex::Recursive), m_nextLoad(0) {}
     ~SlideBuffer();
-    bool Load(ImageItem *im, int direction);
-    void Preload(ImageItem *im);
-    Slide* TakeNext();
-    int Release(Slide*);
+
+    void   Initialise(MythUIImage &image);
+    void   Teardown();
+    bool   Load(ImagePtrK im, int direction);
+    void   Preload(ImagePtrK im);
+    void   ReleaseCurrent();
+    Slide &GetCurrent()
+    {
+        QMutexLocker lock(&m_mutexQ);
+        return *(m_queue.head());
+    }
+
+    Slide  &GetNext()
+    {
+        QMutexLocker lock(&m_mutexQ);
+        return *(m_queue.at(1));
+    }
 
 signals:
     //! Signals that buffer has (count) loaded slides awaiting display
     void SlideReady(int count);
 
 private slots:
-    int FlushAvailable(Slide*, QString reason = "Loaded");
+    void Flush(Slide*, QString reason = "Loaded");
 
 protected:
-    //! Queue of slides awaiting display, loading or spare
-    QQueue<Slide*> m_queue;
-    //! Queue index of first spare slide, or last slide if none spare
-    int m_nextLoad;
+    QString BufferState();
+
+    // Must be recursive to enable Flush->signal->Get whilst retaining lock
+    QMutex         m_mutexQ;   //!< Queue protection
+    QQueue<Slide*> m_queue;    //!< Queue of slides
+    int            m_nextLoad; //!< Index of first spare slide, (or last slide if none spare)
 };
 
 #endif // GALLERYSLIDE_H
diff --git a/mythtv/programs/mythfrontend/galleryslideview.cpp b/mythtv/programs/mythfrontend/galleryslideview.cpp
index 4f360f3..06e9808 100644
--- a/mythtv/programs/mythfrontend/galleryslideview.cpp
+++ b/mythtv/programs/mythfrontend/galleryslideview.cpp
@@ -1,70 +1,55 @@
 #include "galleryslideview.h"
 
-#include <mythmainwindow.h>
-#include <mythuitext.h>
+#include "mythmainwindow.h"
+#include "mythuitext.h"
+#include "mythdialogbox.h"
 
-#include "gallerycommhelper.h"
+#include "galleryviews.h"
 
+#define LOC QString("Slideview: ")
 
-// Numbers of slides to use for buffering image requests.
-// Each will remotely load its image from BE so too many will hamper performance
-// Fewer will result in jumping between slides rather than flicking quickly through them
-// Minimum is 3: 2 for displaying a transition, 1 to handle load requests
-// Reasonable range is 4 - 16 ?
-#define SLIDE_BUFFER_SIZE 8
 
 /**
  *  \brief  Constructor
  *  \param  parent The screen parent
  *  \param  name The name of the screen
  */
-GallerySlideView::GallerySlideView(MythScreenStack *parent,
-                                   const char *name)
+GallerySlideView::GallerySlideView(MythScreenStack *parent, const char *name,
+                                   bool editsAllowed)
     : MythScreenType(parent, name),
-    m_uiImage(NULL),
-    m_uiStatus(NULL),
-    m_uiSlideCount(NULL), m_uiCaptionText(NULL), m_uiHideCaptions(NULL),
-    m_slideShowType(kBrowseSlides),
-    m_slideShowTime(gCoreContext->GetNumSetting("GallerySlideShowTime", 3000)),
-    m_paused(false),
-    m_suspended(false),
-    m_showCaptions(gCoreContext->GetNumSetting("GalleryShowSlideCaptions",
-                                               true)),
-    m_infoList(NULL),
-    m_view(NULL),
-    m_slides(NULL),
-    m_slideCurrent(NULL),
-    m_slideNext(NULL),
-    m_pending(0),
-    m_availableTransitions(GetMythPainter()->SupportsAnimation()),
-    m_updateTransition()
+      m_uiImage(NULL),
+      m_uiStatus(NULL),
+      m_uiSlideCount(NULL), m_uiCaptionText(NULL), m_uiHideCaptions(NULL),
+      m_mgr(ImageManagerFe::getInstance()),
+      m_view(NULL),
+      m_availableTransitions(GetMythPainter()->SupportsAnimation()),
+      m_transition(m_availableTransitions.Select(
+                       gCoreContext->GetNumSetting("GalleryTransitionType",
+                                                   kBlendTransition))),
+      m_updateTransition(),
+      m_slides(),
+      m_infoList(*this),
+      m_slideShowTime(gCoreContext->GetNumSetting("GallerySlideShowTime", 3000)),
+      m_playing(false),
+      m_suspended(false),
+      m_showCaptions(gCoreContext->GetNumSetting("GalleryShowSlideCaptions", true)),
+      m_transitioning(false),
+      m_editsAllowed(editsAllowed)
 {
-    // Get notified when update Transition completes
+    // Detect when transitions finish. Queued signal to allow redraw/pulse to
+    // complete before handling event.
+    connect(&m_transition, SIGNAL(finished()),
+            this, SLOT(TransitionComplete()), Qt::QueuedConnection);
     connect(&m_updateTransition, SIGNAL(finished()),
-            this, SLOT(TransitionComplete()));
+            this, SLOT(TransitionComplete()), Qt::QueuedConnection);
 
-    // Initialise transition
-    int setting = gCoreContext->GetNumSetting("GalleryTransitionType",
-                                              kBlendTransition);
-    m_transition = m_availableTransitions.Select(setting);
-
-    // Transitions signal when complete
-    connect(m_transition, SIGNAL(finished()), this, SLOT(TransitionComplete()));
-
-    // Used by random transition
+    // Seed random generator for random transitions
     qsrand(QTime::currentTime().msec());
 
-    // Slideshow timer
-    m_timer = new QTimer();
-    m_timer->setSingleShot(true);
-    m_timer->setInterval(m_slideShowTime);
-    connect(m_timer, SIGNAL(timeout()), this, SLOT(ShowNextSlide()));
-
-    // Filter db reads using current settings.
-    // These can't change whilst slideshow is displayed.
-    m_db = new ImageDbReader(gCoreContext->GetNumSetting("GallerySortOrder"),
-                             gCoreContext->GetNumSetting("GalleryShowHidden"),
-                             gCoreContext->GetNumSetting("GalleryShowType"));
+    // Initialise slideshow timer
+    m_timer.setSingleShot(true);
+    m_timer.setInterval(m_slideShowTime);
+    connect(&m_timer, SIGNAL(timeout()), this, SLOT(ShowNextSlide()));
 }
 
 
@@ -73,13 +58,8 @@ GallerySlideView::GallerySlideView(MythScreenStack *parent,
  */
 GallerySlideView::~GallerySlideView()
 {
-    delete m_timer;
-    delete m_infoList;
     delete m_view;
-    delete m_slides;
-    delete m_slideCurrent;
-    delete m_slideNext;
-    delete m_db;
+    LOG(VB_GUI, LOG_DEBUG, "Deleted Slideview");
 }
 
 
@@ -100,36 +80,31 @@ bool GallerySlideView::Create()
     UIUtilW::Assign(this, m_uiCaptionText, "caption");
     UIUtilW::Assign(this, m_uiHideCaptions, "hidecaptions");
 
-    // File details list is managed elsewhere
-    m_infoList = InfoList::Create(this, true, tr("Not defined"));
-
-    if (err || !m_infoList)
+    if (err)
     {
-        LOG(VB_GENERAL, LOG_ERR, "Slideview: Cannot load screen 'Slideshow'");
+        LOG(VB_GENERAL, LOG_ERR, LOC + "Cannot load screen 'Slideshow'");
         return false;
     }
 
-    // Create display buffer
-    m_slides = new SlideBuffer(m_uiImage, SLIDE_BUFFER_SIZE);
-
-    // Use empty slide to transition from
-    m_slideCurrent = m_slides->TakeNext();
-    if (!m_slideCurrent)
+    // Initialise details list
+    if (!m_infoList.Create(true))
     {
-        LOG(VB_GENERAL, LOG_ERR, "Slideview: Failed to initialise Slideshow");
+        LOG(VB_GENERAL, LOG_ERR, LOC + "Cannot load 'Info buttonlist'");
         return false;
     }
 
+    // Create display buffer
+    m_slides.Initialise(*m_uiImage);
+
     if (m_uiHideCaptions)
         m_uiHideCaptions->SetText(m_showCaptions ? "" : tr("Hide"));
 
     BuildFocusList();
     SetFocusWidget(m_uiImage);
 
-    // Get notified when a slide is ready for display. Must be queued to
-    // avoid event recursion, ie. event handlers must complete before new
-    // slide notifications are processed.
-    connect(m_slides, SIGNAL(SlideReady(int)),
+    // Detect when slides are available for display.
+    // Queue so that keypress events always complete before transition starts
+    connect(&m_slides, SIGNAL(SlideReady(int)),
             this, SLOT(SlideAvailable(int)), Qt::QueuedConnection);
 
     return true;
@@ -142,25 +117,12 @@ bool GallerySlideView::Create()
 void GallerySlideView::Pulse()
 {
     // Update transition animations
-    if (m_transition)
-        m_transition->Pulse(GetMythMainWindow()->GetDrawInterval());
+    m_transition.Pulse(GetMythMainWindow()->GetDrawInterval());
 
     MythScreenType::Pulse();
 }
 
 
-/*!
- \brief Update changed images
- \param id Image that has changed
-*/
-void GallerySlideView::ThumbnailChange(int id)
-{
-    if (m_view->Update(id))
-        // Current image has changed, so redisplay
-        ShowSlide();
-}
-
-
 /**
  *  \brief  Handle keypresses
  *  \param  event The pressed key
@@ -171,9 +133,8 @@ bool GallerySlideView::keyPressEvent(QKeyEvent *event)
     if (GetFocusWidget()->keyPressEvent(event))
         return true;
 
-    bool        handled = false;
     QStringList actions;
-    handled = GetMythMainWindow()->TranslateKeyPress("Images", event, actions);
+    bool handled = GetMythMainWindow()->TranslateKeyPress("Images", event, actions);
 
     for (int i = 0; i < actions.size() && !handled; i++)
     {
@@ -188,19 +149,13 @@ bool GallerySlideView::keyPressEvent(QKeyEvent *event)
             ShowInfo();
         else if (action == "MENU")
             MenuMain();
-        else if (action == "SLIDESHOW")
+        else if (action == "PLAY")
         {
-            // If a slideshow is active then pause/un-pause it
-            // Otherwise start a normal one
-            if (m_slideShowType == kBrowseSlides)
-                StartNormal();
-            else if (m_paused)
-                Resume();
+            if (m_playing)
+                Stop();
             else
-                Pause();
+                Play();
         }
-        else if (action == "PAUSE")
-            Pause();
         else if (action == "SELECT")
             PlayVideo();
         else if (action == "STOP")
@@ -230,23 +185,13 @@ bool GallerySlideView::keyPressEvent(QKeyEvent *event)
         else if (action == "RECENTER")
             Pan();
         else if (action == "ESCAPE" && !GetMythMainWindow()->IsExitingToMain())
-        {
             // Exit info details, if shown
-            handled = m_infoList->Hide();
-            if (!handled)
-            {
-                // We're exiting - update gallerythumbview selection
-                ImageItem *im = m_view->GetSelected();
-                if (im)
-                    emit ImageSelected(im->m_id);
-            }
-        }
+            handled = m_infoList.Hide();
         else
             handled = false;
     }
 
     if (!handled)
-
         handled = MythScreenType::keyPressEvent(event);
 
     return handled;
@@ -259,7 +204,28 @@ bool GallerySlideView::keyPressEvent(QKeyEvent *event)
  */
 void GallerySlideView::customEvent(QEvent *event)
 {
-    if (event->type() == DialogCompletionEvent::kEventType)
+    if ((MythEvent::Type)(event->type()) == MythEvent::MythEventMessage)
+    {
+        MythEvent *me      = (MythEvent *)event;
+        QString    message = me->Message();
+
+        QStringList extra = me->ExtraDataList();
+
+        if (message == "IMAGE_METADATA" && !extra.isEmpty())
+        {
+            int id = extra[0].toInt();
+            ImagePtrK selected = m_view->GetSelected();
+
+            if (selected && selected->m_id == id)
+                m_infoList.Display(*selected, extra.mid(1));
+        }
+        else if (message == "THUMB_AVAILABLE")
+        {
+            if (!extra.isEmpty() && m_view->Update(extra[0].toInt()))
+                ShowSlide(0);
+        }
+    }
+    else if (event->type() == DialogCompletionEvent::kEventType)
     {
         DialogCompletionEvent *dce = (DialogCompletionEvent *)(event);
 
@@ -270,13 +236,13 @@ void GallerySlideView::customEvent(QEvent *event)
         {
             switch (buttonnum)
             {
-                case 0: Transform(kRotateCW); break;
-                case 1: Transform(kRotateCCW); break;
-                case 2: Transform(kFlipHorizontal); break;
-                case 3: Transform(kFlipVertical); break;
-                case 4: Transform(kResetExif); break;
-                case 5: Zoom(10); break;
-                case 6: Zoom(-10); break;
+            case 0: Transform(kRotateCW); break;
+            case 1: Transform(kRotateCCW); break;
+            case 2: Transform(kFlipHorizontal); break;
+            case 3: Transform(kFlipVertical); break;
+            case 4: Transform(kResetToExif); break;
+            case 5: Zoom(10); break;
+            case 6: Zoom(-10); break;
             }
         }
     }
@@ -289,31 +255,23 @@ void GallerySlideView::customEvent(QEvent *event)
 void GallerySlideView::MenuMain()
 {
     // Create the main menu that will contain the submenus above
-    MythMenu *menu =
-        new MythMenu(tr("Slideshow Options"), this, "mainmenu");
+    MythMenu *menu = new MythMenu(tr("Slideshow Options"), this, "mainmenu");
 
-    ImageItem *im = m_slideCurrent->GetImageData();
+    ImagePtrK im = m_slides.GetCurrent().GetImageData();
     if (im && im->m_type == kVideoFile)
         menu->AddItem(tr("Play Video"), SLOT(PlayVideo()));
 
-    if (m_slideShowType == kBrowseSlides)
-    {
-        menu->AddItem(tr("Start SlideShow"),
-                      SLOT(StartNormal()));
-        menu->AddItem(tr("Start Recursive SlideShow"),
-                      SLOT(StartRecursive()));
-    }
+    if (m_playing)
+        menu->AddItem(tr("Stop"), SLOT(Stop()));
     else
-    {
-        if (m_paused)
-            menu->AddItem(tr("Resume"), SLOT(Resume()));
-        else
-            menu->AddItem(tr("Pause"), SLOT(Pause()));
+        menu->AddItem(tr("Start SlideShow"), SLOT(Play()));
 
-        menu->AddItem(tr("Stop"), SLOT(Stop()));
-    }
+    if (gCoreContext->GetNumSetting("GalleryRepeat", 0))
+        menu->AddItem(tr("Turn Repeat Off"), SLOT(RepeatOff()));
+    else
+        menu->AddItem(tr("Turn Repeat On"), SLOT(RepeatOn()));
 
-    MenuTransforms(menu);
+    MenuTransforms(*menu);
 
     if (m_uiHideCaptions)
     {
@@ -324,16 +282,16 @@ void GallerySlideView::MenuMain()
     }
 
     QString details;
-    switch (m_infoList->GetState())
+    switch (m_infoList.GetState())
     {
-        case kBasicInfo: details = tr("More Details"); break;
-        case kFullInfo: details  = tr("Less Details"); break;
-        default:
-        case kNoInfo: details = tr("Show Details"); break;
+    case kBasicInfo: details = tr("More Details"); break;
+    case kFullInfo:  details = tr("Less Details"); break;
+    default:
+    case kNoInfo:    details = tr("Show Details"); break;
     }
     menu->AddItem(details, SLOT(ShowInfo()));
 
-    if (m_infoList->GetState() != kNoInfo)
+    if (m_infoList.GetState() != kNoInfo)
         menu->AddItem(tr("Hide Details"), SLOT(HideInfo()));
 
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
@@ -349,15 +307,14 @@ void GallerySlideView::MenuMain()
  *  \brief  Add Transforms submenu
  *  \param  mainMenu Parent menu
  */
-void GallerySlideView::MenuTransforms(MythMenu *mainMenu)
+void GallerySlideView::MenuTransforms(MythMenu &mainMenu)
 {
-    ImageItem *im = m_slideCurrent->GetImageData();
-    if (im && SlideShowNotActive())
+    ImagePtrK im = m_slides.GetCurrent().GetImageData();
+    if (im && !m_playing)
     {
         MythMenu *menu = new MythMenu(tr("Transform Options"),
                                       this, "metadatamenu");
-
-        if (im->m_type == kImageFile)
+        if (m_editsAllowed)
         {
             menu->AddItem(tr("Rotate CW"));
             menu->AddItem(tr("Rotate CCW"));
@@ -365,13 +322,14 @@ void GallerySlideView::MenuTransforms(MythMenu *mainMenu)
             menu->AddItem(tr("Flip Vertical"));
             menu->AddItem(tr("Reset to Exif"));
         }
-        if (m_slideCurrent->CanZoomIn())
+
+        if (m_slides.GetCurrent().CanZoomIn())
             menu->AddItem(tr("Zoom In"));
 
-        if (m_slideCurrent->CanZoomOut())
+        if (m_slides.GetCurrent().CanZoomOut())
             menu->AddItem(tr("Zoom Out"));
 
-        mainMenu->AddItem(tr("Transforms"), NULL, menu);
+        mainMenu.AddItem(tr("Transforms"), NULL, menu);
     }
 }
 
@@ -382,19 +340,14 @@ void GallerySlideView::MenuTransforms(MythMenu *mainMenu)
  \param view View to initialise slideshow from.
  \param newScreen True if starting from Thumbview, False otherwise
 */
-void GallerySlideView::Start(ImageSlideShowType type, int parentId,
-                             int selectedId, bool newScreen)
+void GallerySlideView::Start(ImageSlideShowType type, int parentId, int selectedId)
 {
-    // Cleanup any current slideshow
-    Stop();
-    delete m_view;
-
-    m_slideShowType = type;
+    gCoreContext->addListener(this);
 
     if (type == kBrowseSlides)
     {
         // Browsing views a single ordered directory
-        m_view = new FlatView(kOrdered, m_db);
+        m_view = new FlatView(kOrdered);
 
         // Load db images
         m_view->LoadFromDb(parentId);
@@ -407,70 +360,69 @@ void GallerySlideView::Start(ImageSlideShowType type, int parentId,
     }
     else
     {
-        int orderInt = gCoreContext->GetNumSetting("GallerySlideOrder",
-                                                   kOrdered);
+        int orderInt = gCoreContext->GetNumSetting("GallerySlideOrder", kOrdered);
 
-        SlideOrderType order = orderInt < kOrdered || orderInt > kSeasonal
+        SlideOrderType order = (orderInt < kOrdered) || (orderInt > kSeasonal)
                 ? kOrdered
                 : static_cast<SlideOrderType>(orderInt);
 
         // Recursive uses a view of a directory subtree; Normal views a single directory
-        m_view = (type == kRecursiveSlideShow)
-                ? new TreeView(order, m_db) : new FlatView(order, m_db);
-
+        m_view = (type == kRecursiveSlideShow) ? new TreeView(order)
+                                               : new FlatView(order);
         // Load db images
         m_view->LoadFromDb(parentId);
 
         // Ordered views start from selected image
         if (order == kOrdered)
-            // Adjust list so that slideshows show count rather than position
-            // Start at selection for new screens; old screens start at the subsequent
-            // image (they're already showing the selected)
-            m_view->Rotate(selectedId, newScreen ? 0 : 1);
-
-        // Show first image, immediately for new screens
-        ShowNextSlide(!newScreen);
+            // Adjust view so that slideshows show count rather than position
+            m_view->Rotate(selectedId);
 
-        // Start slideshow
-        Resume();
+        // No transition for first image
+        Play(false);
     }
 }
 
 
-/**
- *  \brief  Stops an active slideshow
- */
-void GallerySlideView::Stop()
+void GallerySlideView::Close()
 {
-    m_timer->stop();
-    m_slideShowType = kBrowseSlides;
-    if (m_uiStatus)
-        // Clear paused text
-        m_uiStatus->SetVisible(false);
+    gCoreContext->removeListener(this);
+
+    // Stop further loads
+    m_slides.Teardown();
+
+    // Update gallerythumbview selection
+    ImagePtrK im = m_view->GetSelected();
+    if (im)
+        emit ImageSelected(im->m_id);
+
+    MythScreenType::Close();
 }
 
 
 /**
- *  \brief  Pauses an active slideshow
+ *  \brief Stop a playing slideshow
  */
-void GallerySlideView::Pause()
+void GallerySlideView::Stop()
 {
-    m_timer->stop();
-    m_paused = true;
-    SetStatus(tr("Paused"));
+    m_playing = false;
+    m_timer.stop();
+    SetStatus(tr("Stopped"));
 }
 
 
 /**
- *  \brief  Resumes a paused slideshow
+ *  \brief Start a slideshow
  */
-void GallerySlideView::Resume()
+void GallerySlideView::Play(bool useTransition)
 {
-    m_paused = false;
-    if (m_uiStatus)
-        m_uiStatus->SetVisible(false);
+    // Start from next slide
+    ShowNextSlide(useTransition);
+
+    m_playing = true;
     if (!m_suspended)
-        m_timer->start();
+        m_timer.start();
+    if (m_uiStatus)
+        SetStatus(tr("Playing"));
 }
 
 
@@ -479,7 +431,7 @@ void GallerySlideView::Resume()
 */
 void GallerySlideView::Suspend()
 {
-    m_timer->stop();
+    m_timer.stop();
     m_suspended = true;
 }
 
@@ -490,8 +442,8 @@ void GallerySlideView::Suspend()
 void GallerySlideView::Release()
 {
     m_suspended = false;
-    if (!m_paused && m_slideShowType != kBrowseSlides)
-        m_timer->start();
+    if (m_playing)
+        m_timer.start();
 }
 
 
@@ -501,12 +453,12 @@ void GallerySlideView::Release()
 */
 void GallerySlideView::Transform(ImageFileTransform state)
 {
-    ImageItem *im = m_view->GetSelected();
-    if (im && SlideShowNotActive())
+    ImagePtrK im = m_view->GetSelected();
+    if (im && !m_playing)
     {
         ImageIdList list;
         list.append(im->m_id);
-        QString err = GalleryBERequest::ChangeOrientation(state, list);
+        QString err = m_mgr.ChangeOrientation(state, list);
         if (!err.isEmpty())
             ShowOkPopup(err);
     }
@@ -519,8 +471,8 @@ void GallerySlideView::Transform(ImageFileTransform state)
 */
 void GallerySlideView::Zoom(int increment)
 {
-    if (SlideShowNotActive())
-        m_slideCurrent->Zoom(increment);
+    if (!m_playing)
+        m_slides.GetCurrent().Zoom(increment);
 }
 
 
@@ -530,8 +482,8 @@ void GallerySlideView::Zoom(int increment)
 */
 void GallerySlideView::Pan(QPoint offset)
 {
-    if (SlideShowNotActive())
-        m_slideCurrent->Pan(offset);
+    if (!m_playing)
+        m_slides.GetCurrent().Pan(offset);
 }
 
 
@@ -540,9 +492,7 @@ void GallerySlideView::Pan(QPoint offset)
 */
 void GallerySlideView::ShowInfo()
 {
-    ImageItem *im = m_slideCurrent->GetImageData();
-    if (im)
-        m_infoList->Toggle(im);
+    m_infoList.Toggle(m_slides.GetCurrent().GetImageData());
 }
 
 
@@ -551,7 +501,7 @@ void GallerySlideView::ShowInfo()
 */
 void GallerySlideView::HideInfo()
 {
-    m_infoList->Hide();
+    m_infoList.Hide();
 }
 
 
@@ -581,82 +531,72 @@ void GallerySlideView::HideCaptions()
 */
 void GallerySlideView::ShowSlide(int direction)
 {
-    ImageItem *im = m_view->GetSelected();
+    ImagePtrK im = m_view->GetSelected();
     if (!im)
         // Reached view limits
         return;
 
-    LOG(VB_FILE, LOG_DEBUG, QString("Slideview: Gallery showing %1")
-        .arg(im->m_fileName));
+    LOG(VB_FILE, LOG_DEBUG, LOC + QString("Selected %1").arg(im->m_filePath));
 
     // Suspend the timer until the transition has finished
     Suspend();
 
     // Load image from file
-    if (!m_slides->Load(im, direction))
+    if (!m_slides.Load(im, direction))
         // Image not yet available: show loading status
         SetStatus(tr("Loading"));
 }
 
 
 /*!
- \brief Calculates transition speed factor
- \details x0.5 for every slide waiting. Min = x1, Max = Half buffer size, so
- that buffer retains enough free slots
- \param available Number of slides ready for display
- \return float Factor to speed up transition by
-*/
-static float Speed(int available)
-{
-    return qMin(1.0 + available / 2.0, SLIDE_BUFFER_SIZE / 2.0);
-}
-
-
-/*!
  \brief Start transition
  \details Displays image that has just loaded
- \param pic Gallery cyclic slide that has loaded the image
- \param direction Navigation direction
- \param skipping True if multiple requests have been received. Transitions will
- be accelerated
+ \param count Number of slides ready for display
 */
 void GallerySlideView::SlideAvailable(int count)
 {
+    // Transition speed = 0.5x for every slide waiting. Min = 1x, Max = Half buffer size
+    float speed = 0.5 + count / 2.0;
+
     // Are we transitioning ?
-    if (m_slideNext)
+    if (m_transitioning)
     {
         // More slides waiting for display: accelerate current transition
-        m_transition->SetSpeed(Speed(count));
+        LOG(VB_FILE, LOG_DEBUG, LOC + QString("Changing speed to %1").arg(speed));
+        m_transition.SetSpeed(speed);
         return;
     }
 
     // We've been waiting for this slide: transition immediately
-    // Reset any zoom/pan first
-    Pan();
-    Zoom();
+    m_transitioning = true;
 
     // Take next slide
-    m_slideNext = m_slides->TakeNext();
+    Slide &next = m_slides.GetNext();
 
     // Update loading status
     if (m_uiStatus)
     {
-        if (!m_slideNext->FailedLoad())
+        if (!next.FailedLoad())
 
             m_uiStatus->SetVisible(false);
 
-        else if (ImageItem *im = m_slideNext->GetImageData())
+        else if (ImagePtrK im = next.GetImageData())
 
-            SetStatus(tr("Failed to load %1").arg(im->m_name));
+            SetStatus(tr("Failed to load %1").arg(im->m_filePath));
     }
 
-    int direction = m_slideNext->GetDirection();
+    // Update slide counts
+    if (m_uiSlideCount)
+        m_uiSlideCount->SetText(m_view->GetPosition());
+
+    int direction = next.GetDirection();
 
     // Use special transition for updates/start-up
-    Transition *transition = (direction == 0) ? &m_updateTransition : m_transition;
+    Transition &transition = (direction == 0) ? m_updateTransition : m_transition;
 
-    // Start transition, transitioning quickly if more slides waiting
-    transition->Start(m_slideCurrent, m_slideNext, direction >= 0, Speed(m_pending));
+    // Reset any zoom before starting transition
+    Zoom();
+    transition.Start(m_slides.GetCurrent(), next, direction >= 0, speed);
 }
 
 
@@ -668,37 +608,32 @@ void GallerySlideView::SlideAvailable(int count)
 */
 void GallerySlideView::TransitionComplete()
 {
-    // Release old slide. May cause further transitions but they won't be handled
-    // until we've finished here
-    m_pending = m_slides->Release(m_slideCurrent);
-
-    m_slideCurrent = m_slideNext;
-    m_slideNext    = NULL;
-
-    // Update slide counts
-    if (m_uiSlideCount)
-        m_uiSlideCount->SetText(m_view->GetPosition());
+    if (m_IsDeleting)
+        return;
 
-    ImageItem *im = m_slideCurrent->GetImageData();
+    m_transitioning = false;
 
-    LOG(VB_FILE, LOG_DEBUG, QString("Slideview: Finished transition to %1")
-        .arg(im->m_fileName));
+    // Release old slide, which may start a new transition
+    m_slides.ReleaseCurrent();
 
     // No further actions when skipping
-    if (m_pending > 0)
+    if (m_transitioning)
         return;
 
     // Preload next slide, if any
-    m_slides->Preload(m_view->HasNext());
+    m_slides.Preload(m_view->HasNext());
+
+    // Populate display for new slide
+    ImagePtrK im  = m_slides.GetCurrent().GetImageData();
 
     // Update any file details information
-    m_infoList->Update(im);
+    m_infoList.Update(im);
 
-    if (m_uiCaptionText)
+    if (im && m_uiCaptionText)
     {
         // show the date & comment
         QStringList text;
-        text << ImageUtils::ImageDateOf(im);
+        text << m_mgr.LongDateOf(im);
 
         if (!im->m_comment.isEmpty())
             text << im->m_comment;
@@ -709,11 +644,10 @@ void GallerySlideView::TransitionComplete()
     // Start any video unless we're paused or browsing
     if (im && im->m_type == kVideoFile)
     {
-        if (m_paused || m_slideShowType == kBrowseSlides)
-
-            SetStatus(tr("Video"));
-        else
+        if (m_playing)
             PlayVideo();
+        else
+            SetStatus(tr("Video"));
     }
 
     // Resume slideshow timer
@@ -726,7 +660,11 @@ void GallerySlideView::TransitionComplete()
 */
 void GallerySlideView::ShowPrevSlide()
 {
-    if (m_view->Prev())
+    if (m_playing && m_view->HasPrev() == NULL)
+        // Prohibit back-wrapping during slideshow: it will cause premature end
+        SetStatus(tr("Start"));
+
+    else if (m_view->Prev())
         ShowSlide(-1);
 }
 
@@ -738,8 +676,7 @@ void GallerySlideView::ShowPrevSlide()
 void GallerySlideView::ShowNextSlide(bool useTransition)
 {
     // Browsing always wraps; slideshows depend on repeat setting
-    if (!m_view->HasNext()
-            && m_slideShowType != kBrowseSlides
+    if (m_playing && m_view->HasNext() == NULL
             && !gCoreContext->GetNumSetting("GalleryRepeat", false))
     {
         Stop();
@@ -752,8 +689,8 @@ void GallerySlideView::ShowNextSlide(bool useTransition)
         // No images
         Stop();
         SetStatus(tr("Empty"));
-        m_infoList->Hide();
-        m_slideCurrent->Clear();
+        m_infoList.Hide();
+        m_slides.GetCurrent().Clear();
         if (m_uiSlideCount)
             m_uiSlideCount->SetText(tr("None"));
         if (m_uiCaptionText)
@@ -767,16 +704,13 @@ void GallerySlideView::ShowNextSlide(bool useTransition)
 */
 void GallerySlideView::PlayVideo()
 {
-    if (!m_slideCurrent || m_slideCurrent->FailedLoad())
+    if (m_slides.GetCurrent().FailedLoad())
         return;
 
-    ImageItem *im = m_slideCurrent->GetImageData();
+    ImagePtrK im = m_slides.GetCurrent().GetImageData();
 
     if (im && im->m_type == kVideoFile)
-    {
-        QString url = ImageSg::getInstance()->GenerateUrl(im->m_fileName);
-        GetMythMainWindow()->HandleMedia("Internal", url);
-    }
+        GetMythMainWindow()->HandleMedia("Internal", im->m_url);
 }
 
 
diff --git a/mythtv/programs/mythfrontend/galleryslideview.h b/mythtv/programs/mythfrontend/galleryslideview.h
index 89a71a2..575e044 100644
--- a/mythtv/programs/mythfrontend/galleryslideview.h
+++ b/mythtv/programs/mythfrontend/galleryslideview.h
@@ -4,18 +4,12 @@
 #ifndef GALLERYWIDGET_H
 #define GALLERYWIDGET_H
 
-#include <QTimer>
-#include <QEvent>
-#include <QPoint>
-
-#include <mythscreentype.h>
-#include <mythdialogbox.h>
-#include <imagemetadata.h>
-
 #include "gallerytransitions.h"
-#include "galleryviews.h"
-#include "galleryslide.h"
+#include "galleryinfo.h"
+
 
+class MythMenu;
+class FlatView;
 
 //! Type of slide show
 enum ImageSlideShowType {
@@ -25,21 +19,19 @@ enum ImageSlideShowType {
 };
 
 
-//! \brief Slideshow screen
+//! Slideshow screen
 class GallerySlideView : public MythScreenType
 {
     Q_OBJECT
 public:
-    GallerySlideView(MythScreenStack *parent,
-                     const char *name);
+    GallerySlideView(MythScreenStack *parent, const char *name, bool editsAllowed);
     ~GallerySlideView();
     bool Create();
 
 public slots:
-    void Start(ImageSlideShowType type, int parentId, int selectedId = 0,
-               bool newScreen = true);
+    void Start(ImageSlideShowType type, int parentId, int selectedId = 0);
+    void Close();
     void Pulse();
-    void ThumbnailChange(int id);
 
 signals:
     void ImageSelected(int);
@@ -48,14 +40,12 @@ private:
     bool keyPressEvent(QKeyEvent *);
     void customEvent(QEvent *);
     void MenuMain();
-    void MenuTransforms(MythMenu *);
+    void MenuTransforms(MythMenu &);
     void Suspend();
     void Release();
     void Transform(ImageFileTransform);
     void Zoom(int = 0);
     void Pan(QPoint = QPoint(0, 0));
-    bool SlideShowNotActive()
-    { return m_slideShowType == kBrowseSlides || m_paused; }
     void SetStatus(QString msg);
 
 private slots:
@@ -64,13 +54,10 @@ private slots:
     void SlideAvailable(int count);
     void TransitionComplete();
     void ShowSlide(int direction = 0);
-    void StartNormal()     { Start(kNormalSlideShow, m_view->GetParentId(),
-                                   m_view->GetSelected()->m_id, false); }
-    void StartRecursive()  { Start(kRecursiveSlideShow, m_view->GetParentId(),
-                                   m_view->GetSelected()->m_id, false); }
     void Stop();
-    void Pause();
-    void Resume();
+    void Play(bool useTransition = true);
+    void RepeatOn(int on = 1)   { gCoreContext->SaveSetting("GalleryRepeat", on); }
+    void RepeatOff()            { RepeatOn(0); }
     void ShowInfo();
     void HideInfo();
     void ShowCaptions();
@@ -82,42 +69,24 @@ private:
     MythUIImage *m_uiImage;
     MythUIText  *m_uiStatus, *m_uiSlideCount, *m_uiCaptionText, *m_uiHideCaptions;
 
-    ImageSlideShowType m_slideShowType;
-    int          m_slideShowTime;
-    QTimer      *m_timer;
-    bool         m_paused, m_suspended, m_showCaptions;
-
-    //! Image details overlay
-    InfoList *m_infoList;
-
-    //! List of images in the slideshow
-    FlatView *m_view;
-
-    //! \brief A queue of slides used to display images.
-    //! \details Image requests go to successive slides. When loaded the slide is available
-    //! for display. The head is removed once it is displayed. When no longer on display
-    //! it is returned to the back of the queue for re-use.
-    SlideBuffer *m_slides;
-
-    //! Slide currently displayed or being transitioned from
-    Slide *m_slideCurrent;
-    //! Slide being transitioned to, NULL if no transition in progress.
-    Slide *m_slideNext;
-
-    //! Number of slides waiting to be displayed
-    int m_pending;
+    ImageManagerFe &m_mgr;  //!< Manages the images
+    FlatView       *m_view; //!< List of images comprising the slideshow
 
-    //! Transitions available
-    TransitionRegistry m_availableTransitions;
-    //! Selected transition
-    Transition *m_transition;
+    TransitionRegistry m_availableTransitions; //!< Transitions available
+    Transition        &m_transition;           //!< Selected transition
     //! Instant transition that is always used for start-up & image updates
-    TransitionNone m_updateTransition;
+    TransitionNone     m_updateTransition;
+
+    SlideBuffer m_slides;        //!< A queue of slides used to display images.
+    InfoList    m_infoList;      //!< Image details overlay
+    int         m_slideShowTime; //!< Time to display a slide in a slideshow
+    QTimer      m_timer;         //!< Slide duration timer
+    bool        m_playing;       //!< True when slideshow is running
+    bool        m_suspended;     //!< True when transition is running or video playing
+    bool        m_showCaptions;  //!< If true, captions are shown
+    bool        m_transitioning; //!< True when a transition is in progress
+    bool        m_editsAllowed;  //!< True when edits are enabled
 
-    //! \brief Filtered view of the image database
-    //! \details A helper that provides read-only access to the database. Results
-    //! are filtered by 'Show Hidden' setting and sorted iaw Thumbview ordering.
-    ImageDbReader *m_db;
 };
 
 #endif // GALLERYWIDGET_H
diff --git a/mythtv/programs/mythfrontend/gallerythumbview.cpp b/mythtv/programs/mythfrontend/gallerythumbview.cpp
index c366e9b..b999f2a 100644
--- a/mythtv/programs/mythfrontend/gallerythumbview.cpp
+++ b/mythtv/programs/mythfrontend/gallerythumbview.cpp
@@ -1,15 +1,145 @@
 #include "gallerythumbview.h"
 
-#include <QFileInfo>
+#include <unistd.h> // for usleep
 
-#include <mythcontext.h>
-#include <mythscreentype.h>
-#include <mythuimultifilebrowser.h>
-#include <mythuiprogressbar.h>
-#include <imageutils.h>
+#include <QApplication>
+
+#include "mythuitext.h"
+#include "mythprogressdialog.h"
+#include "mythuiprogressbar.h"
+#include "remotefile.h"
+#include "mythsystemlegacy.h"
+#include "mythdialogbox.h"
 
 #include "galleryconfig.h"
 
+#define LOC QString("Thumbview: ")
+
+
+//! Worker thread for running import
+class ShellThread: public MThread
+{
+public:
+    ShellThread(QString cmd, QString path)
+        : MThread("Import"), m_result(0), m_command(cmd), m_path(path) {}
+
+    int GetResult(void) { return m_result; }
+
+    virtual void run()
+    {
+        RunProlog();
+
+        QString cmd = QString("cd %1 && %2").arg(m_path, m_command);
+        LOG(VB_GENERAL, LOG_INFO, QString("Executing \"%1\"").arg(cmd));
+
+        m_result = myth_system(cmd);
+
+        LOG(VB_GENERAL, LOG_INFO, QString(" ...with result %1").arg(m_result));
+
+        RunEpilog();
+    }
+
+private:
+    int     m_result;
+    QString m_command;
+    QString m_path;
+};
+
+
+//! Worker thread for copying/moving files
+class TransferThread : public MThread
+{
+    Q_DECLARE_TR_FUNCTIONS(FileTransferWorker)
+public:
+    typedef QMap<ImagePtrK, QString> TransferMap;
+    typedef QSet<ImagePtrK> ImageSet;
+
+    TransferThread(const TransferMap &files, bool move, MythUIProgressDialog *dialog)
+        : MThread("FileTransfer"),
+          m_move(move), m_files(files), m_failed(), m_dialog(dialog) {}
+
+    ImageSet GetResult(void) { return m_failed; }
+
+    virtual void run()
+    {
+        RunProlog();
+
+        QString action = m_move ? tr("Moving") : tr("Copying");
+
+        // Sum file sizes
+        int total = 0;
+        foreach (ImagePtrK im, m_files.keys())
+            total += im->m_size;
+
+        int progressSize = 0;
+        foreach (ImagePtrK im, m_files.keys())
+        {
+            // Update progress dialog
+            if (m_dialog)
+            {
+                QString message = QString("%1 %2\n%3")
+                        .arg(action, QFileInfo(im->m_url).fileName(),
+                             ImageAdapterBase::FormatSize(im->m_size / 1024));
+
+                ProgressUpdateEvent *pue =
+                        new ProgressUpdateEvent(progressSize, total, message);
+                QApplication::postEvent(m_dialog, pue);
+            }
+
+            QString newPath = m_files.value(im);
+            LOG(VB_FILE, LOG_INFO, QString("%2 %3 -> %4")
+                .arg(action, im->m_url, newPath));
+
+            bool success = m_move ? RemoteFile::MoveFile(im->m_url, newPath)
+                                  : RemoteFile::CopyFile(im->m_url, newPath,
+                                                         false, true);
+            if (!success)
+            {
+                // Flag failures
+                m_failed.insert(im);
+
+                LOG(VB_GENERAL, LOG_ERR,
+                    QString("%1: Failed to copy/move %2 -> %3")
+                    .arg(objectName(), im->m_url, m_files[im]));
+            }
+
+            progressSize += im->m_size;
+        }
+
+        // Update progress dialog
+        if (m_dialog)
+        {
+            ProgressUpdateEvent *pue =
+                    new ProgressUpdateEvent(progressSize, total, tr("Complete"));
+            QApplication::postEvent(m_dialog, pue);
+        }
+
+        RunEpilog();
+    }
+
+private:
+    bool                  m_move;   //!< Copy if false, Move if true
+    TransferMap           m_files;  //!< Maps source filepath to destination filepath
+    ImageSet              m_failed; //! Images for which copy/move failed
+    MythUIProgressDialog *m_dialog; //!< Progress dialog for transfer
+};
+
+
+/*!
+ \brief Runs a worker thread and waits for it to finish
+ \param worker Thread to execute
+*/
+static void WaitUntilDone(MThread &worker)
+{
+    worker.start();
+    while (!worker.isFinished())
+    {
+        usleep(1000);
+        qApp->processEvents();
+    }
+}
+
+
 /*!
  *  \brief  Constructor
  *  \param  parent The screen parent
@@ -17,51 +147,55 @@
  */
 GalleryThumbView::GalleryThumbView(MythScreenStack *parent, const char *name)
     : MythScreenType(parent, name),
-    m_imageList(NULL),
-    m_captionText(NULL),
-    m_crumbsText(NULL),
-    m_hideFilterText(NULL),
-    m_typeFilterText(NULL),
-    m_positionText(NULL),
-    m_emptyText(NULL),
-    m_scanProgressText(NULL),
-    m_scanProgressBar(NULL),
-    m_scanInProgress(false),
-    m_zoomLevel(0),
-    m_infoList(NULL),
-    m_editsAllowed(false),
-    m_deleteAfterImport(false),
-    m_importTmp(NULL)
+      m_imageList(NULL),
+      m_captionText(NULL),      m_crumbsText(NULL),     m_emptyText(NULL),
+      m_hideFilterText(NULL),   m_typeFilterText(NULL), m_positionText(NULL),
+      m_scanProgressText(NULL), m_scanProgressBar(NULL),
+      m_zoomWidgets(),          m_zoomLevel(0),
+      m_popupStack(*GetMythMainWindow()->GetStack("popup stack")),
+      m_mgr(ImageManagerFe::getInstance()),
+      // This screen uses a single fixed view (Parent dir, ordered dirs, ordered images)
+      m_view(new DirectoryView(kOrdered)),
+      m_infoList(*this),
+      m_scanProgress(),         m_scanActive(),         m_menuState(),
+      m_pendingMap(),           m_thumbExists(),
+      // Start in edit mode unless a password exists
+      m_editsAllowed(gCoreContext->GetSetting("GalleryPassword").isEmpty())
 {
-    // Handles BE messages for all views
-    gCoreContext->addListener(this);
-
-    m_popupStack = GetMythMainWindow()->GetStack("popup stack");
-    m_mainStack  = GetMythMainWindow()->GetMainStack();
-
-    // Filter db reads using current settings
-    m_db = new ImageDbReader(gCoreContext->GetNumSetting("GallerySortOrder"),
-                             gCoreContext->GetNumSetting("GalleryShowHidden"),
-                             gCoreContext->GetNumSetting("GalleryShowType"));
-
-    // This screen uses a single fixed view (Parent dir, ordered dirs, ordered images)
-    m_view = new DirectoryView(kOrdered, m_db);
-
     m_menuState.Clear();
+
+    // Hide hidden when edits disallowed
+    if (!m_editsAllowed)
+        m_mgr.SetVisibility(false);
 }
 
 
 /*!
- *  \brief  Destructor
+ \brief  Destructor
  */
 GalleryThumbView::~GalleryThumbView()
 {
+    LOG(VB_GUI, LOG_DEBUG, LOC + "Exiting Gallery");
+    delete m_view;
+}
+
+
+/*!
+ \brief Exit Gallery
+*/
+void GalleryThumbView::Close()
+{
+    LOG(VB_GUI, LOG_DEBUG, LOC + "Closing Gallery");
+
     gCoreContext->removeListener(this);
 
-    delete m_view;
-    delete m_db;
-    delete m_infoList;
-    delete m_importTmp;
+    // Cleanup local devices
+    m_mgr.CloseDevices();
+
+    // Cleanup view
+    m_view->Clear();
+
+    MythScreenType::Close();
 }
 
 
@@ -91,17 +225,16 @@ bool GalleryThumbView::Create()
 
     if (m_zoomWidgets.isEmpty())
     {
-        LOG(VB_GENERAL, LOG_ERR, "Thumbview: Screen 'Gallery' is missing 'images0'");
+        LOG(VB_GENERAL, LOG_ERR, LOC + "Screen 'Gallery' is missing 'images0'");
         return false;
     }
-    LOG(VB_GUI, LOG_DEBUG, QString("Thumbview: Screen 'Gallery' found %1 zoom levels")
+    LOG(VB_GUI, LOG_DEBUG, LOC + QString("Screen 'Gallery' found %1 zoom levels")
         .arg(m_zoomWidgets.size()));
 
     // File details list is managed elsewhere
-    m_infoList = InfoList::Create(this, false, tr("Not defined"));
-    if (!m_infoList)
+    if (!m_infoList.Create(false))
     {
-        LOG(VB_GENERAL, LOG_ERR, "Slideview: Cannot load screen 'Gallery'");
+        LOG(VB_GENERAL, LOG_ERR, LOC + "Cannot load 'Info buttonlist'");
         return false;
     }
 
@@ -125,9 +258,6 @@ bool GalleryThumbView::Create()
     m_zoomLevel = gCoreContext->GetNumSetting("GalleryZoomLevel", 0);
     SelectZoomWidget(0);
 
-    // Start in edit mode unless a password exists
-    m_editsAllowed = gCoreContext->GetSetting("GalleryPassword").isEmpty();
-
     return true;
 }
 
@@ -165,26 +295,32 @@ bool GalleryThumbView::keyPressEvent(QKeyEvent *event)
             FlipHorizontal();
         else if (action == "FLIPVERTICAL")
             FlipVertical();
-        else if (action == "SLIDESHOW")
+        else if (action == "PLAY")
             Slideshow();
         else if (action == "RECURSIVESHOW")
-            RecursiveSlideshow();
+        {
+            ImagePtrK im = m_view->GetSelected();
+            if (im && im->IsDirectory())
+                RecursiveSlideshow();
+        }
         else if (action == "MARK")
         {
-            ImageItem *im = m_view->GetSelected();
-            if (im && m_editsAllowed)
+            ImagePtrK im = m_view->GetSelected();
+            if (m_editsAllowed && im && im != m_view->GetParent())
                 MarkItem(!m_view->IsMarked(im->m_id));
         }
         else if (action == "ESCAPE" && !GetMythMainWindow()->IsExitingToMain())
         {
             // Exit info list, if shown
-            handled = m_infoList->Hide();
+            handled = m_infoList.Hide();
 
-            // Ascend the tree if first node is an kUpDirectory
+            // Ascend the tree unless parent is root,
+            // or a device and multiple devices/imports exist
             if (!handled)
             {
-                ImageItem *data = m_view->GetParent();
-                if (data && data->m_type == kUpDirectory)
+                ImagePtrK node = m_view->GetParent();
+                if (node && node->m_id != GALLERY_DB_ID
+                        && (!node->IsDevice() || m_mgr.DeviceCount() > 0))
                     handled = DirSelectUp();
             }
         }
@@ -205,6 +341,7 @@ bool GalleryThumbView::keyPressEvent(QKeyEvent *event)
  */
 void GalleryThumbView::customEvent(QEvent *event)
 {
+
     if ((MythEvent::Type)(event->type()) == MythEvent::MythEventMessage)
     {
         MythEvent *me      = (MythEvent *)event;
@@ -212,7 +349,18 @@ void GalleryThumbView::customEvent(QEvent *event)
 
         QStringList extra = me->ExtraDataList();
 
-        if (message == "THUMB_AVAILABLE")
+        if (extra.isEmpty())
+            return;
+
+        if (message == "IMAGE_METADATA")
+        {
+            int id = extra[0].toInt();
+            ImagePtrK selected = m_view->GetSelected();
+
+            if (selected && selected->m_id == id)
+                m_infoList.Display(*selected, extra.mid(1));
+        }
+        else if (message == "THUMB_AVAILABLE")
         {
             int id = extra[0].toInt();
 
@@ -222,95 +370,87 @@ void GalleryThumbView::customEvent(QEvent *event)
             // Thumbview is only concerned with thumbnails we've requested
             if (!affected.isEmpty())
             {
-                LOG(VB_GENERAL, LOG_DEBUG,
-                    QString("Thumbview: Rx %1 : %2").arg(message, extra.join(",")));
+                LOG(VB_GENERAL, LOG_DEBUG, LOC +
+                    QString("Rx %1 : %2").arg(message, extra.join(",")));
 
-                QString url = "";
+                // Thumb url is cached before request is sent
+                QString url = m_view->GetCachedThumbUrl(id);
 
                 // Set thumbnail for each button now it exists
                 foreach(const ThumbLocation &location, affected)
                 {
                     MythUIButtonListItem *button = location.first;
-                    int index  = location.second;
-                    ImageItem *im = button->GetData().value<ImageItem*>();
+                    int                   index  = location.second;
 
+                    ImagePtrK im = button->GetData().value<ImagePtrK>();
                     if (im)
-                    {
-                        // All buttons use the same url so only generate it once
-                        if (url.isEmpty())
-                            url = ImageSg::getInstance()->GenerateThumbUrl(im->m_thumbNails.at(index));
-
                         UpdateThumbnail(button, im, url, index);
-                    }
                 }
 
-                // Cancel pending request & store url
+                // Cancel pending request & mark thumbnail
                 m_pendingMap.remove(id);
-                m_url.insert(id, url);
+                m_thumbExists.insert(id);
             }
-
-            // Pass on to Slideshow
-            emit ThumbnailChanged(id);
         }
-        else if (message == "IMAGE_DB_CHANGED")
+        else if (message.startsWith("IMAGE_DB_CHANGED"))
         {
-            // Expects either:
-            // "ALL" when db cleared, or
-            // csv list of deleted ids, csv list of changed ids,
-            // csv list of urls to remove from cache
-            LOG(VB_GENERAL, LOG_DEBUG,
-                QString("Thumbview: Rx %1 : %2").arg(message, extra.join(",")));
+            // Ignore messages intended for oher FE's
+            QStringList sender = message.split(' ');
+            if (sender.size() >= 2 && sender[1] != gCoreContext->GetHostName())
+                return;
 
-            QStringList idDeleted, idChanged;
+            // Expects csv list of deleted ids, csv list of changed ids
+            LOG(VB_GENERAL, LOG_DEBUG, LOC +
+                QString("Rx %1 : %2").arg(message, extra.join(",")));
 
             if (!extra.isEmpty())
-                idDeleted = extra.takeFirst().split(",",  QString::SkipEmptyParts);
-            if (!extra.isEmpty())
-                idChanged = extra.takeFirst().split(",",  QString::SkipEmptyParts);
-
-            if (!idDeleted.isEmpty() && idDeleted[0] == "ALL")
             {
-                m_view->Clear();
-                m_url.clear();
+                QStringList idDeleted =
+                        extra[0].split(",", QString::SkipEmptyParts);
 
-                LOG(VB_FILE, LOG_DEBUG, "Thumbview: Clearing image cache");
-
-                // Remove all cached thumbnails
-                GetMythUI()->RemoveFromCacheByFile(QString("/%1/").arg(THUMBNAIL_DIR));
-                // Remove all cached images
-                GetMythUI()->RemoveFromCacheByFile(QString("//%1@").arg(IMAGE_STORAGE_GROUP));
+                RemoveImages(idDeleted);
             }
-            else
+            if (extra.size() >= 2)
             {
-                LOG(VB_FILE, LOG_DEBUG, QString("Thumbview: Removing %1- Updating %2")
-                    .arg(idDeleted.join(","), idChanged.join(",")));
+                QStringList idChanged =
+                        extra[1].split(",", QString::SkipEmptyParts);
+                RemoveImages(idChanged, false);
+            }
 
-                // Reset image urls so that new thumbnails are requested
-                foreach (const QString &ident, idChanged)
-                    m_url.remove(ident.toInt());
+            // Refresh display
+            LoadData(m_view->GetParentId());
+        }
+        else if (message.startsWith("IMAGE_DEVICE_CHANGED"))
+        {
+            // Ignore messages intended for oher FE's
+            QStringList sender = message.split(' ');
+            if (sender.size() >= 2 && sender[1] != gCoreContext->GetHostName())
+                return;
 
-                // Cleanup image urls & marked files
-                foreach (const QString &ident, idDeleted)
-                {
-                    m_url.remove(ident.toInt());
-                    m_view->Mark(ident.toInt(), false);
-                }
+            // Expects list of url prefixes
+            LOG(VB_GENERAL, LOG_DEBUG, LOC +
+                QString("Rx %1 : %2").arg(message, extra.join(",")));
 
-                // Remove cached thumbs & images
-                foreach(const QString &url, extra)
-                    GetMythUI()->RemoveFromCacheByFile(url);
-            }
+            // Clear everything. Local devices will be rebuilt
+            m_view->Clear();
+            m_thumbExists.clear();
+
+            // Remove thumbs & images from image cache using supplied prefixes
+            foreach(const QString &url, extra)
+                GetMythUI()->RemoveFromCacheByFile(url);
 
             // Refresh display
-            LoadData();
+            LoadData(m_view->GetParentId());
         }
-        else if (message == "IMAGE_SCAN_STATUS")
+        else if (message.startsWith("IMAGE_SCAN_STATUS") && extra.size() == 3)
         {
-            // Expects mode, scanned#, total#
-            if (extra.size() == 3)
-            {
-                UpdateScanProgress(extra[0], extra[1], extra[2]);
-            }
+            // Ignore messages intended for oher FE's
+            QStringList sender = message.split(' ');
+            if (sender.size() >= 2 && sender[1] != gCoreContext->GetHostName())
+                return;
+
+            // Expects scanner id, scanned#, total#
+            UpdateScanProgress(extra[0], extra[1].toInt(), extra[2].toInt());
         }
     }
     else if (event->type() == DialogCompletionEvent::kEventType)
@@ -325,35 +465,25 @@ void GalleryThumbView::customEvent(QEvent *event)
             QString newName = dce->GetResultText();
             if (m_menuState.m_selected)
             {
-                QString err = GalleryBERequest::RenameFile(
-                    m_menuState.m_selected->m_id, newName);
-
+                QString err = m_mgr.RenameFile(m_menuState.m_selected,
+                                               newName);
                 if (!err.isEmpty())
                     ShowOkPopup(err);
             }
         }
-        else if (resultid == "ImportFilesSelected")
-        {
-            QStringList files = dce->GetData().value<QStringList>();
-            LOG(VB_FILE, LOG_DEBUG, "Thumbview: Import files " + files.join(","));
-            ImportFiles(files);
-        }
         else if (resultid == "MakeDir")
         {
-            if (!m_menuState.m_selected)
-                return;
-
-            QStringList newPath;
-            newPath << QString("%1/%2")
-                .arg(m_menuState.m_selected->m_fileName,
-                     dce->GetResultText());
-
-            QString err = GalleryBERequest::MakeDirs(newPath);
-            if (err.isEmpty())
-                // Rescan to display new dir
-                StartScan();
-            else
-                ShowOkPopup(err);
+            if (m_menuState.m_selected)
+            {
+                // Prohibit subtrees
+                QString name = dce->GetResultText();
+                QString err  = name.contains("/")
+                        ? tr("Invalid Name")
+                        : m_mgr.MakeDir(m_menuState.m_selected->m_id,
+                                        QStringList(name));
+                if (!err.isEmpty())
+                    ShowOkPopup(err);
+            }
         }
         else if (resultid == "SlideOrderMenu")
         {
@@ -361,13 +491,40 @@ void GalleryThumbView::customEvent(QEvent *event)
 
             switch (buttonnum)
             {
-                case 0: slideOrder = kOrdered; break;
-                case 1: slideOrder = kShuffle; break;
-                case 2: slideOrder = kRandom; break;
-                case 3: slideOrder = kSeasonal; break;
+            case 0: slideOrder = kOrdered; break;
+            case 1: slideOrder = kShuffle; break;
+            case 2: slideOrder = kRandom; break;
+            case 3: slideOrder = kSeasonal; break;
             }
             gCoreContext->SaveSetting("GallerySlideOrder", slideOrder);
-            LOG(VB_FILE, LOG_DEBUG, QString("Order %1").arg(slideOrder));
+            LOG(VB_FILE, LOG_DEBUG, LOC + QString("Order %1").arg(slideOrder));
+        }
+        else if (resultid == "ImageCaptionMenu")
+        {
+            ImageCaptionType captions = kNoCaption;
+
+            switch (buttonnum)
+            {
+            case 0: captions = kNameCaption; break;
+            case 1: captions = kDateCaption; break;
+            case 2: captions = kUserCaption; break;
+            case 3: captions = kNoCaption;   break;
+            }
+            gCoreContext->SaveSetting("GalleryImageCaption", captions);
+            BuildImageList();
+        }
+        else if (resultid == "DirCaptionMenu")
+        {
+            ImageCaptionType captions = kNoCaption;
+
+            switch (buttonnum)
+            {
+            case 0: captions = kNameCaption; break;
+            case 1: captions = kDateCaption; break;
+            case 2: captions = kNoCaption;   break;
+            }
+            gCoreContext->SaveSetting("GalleryDirCaption", captions);
+            BuildImageList();
         }
         else if (resultid == "Password")
         {
@@ -377,36 +534,72 @@ void GalleryThumbView::customEvent(QEvent *event)
         else if (buttonnum == 1)
         {
             // Confirm current file deletion
+            QString err;
             if (resultid == "ConfirmDelete" && m_menuState.m_selected)
             {
                 ImageIdList ids = ImageIdList() << m_menuState.m_selected->m_id;
-                QString     err = GalleryBERequest::RemoveFiles(ids);
-                if (!err.isEmpty())
-                    ShowOkPopup(err);
+                err = m_mgr.DeleteFiles(ids);
             }
-            // Confirm all selected file deletion
+            // Confirm marked file deletion
             else if (resultid == "ConfirmDeleteMarked")
             {
-                QString err = GalleryBERequest::RemoveFiles(m_menuState.m_markedId);
-                if (!err.isEmpty())
-                    ShowOkPopup(err);
+                err = m_mgr.DeleteFiles(m_menuState.m_markedId);
             }
+            else
+                return;
+
+            if (!err.isEmpty())
+                ShowOkPopup(err);
+        }
+    }
+}
+
+
+/*!
+ \brief Cleanup UI & image caches when a device is removed
+ \param prefixes List of url prefixes to remove from image cache
+*/
+void GalleryThumbView::RemoveImages(const QStringList &ids, bool deleted)
+{
+    foreach (const QString &id, ids)
+    {
+        // Remove image from view
+        QStringList urls = m_view->RemoveImage(id.toInt(), deleted);
+        // Cleanup url lookup
+        m_thumbExists.remove(id.toInt());
+
+        // Remove thumbs & images from image cache
+        foreach(const QString &url, urls)
+        {
+            LOG(VB_FILE, LOG_DEBUG, LOC +
+                QString("Clearing image cache of '%1'").arg(url));
+
+            GetMythUI()->RemoveFromCacheByFile(url);
         }
     }
 }
 
 
-/**
- * @brief Start Thumbnail screen
+/*!
+ \brief Start Thumbnail screen
  */
 void GalleryThumbView::Start()
 {
-    // Detect any current scans
-    QStringList message = GalleryBERequest::ScanQuery();
-    UpdateScanProgress(message[1], message[2], message[3]);
+    // Detect any running BE scans
+    // Expects OK, scanner id, current#, total#
+    QStringList message = m_mgr.ScanQuery();
+    if (message.size() == 4 && message[0] == "OK")
+    {
+        UpdateScanProgress(message[1], message[2].toInt(), message[3].toInt());
+    }
 
-    // Always start showing top level images
-    LoadData(ROOT_DB_ID);
+    // Only receive events after device/scan status has been established
+    gCoreContext->addListener(this);
+
+    // Start at Root if devices exist. Otherwise go straight to SG node
+    int start = m_mgr.DetectLocalDevices() ? GALLERY_DB_ID : PHOTO_DB_ID;
+
+    LoadData(start);
 }
 
 
@@ -425,19 +618,19 @@ void GalleryThumbView::LoadData(int parent)
         if (m_emptyText)
             m_emptyText->SetVisible(false);
 
-        // Build the buttonlist
+        // Construct the buttonlist
         BuildImageList();
     }
     else
     {
-        m_infoList->Hide();
+        m_infoList.Hide();
         m_imageList->SetVisible(false);
         if (m_emptyText)
         {
             m_emptyText->SetVisible(true);
-            m_emptyText->SetText(tr("No images found in the database.\n"
-                                    "Set Photographs storage group,\n"
-                                    "then scan from menu."));
+            m_emptyText->SetText(tr("No images found.\n"
+                                    "Scan storage group using menu,\n"
+                                    "or insert/mount local media.\n"));
         }
     }
 }
@@ -451,139 +644,134 @@ void GalleryThumbView::BuildImageList()
     m_imageList->Reset();
     m_pendingMap.clear();
 
-    // get all children from the the active node
-    ImageList      children = m_view->GetAllNodes();
-    ImageItem *selected = m_view->GetSelected();
+    // Get parent & all children
+    ImageListK nodes    = m_view->GetAllNodes();
+    ImagePtrK  selected = m_view->GetSelected();
 
     // go through the entire list and update
-    foreach(ImageItem *im, children)
-    if (im)
-    {
-        // Data must be set by constructor: First item is automatically
-        // selected and must have data available for selection event, as
-        // subsequent reselection of same item will always fail.
-        MythUIButtonListItem *item = new MythUIButtonListItem(
-            m_imageList, "", qVariantFromValue(im));
-
-        item->setCheckable(true);
-        item->setChecked(MythUIButtonListItem::NotChecked);
+    foreach(const ImagePtrK &im, nodes)
+        if (im)
+        {
+            // Data must be set by constructor: First item is automatically
+            // selected and must have data available for selection event, as
+            // subsequent reselection of same item will always fail.
+            MythUIButtonListItem *item =
+                    new MythUIButtonListItem(m_imageList, "", qVariantFromValue(im));
 
-        // assign and display all information about
-        // the current item, like title and subdirectory count
-        UpdateImageItem(item);
+            item->setCheckable(true);
+            item->setChecked(MythUIButtonListItem::NotChecked);
 
-        // Reinstate the active button item
-        if (im == selected)
-            m_imageList->SetItemCurrent(item);
-    }
+            // assign and display all information about
+            // the current item, like title and subdirectory count
+            UpdateImageItem(item);
 
-    // Updates all other widgets on the screen that show
-    // information about the selected MythUIButtonListItem
-    SetUiSelection(m_imageList->GetItemCurrent());
+            // Treat parent differently
+            if (im == nodes[0])
+            {
+                // Only non-root parents can ascend
+                if (im->m_id != GALLERY_DB_ID)
+                    item->DisplayState("upfolder", "parenttype");
+            }
+            else if (im == selected)
+                // Reinstate the active button item. Note this would fail for parent
+                m_imageList->SetItemCurrent(item);
+        }
 }
 
 
 /*!
  *  \brief  Initialises a single buttonlist item
  *  \param  item The buttonlist item
-
  */
 void GalleryThumbView::UpdateImageItem(MythUIButtonListItem *item)
 {
-    ImageItem *im = item->GetData().value<ImageItem *>();
+    ImagePtrK im = item->GetData().value<ImagePtrK >();
     if (!im)
         return;
 
     // Allow themes to distinguish between roots, folders, pics, videos
     switch (im->m_type)
     {
-        case kUpDirectory:
-            item->DisplayState("upfolder", "buttontype");
-            break;
-
-        case kBaseDirectory:
-        case kSubDirectory:
-            if (im->m_dirCount > 0)
-                item->SetText(QString("%1/%2")
-                              .arg(im->m_fileCount).arg(im->m_dirCount),
-                              "childcount");
-            else
-                item->SetText(QString::number(im->m_fileCount), "childcount");
+    case kDevice:
+    case kCloneDir:
+    case kDirectory:
+        if (im->m_dirCount > 0)
+            item->SetText(QString("%1/%2")
+                          .arg(im->m_fileCount).arg(im->m_dirCount),
+                          "childcount");
+        else
+            item->SetText(QString::number(im->m_fileCount), "childcount");
 
-            item->DisplayState("subfolder", "buttontype");
-            break;
+        item->DisplayState(im->IsDevice() ? "device" : "subfolder", "buttontype");
+        break;
 
-        case kImageFile:
-            item->DisplayState("image", "buttontype");
-            break;
+    case kImageFile:
+        item->DisplayState("image", "buttontype");
+        break;
 
-        case kVideoFile:
-            item->DisplayState("video", "buttontype");
-            break;
+    case kVideoFile:
+        item->DisplayState("video", "buttontype");
+        break;
 
-        default:
-            break;
+    default:
+        break;
     }
 
     // Allow theme to distinguish visible/hidden nodes
     QString hideState = (im->m_isHidden) ? "hidden" : "visible";
     item->DisplayState(hideState, "buttonstate");
 
-    // No text for roots or Upfolders
-    if (im->m_type >= kSubDirectory)
+    // Caption
+    QString text;
+    int show = gCoreContext->GetNumSetting(
+                im->IsFile() ? "GalleryImageCaption"
+                             : "GalleryDirCaption");
+    switch (show)
     {
-        int     show = gCoreContext->GetNumSetting("GalleryShowCaption");
-        QString text;
-        switch (show)
-        {
-            case kNameCaption: text = im->m_name; break;
-            case kDateCaption: text = ImageUtils::ImageDateOf(im); break;
-            case kUserCaption: text = im->m_comment; break;
-            default:
-            case kNoCaption:   text = ""; break;
-        }
-        item->SetText(text);
+    case kNameCaption: text = m_mgr.CrumbName(im); break;
+    case kDateCaption: text = m_mgr.ShortDateOf(im); break;
+    case kUserCaption: text = im->m_comment; break;
+    default:
+    case kNoCaption:   text = ""; break;
     }
+    item->SetText(text);
 
     // Set marked state
     MythUIButtonListItem::CheckState state
-        = m_view->IsMarked(im->m_id)
-          ? MythUIButtonListItem::FullChecked
-          : MythUIButtonListItem::NotChecked;
+            = m_view->IsMarked(im->m_id)
+            ? MythUIButtonListItem::FullChecked
+            : MythUIButtonListItem::NotChecked;
 
     item->setChecked(state);
 
-    // Thumbnails required from BE
-    QStringList required = QStringList();
+    // Thumbnails required
+    ImageIdList request;
 
     if (im->m_thumbNails.size() == 1)
     {
         // Single thumbnail
-        QString url = CheckThumbnail(item, im, required);
+        QString url = CheckThumbnail(item, im, request, 0);
 
         if (!url.isEmpty())
-            UpdateThumbnail(item, im, url);
+            UpdateThumbnail(item, im, url, 0);
     }
     else
     {
-        // Dir showing up to 4 thumbs
+        // Dir showing up to 4 thumbs. Set them all at same time
         InfoMap thumbMap;
         for (int index = 0; index < im->m_thumbNails.size(); ++index)
         {
-            QString url = CheckThumbnail(item, im, required, index);
-
+            QString url = CheckThumbnail(item, im, request, index);
             if (!url.isEmpty())
                 thumbMap.insert(QString("thumbimage%1").arg(index), url);
         }
-
-        // Set multiple images at same time
         if (!thumbMap.isEmpty())
             item->SetImageFromMap(thumbMap);
     }
 
-    // Request BE to create/verify any missing thumbnails.
-    if (!required.isEmpty())
-        GalleryBERequest::CreateThumbnails(required, im->IsDirectory());
+    // Request creation/verification of unknown thumbnails.
+    if (!request.isEmpty())
+        m_mgr.CreateThumbnails(request, im->IsDirectory());
 }
 
 
@@ -598,20 +786,18 @@ void GalleryThumbView::UpdateImageItem(MythUIButtonListItem *item)
  \param index Thumbnail index in buttonlist item (Dirs use 4 thumbnails)
  \return QString URL of thumbnail
 */
-QString GalleryThumbView::CheckThumbnail(MythUIButtonListItem *item, ImageItem *im,
-                                         QStringList &request, int index)
+QString GalleryThumbView::CheckThumbnail(MythUIButtonListItem *item, ImagePtrK im,
+                                         ImageIdList &request, int index)
 {
-    int id = im->m_thumbIds.at(index);
+    ThumbPair thumb(im->m_thumbNails.at(index));
+    int id = thumb.first;
 
-    // Thumbs are retrieved & cached as urls
-    QString url = m_url.value(id, "");
-
-    if (!url.isEmpty())
-        return url;
+    if (m_thumbExists.contains(id))
+        return thumb.second;
 
     // Request BE thumbnail check if it is not already pending
     if (!m_pendingMap.contains(id))
-        request << QString::number(id);
+        request << id;
 
     // Note this button is awaiting an update
     m_pendingMap.insertMulti(id, qMakePair(item, index));
@@ -628,21 +814,18 @@ QString GalleryThumbView::CheckThumbnail(MythUIButtonListItem *item, ImageItem *
  \param index Index of the thumbnail on the button
 */
 void GalleryThumbView::UpdateThumbnail(MythUIButtonListItem *button,
-                                       ImageItem *im, const QString &url,
+                                       ImagePtrK im, const QString &url,
                                        int index)
 {
     if (im->m_thumbNails.size() == 1)
     {
         // Pics, dirs & videos use separate widgets
-        QString widget;
         switch (im->m_type)
         {
-            case kImageFile: widget = ""; break;
-            case kVideoFile: widget = "videoimage"; break;
-            default:         widget = "folderimage"; break;
+        case kImageFile: button->SetImage(url); break;
+        case kVideoFile: button->SetImage(url, "videoimage"); break;
+        default:         button->SetImage(url, "folderimage"); break;
         }
-
-        button->SetImage(url, widget);
     }
     else
         // Dir with 4 thumbnails
@@ -652,48 +835,79 @@ void GalleryThumbView::UpdateThumbnail(MythUIButtonListItem *button,
 
 /*!
  \brief Update progressbar with scan status
- \param mode BE scan state
+ \details Combines progress of both BE & FE scanners
+ \param scanner Scanner id
  \param current Number of images scanned
  \param total Total number of images to scan
 */
-void GalleryThumbView::UpdateScanProgress(QString mode,
-                                          QString current,
-                                          QString total)
+void GalleryThumbView::UpdateScanProgress(const QString &scanner,
+                                          int current, int total)
 {
-    if (!mode.isEmpty() && !m_scanInProgress)
+    // Scan update
+    m_scanProgress.insert(scanner, qMakePair(current, total));
+
+    // Detect end of this scan
+    if (current >= total)
     {
-        // Scan just started
-        if (m_scanProgressBar)
+        LOG(VB_GUI, LOG_DEBUG, LOC + QString("Scan Finished %1 %2/%3")
+            .arg(scanner).arg(current).arg(total));
+
+        // Mark inactive scanner
+        m_scanActive.remove(scanner);
+
+        // Detect end of last scan
+        if (m_scanActive.isEmpty())
         {
-            m_scanProgressBar->SetVisible(true);
-            m_scanProgressBar->SetStart(0);
-        }
-        if (m_scanProgressText)
-            m_scanProgressText->SetVisible(true);
-    }
+            if (m_scanProgressText)
+                m_scanProgressText->SetVisible(false);
+            if (m_scanProgressBar)
+                m_scanProgressBar->SetVisible(false);
 
-    m_scanInProgress = !mode.isEmpty();
+            m_scanProgress.clear();
 
-    if (m_scanInProgress)
+            return;
+        }
+    }
+    else
     {
-        // Scan update
-        if (m_scanProgressBar)
+        // Detect first scan update
+        if (m_scanActive.isEmpty())
+        {
+            // Show progressbar when first scan starts
+            if (m_scanProgressBar)
+            {
+                m_scanProgressBar->SetVisible(true);
+                m_scanProgressBar->SetStart(0);
+            }
+            if (m_scanProgressText)
+                m_scanProgressText->SetVisible(true);
+        }
+
+        if (!m_scanActive.contains(scanner))
         {
-            m_scanProgressBar->SetUsed(current.toInt());
-            m_scanProgressBar->SetTotal(total.toInt());
+            LOG(VB_GUI, LOG_DEBUG, LOC + QString("Scan Started %1 %2/%3")
+                .arg(scanner).arg(current).arg(total));
+
+            // Mark active scanner
+            m_scanActive.insert(scanner);
         }
-        if (m_scanProgressText)
-            m_scanProgressText->SetText(tr("%1 of %3")
-                                        .arg(current, total));
     }
-    else
+
+    // Aggregate all running scans
+    int currentAgg = 0, totalAgg = 0;
+    foreach (IntPair scan, m_scanProgress.values())
+    {
+        currentAgg += scan.first;
+        totalAgg   += scan.second;
+    }
+
+    if (m_scanProgressBar)
     {
-        // Scan just finished
-        if (m_scanProgressText)
-            m_scanProgressText->SetVisible(false);
-        if (m_scanProgressBar)
-            m_scanProgressBar->SetVisible(false);
+        m_scanProgressBar->SetUsed(currentAgg);
+        m_scanProgressBar->SetTotal(totalAgg);
     }
+    if (m_scanProgressText)
+        m_scanProgressText->SetText(tr("%L1 of %L3").arg(currentAgg).arg(totalAgg));
 }
 
 
@@ -725,61 +939,52 @@ void GalleryThumbView::ResetUiSelection()
  */
 void GalleryThumbView::SetUiSelection(MythUIButtonListItem *item)
 {
-    ImageItem *im = item->GetData().value<ImageItem *>();
+    ImagePtrK im = item->GetData().value<ImagePtrK >();
     if (im)
     {
+        // update the position in the node list
+        m_view->Select(im->m_id);
+
+        // show the name/path of the image
+        if (m_crumbsText)
+            m_crumbsText->SetText(m_mgr.CrumbName(im, true).replace("/", " : "));
+
         if (m_captionText)
         {
-            // show the date & comment of a node
+            // show the date & comment of non-root nodes
             QStringList text;
-            text << ImageUtils::ImageDateOf(im);
-
-            if (!im->m_comment.isEmpty())
-                text << im->m_comment;
-
+            if (im->m_id != GALLERY_DB_ID)
+            {
+                text << m_mgr.LongDateOf(im);
+                if (!im->m_comment.isEmpty())
+                    text << im->m_comment;
+            }
             m_captionText->SetText(text.join(" - "));
         }
 
         if (m_hideFilterText)
         {
-            int show = gCoreContext->GetNumSetting("GalleryShowHidden");
-            m_hideFilterText->SetText(show ? tr("Hidden") : "");
+            m_hideFilterText->SetText(m_mgr.GetVisibility() ? tr("Hidden") : "");
         }
 
         if (m_typeFilterText)
         {
-            int type = gCoreContext->GetNumSetting("GalleryShowType");
             QString text = "";
-            switch (type)
+            switch (m_mgr.GetType())
             {
             case kPicAndVideo : text = ""; break;
             case kPicOnly     : text = tr("Pictures"); break;
             case kVideoOnly   : text = tr("Videos"); break;
             }
-
             m_typeFilterText->SetText(text);
         }
 
         // show the position of the image
         if (m_positionText)
-            m_positionText->SetText(QString("%1/%2")
-                                    .arg(m_imageList->GetCurrentPos())
-                                    .arg(m_imageList->GetCount() - 1));
-
-        // show the path of the image
-        if (m_crumbsText)
-        {
-            if (im->m_id == ROOT_DB_ID)
-                m_crumbsText->SetText(tr("Gallery"));
-            else
-            {
-                QString crumbs = im->m_fileName;
-                m_crumbsText->SetText(crumbs.replace("/", " - "));
-            }
-        }
+            m_positionText->SetText(m_view->GetPosition());
 
         // Update any file details information
-        m_infoList->Update(im);
+        m_infoList.Update(im);
     }
 }
 
@@ -810,17 +1015,17 @@ void GalleryThumbView::MenuMain()
             menu->AddItem(tr("Enable Edits"), SLOT(ShowPassword()));
     }
 
-    // Scan control depends on current status
-    if (m_scanInProgress)
+    // Depends on current status of backend scanner - string(number(isBackend()))
+    if (m_scanActive.contains("1"))
         menu->AddItem(tr("Stop Scan"), SLOT(StopScan()));
     else
-        menu->AddItem(tr("Start Scan"), SLOT(StartScan()));
+        menu->AddItem(tr("Scan Storage Group"), SLOT(StartScan()));
 
     menu->AddItem(tr("Settings"), SLOT(ShowSettings()));
 
-    MythDialogBox *popup = new MythDialogBox(menu, m_popupStack, "menuPopup");
+    MythDialogBox *popup = new MythDialogBox(menu, &m_popupStack, "menuPopup");
     if (popup->Create())
-        m_popupStack->AddScreen(popup);
+        m_popupStack.AddScreen(popup);
     else
         delete popup;
 }
@@ -832,12 +1037,13 @@ void GalleryThumbView::MenuMain()
  */
 void GalleryThumbView::MenuMarked(MythMenu *mainMenu)
 {
-    if (m_menuState.m_childCount == 0)
-        return;
+    ImagePtrK parent = m_view->GetParent();
 
-    QString title = tr("%1 marked").arg(m_menuState.m_markedId.size());
+    if (m_menuState.m_childCount == 0 || parent.isNull())
+        return;
 
-    MythMenu *menu = new MythMenu(title, this, "markmenu");
+    QString   title = tr("%L1 marked").arg(m_menuState.m_markedId.size());
+    MythMenu *menu  = new MythMenu(title, this, "markmenu");
 
     // Mark/unmark selected
     if (m_menuState.m_selected->IsFile())
@@ -848,7 +1054,8 @@ void GalleryThumbView::MenuMarked(MythMenu *mainMenu)
             menu->AddItem(tr("Mark File"), SLOT(MarkItem()));
     }
     // Cannot mark/unmark parent dir from this level
-    else if (m_menuState.m_selected->m_type == kSubDirectory)
+    else if (!m_menuState.m_selected->IsDevice()
+             && m_menuState.m_selected != parent)
     {
         if (m_menuState.m_selectedMarked)
             menu->AddItem(tr("Unmark Directory"), SLOT(UnmarkItem()));
@@ -856,18 +1063,24 @@ void GalleryThumbView::MenuMarked(MythMenu *mainMenu)
             menu->AddItem(tr("Mark Directory"), SLOT(MarkItem()));
     }
 
-    // Mark All if unmarked files exist
-    if (m_menuState.m_markedId.size() < m_menuState.m_childCount)
-        menu->AddItem(tr("Mark All"), SLOT(MarkAll()));
-
-    // Unmark All if marked files exist
-    if (!m_menuState.m_markedId.isEmpty())
+    if (parent->m_id != GALLERY_DB_ID)
     {
-        menu->AddItem(tr("Unmark All"), SLOT(UnmarkAll()));
-        menu->AddItem(tr("Invert Marked"), SLOT(MarkInvertAll()));
+        // Mark All if unmarked files exist
+        if (m_menuState.m_markedId.size() < m_menuState.m_childCount)
+            menu->AddItem(tr("Mark All"), SLOT(MarkAll()));
+
+        // Unmark All if marked files exist
+        if (!m_menuState.m_markedId.isEmpty())
+        {
+            menu->AddItem(tr("Unmark All"), SLOT(UnmarkAll()));
+            menu->AddItem(tr("Invert Marked"), SLOT(MarkInvertAll()));
+        }
     }
 
-    mainMenu->AddItem(tr("Mark"), NULL, menu);
+    if (menu->IsEmpty())
+        delete menu;
+    else
+        mainMenu->AddItem(tr("Mark"), NULL, menu);
 }
 
 
@@ -877,8 +1090,9 @@ void GalleryThumbView::MenuMarked(MythMenu *mainMenu)
 */
 void GalleryThumbView::MenuPaste(MythMenu *mainMenu)
 {
-    // Can only copy/move into dirs
-    if (m_menuState.m_selected->IsDirectory())
+    // Can only copy/move into non-root dirs
+    if (m_menuState.m_selected->IsDirectory()
+            && m_menuState.m_selected->m_id != GALLERY_DB_ID)
     {
         // Operate on current marked files, if any
         ImageIdList files = m_menuState.m_markedId;
@@ -887,7 +1101,7 @@ void GalleryThumbView::MenuPaste(MythMenu *mainMenu)
         if (files.isEmpty())
             return;
 
-        QString title = tr("%1 marked").arg(files.size());
+        QString title = tr("%L1 marked").arg(files.size());
 
         MythMenu *menu = new MythMenu(title, this, "pastemenu");
 
@@ -908,7 +1122,7 @@ void GalleryThumbView::MenuTransform(MythMenu *mainMenu)
     // Operate on marked files, if any, otherwise selected node
     if (!m_menuState.m_markedId.isEmpty())
     {
-        QString title = tr("%1 marked").arg(m_menuState.m_markedId.size());
+        QString title = tr("%L1 marked").arg(m_menuState.m_markedId.size());
 
         MythMenu *menu = new MythMenu(title, this, "");
 
@@ -922,7 +1136,7 @@ void GalleryThumbView::MenuTransform(MythMenu *mainMenu)
     }
     else if (m_menuState.m_selected->IsFile())
     {
-        MythMenu *menu = new MythMenu(m_menuState.m_selected->m_name, this, "");
+        MythMenu *menu = new MythMenu(m_menuState.m_selected->m_baseName, this, "");
 
         menu->AddItem(tr("Rotate CW"), SLOT(RotateCW()));
         menu->AddItem(tr("Rotate CCW"), SLOT(RotateCCW()));
@@ -942,11 +1156,12 @@ void GalleryThumbView::MenuTransform(MythMenu *mainMenu)
 void GalleryThumbView::MenuAction(MythMenu *mainMenu)
 {
     MythMenu *menu;
+    ImagePtrK selected = m_menuState.m_selected;
 
     // Operate on current marked files, if any
     if (m_menuState.m_markedId.size() > 0)
     {
-        QString title = tr("%1 marked").arg(m_menuState.m_markedId.size());
+        QString title = tr("%L1 marked").arg(m_menuState.m_markedId.size());
 
         menu = new MythMenu(title, this, "actionmenu");
 
@@ -961,52 +1176,42 @@ void GalleryThumbView::MenuAction(MythMenu *mainMenu)
     else
     {
         // Operate on selected file/dir
-        menu = new MythMenu(m_menuState.m_selected->m_name, this, "actionmenu");
+        menu = new MythMenu(selected->m_baseName, this, "actionmenu");
 
-        // No actions on Base/Up dirs
-        if (m_menuState.m_selected->m_type >= kSubDirectory)
+        // Prohibit actions on devices and parent dirs
+        if (!selected->IsDevice() && selected != m_view->GetParent())
         {
-            menu->AddItem(tr("Use as Cover"), SLOT(SetCover()));
-
-            if (m_menuState.m_selected->m_isHidden)
+            if (selected->m_isHidden)
                 menu->AddItem(tr("Unhide"), SLOT(Unhide()));
             else
                 menu->AddItem(tr("Hide"), SLOT(HideItem()));
 
-            menu->AddItem(tr("Delete"), SLOT(DeleteItem()));
-            menu->AddItem(tr("Rename"), SLOT(ShowRenameInput()));
+            menu->AddItem(tr("Use as Cover"), SLOT(SetCover()));
+            menu->AddItem(tr("Delete"),       SLOT(DeleteItem()));
+            menu->AddItem(tr("Rename"),       SLOT(ShowRenameInput()));
         }
-        else if (m_menuState.m_selected->m_userThumbnail)
+        else if (selected->m_userThumbnail)
             menu->AddItem(tr("Reset Cover"), SLOT(ResetCover()));
 
-        // Can only import/mkdir in a dir
-        if (m_menuState.m_selected->IsDirectory())
-        {
+        // Can only mkdir in a non-root dir
+        if (selected->IsDirectory()
+                && selected->m_id != GALLERY_DB_ID)
             menu->AddItem(tr("Create Directory"), SLOT(MakeDir()));
-            MenuImport(menu);
-        }
-        menu->AddItem(tr("Eject media"), SLOT(Eject()));
-    }
-
-    mainMenu->AddItem(tr("Actions"), NULL, menu);
-}
-
-
-/*!
- \brief Add an Import submenu
- \param mainMenu Parent menu
-*/
-void GalleryThumbView::MenuImport(MythMenu *parent)
-{
-    MythMenu *menu = new MythMenu(tr("Import Options"), this, "importmenu");
 
-    menu->AddItem(tr("By Moving"), SLOT(ShowMoveImport()));
-    menu->AddItem(tr("By Copying"), SLOT(ShowImport()));
+        // Only show import command on root, when defined
+        if (selected->m_id == GALLERY_DB_ID
+                && !gCoreContext->GetSetting("GalleryImportCmd").isEmpty())
+            menu->AddItem(tr("Import"), SLOT(Import()));
+    }
 
-    if (gCoreContext->GetNumSetting("GalleryUseImportCmd"))
-        menu->AddItem(tr("Run Import Command"), SLOT(RunImportCmd()));
+    // Only show eject when devices (excluding import) exist
+    if (selected->IsDevice() && selected->IsLocal())
+        menu->AddItem(tr("Eject media"), SLOT(Eject()));
 
-    parent->AddItem(tr("Import"), NULL, menu);
+    if (menu->IsEmpty())
+        delete menu;
+    else
+        mainMenu->AddItem(tr("Actions"), NULL, menu);
 }
 
 
@@ -1028,12 +1233,14 @@ void GalleryThumbView::MenuSlideshow(MythMenu *mainMenu)
     default: ordering = tr("Unknown ordering\n"); break;
     }
 
-    MythMenu *menu = new MythMenu(ordering + tr("Slideshow"), this, "SlideshowMenu");
+    MythMenu *menu = new MythMenu(ordering + tr("Slideshow"), this,
+                                  "SlideshowMenu");
 
     // Use selected dir or parent, if image selected
     if (m_menuState.m_selected->IsDirectory())
     {
-        menu->AddItem(tr("Directory"), SLOT(Slideshow()));
+        if (m_menuState.m_selected->m_fileCount > 0)
+            menu->AddItem(tr("Directory"), SLOT(Slideshow()));
 
         if (m_menuState.m_selected->m_dirCount > 0)
             menu->AddItem(tr("Recursive"), SLOT(RecursiveSlideshow()));
@@ -1041,7 +1248,8 @@ void GalleryThumbView::MenuSlideshow(MythMenu *mainMenu)
     else
         menu->AddItem(tr("Current Directory"), SLOT(Slideshow()));
 
-    MythMenu *orderMenu = new MythMenu(tr("Slideshow Order"), this, "SlideOrderMenu");
+    MythMenu *orderMenu = new MythMenu(tr("Slideshow Order"), this,
+                                       "SlideOrderMenu");
 
     orderMenu->AddItem(tr("Ordered"),  NULL, NULL, order == kOrdered);
     orderMenu->AddItem(tr("Shuffled"), NULL, NULL, order == kShuffle);
@@ -1067,7 +1275,7 @@ void GalleryThumbView::MenuShow(MythMenu *mainMenu)
 {
     MythMenu *menu = new MythMenu(tr("Show Options"), this, "showmenu");
 
-    int type = gCoreContext->GetNumSetting("GalleryShowType");
+    int type = m_mgr.GetType();
     if (type == kPicAndVideo)
     {
         menu->AddItem(tr("Hide Pictures"), SLOT(HidePictures()));
@@ -1077,45 +1285,45 @@ void GalleryThumbView::MenuShow(MythMenu *mainMenu)
         menu->AddItem(type == kPicOnly ? tr("Show Videos") : tr("Show Pictures"),
                       SLOT(ShowType()));
 
-    int show = gCoreContext->GetNumSetting("GalleryShowCaption");
-    if (show != kNoCaption)
-        menu->AddItem(tr("Hide Captions"), SLOT(ShowCaptions()));
-    if (show != kNameCaption)
-        menu->AddItem(tr("Show Name Captions"), SLOT(CaptionsName()));
-    if (show != kDateCaption)
-        menu->AddItem(tr("Show Date Captions"), SLOT(CaptionsDate()));
-    if (show != kUserCaption)
-        menu->AddItem(tr("Show Comment Captions"), SLOT(CaptionsComment()));
-
-    if (gCoreContext->GetNumSetting("GalleryShowHidden"))
-        menu->AddItem(tr("Hide Hidden Files"), SLOT(HideHidden()));
-    else
-        menu->AddItem(tr("Show Hidden Files"), SLOT(ShowHidden()));
+    int show = gCoreContext->GetNumSetting("GalleryImageCaption");
+    MythMenu *captionMenu = new MythMenu(tr("Image Captions"), this,
+                                         "ImageCaptionMenu");
+
+    captionMenu->AddItem(tr("Name"),    NULL, NULL, show == kNameCaption);
+    captionMenu->AddItem(tr("Date"),    NULL, NULL, show == kDateCaption);
+    captionMenu->AddItem(tr("Comment"), NULL, NULL, show == kUserCaption);
+    captionMenu->AddItem(tr("None"),    NULL, NULL, show == kNoCaption);
+
+    menu->AddItem(tr("Image Captions"), NULL, captionMenu);
+
+    show = gCoreContext->GetNumSetting("GalleryDirCaption");
+    captionMenu = new MythMenu(tr("Directory Captions"), this, "DirCaptionMenu");
+
+    captionMenu->AddItem(tr("Name"), NULL, NULL, show == kNameCaption);
+    captionMenu->AddItem(tr("Date"), NULL, NULL, show == kDateCaption);
+    captionMenu->AddItem(tr("None"), NULL, NULL, show == kNoCaption);
+
+    menu->AddItem(tr("Directory Captions"), NULL, captionMenu);
+
+    if (m_editsAllowed)
+    {
+        if (m_mgr.GetVisibility())
+            menu->AddItem(tr("Hide Hidden Items"), SLOT(HideHidden()));
+        else
+            menu->AddItem(tr("Show Hidden Items"), SLOT(ShowHidden()));
+    }
 
     if (m_zoomLevel > 0)
         menu->AddItem(tr("Zoom Out"), SLOT(ZoomOut()));
     if (m_zoomLevel < m_zoomWidgets.size() - 1)
         menu->AddItem(tr("Zoom In"), SLOT(ZoomIn()));
 
-    mainMenu->AddItem(tr("Show"), NULL, menu);
-}
+    QString details = m_infoList.GetState() == kNoInfo
+            ? tr("Show Details") : tr("Hide Details");
 
+    menu->AddItem(details, SLOT(ShowDetails()));
 
-/*!
- \brief Update item that has been selected
- \param item Buttonlist item
-*/
-void GalleryThumbView::ItemSelected(MythUIButtonListItem *item)
-{
-    ImageItem *im = item->GetData().value<ImageItem *>();
-    if (!im)
-        return;
-
-    // update the position in the node list
-    m_view->Select(im->m_id);
-
-    // Update other widgets
-    SetUiSelection(item);
+    mainMenu->AddItem(tr("Show"), NULL, menu);
 }
 
 
@@ -1140,17 +1348,24 @@ void GalleryThumbView::ItemClicked(MythUIButtonListItem *item)
     if (!item)
         return;
 
-    ImageItem *im = item->GetData().value<ImageItem *>();
+    ImagePtrK im = item->GetData().value<ImagePtrK>();
     if (!im)
         return;
 
     switch (im->m_type)
     {
-        case kBaseDirectory:
-        case kSubDirectory:     DirSelectDown(); break;
-        case kUpDirectory:      DirSelectUp(); break;
-        case kImageFile:
-        case kVideoFile:        StartSlideshow(kBrowseSlides); break;
+    case kDevice:
+    case kCloneDir:
+    case kDirectory:
+        if (im == m_view->GetParent())
+            DirSelectUp();
+        else
+            DirSelectDown();
+        break;
+
+    case kImageFile:
+    case kVideoFile:
+        StartSlideshow(kBrowseSlides); break;
     };
 }
 
@@ -1161,7 +1376,7 @@ void GalleryThumbView::ItemClicked(MythUIButtonListItem *item)
 */
 void GalleryThumbView::StartScan(bool start)
 {
-    QString err = GalleryBERequest::ScanImagesAction(start);
+    QString err = m_mgr.ScanImagesAction(start);
     if (!err.isEmpty())
         ShowOkPopup(err);
 }
@@ -1173,18 +1388,16 @@ void GalleryThumbView::StartScan(bool start)
 */
 void GalleryThumbView::StartSlideshow(ImageSlideShowType mode)
 {
-    ImageItem *selected = m_view->GetSelected();
+    ImagePtrK selected = m_view->GetSelected();
     if (!selected)
         return;
 
-    GallerySlideView *slide = new GallerySlideView(m_mainStack, "galleryslideview");
+    MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
+    GallerySlideView *slide = new GallerySlideView(mainStack, "galleryslideview",
+                                                   m_editsAllowed);
     if (slide->Create())
     {
-        m_mainStack->AddScreen(slide);
-
-        // Pass on thumbnail updates
-        connect(this, SIGNAL(ThumbnailChanged(int)),
-                slide, SLOT(ThumbnailChange(int)));
+        mainStack->AddScreen(slide);
 
         // Update selected item when slideshow exits
         connect(slide, SIGNAL(ImageSelected(int)),
@@ -1207,9 +1420,12 @@ void GalleryThumbView::StartSlideshow(ImageSlideShowType mode)
  */
 bool GalleryThumbView::DirSelectUp()
 {
-    ImageItem *im = m_view->GetParent();
+    ImagePtrK im = m_view->GetParent();
     if (im)
     {
+        LOG(VB_GUI, LOG_DEBUG, LOC +
+            QString("Going up from %1").arg(im->m_filePath));
+
         // Select the upfolder in the higher dir
         m_view->Select(im->m_id);
 
@@ -1225,10 +1441,15 @@ bool GalleryThumbView::DirSelectUp()
  */
 void GalleryThumbView::DirSelectDown()
 {
-    ImageItem *im = m_view->GetSelected();
+    ImagePtrK im = m_view->GetSelected();
     if (im)
+    {
+        LOG(VB_GUI, LOG_DEBUG, LOC +
+            QString("Going down to %1").arg(im->m_filePath));
+
         // Create tree rooted at selected item
         LoadData(im->m_id);
+    }
 }
 
 
@@ -1238,13 +1459,13 @@ void GalleryThumbView::DirSelectDown()
 */
 void GalleryThumbView::MarkItem(bool mark)
 {
-    ImageItem *im = m_view->GetSelected();
+    ImagePtrK im = m_view->GetSelected();
     if (im)
     {
         // Mark/unmark selected item
         m_view->Mark(im->m_id, mark);
 
-        // Redisplay buttonlist as a parent dir may have been unmarked by this mark
+        // Redisplay buttonlist as a parent dir may have been unmarked
         BuildImageList();
     }
 }
@@ -1284,12 +1505,12 @@ void GalleryThumbView::MarkInvertAll()
 */
 void GalleryThumbView::TransformItem(ImageFileTransform transform)
 {
-    ImageItem *im = m_view->GetSelected();
+    ImagePtrK im = m_view->GetSelected();
     if (im && m_editsAllowed)
     {
         ImageIdList ids;
         ids.append(im->m_id);
-        QString err = GalleryBERequest::ChangeOrientation(transform, ids);
+        QString err = m_mgr.ChangeOrientation(transform, ids);
         if (!err.isEmpty())
             ShowOkPopup(err);
     }
@@ -1302,7 +1523,7 @@ void GalleryThumbView::TransformItem(ImageFileTransform transform)
 */
 void GalleryThumbView::TransformMarked(ImageFileTransform transform)
 {
-    QString err = GalleryBERequest::ChangeOrientation(transform, m_menuState.m_markedId);
+    QString err = m_mgr.ChangeOrientation(transform, m_menuState.m_markedId);
     if (!err.isEmpty())
         ShowOkPopup(err);
 }
@@ -1319,14 +1540,14 @@ void GalleryThumbView::HideItem(bool hide)
         ImageIdList ids;
         ids.append(m_menuState.m_selected->m_id);
 
-        QString err = GalleryBERequest::HideFiles(hide, ids);
+        QString err = m_mgr.HideFiles(hide, ids);
         if (!err.isEmpty())
 
             ShowOkPopup(err);
 
-        else if (hide)
+        else if (hide && !m_mgr.GetVisibility())
 
-            // Unmark hidden file
+            // Unmark invisible file
             m_view->Mark(m_menuState.m_selected->m_id, false);
     }
 }
@@ -1338,18 +1559,16 @@ void GalleryThumbView::HideItem(bool hide)
 */
 void GalleryThumbView::HideMarked(bool hide)
 {
-    QString err = GalleryBERequest::HideFiles(hide, m_menuState.m_markedId);
+    QString err = m_mgr.HideFiles(hide, m_menuState.m_markedId);
     if (!err.isEmpty())
 
         ShowOkPopup(err);
 
-    else if (hide)
+    else if (hide && !m_mgr.GetVisibility())
 
-        // Unmark hidden files
+        // Unmark invisible files
         foreach (int id, m_menuState.m_markedId)
-        {
             m_view->Mark(id, false);
-        }
 }
 
 
@@ -1359,10 +1578,8 @@ void GalleryThumbView::HideMarked(bool hide)
 void GalleryThumbView::DeleteItem()
 {
     if (m_menuState.m_selected)
-    {
-        ShowDialog(tr("Do you want to delete\n%1 ?").arg(m_menuState.m_selected->m_name),
-                   "ConfirmDelete");
-    }
+        ShowDialog(tr("Do you want to delete\n%1 ?")
+                   .arg(m_menuState.m_selected->m_baseName), "ConfirmDelete");
 }
 
 
@@ -1381,28 +1598,42 @@ void GalleryThumbView::DeleteMarked()
 */
 void GalleryThumbView::ShowSettings()
 {
+    QString oldDate       = gCoreContext->GetSetting("GalleryDateFormat");
     QString oldExclusions = gCoreContext->GetSetting("GalleryIgnoreFilter");
-    int oldSort = gCoreContext->GetNumSetting("GallerySortOrder");
+    int oldSortIm         = gCoreContext->GetNumSetting("GalleryImageOrder");
+    int oldSortDir        = gCoreContext->GetNumSetting("GalleryDirOrder");
 
     // Show settings dialog
     GalleryConfig config = GalleryConfig(m_editsAllowed);
+    connect(config.GetClearPage(), SIGNAL(ClearDbPressed()),
+            this, SLOT(ClearSgDb()));
+
     config.exec();
     gCoreContext->ClearSettingsCache();
 
-    QString exclusions = gCoreContext->GetSetting("GalleryIgnoreFilter");
-    int sort = gCoreContext->GetNumSetting("GallerySortOrder");
-
-    if (exclusions != oldExclusions)
+    // Effect any changes
+    QString date = gCoreContext->GetSetting("GalleryDateFormat");
+    if (date != oldDate)
+    {
+        m_mgr.SetDateFormat(date);
+        BuildImageList();
+    }
 
-        // Exclusions changed: request rescan
-        GalleryBERequest::IgnoreDirs(exclusions);
+    int sortIm  = gCoreContext->GetNumSetting("GalleryImageOrder");
+    int sortDir = gCoreContext->GetNumSetting("GalleryDirOrder");
 
-    else if (sort != oldSort)
+    if (sortIm != oldSortIm || sortDir != oldSortDir)
     {
-        // Order changed: Update db view & reload
-        m_db->SetSortOrder(sort);
-        LoadData();
+        // Order changed: Update db view, reset cover cache & reload
+        m_mgr.SetSortOrder(sortIm, sortDir);
+        m_view->ClearCache();;
+        LoadData(m_view->GetParentId());
     }
+
+    QString exclusions = gCoreContext->GetSetting("GalleryIgnoreFilter");
+    if (exclusions != oldExclusions)
+        // Exclusions changed: request rescan
+        m_mgr.IgnoreDirs(exclusions);
 }
 
 
@@ -1412,21 +1643,15 @@ void GalleryThumbView::ShowSettings()
 */
 void GalleryThumbView::ShowHidden(bool show)
 {
-    // Save setting, update db view & reload
     gCoreContext->SaveSetting("GalleryShowHidden", show);
-    m_db->SetVisibility(show);
-    LoadData();
-}
 
+    // Update Db(s)
+    m_mgr.SetVisibility(show);
 
-/*!
- \brief Show or hide captions
- \param setting None, Names, Dates or Comments
-*/
-void GalleryThumbView::ShowCaptions(int setting)
-{
-    gCoreContext->SaveSetting("GalleryShowCaption", setting);
-    BuildImageList();
+    // Reset dir thumbnail cache
+    m_view->ClearCache();;
+
+    LoadData(m_view->GetParentId());
 }
 
 
@@ -1438,12 +1663,12 @@ void GalleryThumbView::ShowCaptions(int setting)
 void GalleryThumbView::ShowDialog(QString msg, QString event)
 {
     MythConfirmationDialog *popup =
-        new MythConfirmationDialog(m_popupStack, msg, true);
+            new MythConfirmationDialog(&m_popupStack, msg, true);
 
     if (popup->Create())
     {
         popup->SetReturnEvent(this, event);
-        m_popupStack->AddScreen(popup);
+        m_popupStack.AddScreen(popup);
     }
     else
         delete popup;
@@ -1457,15 +1682,14 @@ void GalleryThumbView::ShowRenameInput()
 {
     if (m_menuState.m_selected)
     {
-        QString base =
-            QFileInfo(m_menuState.m_selected->m_name).completeBaseName();
-        QString              msg   = tr("Enter a new name for '%1'.").arg(base);
+        QString base = QFileInfo(m_menuState.m_selected->m_baseName).completeBaseName();
+        QString msg  = tr("Enter a new name:");
         MythTextInputDialog *popup =
-            new MythTextInputDialog(m_popupStack, msg, FilterNone, false, base);
+                new MythTextInputDialog(&m_popupStack, msg, FilterNone, false, base);
         if (popup->Create())
         {
             popup->SetReturnEvent(this, "FileRename");
-            m_popupStack->AddScreen(popup);
+            m_popupStack.AddScreen(popup);
         }
         else
             delete popup;
@@ -1478,7 +1702,7 @@ void GalleryThumbView::ShowRenameInput()
  */
 void GalleryThumbView::ShowDetails()
 {
-    m_infoList->Toggle(m_view->GetSelected());
+    m_infoList.Toggle(m_view->GetSelected());
 }
 
 
@@ -1489,11 +1713,11 @@ void GalleryThumbView::ShowPassword()
 {
     QString msg = tr("Enter password:");
     MythTextInputDialog *popup =
-        new MythTextInputDialog(m_popupStack, msg, FilterNone, true);
+            new MythTextInputDialog(&m_popupStack, msg, FilterNone, true);
     if (popup->Create())
     {
         popup->SetReturnEvent(this, "Password");
-        m_popupStack->AddScreen(popup);
+        m_popupStack.AddScreen(popup);
     }
     else
         delete popup;
@@ -1506,8 +1730,14 @@ void GalleryThumbView::ShowPassword()
 void GalleryThumbView::ShowType(int type)
 {
     gCoreContext->SaveSetting("GalleryShowType", type);
-    m_db->SetType(type);
-    LoadData();
+
+    // Update Db(s)
+    m_mgr.SetType(type);
+
+    // Reset dir thumbnail cache
+    m_view->ClearCache();
+
+    LoadData(m_view->GetParentId());
 }
 
 
@@ -1519,10 +1749,9 @@ void GalleryThumbView::SetCover(bool reset)
 {
     if (m_menuState.m_selected)
     {
-        QString err = reset
-                ? GalleryBERequest::SetCover(m_menuState.m_selected->m_id, 0)
-                : GalleryBERequest::SetCover(m_menuState.m_selected->m_parentId,
-                                              m_menuState.m_selected->m_id);
+        QString err = reset ? m_mgr.SetCover(m_menuState.m_selected->m_id, 0)
+                            : m_mgr.SetCover(m_menuState.m_selected->m_parentId,
+                                             m_menuState.m_selected->m_id);
         if (!err.isEmpty())
             ShowOkPopup(err);
     }
@@ -1563,7 +1792,7 @@ void GalleryThumbView::SelectZoomWidget(int change)
     if (m_zoomLevel >= m_zoomWidgets.size())
         m_zoomLevel = m_zoomWidgets.size() - 1;
 
-    // store any requested change, but not constraining adjustments
+    // Store any requested change, but not constraining adjustments
     // Thus, changing to a theme with fewer zoom levels will not overwrite the
     // setting
     if (change != 0)
@@ -1586,7 +1815,7 @@ void GalleryThumbView::SelectZoomWidget(int change)
     connect(m_imageList, SIGNAL(itemClicked(MythUIButtonListItem *)),
             SLOT(ItemClicked(MythUIButtonListItem *)));
     connect(m_imageList, SIGNAL(itemSelected(MythUIButtonListItem *)),
-            SLOT(ItemSelected(MythUIButtonListItem *)));
+            SLOT(SetUiSelection(MythUIButtonListItem*)));
 }
 
 
@@ -1595,12 +1824,13 @@ void GalleryThumbView::SelectZoomWidget(int change)
 */
 void GalleryThumbView::MakeDir()
 {
-    MythTextInputDialog *popup = new MythTextInputDialog(
-        m_popupStack, tr("Enter name of new directory"), FilterNone, false);
+    MythTextInputDialog *popup =
+            new MythTextInputDialog(&m_popupStack, tr("Enter name of new directory"),
+                                    FilterNone, false);
     if (popup->Create())
     {
         popup->SetReturnEvent(this, "MakeDir");
-        m_popupStack->AddScreen(popup);
+        m_popupStack.AddScreen(popup);
     }
     else
         delete popup;
@@ -1608,110 +1838,78 @@ void GalleryThumbView::MakeDir()
 
 
 /*!
- \brief Move marked files to selected dir. If no marked files, use previously
- marked files
+ \brief Remove local device (or Import) from Gallery
 */
-void GalleryThumbView::Move()
+void GalleryThumbView::Eject()
 {
-    ImageItem *destIm = m_menuState.m_selected;
-
-    // Destination must be a dir
-    if (!destIm || destIm->IsFile())
-        return;
-
-    // Use current markings, if any. Otherwise use previous markings
-    ImageIdList files = m_menuState.m_markedId;
-    if (files.isEmpty())
-        files = m_menuState.m_prevMarkedId;
-    if (files.isEmpty())
-        return;
-
-    // Move files/dirs in clipboard
-    QString err = GalleryBERequest::MoveFiles(destIm->m_id, files);
-    if (!err.isEmpty())
-        ShowOkPopup(err);
+    ImagePtrK dir = m_menuState.m_selected;
+    if (dir)
+        m_mgr.CloseDevices(dir->m_device, true);
 }
 
 
 /*!
- \brief Copy marked files to selected dir. If no marked files, use previously
- marked files
+ \brief Copy marked images to selected dir. If no marked files, use previously
+ marked files. Will not overwrite/duplicate existing files on destination host.
+ \details Copies files and dir subtrees and updates Db to preserve states such as
+ hidden, orientation & cover.
+ Attempts to copy all files and reports the number of failures (but not which ones)
+ \param deleteAfter If set, source images will be deleted after being successfully
+ copied.
 */
-void GalleryThumbView::Copy()
+void GalleryThumbView::Copy(bool deleteAfter)
 {
     // Destination must be a dir
-    ImageItem *destIm = m_menuState.m_selected;
-    if (!destIm || destIm->IsFile())
+    ImagePtrK destDir = m_menuState.m_selected;
+    if (!destDir || destDir->IsFile())
         return;
 
     // Use current markings, if any. Otherwise use previous markings
-    ImageIdList files = m_menuState.m_markedId;
-    if (files.isEmpty())
-        files = m_menuState.m_prevMarkedId;
-    if (files.isEmpty())
-        return;
-
-    // Get paste files from clipboard
-    QStringList ids;
-    foreach (int id, files)
-        ids.append(QString::number(id));
-
-    // Create new dir subtree & copy all files within it
-
-    // Get all files/dirs in subtree
-    ImageList images, dirs;
-    m_db->ReadDbTree(images, dirs, ids);
-
-    // Determine root dir of marked items
-    ImageItem *baseIm;
-    // Any dirs will be in hierarchial order so root must be derived from first
-    if (!dirs.isEmpty())
-        baseIm = dirs[0];
-    // If no dirs, root can be derived from any image
-    else if (!images.isEmpty())
-        baseIm = images[0];
-    else // should never happen
-        return;
-
-    QDir base = QDir("/" + baseIm->m_path);
-    QDir destDir(destIm->m_id == ROOT_DB_ID ? "" : destIm->m_fileName);
-
-    // Create dir subtree
-    if (!dirs.isEmpty())
+    ImageIdList markedIds = m_menuState.m_markedId;
+    if (markedIds.isEmpty())
     {
-        // Build list of destination paths for dirs
-        QStringList newDirs;
-        foreach(const ImageItem *im, dirs)
-            newDirs << destDir.filePath(base.relativeFilePath("/" + im->m_fileName));
-
-        qDeleteAll(dirs);
-
-        // Request BE to create directories first
-        QString err = GalleryBERequest::MakeDirs(newDirs);
-        if (!err.isEmpty())
+        markedIds = m_menuState.m_prevMarkedId;
+        if (markedIds.isEmpty())
         {
-            ShowOkPopup(err);
+            ShowOkPopup(tr("No files specified"));
             return;
         }
     }
 
-    // Build map of source & destination paths for each image
-    NameMap transfer;
-    foreach(const ImageItem *im, images)
+    // Get all files/dirs in subtree(s). Only files are copied
+    ImageList files, dirs;
+    m_mgr.GetDescendants(markedIds, files, dirs);
+
+    if (dirs.isEmpty() && files.isEmpty())
     {
-        ImageSg *sg = ImageSg::getInstance();
-        QString srcName  = sg->GenerateUrl(im->m_fileName);
-        QString destName = sg->GenerateUrl(
-            destDir.filePath(base.relativeFilePath("/" + im->m_fileName)));
-        transfer.insert(srcName, destName);
+        ShowOkPopup(tr("No images"));
+        // Nothing to clean up
+        return;
     }
 
-    qDeleteAll(images);
+    // Child dirs appear before their subdirs. If no dirs, images are all direct children
+    ImagePtrK aChild = dirs.isEmpty() ? files[0] : dirs[0];
+
+    // Determine parent path including trailing /
+    int basePathSize = aChild->m_filePath.size() - aChild->m_baseName.size();
+
+    // Update filepaths for Db & generate URLs for filesystem copy
+    // Only copy files, destination dirs will be created automatically
+    TransferThread::TransferMap transfers;
+    foreach(ImagePtr im, files)
+    {
+        // Replace base path with destination path
+        im->m_filePath = m_mgr.ConstructPath(destDir->m_filePath,
+                                             im->m_filePath.mid(basePathSize));
+
+        transfers.insert(im, m_mgr.BuildTransferUrl(im->m_filePath,
+                                                    destDir->IsLocal()));
+    }
 
     // Create progress dialog
     MythScreenStack      *popupStack = GetMythMainWindow()->GetStack("popup stack");
     MythUIProgressDialog *progress   =
-        new MythUIProgressDialog(tr("Copying files"), popupStack, "copydialog");
+            new MythUIProgressDialog(tr("Copying files"), popupStack, "copydialog");
     if (progress->Create())
         popupStack->AddScreen(progress, false);
     else
@@ -1720,117 +1918,133 @@ void GalleryThumbView::Copy()
         progress = NULL;
     }
 
-    // Copy files in a separate thread
-    if (RunWorker(new FileTransferWorker(false, transfer, progress)))
-        // Rescan to detect new files
-        GalleryBERequest::ScanImagesAction(true);
-    else
-        ShowOkPopup(tr("Failed to copy files"));
-}
+    // Copy files in a servant thread
+    TransferThread copy(transfers, false, progress);
+    WaitUntilDone(copy);
+    TransferThread::ImageSet failed = copy.GetResult();
 
+    if (progress)
+        progress->Close();
 
-/*!
- \brief Executes user 'Import command'
-*/
-void GalleryThumbView::RunImportCmd()
-{
-    // Replace tokens
-    QString cmd = gCoreContext->GetSetting("GalleryImportCmd");
-    QString dir = gCoreContext->GetSetting("GalleryImportLocation");
+    if (!failed.isEmpty())
+        ShowOkPopup(tr("Failed to copy %L1/%Ln file(s)", 0, transfers.size())
+                    .arg(failed.size()));
+
+    // Don't update Db for files that failed
+    foreach (ImagePtrK im, failed)
+        transfers.remove(im);
 
-    cmd.replace("%DIR%", QString("'%1'").arg(dir));
+    ImageListK newImages = transfers.keys();
 
-    if (cmd.contains("%TMPDIR%"))
+    // Include dirs
+    QStringList dirPaths;
+    foreach(ImagePtr im, dirs)
     {
-        // Remove previous temp dir
-        delete m_importTmp;
-        // Create temp dir
-        m_importTmp = new QTemporaryDir();
-        if (!m_importTmp->isValid())
-        {
-            ShowOkPopup(QString(tr("Failed to create temporary directory\n%1"))
-                        .arg(m_importTmp->path()));
-            return;
-        }
+        QString relPath = im->m_filePath.mid(basePathSize);
 
-        cmd.replace("%TMPDIR%", m_importTmp->path());
+        dirPaths << relPath;
+
+        // Replace base path with destination path
+        im->m_filePath = m_mgr.ConstructPath(destDir->m_filePath, relPath);
+
+        // Append dirs so that hidden state & cover is preserved for new dirs
+        // Pre-existing dirs will take precedance over these.
+        newImages.append(im);
     }
 
-    // Run command in a separate thread
-    MythUIBusyDialog *busy = ShowBusyPopup(tr("Running Import command.\nPlease wait..."));
+    // Copy empty dirs as well (will fail for non-empty dirs)
+    if (!dirPaths.isEmpty())
+        m_mgr.MakeDir(destDir->m_id, dirPaths, false);
 
-    int error = RunWorker(new ShellWorker(cmd));
+    if (!newImages.isEmpty())
+    {
+        // Update Db
+        m_mgr.CreateImages(destDir->m_id, newImages);
 
-    if (busy)
-        busy->Close();
+        if (deleteAfter)
+        {
+            // Delete files/dirs that have been successfully copied
+            // Will fail for dirs containing images that failed to copy
+            ImageIdList ids;
+            foreach (ImagePtrK im, newImages)
+                ids << im->m_id;
 
-    if (error != 0)
-        ShowOkPopup(QString(tr("Import command failed: Error %1")).arg(error));
+            m_mgr.DeleteFiles(ids);
+        }
+    }
 }
 
 
 /*!
- \brief Show import dialog
+ \brief Move marked images to selected dir. If no marked files, use previously
+ marked files. Will not overwrite/duplicate existing files on destination host.
+ \details When moving between different hosts the files are copied then deleted.
+ When moving on same host the files are renamed by the filesystem (which may also
+ copy/delete). The Db is updated to preserve states such as hidden, orientation & cover.
+ Attempts to move all files and reports the number of failures (but not which ones)
+ Successful moves are unmarked, failed ones remain marked.
 */
-void GalleryThumbView::ShowImport(bool deleteAfter)
+void GalleryThumbView::Move()
 {
-    m_deleteAfterImport = deleteAfter;
-
-    // Use temp dir if it exists
-    QString start = m_importTmp
-            ? m_importTmp->path()
-            : gCoreContext->GetSetting("GalleryImportLocation", "/media");
-
-    MythScreenStack        *popupStack = GetMythMainWindow()->GetStack("popup stack");
-    MythUIMultiFileBrowser *fb = new MythUIMultiFileBrowser(popupStack, start);
-
-    // Only browse supported image/video files
-    QDir filters(ImageSg::getInstance()->GetImageFilters());
-    fb->SetNameFilter(filters.nameFilters());
+    // Destination must be a dir
+    ImagePtrK destDir = m_menuState.m_selected;
+    if (!destDir || destDir->IsFile())
+        return;
 
-    fb->SetTypeFilter(QDir::AllDirs | QDir::Files | QDir::NoSymLinks | QDir::Readable);
-    if (fb->Create())
+    // Use current markings, if any. Otherwise use previous markings
+    ImageIdList markedIds = m_menuState.m_markedId;
+    if (markedIds.isEmpty())
     {
-        fb->SetReturnEvent(this, "ImportFilesSelected");
-        popupStack->AddScreen(fb);
+        markedIds = m_menuState.m_prevMarkedId;
+        if (markedIds.isEmpty())
+        {
+            ShowOkPopup(tr("No files specified"));
+            return;
+        }
     }
-    else
-        delete fb;
-}
-
 
-/*!
- \brief Import files into selected dir
- \param files List of file names
-*/
-void GalleryThumbView::ImportFiles(QStringList files)
-{
-    // Determine destination dir
-    ImageItem *destIm = m_menuState.m_selected;
+    // Note UI mandates that transferees are either all local or all remote
+    if (destDir->IsLocal() != ImageItem::IsLocalId(markedIds[0]))
+    {
+        // Moves between hosts require copy/delete
+        Copy(true);
+        return;
+    }
 
-    // Destination must be a dir
-    if (!destIm || destIm->IsFile())
+    // Get marked images. Each file and dir will be renamed
+    ImageList files, dirs;
+    if (m_mgr.GetImages(markedIds, files, dirs) <= 0)
+    {
+        ShowOkPopup(tr("No images specified"));
+        // Nothing to clean up
         return;
+    }
+    ImageList images = dirs + files;
+
+    // Determine parent from first dir or pic
+    ImagePtr aChild = images[0];
 
-    QDir    destDir(destIm->m_id == ROOT_DB_ID ? "" : destIm->m_fileName);
+    // Determine parent path including trailing /
+    // Note UI mandates that transferees all have same parent.
+    int basePathSize = aChild->m_filePath.size() - aChild->m_baseName.size();
+    QString parentPath = aChild->m_filePath.left(basePathSize);
 
-    // Build map of source & destination paths.
-    // Assumes all files are images; no dirs permitted
-    NameMap transfer;
-    ImageSg *sg = ImageSg::getInstance();
-    foreach(const QString &source, files)
+    // Determine destination URLs
+    TransferThread::TransferMap transfers;
+    foreach(ImagePtrK im, images)
     {
-        QFileInfo fi(source);
-        QString   destName(sg->GenerateUrl(destDir.filePath(fi.fileName())));
-        transfer.insert(source, destName);
+        // Replace base path with destination path
+        QString newPath = m_mgr.ConstructPath(destDir->m_filePath,
+                                              im->m_filePath.mid(basePathSize));
+
+        transfers.insert(im, m_mgr.BuildTransferUrl(newPath, aChild->IsLocal()));
     }
 
     // Create progress dialog
     MythScreenStack      *popupStack = GetMythMainWindow()->GetStack("popup stack");
     MythUIProgressDialog *progress   =
-        new MythUIProgressDialog(tr("Importing files"),
-                                 popupStack,
-                                 "importdialog");
+            new MythUIProgressDialog(tr("Moving files"), popupStack, "movedialog");
+
     if (progress->Create())
         popupStack->AddScreen(progress, false);
     else
@@ -1839,10 +2053,68 @@ void GalleryThumbView::ImportFiles(QStringList files)
         progress = NULL;
     }
 
-    // Import files in a separate thread
-    if (RunWorker(new FileTransferWorker(m_deleteAfterImport, transfer, progress)))
-        // Rescan to detect new files
-        GalleryBERequest::ScanImagesAction(true);
-    else
-        ShowOkPopup(tr("Failed to import files"));
+    // Move files in a servant thread
+    TransferThread move(transfers, true, progress);
+    WaitUntilDone(move);
+    TransferThread::ImageSet failed = move.GetResult();
+
+    if (progress)
+        progress->Close();
+
+    if (!failed.isEmpty())
+        ShowOkPopup(tr("Failed to move %L1/%Ln file(s)", 0, transfers.size())
+                    .arg(failed.size()));
+
+    // Don't update Db for files that failed
+    foreach (ImagePtrK im, failed)
+        transfers.remove(im);
+
+    if (!transfers.isEmpty())
+    {
+        ImageListK moved = transfers.keys();
+
+        // Unmark moved files
+        foreach (ImagePtrK im, moved)
+            m_view->Mark(im->m_id, false);
+
+        // Update Db
+        m_mgr.MoveDbImages(destDir, moved, parentPath);
+    }
+}
+
+
+/*!
+ \brief Executes user 'Import command'
+*/
+void GalleryThumbView::Import()
+{
+    QString path = m_mgr.CreateImport();
+    if (path.isEmpty())
+    {
+        ShowOkPopup(tr("Failed to create temporary directory."));
+        return;
+    }
+
+    // Replace placeholder in command
+    QString cmd = gCoreContext->GetSetting("GalleryImportCmd");
+    cmd.replace("%TMPDIR%", path);
+
+    // Run command in a separate thread
+    MythUIBusyDialog *busy =
+            ShowBusyPopup(tr("Running Import command.\nPlease wait..."));
+
+    ShellThread thread(cmd, path);
+    WaitUntilDone(thread);
+
+    if (busy)
+        busy->Close();
+
+    int error = thread.GetResult();
+    if (error != 0)
+        ShowOkPopup(QString(tr("Import command failed.\nError: %1")).arg(error));
+
+    // Rescan local devices
+    QString err = m_mgr.ScanImagesAction(true, true);
+    if (!err.isEmpty())
+        LOG(VB_GENERAL, LOG_ERR, LOC + err);
 }
diff --git a/mythtv/programs/mythfrontend/gallerythumbview.h b/mythtv/programs/mythfrontend/gallerythumbview.h
index d1535f6..37073a6 100644
--- a/mythtv/programs/mythfrontend/gallerythumbview.h
+++ b/mythtv/programs/mythfrontend/gallerythumbview.h
@@ -4,56 +4,11 @@
 #ifndef GALLERYVIEW_H
 #define GALLERYVIEW_H
 
-#include <QMap>
-#include <QHash>
-#include <QList>
-#include <QMutex>
-#include <QPair>
-#include <QEvent>
-#include <QKeyEvent>
-#include <QDir>
-
-#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
-    #include <QTemporaryDir>
-#else
-
-#define DIRNAME "import"
-class QTemporaryDir
-{
-public:
-    QTemporaryDir() : m_dir(QDir::temp())
-    {
-        m_dir.mkdir(DIRNAME);
-        m_dir.cd(DIRNAME);
-    }
-
-    ~QTemporaryDir()
-    {
-        foreach (const QString &name, m_dir.entryList(QDir::Files | QDir::NoDotAndDotDot))
-            m_dir.remove(name);
-        m_dir.cdUp();
-        m_dir.rmdir(DIRNAME);
-    }
-
-    bool isValid() { return m_dir.exists(); }
-    QString path() { return m_dir.absolutePath(); }
-
-private:
-    QDir m_dir;
-};
-
-#endif
-
-#include <mythuitext.h>
-#include <mythuibuttonlist.h>
-#include <mythdialogbox.h>
-#include <imagemetadata.h>
-#include <mythmediamonitor.h>
-
-#include "galleryviews.h"
 #include "galleryslideview.h"
+#include "galleryviews.h"
 
-
+class DirectoryView;
+class MythMenu;
 
 //! Type of captions to display
 enum ImageCaptionType {
@@ -75,44 +30,42 @@ public:
 
 public slots:
     void    Start();
-
-signals:
-    void    ThumbnailChanged(int);
+    void    Close();
+    void    ClearSgDb()  { m_mgr.ClearStorageGroup(); }
 
 private:
     bool    keyPressEvent(QKeyEvent *);
+    void    mediaEvent(MythMediaEvent *event)     { m_mgr.DeviceEvent(event); }
     void    customEvent(QEvent *);
+    void    RemoveImages(const QStringList &ids, bool deleted = true);
     void    BuildImageList();
     void    ResetUiSelection();
     void    TransformItem(ImageFileTransform tran = kRotateCW);
     void    TransformMarked(ImageFileTransform tran = kRotateCW);
     void    UpdateImageItem(MythUIButtonListItem *);
-    void    UpdateScanProgress(QString, QString, QString);
+    void    UpdateScanProgress(const QString &, int, int);
     void    StartSlideshow(ImageSlideShowType mode);
     void    SelectZoomWidget(int change);
-    void    ImportFiles(QStringList);
-    void    SetUiSelection(MythUIButtonListItem *);
-    QString CheckThumbnail(MythUIButtonListItem *, ImageItem *,
-                           QStringList &, int = 0);
-    void    UpdateThumbnail(MythUIButtonListItem *, ImageItem *,
-                            const QString &url, int = 0);
+    QString CheckThumbnail(MythUIButtonListItem *, ImagePtrK,
+                           ImageIdList &required, int);
+    void    UpdateThumbnail(MythUIButtonListItem *, ImagePtrK,
+                            const QString &url, int);
     void    MenuMain();
     void    MenuShow(MythMenu *);
     void    MenuMarked(MythMenu *);
     void    MenuPaste(MythMenu *);
     void    MenuTransform(MythMenu *);
     void    MenuAction(MythMenu *);
-    void    MenuImport(MythMenu *);
     void    MenuSlideshow(MythMenu *);
     bool    DirSelectUp();
     void    DirSelectDown();
     void    ShowDialog(QString, QString = "");
 
 private slots:
-    void    LoadData(int parent = -1);
-    void    SelectImage(int id);
+    void    LoadData(int);
+    void    SelectImage(int);
     void    ItemClicked(MythUIButtonListItem *);
-    void    ItemSelected(MythUIButtonListItem *);
+    void    SetUiSelection(MythUIButtonListItem *);
     void    Slideshow()            { StartSlideshow(kNormalSlideShow); }
     void    RecursiveSlideshow()   { StartSlideshow(kRecursiveSlideShow); }
     void    ShowDetails();
@@ -120,12 +73,12 @@ private slots:
     void    RotateCCW()            { TransformItem(kRotateCCW); }
     void    FlipHorizontal()       { TransformItem(kFlipHorizontal); }
     void    FlipVertical()         { TransformItem(kFlipVertical); }
-    void    ResetExif()            { TransformItem(kResetExif); }
+    void    ResetExif()            { TransformItem(kResetToExif); }
     void    RotateCWMarked()       { TransformMarked(kRotateCW); }
     void    RotateCCWMarked()      { TransformMarked(kRotateCCW); }
     void    FlipHorizontalMarked() { TransformMarked(kFlipHorizontal); }
     void    FlipVerticalMarked()   { TransformMarked(kFlipVertical); }
-    void    ResetExifMarked()      { TransformMarked(kResetExif); }
+    void    ResetExifMarked()      { TransformMarked(kResetToExif); }
     void    MarkItem(bool = true);
     void    UnmarkItem()           { MarkItem(false); }
     void    MarkAll(bool = true);
@@ -140,10 +93,6 @@ private slots:
     void    HideHidden()           { ShowHidden(false); }
     void    SetCover(bool reset = false);
     void    ResetCover()           { SetCover(true); }
-    void    ShowCaptions(int = kNoCaption);
-    void    CaptionsName()         { ShowCaptions(kNameCaption); }
-    void    CaptionsDate()         { ShowCaptions(kDateCaption); }
-    void    CaptionsComment()      { ShowCaptions(kUserCaption); }
     void    ShowType(int = kPicAndVideo);
     void    HidePictures()         { ShowType(kVideoOnly); }
     void    HideVideos()           { ShowType(kPicOnly); }
@@ -154,54 +103,49 @@ private slots:
     void    StopScan()             { StartScan(false); }
     void    DeleteItem();
     void    DeleteMarked();
-    void    ShowImport(bool deleteAfter = false);
-    void    ShowMoveImport()           { ShowImport(true); }
-    void    RunImportCmd();
+    void    Import();
     void    MakeDir();
-    void    Eject()  { MediaMonitor::GetMediaMonitor()->ChooseAndEjectMedia(); }
-    void    Copy();
+    void    Eject();
+    void    Copy(bool deleteAfter = false);
     void    Move();
     void    ShowPassword();
-    void    RepeatOn(int on = 1)  { gCoreContext->SaveSetting("GalleryRepeat", on); }
-    void    RepeatOff()        { RepeatOn(0); }
+    void    RepeatOn(int on = 1)   { gCoreContext->SaveSetting("GalleryRepeat", on); }
+    void    RepeatOff()            { RepeatOn(0); }
 
 private:
-    ImageDbReader     *m_db;
-    DirectoryView     *m_view;
-    MythScreenStack   *m_popupStack,       *m_mainStack;
+    typedef QPair<int,int> IntPair;
+
+    // Theme widgets
     MythUIButtonList  *m_imageList;
-    MythUIText        *m_captionText,      *m_crumbsText;
-    MythUIText        *m_hideFilterText,   *m_typeFilterText;
-    MythUIText        *m_positionText,     *m_emptyText;
+    MythUIText        *m_captionText,    *m_crumbsText,     *m_emptyText;
+    MythUIText        *m_hideFilterText, *m_typeFilterText, *m_positionText;
     MythUIText        *m_scanProgressText;
     MythUIProgressBar *m_scanProgressBar;
-    bool               m_scanInProgress;
-    int                m_zoomLevel;
-
-    //! Image details overlay
-    InfoList *m_infoList;
-
-    //! Current selection/marked files when menu is invoked
-    MenuSubjects m_menuState;
 
     //! Theme buttonlist widgets implementing zoom levels
     QList<MythUIButtonList *> m_zoomWidgets;
+    int                       m_zoomLevel;
 
-    //! Buttons waiting for BE to create thumbnail
-    typedef QPair<MythUIButtonListItem *, int> ThumbLocation;
-    QHash<int, ThumbLocation> m_pendingMap;
+    MythScreenStack &m_popupStack;
+    ImageManagerFe  &m_mgr;  //!< Manages the images
+    DirectoryView   *m_view; //!< List of images comprising the view
+    InfoList         m_infoList; //!< Image details overlay
 
-    //! Urls of images where thumbnails are known to exist
-    QHash<int, QString> m_url;
+    //! Last scan updates received from scanners
+    QHash<QString, IntPair> m_scanProgress;
+    //! Scanners currently scanning
+    QSet<QString>          m_scanActive;
 
-    //! Edit privileges
-    bool m_editsAllowed;
+    //! Current selection/marked files when menu is invoked
+    MenuSubjects m_menuState;
 
-    //! Distinguishes Import(Copy) from Import(Move)
-    bool m_deleteAfterImport;
+    typedef QPair<MythUIButtonListItem *, int> ThumbLocation;
+    //! Buttons waiting for thumbnails to be created
+    QHash<int, ThumbLocation> m_pendingMap;
 
-    //! Temporary dir for import commands/scripts
-    QTemporaryDir *m_importTmp;
+    QSet<int> m_thumbExists;  //!< Images where thumbnails are known to exist
+    bool      m_editsAllowed; //!< Edit privileges
 };
 
+
 #endif // GALLERYVIEW_H
diff --git a/mythtv/programs/mythfrontend/gallerytransitions.cpp b/mythtv/programs/mythfrontend/gallerytransitions.cpp
index 9ff664c..f1337e9 100644
--- a/mythtv/programs/mythfrontend/gallerytransitions.cpp
+++ b/mythtv/programs/mythfrontend/gallerytransitions.cpp
@@ -1,7 +1,18 @@
 #include "gallerytransitions.h"
 
-#include <QEasingCurve>
-#include <QPoint>
+#include "mythcorecontext.h"
+
+
+#define LOC QString("Transition: ")
+
+
+Transition::Transition(QString name)
+    : QObject(),
+      m_duration(gCoreContext->GetNumSetting("GalleryTransitionTime", 1000)),
+      m_old(NULL), m_new(NULL), m_prev(NULL), m_next(NULL)
+{
+    setObjectName(name);
+}
 
 
 /*!
@@ -10,16 +21,26 @@
  \param setting The user selected transition setting
  \return Transition The transition object or an alternative
 */
-Transition* TransitionRegistry::Select(int setting)
+Transition &TransitionRegistry::Select(int setting)
 {
+    // Guard against garbage
+    int value = (setting >= kNoTransition && setting < kLastTransSentinel)
+            ? setting : kNoTransition;
+
     // If chosen transition isn't viable for painter then use previous ones.
-    // First transition ust always be useable by all painters
+    // First transition must always be useable by all painters
     Transition *result = NULL;
     do
-        result = m_map.value(setting--, NULL);
-    while (setting >= 0 && !result);
+        result = m_map.value(value--, NULL);
+    while (value >= kNoTransition && !result);
 
-    return result;
+    if (result)
+        return *result;
+
+    LOG(VB_GENERAL, LOG_CRIT,
+        LOC + QString("No transitions found for setting %1").arg(setting));
+
+    return m_immediate;
 }
 
 
@@ -28,6 +49,7 @@ Transition* TransitionRegistry::Select(int setting)
  \param includeAnimations Whether to use animated transitions (zoom, rotate)
 */
 TransitionRegistry::TransitionRegistry(bool includeAnimations)
+    : m_immediate()
 {
     // Create all non-animated transitions to be used by Random
     m_map.insert(kBlendTransition, new TransitionBlend());
@@ -41,10 +63,10 @@ TransitionRegistry::TransitionRegistry(bool includeAnimations)
         m_map.insert(kSpinTransition,  new TransitionSpin());
     }
 
-    // Create random set
-    m_map.insert(kRandomTransition, new TransitionRandom(m_map));
+    // Create random set from those already defined
+    m_map.insert(kRandomTransition, new TransitionRandom(m_map.values()));
 
-    // Create all transitions not to be used by Random
+    // Create other transitions that aren't to be used by Random
     m_map.insert(kNoTransition, new TransitionNone());
 }
 
@@ -56,20 +78,20 @@ TransitionRegistry::TransitionRegistry(bool includeAnimations)
  \param forwards Direction
  \param speed Unused
 */
-void Transition::Start(Slide *from, Slide *to,
+void Transition::Start(Slide &from, Slide &to,
                        bool forwards, float speed)
 {
-    LOG(VB_FILE, LOG_DEBUG,
-        QString("Transition: Starting transition from %1 to %2 (forwards= %3, speed= %4)")
-        .arg(from->objectName(), to->objectName()).arg(forwards).arg(speed));
+    LOG(VB_FILE, LOG_DEBUG, LOC +
+        QString("Starting transition %1 -> %2 (forwards= %3, speed= %4)")
+        .arg(from.objectName(), to.objectName()).arg(forwards).arg(speed));
 
-    m_old = from;
-    m_new = to;
+    m_old = &from;
+    m_new = &to;
 
     // When playing forwards next image replaces prev image
     // When playing backwards prev image replaces next image
-    m_prev  = forwards ? from : to;
-    m_next = forwards ? to : from;
+    m_prev  = forwards ? m_old : m_new;
+    m_next = forwards ? m_new : m_old;
 
     // Set up transition
     Initialise();
@@ -90,6 +112,9 @@ void Transition::Finished()
     // Undo transition effects
     Finalise();
 
+    LOG(VB_FILE, LOG_DEBUG, LOC +
+        QString("Finished transition to %1").arg(m_new->objectName()));
+
     emit finished();
 }
 
@@ -101,7 +126,7 @@ void Transition::Finished()
  \param forwards Direction
  \param speed Factor, 1.0 = real-time
 */
-void TransitionNone::Start(Slide *from, Slide *to,
+void TransitionNone::Start(Slide &from, Slide &to,
                            bool forwards, float speed)
 {
     Transition::Start(from, to, forwards, speed);
@@ -125,7 +150,6 @@ GroupTransition::GroupTransition(GroupAnimation *animation, QString name)
 
 /*!
  \brief Destroy group transition
-
 */
 GroupTransition::~GroupTransition()
 {
@@ -141,7 +165,7 @@ GroupTransition::~GroupTransition()
  \param forwards Direction
  \param speed Factor, 1.0 = real-time
 */
-void GroupTransition::Start(Slide *from, Slide *to,
+void GroupTransition::Start(Slide &from, Slide &to,
                             bool forwards, float speed)
 {
     // Clear previous transition
@@ -162,10 +186,7 @@ void GroupTransition::Start(Slide *from, Slide *to,
 void GroupTransition::SetSpeed(float speed)
 {
     if (m_animation)
-    {
-        LOG(VB_FILE, LOG_DEBUG, QString("Transition: Changing speed to %1").arg(speed));
         m_animation->SetSpeed(speed);
-    }
 }
 
 
@@ -383,7 +404,7 @@ void TransitionSpin::Finalise()
  \param forwards Direction
  \param speed Unused
 */
-void TransitionRandom::Start(Slide *from, Slide *to, bool forwards, float speed)
+void TransitionRandom::Start(Slide &from, Slide &to, bool forwards, float speed)
 {
     // Select a random peer.
     int rand = qrand() % m_peers.size();
diff --git a/mythtv/programs/mythfrontend/gallerytransitions.h b/mythtv/programs/mythfrontend/gallerytransitions.h
index 4c38ce3..93facca 100644
--- a/mythtv/programs/mythfrontend/gallerytransitions.h
+++ b/mythtv/programs/mythfrontend/gallerytransitions.h
@@ -4,17 +4,12 @@
 #ifndef GALLERYTRANSITIONS_H
 #define GALLERYTRANSITIONS_H
 
-#include <QMap>
-#include <QList>
-
-#include <mythcorecontext.h>
-
 #include "galleryslide.h"
 
 
 //! Available transitions
 enum ImageTransitionType {
-    // First transition must be useable by all painters
+    // First transition must be 0 and useable by all painters
     kNoTransition      = 0,
     kRandomTransition  = 1,
     kBlendTransition   = 2,
@@ -22,6 +17,7 @@ enum ImageTransitionType {
     kSlideTransition   = 4,
     kZoomTransition    = 5,
     kSpinTransition    = 6,
+    kLastTransSentinel = 7  // Must be last
 };
 
 
@@ -30,18 +26,14 @@ class Transition : public QObject
 {
     Q_OBJECT
 public:
-    Transition(QString name)
-        : m_duration(gCoreContext->GetNumSetting("GalleryTransitionTime", 1000)),
-          m_old(NULL), m_new(NULL), m_prev(NULL), m_next(NULL),
-          m_name(name)                 {}
+    Transition(QString name);
     virtual ~Transition()              {}
 
-    virtual void Start(Slide *from, Slide *to, bool forwards, float speed = 1.0);
-    virtual void SetSpeed(float speed) {}
+    virtual void Start(Slide &from, Slide &to, bool forwards, float speed = 1.0);
+    virtual void SetSpeed(float)       {}
     virtual void Pulse(int interval)   = 0;
     virtual void Initialise()          {}
     virtual void Finalise()            {}
-    QString GetName()                  { return m_name; }
 
 protected slots:
     virtual void Finished();
@@ -68,8 +60,6 @@ protected:
     Slide *m_prev;
     //! The image occurring later in the slideshow sequence
     Slide *m_next;
-    //! Name that appears in settings
-    QString m_name;
 };
 
 
@@ -81,7 +71,7 @@ class TransitionNone : public Transition
 {
 public:
     TransitionNone() : Transition("None") {}
-    virtual void Start(Slide *from, Slide *to,
+    virtual void Start(Slide &from, Slide &to,
                        bool forwards, float speed = 1.0);
     virtual void Pulse(int) {}
 };
@@ -93,11 +83,11 @@ class GroupTransition : public Transition
 public:
     GroupTransition(GroupAnimation *animation, QString name);
     virtual ~GroupTransition();
-    virtual void Start(Slide *from, Slide *to,
+    virtual void Start(Slide &from, Slide &to,
                        bool forwards, float speed = 1.0);
     virtual void SetSpeed(float speed);
     virtual void Pulse(int interval);
-    virtual void Initialise() = 0;
+    virtual void Initialise()  = 0;
     virtual void Finalise()    = 0;
 
 protected:
@@ -149,7 +139,7 @@ public:
 class TransitionSpin : public TransitionBlend
 {
 public:
-    TransitionSpin() : TransitionBlend() { m_name = tr("Spin"); }
+    TransitionSpin() : TransitionBlend() { setObjectName(tr("Spin")); }
     virtual void Initialise();
     virtual void Finalise();
 };
@@ -160,20 +150,22 @@ class TransitionRandom : public Transition
 {
     Q_OBJECT
 public:
-    TransitionRandom(TransitionMap peers) : Transition(tr("Random")),
-          m_peers(peers.values()), m_current(NULL) {}
-    virtual void Start(Slide *from, Slide *to,
-                       bool forwards, float speed = 1.0);
-    virtual void Pulse(int interval) { if (m_current) m_current->Pulse(interval); }
-    virtual void Initialise()        { if (m_current) m_current->Initialise(); }
-    virtual void Finalise()          { if (m_current) m_current->Finalise(); }
+    TransitionRandom(QList<Transition*> peers)
+        : Transition(tr("Random")), m_peers(peers), m_current(NULL) {}
+    virtual void Start(Slide &from, Slide &to, bool forwards, float speed = 1.0);
+    virtual void SetSpeed(float speed) { if (m_current) m_current->SetSpeed(speed); }
+    virtual void Pulse(int interval)   { if (m_current) m_current->Pulse(interval); }
+    virtual void Initialise()          { if (m_current) m_current->Initialise(); }
+    virtual void Finalise()            { if (m_current) m_current->Finalise(); }
 
 protected slots:
     void Finished();
 
 protected:
+    //! Set of distinct transitions
     QList<Transition*> m_peers;
-    Transition *m_current;
+    //! Selected transition
+    Transition        *m_current;
 };
 
 
@@ -183,10 +175,14 @@ class TransitionRegistry
 public:
     TransitionRegistry(bool includeAnimations);
     ~TransitionRegistry()    { qDeleteAll(m_map); }
-    const TransitionMap GetAll() { return m_map; }
-    Transition *Select(int setting);
+    const TransitionMap GetAll() const { return m_map; }
+    Transition &Select(int setting);
+
+    //! A transition that updates instantly
+    TransitionNone m_immediate;
 
 private:
+    //! All possible transitions
     TransitionMap m_map;
 };
 
diff --git a/mythtv/programs/mythfrontend/galleryviews.cpp b/mythtv/programs/mythfrontend/galleryviews.cpp
index 703b9e6..552e400 100644
--- a/mythtv/programs/mythfrontend/galleryviews.cpp
+++ b/mythtv/programs/mythfrontend/galleryviews.cpp
@@ -2,67 +2,35 @@
 
 #include <cmath> // for qsrand
 
-#include <QTime>
 
-#include "gallerycommhelper.h"
+#define LOC QString("Galleryviews: ")
 
-
-/*!
- \brief Number of thumbnails to use for folders
-*/
+//! Number of thumbnails to use for folders
 const static int   kMaxFolderThumbnails = 4;
 
-/*!
- \brief Exif data with these titles comprise the Basic file info
-*/
-static QStringList kBasicInfoFields = QStringList()
-                                      // Exif tags
-                                      << "Date and Time"
-                                      << "Exposure Time"
-                                      << "FNumber"
-                                      << "Focal Length"
-                                      << "Image Description"
-                                      << "User Comment"
-                                      << "Manufacturer"
-                                      << "Max Aperture Value"
-                                      << "Model"
-                                      << "Orientation"
-                                      << "Pixel X Dimension"
-                                      << "Pixel Y Dimension"
-                                      // Video tags
-                                      << "model"
-                                      << "encoder";
-
-/*!
- \brief 
- Tuning parameter for seasonal weights, between 0 and 1, where lower numbers
- give greater weight to seasonal photos. The leading beta shape controls
- dates that are approaching and the trailing beta shape controls dates that
- just passed. When these are set to 0.175 and 0.31, respectively, about one
- quarter of the photos are from the upcoming week in prior years and about one
- quarter of the photos are from the preceding month in prior years.
-*/
+//! Tuning parameter for seasonal weights, between 0 and 1, where lower numbers
+//! give greater weight to seasonal photos. The leading beta shape controls
+//! dates that are approaching and the trailing beta shape controls dates that
+//! just passed. When these are set to 0.175 and 0.31, respectively, about one
+//! quarter of the photos are from the upcoming week in prior years and about one
+//! quarter of the photos are from the preceding month in prior years.
 const double LEADING_BETA_SHAPE  = 0.175;
-/*!
- \brief See LEADING_BETA_SHAPE
-*/
+//! See LEADING_BETA_SHAPE
 const double TRAILING_BETA_SHAPE = 0.31;
-/*!
- \brief Photos without an exif timestamp will default to the mode of the beta distribution.
-*/
+
+//! Photos without an exif timestamp will default to the mode of the beta distribution.
 const double DEFAULT_WEIGHT = std::pow(0.5, TRAILING_BETA_SHAPE - 1) *
                               std::pow(0.5, LEADING_BETA_SHAPE - 1);
-/*!
- \brief The edges of the distribution get clipped to avoid a singularity.
-*/
+//! The edges of the distribution get clipped to avoid a singularity.
 const qint64 BETA_CLIP = 60 * 60 * 24;
 
+
 /*!
  \brief Reset menu state
 */
 void MenuSubjects::Clear()
 {
-    m_selected       = NULL;
+    m_selected.clear();
     m_selectedMarked = false;
     m_childCount     = 0;
     m_markedId.clear();
@@ -73,198 +41,26 @@ void MenuSubjects::Clear()
 
 
 /*!
- \brief Factory for initialising an info/details buttonlist
-
- \param container The Screen widget
- \param focusable Set if info list should be focusable (for scrolling)
- \param undefined Text to display for tags with no value
- \return InfoList The info buttonlist
-*/
-InfoList* InfoList::Create(MythScreenType *container,
-                           bool focusable,
-                           QString undefined)
-{
-    MythUIButtonList *btnList;
-    bool              err = false;
-    UIUtilE::Assign(container, btnList, "infolist", &err);
-    if (err)
-        return NULL;
-
-    return new InfoList(container, focusable, undefined, btnList);
-}
-
-
-/*!
- \brief Info/details buttonlist constructor
-
- \param container The Screen widget
- \param focusable Set if info list should be focusable (for scrolling)
- \param undefined Text to display for tags with no value
- \param btnList Buttonlist provided by the theme
-*/
-InfoList::InfoList(MythScreenType *container, bool focusable, QString undefined,
-                   MythUIButtonList *btnList)
-    : m_screen(container),
-    m_btnList(btnList),
-    m_infoVisible(kNoInfo),
-    m_undefinedText(undefined)
-{
-    m_btnList->SetVisible(false);
-    m_btnList->SetCanTakeFocus(focusable);
-}
-
-
-/*!
- \brief Toggle infolist state for an image. Focusable widgets toggle between
- Basic & Full info. Non-focusable widgets toggle between Basic & Off.
- \param im The image/dir for which info is shown
-*/
-void InfoList::Toggle(const ImageItem *im)
-{
-    // Only focusable lists have an extra 'full' state as they can
-    // be scrolled to view it all
-    if (m_btnList->CanTakeFocus())
-
-        // Start showing basic info then toggle between basic/full
-        m_infoVisible = m_infoVisible == kBasicInfo ? kFullInfo : kBasicInfo;
-
-    // Toggle between off/basic
-    else if (m_infoVisible == kBasicInfo)
-    {
-        m_infoVisible = kNoInfo;
-        m_btnList->SetVisible(false);
-        return;
-    }
-    else
-        m_infoVisible = kBasicInfo;
-
-    Update(im);
-
-    m_btnList->SetVisible(true);
-}
-
-
-/*!
- \brief Remove infolist from display
- \return bool True if buttonlist was displayed/removed
-*/
-bool InfoList::Hide()
-{
-    // Only handle event if info currently displayed
-    bool handled = (m_infoVisible != kNoInfo);
-    m_infoVisible = kNoInfo;
-
-    m_btnList->SetVisible(false);
-
-    return handled;
-}
-
-
-/*!
- \brief Populate a buttonlist item with exif tag name & value
- \param name Exif tag name
- \param value Exif tag value
-*/
-void InfoList::CreateButton(QString name, QString value)
-{
-    MythUIButtonListItem *item = new MythUIButtonListItem(m_btnList, "");
-
-    InfoMap               infoMap;
-    infoMap.insert("name", name);
-    infoMap.insert("value", value.isEmpty() ? m_undefinedText : value);
-
-    item->SetTextFromMap(infoMap);
-}
-
-
-/*!
- \brief Populates available exif details for the current image/dir.
- \param im An image or dir
-*/
-void InfoList::Update(const ImageItem *im)
-{
-    if (!im || m_infoVisible == kNoInfo)
-        return;
-
-    // Clear info
-    m_btnList->Reset();
-
-    if (im->IsFile())
-    {
-        // File stats
-        CreateButton("Filename", im->m_name);
-        CreateButton("File Modified",
-                     QDateTime::fromTime_t(im->m_modTime).toString());
-        CreateButton("File size", QString("%1 Kb").arg(im->m_size / 1024));
-        CreateButton("Path", im->m_path);
-
-        NameMap tags = GalleryBERequest::GetMetaData(im);
-
-        // Now go through the info list and create a map for the buttonlist
-        NameMap::const_iterator i = tags.constBegin();
-        while (i != tags.constEnd())
-        {
-            if (m_infoVisible == kFullInfo || kBasicInfoFields.contains(i.key()))
-                CreateButton(i.key(), i.value());
-            ++i;
-        }
-
-        // Only give list focus if requested
-        if (m_btnList->CanTakeFocus())
-            m_screen->SetFocusWidget(m_btnList);
-    }
-    else if (im->m_id == ROOT_DB_ID)
-    {
-        // Gallery stats
-        CreateButton("Last scan", QDateTime::fromTime_t(
-                         im->m_modTime).toString());
-        CreateButton("Contains", QString("%1 Images, %2 Directories")
-                     .arg(im->m_fileCount).arg(im->m_dirCount));
-    }
-    else // dir
-    {
-        // File stats
-        CreateButton("Dirname", im->m_name);
-        CreateButton("Dir Modified",
-                     QDateTime::fromTime_t(im->m_modTime).toString());
-        CreateButton("Path", im->m_path);
-        CreateButton("Contains", QString("%1 Images, %2 Directories")
-                     .arg(im->m_fileCount).arg(im->m_dirCount));
-    }
-}
-
-
-/*!
- \brief Get current displayed state of buttonlist
- \return InfoVisibleState
-*/
-InfoVisibleState InfoList::GetState()
-{
-    return m_infoVisible;
-}
-
-
-/*!
  \brief Get all images/dirs in view
  \return ImageList List of images/dirs
 */
-ImageList FlatView::GetAllNodes() const
+ImageListK FlatView::GetAllNodes() const
 {
-    ImageList files;
-    foreach (ImageRef ptr, m_sequence)
-        files.append(*ptr);
+    ImageListK files;
+    foreach (int id, m_sequence)
+        files.append(m_images.value(id));
     return files;
 }
 
 
 /*!
  \brief Get current selection
- \return ImageItem* An image or NULL
+ \return ImagePtr An image or NULL
 */
-ImageItem* FlatView::GetSelected() const
+ImagePtrK FlatView::GetSelected() const
 {
     return m_active < 0 || m_active >= m_sequence.size()
-           ? NULL : *m_sequence[m_active];
+            ? ImagePtrK() : m_images.value(m_sequence.at(m_active));
 }
 
 
@@ -282,10 +78,10 @@ QString FlatView::GetPosition() const
  \brief Peeks at next image in view but does not advance iterator
  \return ImageItem The next image or NULL
 */
-ImageItem* FlatView::HasNext() const
+ImagePtrK FlatView::HasNext() const
 {
     return m_sequence.isEmpty() || m_active >= m_sequence.size() - 1
-           ? NULL : *m_sequence[m_active + 1];
+            ? ImagePtrK() : m_images.value(m_sequence.at(m_active + 1));
 }
 
 
@@ -293,10 +89,10 @@ ImageItem* FlatView::HasNext() const
  \brief Peeks at previous image in view but does not decrement iterator
  \return ImageItem The previous image or NULL
 */
-ImageItem* FlatView::HasPrev() const
+ImagePtrK FlatView::HasPrev() const
 {
     return m_sequence.isEmpty() || m_active <= 0
-           ? NULL : *m_sequence[m_active - 1];
+            ? ImagePtrK() : m_images.value(m_sequence.at(m_active - 1));
 }
 
 
@@ -307,40 +103,29 @@ ImageItem* FlatView::HasPrev() const
 */
 bool FlatView::Update(int id)
 {
-    bool activeUpdated = false;
+    ImagePtrK im = m_images.value(id);
+    if (!im)
+        return false;
 
-    // Replace old version of image
-    for (int j=0; j < m_images.size(); ++j)
-    {
-        if (m_images.at(j)->m_id == id)
-        {
-            // Get updated image
-            ImageList files;
-            m_db->ReadDbFilesById(files, QString::number(id), false);
+    // Get updated image
+    ImageList files, dirs;
+    ImageIdList ids = ImageIdList() << id;
+    if (m_mgr.GetImages(ids, files, dirs) != 1 || files.size() != 1)
+        return false;
 
-            if (files.size() == 1)
-            {
-                activeUpdated = GetSelected() == m_images.at(j);
+    bool active = (im == GetSelected());
 
-                // Replace image
-                delete m_images.at(j);
-                m_images.replace(j, files.at(0));
+    // Replace image
+    m_images.insert(id, files.at(0));
 
-                LOG(VB_FILE, LOG_DEBUG, QString("Views: Modified id %1 @ index %2")
-                    .arg(id).arg(j));
-            }
-            else
-                qDeleteAll(files);
+    LOG(VB_FILE, LOG_DEBUG, LOC + QString("Modified id %1").arg(id));
 
-            break;
-        }
-    }
-    return activeUpdated;
+    return active;
 }
 
 
 /*!
- \brief Select image
+ \brief Selects first occurrence of an image
  \param id Image id
  \param fallback View index to select if image is not in view. Defaults to first
  image. If negative then current selection is not changed if the image is not found
@@ -349,14 +134,11 @@ bool FlatView::Update(int id)
 bool FlatView::Select(int id, int fallback)
 {
     // Select first appearance of image
-    for (int i = 0; i < m_sequence.size(); ++i)
+    int index = m_sequence.indexOf(id);
+    if (index >= 0)
     {
-        ImageItem *im = *m_sequence.at(i);
-        if (im->m_id == id)
-        {
-            m_active = i;
-            return true;
-        }
+        m_active = index;
+        return true;
     }
 
     if (fallback >= 0)
@@ -372,13 +154,11 @@ bool FlatView::Select(int id, int fallback)
 */
 void FlatView::Clear(bool resetParent)
 {
-    if (!m_images.isEmpty())
-        qDeleteAll(m_images);
     m_images.clear();
     m_sequence.clear();
     m_active = -1;
     if (resetParent)
-        m_parentId = ROOT_DB_ID;
+        m_parentId = GALLERY_DB_ID;
 }
 
 
@@ -387,10 +167,10 @@ void FlatView::Clear(bool resetParent)
  view order on wrap, if necessary
  \return ImageItem Next image or NULL if empty
 */
-ImageItem *FlatView::Next()
+ImagePtrK FlatView::Next()
 {
     if (m_sequence.isEmpty())
-        return NULL;
+        return ImagePtrK();
 
     // wrap at end
     if (m_active >= m_sequence.size() - 1)
@@ -398,12 +178,12 @@ ImageItem *FlatView::Next()
         if (m_order == kOrdered)
             m_active = -1;
         // Regenerate unordered views on every repeat
-        else if (!LoadFromDb())
+        else if (!LoadFromDb(m_parentId))
             // Images have disappeared
-            return NULL;
+            return ImagePtrK();
     }
 
-    return *m_sequence[++m_active];
+    return m_images.value(m_sequence.at(++m_active));
 }
 
 
@@ -411,15 +191,15 @@ ImageItem *FlatView::Next()
  \brief Decrements iterator and returns previous image. Wraps at start.
  \return ImageItem Previous image or NULL if empty
 */
-ImageItem *FlatView::Prev()
+ImagePtrK FlatView::Prev()
 {
     if (m_sequence.isEmpty())
-        return NULL;
+        return ImagePtrK();
 
     if (m_active <= 0)
         m_active = m_sequence.size();
 
-    return *m_sequence[--m_active];
+    return m_images.value(m_sequence.at(--m_active));
 }
 
 
@@ -435,17 +215,24 @@ void FlatView::Populate(ImageList &files)
     if (files.isEmpty())
         return;
 
-    // Store available images for view
-    m_images = files;
+    foreach (ImagePtrK im, files)
+    {
+        // Add image to view
+        m_images.insert(im->m_id, im);
 
-    if (m_images.size() == 1 || m_order == kOrdered || m_order == kShuffle)
+        // Cache all displayed images
+        if (im->IsFile())
+            Cache(im->m_id, im->m_parentId, im->m_url, im->m_thumbNails.at(0).second);
+    }
+
+    if (files.size() == 1 || m_order == kOrdered || m_order == kShuffle)
     {
         // Default sequence is ordered
-        for (int i = 0; i < m_images.size(); ++i)
-            m_sequence.append(&m_images.at(i));
+        foreach (ImagePtrK im, files)
+            m_sequence.append(im->m_id);
     }
 
-    if (m_images.size() > 1)
+    if (files.size() > 1)
     {
         // Modify viewing sequence
         if (m_order == kShuffle)
@@ -455,30 +242,30 @@ void FlatView::Populate(ImageList &files)
         else if (m_order == kRandom)
         {
             qsrand(QTime::currentTime().msec());
-            int range = m_images.size() - 1;
-            int rand, slot = range;
-            for (int i = 0; i < m_images.size(); ++i)
+            // An image is not a valid candidate for its successor
+            int range = files.size() - 1;
+            int index = range;
+            for (int count = 0; count < files.size(); ++count)
             {
-                rand = qrand() % range;
+                int rand = qrand() % range;
                 // Avoid consecutive repeats
-                slot = (rand < slot) ? rand : rand + 1;
-                m_sequence.append(&m_images.at(slot));
-//                LOG(VB_FILE, LOG_DEBUG, QString("Rand %1").arg(slot));
+                index = (rand < index) ? rand : rand + 1;
+                m_sequence.append(files.at(index)->m_id);
             }
         }
         else if (m_order == kSeasonal)
         {
-            WeightList weights   = CalculateSeasonalWeights(m_images);
+            WeightList weights   = CalculateSeasonalWeights(files);
             double     maxWeight = weights.last();
 
             qsrand(QTime::currentTime().msec());
-            for (int i = 0; i < m_images.size(); ++i)
+            for (int count = 0; count < files.size(); ++count)
             {
-                double               randWeight = qrand() * maxWeight / RAND_MAX;
+                double randWeight = qrand() * maxWeight / RAND_MAX;
                 WeightList::iterator it =
                         std::upper_bound(weights.begin(), weights.end(), randWeight);
-                int                  slot = std::distance(weights.begin(), it);
-                m_sequence.append(&m_images.at(slot));
+                int    index      = std::distance(weights.begin(), it);
+                m_sequence.append(files.at(index)->m_id);
             }
         }
     }
@@ -486,7 +273,7 @@ void FlatView::Populate(ImageList &files)
 
 
 /*!
- \brief 
+ \brief
  * This method calculates a weight for the item based on how closely it was
  * taken to the current time of year. This means that New Year's pictures will
  * be displayed very frequently on every New Year's, and that anniversary
@@ -503,8 +290,8 @@ WeightList FlatView::CalculateSeasonalWeights(ImageList &files)
 
     for (int i = 0; i < files.size(); ++i)
     {
-        ImageItem *im      = files.at(i);
-        double         weight;
+        ImagePtrK im = files.at(i);
+        double weight;
 
         if (im->m_date == 0)
             weight = DEFAULT_WEIGHT;
@@ -512,37 +299,34 @@ WeightList FlatView::CalculateSeasonalWeights(ImageList &files)
         {
             QDateTime      timestamp = QDateTime::fromTime_t(im->m_date);
             QDateTime curYearAnniversary =
-                QDateTime(QDate(now.date().year(),
-                                timestamp.date().month(),
-                                timestamp.date().day()),
-                          timestamp.time());
+                    QDateTime(QDate(now.date().year(),
+                                    timestamp.date().month(),
+                                    timestamp.date().day()),
+                              timestamp.time());
 
             bool      isAnniversaryPast = curYearAnniversary < now;
 
             QDateTime adjacentYearAnniversary =
-                QDateTime(QDate(now.date().year() +
-                                (isAnniversaryPast ? 1 : -1),
-                                timestamp.date().month(),
-                                timestamp.date().day()),
-                          timestamp.time());
+                    QDateTime(QDate(now.date().year() +
+                                    (isAnniversaryPast ? 1 : -1),
+                                    timestamp.date().month(),
+                                    timestamp.date().day()),
+                              timestamp.time());
 
-            double range = std::abs(
-                curYearAnniversary.secsTo(adjacentYearAnniversary)) + BETA_CLIP;
+            double range = abs(curYearAnniversary.secsTo(
+                                   adjacentYearAnniversary)) + BETA_CLIP;
 
             // This calculation is not normalized, because that would require the
             // beta function, which isn't part of the C++98 libraries. Weights
             // that aren't normalized work just as well relative to each other.
-            weight = std::pow(abs(now.secsTo(
-                                      isAnniversaryPast ? curYearAnniversary
-                                      : adjacentYearAnniversary
-                                      ) + BETA_CLIP) / range,
-                              TRAILING_BETA_SHAPE - 1) *
-                     std::pow(abs(now.secsTo(
-                                      isAnniversaryPast ?
-                                      adjacentYearAnniversary :
-                                      curYearAnniversary
-                                      ) + BETA_CLIP) / range,
-                              LEADING_BETA_SHAPE - 1);
+            QDateTime d1(isAnniversaryPast ? curYearAnniversary
+                                           : adjacentYearAnniversary);
+            QDateTime d2(isAnniversaryPast ? adjacentYearAnniversary
+                                           : curYearAnniversary);
+            weight = pow(abs(now.secsTo(d1) + BETA_CLIP) / range,
+                         TRAILING_BETA_SHAPE - 1)
+                    * pow(abs(now.secsTo(d2) + BETA_CLIP) / range,
+                          LEADING_BETA_SHAPE - 1);
         }
         totalWeight += weight;
         weights[i]   = totalWeight;
@@ -559,12 +343,11 @@ WeightList FlatView::CalculateSeasonalWeights(ImageList &files)
 */
 bool FlatView::LoadFromDb(int parentId)
 {
-    if (parentId > 0)
-        m_parentId = parentId;
+    m_parentId = parentId;
 
     // Load child images of the parent
-    ImageList files;
-    m_db->ReadDbChildFiles(files, QString::number(m_parentId), false, true);
+    ImageList files, dirs;
+    m_mgr.GetChildren(m_parentId, files, dirs);
 
     // Load gallery datastore with current dir
     Populate(files);
@@ -574,53 +357,109 @@ bool FlatView::LoadFromDb(int parentId)
 
 
 /*!
+ \brief Clears UI cache
+*/
+void FlatView::ClearCache()
+{
+    LOG(VB_FILE, LOG_DEBUG, LOC + "Cleared File cache");
+    m_fileCache.clear();
+}
+
+
+/*!
+ \brief Clear file from UI cache and optionally from view
+ \param id
+ \param remove If true, file is also deleted from view
+ \return QStringList Url of image & thumbnail to remove from image cache
+*/
+QStringList FlatView::ClearImage(int id, bool remove)
+{
+    if (remove)
+    {
+        m_sequence.removeAll(id);
+        m_images.remove(id);
+    }
+
+    QStringList urls;
+    FileCacheEntry file = m_fileCache.take(id);
+
+    if (!file.m_url.isEmpty())
+        urls << file.m_url;
+
+    if (!file.m_thumbUrl.isEmpty())
+        urls << file.m_thumbUrl;
+
+    LOG(VB_FILE, LOG_DEBUG, LOC + QString("Cleared %1 from file cache (%2)")
+        .arg(id).arg(urls.join(",")));
+    return urls;
+}
+
+
+/*!
  \brief Rotate view so that starting image is at front.
  \param id The image to be positioned
- \param offset Distance the image will be from element 0
 */
-void FlatView::Rotate(int id, int offset)
+void FlatView::Rotate(int id)
 {
     // Rotate sequence so that (first appearance of) specified image is
     // at offset from front
-    for (int i = 0; i < m_sequence.size(); ++i)
+    int index = m_sequence.indexOf(id);
+    if (index >= 0)
     {
-        ImageItem *im = *m_sequence.at(i);
-        if (im->m_id == id)
-        {
-            int first = (i + offset) % m_sequence.size();
-            if (first > 0)
-                m_sequence = m_sequence.mid(first) + m_sequence.mid(0, first);
-            break;
-        }
+        int first = index % m_sequence.size();
+        if (first > 0)
+            m_sequence = m_sequence.mid(first) + m_sequence.mid(0, first);
     }
 }
 
 
 /*!
+ * \brief Cache image properties to optimize UI
+ * \param id Image id
+ * \param parent Its dir
+ * \param url Image url
+ * \param thumb Thumbnail url
+ */
+void FlatView::Cache(int id, int parent, const QString &url, const QString &thumb)
+{
+    // Cache parent dir so that dir thumbs are updated when a child changes.
+    // Also store urls for image cache cleanup
+    FileCacheEntry cached(parent, url, thumb);
+    m_fileCache.insert(id, cached);
+    LOG(VB_FILE, LOG_DEBUG, LOC + "Caching " + cached.ToString(id));
+}
+
+
+QString DirCacheEntry::ToString(int id) const
+{
+    QStringList ids;
+    for (int i = 0; i < m_thumbs.size(); ++i)
+        ids << QString::number(m_thumbs.at(i).first);
+    return QString("Dir %1 (%2, %3) Thumbs %4 (%5) Parent %6")
+            .arg(id).arg(m_fileCount).arg(m_dirCount).arg(ids.join(","))
+            .arg(m_thumbCount).arg(m_parent);
+}
+
+
+/*!
  \brief Constructs a view of images & directories that can be marked
  \param order Ordering to use for view
 */
-DirectoryView::DirectoryView(SlideOrderType order, ImageDbReader *db)
-    : FlatView(order, db)
+DirectoryView::DirectoryView(SlideOrderType order)
+    : FlatView(order)
 {
-    m_marked.Reset(ROOT_DB_ID);
-    m_prevMarked.Reset();
+    m_marked.Clear();
+    m_prevMarked.Clear();
 }
 
 
 /*!
- \brief Get all view items except the first (the parent dir)
- \return ImageIdList List of images/dirs
+ \brief Get positional status
+ \return QString "m/n" where m is selected index (0 for parent), n is total images
 */
-ImageIdList DirectoryView::GetChildren() const
+QString DirectoryView::GetPosition() const
 {
-    ImageIdList children;
-    for (int i = 1; i < m_sequence.size(); ++i)
-    {
-        ImageItem *im = *m_sequence.at(i);
-        children.append(im->m_id);
-    }
-    return children;
+    return QString("%1/%2").arg(m_active).arg(m_sequence.size() - 1);
 }
 
 
@@ -634,38 +473,61 @@ subtree.
 */
 bool DirectoryView::LoadFromDb(int parentId)
 {
-    // Invalid id signifies a refresh of the current view
-    if (parentId > 0)
-        SetDirectory(parentId);
-    else
-        parentId = m_parentId;
+    // Determine parent (defaulting to ancestor) & get initial children
+    ImageList files, dirs;
+    ImagePtr parent;
+    int count;
+    // Root is guaranteed to return at least 1 item
+    while ((count = m_mgr.GetDirectory(parentId, parent, files, dirs)) == 0)
+    {
+        // Fallback if dir no longer exists
+        // Ascend to Gallery for gallery subdirs, Root for device dirs & Gallery
+        parentId = parentId > PHOTO_DB_ID ? PHOTO_DB_ID : GALLERY_DB_ID;
+    }
+
+    SetDirectory(parentId);
+    m_parentId = parentId;
 
-    // Load visible parent or root
-    ImageItem *parent = GetDbParent(parentId);
-    if (!parent)
+    // No SG & no devices uses special 'empty' screen
+    if (!parent || (parentId == GALLERY_DB_ID && count == 1))
     {
-        Clear();
+        parent.clear();
         return false;
     }
 
-    m_parentId = parent->m_id;
+    // Populate all subdirs
+    foreach (ImagePtr im, dirs)
+    {
+        if (im)
+            // Load sufficient thumbs from each dir as subsequent dirs may be empty
+            LoadDirThumbs(*im, kMaxFolderThumbnails);
+    }
 
-    // Preserve current selection
-    ImageItem *selected = GetSelected();
-    int activeId = selected ? selected->m_id : 0;
+    // Populate parent
+    if (!PopulateFromCache(*parent, kMaxFolderThumbnails))
+        PopulateThumbs(*parent, kMaxFolderThumbnails, files, dirs);
 
-    // Load db data for this parent dir
-    ImageList dirs, images;
-    GetDbTree(images, dirs, parent);
+    // Dirs shown before images
+    ImageList images = dirs + files;
 
-    // Construct view as:
-    //  Parent kUpDirectory at start for navigating up.
-    //  Ordered dirs
-    //  Ordered files
-    ImageList files = dirs + images;
-    files.prepend(parent);
+    // Validate marked images
+    if (!m_marked.isEmpty())
+    {
+        QSet<int> ids;
+        foreach (ImagePtrK im, images)
+            ids.insert(im->m_id);
+        m_marked.intersect(ids);
+    }
 
-    Populate(files);
+    // Parent is always first (for navigating up).
+    images.prepend(parent);
+
+    // Preserve current selection before view is destroyed
+    ImagePtrK selected = GetSelected();
+    int activeId = selected ? selected->m_id : 0;
+
+    // Construct view
+    Populate(images);
 
     // Reinstate selection, falling back to parent
     Select(activeId);
@@ -675,13 +537,150 @@ bool DirectoryView::LoadFromDb(int parentId)
 
 
 /*!
+ \brief Populate thumbs for a dir
+ \param parent Parent dir
+ \param thumbsNeeded Number of thumbnails needed
+ \param level Recursion depth
+*/
+void DirectoryView::LoadDirThumbs(ImageItem &parent, int thumbsNeeded, int level)
+{
+    // Use cached data, if available
+    if (PopulateFromCache(parent, thumbsNeeded))
+        return;
+
+    // Load child images & dirs
+    ImageList files, dirs;
+    m_mgr.GetChildren(parent.m_id, files, dirs);
+
+    PopulateThumbs(parent, thumbsNeeded, files, dirs, level);
+}
+
+
+/*!
+ \brief Populate directory stats & thumbnails recursively from database as follows:
+Use user cover, if assigned. Otherwise derive 4 thumbnails from: first 4 images,
+then 1st thumbnail from first 4 sub-dirs, then 2nd thumbnail from sub-dirs etc
+ \param parent The parent dir
+ \param limit Number of thumbnails required
+ \param level Recursion level (to detect recursion deadlocks)
+*/
+void DirectoryView::PopulateThumbs(ImageItem &parent, int thumbsNeeded,
+                                   const ImageList &files, const ImageList &dirs,
+                                   int level)
+{
+    // Set parent stats
+    parent.m_fileCount = files.size();
+    parent.m_dirCount  = dirs.size();
+
+    // Locate user assigned thumb amongst children, if defined
+    ImagePtr userIm;
+    if (parent.m_userThumbnail != 0)
+    {
+        foreach (ImagePtr im, files + dirs)
+        {
+            if (im && im->m_id == parent.m_userThumbnail)
+            {
+                userIm = im;
+                break;
+            }
+        }
+    }
+
+    // Children to use as thumbnails
+    ImageList thumbFiles, thumbDirs;
+
+    if (!userIm)
+    {
+        // Construct multi-thumbnail from all children
+        thumbFiles = files;
+        thumbDirs  = dirs;
+    }
+    else if (userIm->IsFile())
+    {
+        thumbFiles.append(userIm);
+        thumbsNeeded = 1;
+    }
+    else
+        thumbDirs.append(userIm);
+
+    // Fill parent thumbs from child files first
+    // Whilst they're available fill as many as possible for cache
+    for (int i = 0; i < qMin(kMaxFolderThumbnails, thumbFiles.size()); ++i)
+    {
+        parent.m_thumbNails.append(thumbFiles.at(i)->m_thumbNails.at(0));
+        --thumbsNeeded;
+    }
+
+    // Only recurse if necessary
+    if (thumbsNeeded > 0)
+    {
+        // Prevent lengthy/infinite recursion due to deep/cyclic folder
+        // structures
+        if (++level > 10)
+            LOG(VB_GENERAL, LOG_NOTICE, LOC +
+                "Directory thumbnails are more than 10 levels deep");
+        else
+        {
+            // Recursively load subdir thumbs to try to get 1 thumb from each
+            foreach (ImagePtr im, thumbDirs)
+            {
+                if (!im)
+                    continue;
+
+                // Load sufficient thumbs from each dir as subsequent dirs may
+                // be empty
+                LoadDirThumbs(*im, thumbsNeeded, level);
+
+                if (im->m_thumbNails.size() > 0)
+                {
+                    // Add first thumbnail to parent thumb
+                    parent.m_thumbNails.append(im->m_thumbNails.at(0));
+
+                    // Quit when we have sufficient thumbs
+                    if (--thumbsNeeded == 0)
+                        break;
+                }
+            }
+
+            // If insufficient dirs to supply 1 thumb per dir, use other dir
+            // thumbs (indices 1-3) as well
+            int i = 0;
+            while (thumbsNeeded > 0 && ++i < kMaxFolderThumbnails)
+            {
+                foreach (ImagePtrK im, thumbDirs)
+                {
+                    if (i < im->m_thumbNails.size())
+                    {
+                        parent.m_thumbNails.append(im->m_thumbNails.at(i));
+                        if (--thumbsNeeded == 0)
+                            break;
+                    }
+                }
+            }
+        }
+    }
+
+    // Flag the cached entry with number of thumbs loaded. If future uses require
+    // more, then the dir must be reloaded.
+    // For user thumbs and dirs with insufficient child images, the cache is always valid
+    int scanned = (userIm || thumbsNeeded > 0)
+            ? kMaxFolderThumbnails
+            : parent.m_thumbNails.size();
+
+    // Cache result to optimize navigation
+    Cache(parent, scanned);
+}
+
+
+/*!
  \brief Resets view
  \param resetParent parent id is only reset to root when this is set
 */
-void DirectoryView::Clear(bool resetParent)
+void DirectoryView::Clear(bool)
 {
     ClearMarked();
-    FlatView::Clear(resetParent);
+    ClearCache();
+    FlatView::Clear();
 }
 
 
@@ -691,8 +690,7 @@ void DirectoryView::Clear(bool resetParent)
 void DirectoryView::MarkAll()
 {
     // Any marking clears previous marks
-    m_prevMarked.Reset();
-
+    m_prevMarked.Clear();
     m_marked.Add(GetChildren());
 }
 
@@ -707,11 +705,14 @@ void DirectoryView::Mark(int id, bool mark)
     if (mark)
     {
         // Any marking clears previous marks
-        m_prevMarked.Reset();
+        m_prevMarked.Clear();
         m_marked.Add(id);
     }
     else
-        m_marked.Remove(id);
+    {
+        m_prevMarked.remove(id);
+        m_marked.remove(id);
+    }
 }
 
 
@@ -721,8 +722,7 @@ void DirectoryView::Mark(int id, bool mark)
 void DirectoryView::InvertMarked()
 {
     // Any marking clears previous marks
-    m_prevMarked.Reset();
-
+    m_prevMarked.Clear();
     m_marked.Invert(GetChildren());
 }
 
@@ -732,8 +732,8 @@ void DirectoryView::InvertMarked()
 */
 void DirectoryView::ClearMarked()
 {
-    m_marked.Reset();
-    m_prevMarked.Reset();
+    m_marked.Clear();
+    m_prevMarked.Clear();
 }
 
 
@@ -743,23 +743,27 @@ void DirectoryView::ClearMarked()
 */
 void DirectoryView::SetDirectory(int newParent)
 {
+    if (m_marked.IsFor(newParent))
+        // Directory hasn't changed
+        return;
+
     // Markings are cleared on every dir change
-    // Any current markings become previous markingsConfirmDeleteSelected
+    // Any current markings become previous markings
     // Only 1 set of previous markings are preserved
     if (m_prevMarked.IsFor(newParent))
     {
         // Returned to dir of previous markings: reinstate them
         m_marked = m_prevMarked;
-        m_prevMarked.Reset();
+        m_prevMarked.Clear();
         return;
     }
 
-    if (!m_marked.IsEmpty())
+    if (!m_marked.isEmpty())
         // Preserve current markings
         m_prevMarked = m_marked;
 
     // Initialise current markings for new dir
-    m_marked.Reset(newParent);
+    m_marked.Initialise(newParent);
 }
 
 
@@ -774,252 +778,127 @@ MenuSubjects DirectoryView::GetMenuSubjects()
 
     state.m_selected       = GetSelected();
     state.m_selectedMarked = state.m_selected
-                             && m_marked.Contains(state.m_selected->m_id);
+            && m_marked.contains(state.m_selected->m_id);
 
     // At least one set will be empty
-    state.m_markedId     = m_marked.GetIds();
-    state.m_prevMarkedId = m_prevMarked.GetIds();
+    state.m_markedId     = m_marked.toList();
+    state.m_prevMarkedId = m_prevMarked.toList();
 
     state.m_childCount   = m_sequence.size() - 1;
 
-    // Only inspect children
-    for (int i = 1; i < m_sequence.size(); ++i)
+    // m_hiddenMarked is true if 1 or more marked items are hidden
+    // m_unhiddenMarked is true if 1 or more marked items are not hidden
+    foreach (int id, m_marked)
     {
-        ImageItem *im = *m_sequence.at(i);
-
-        if (m_marked.Contains(im->m_id))
-        {
-            state.m_hiddenMarked   = state.m_hiddenMarked || im->m_isHidden;
-            state.m_unhiddenMarked = state.m_unhiddenMarked || !im->m_isHidden;
-        }
+        ImagePtrK im = m_images.value(id);
+        if (!im)
+            continue;
+        if (im->m_isHidden)
+            state.m_hiddenMarked = true;
+        else
+            state.m_unhiddenMarked = true;
+        if (state.m_hiddenMarked && state.m_unhiddenMarked)
+            break;
     }
     return state;
 }
 
 
 /*!
- \brief Get parent dir from database
- \param parentId Id of dir
- \return ImageItem Dir image info
+ \brief Retrieve cached dir, if available
+ \param dir Dir image
+ \param required Number of thumbnails required
+ \return bool True if a cache entry exists
 */
-ImageItem *DirectoryView::GetDbParent(int parentId) const
+bool DirectoryView::PopulateFromCache(ImageItem &dir, int required)
 {
-    ImageList dirs;
-    m_db->ReadDbDirsById(dirs, QString::number(parentId), false, false);
+    DirCacheEntry cached(m_dirCache.value(dir.m_id));
+    if (cached.m_dirCount == -1 || cached.m_thumbCount < required)
+        return false;
 
-    if (dirs.isEmpty())
-    {
-        // Fallback to top level if parent dir no longer exists
-        // If no root then Db is empty
-        return parentId == ROOT_DB_ID ? NULL : GetDbParent(ROOT_DB_ID);
-    }
+    dir.m_fileCount  = cached.m_fileCount;
+    dir.m_dirCount   = cached.m_dirCount;
+    dir.m_thumbNails = cached.m_thumbs;
 
-    // Override parent type
-    if (dirs[0]->m_id != ROOT_DB_ID)
-        dirs[0]->m_type = kUpDirectory;
-    return dirs[0];
+    LOG(VB_FILE, LOG_DEBUG, LOC + "Using cached " + cached.ToString(dir.m_id));
+    return true;
 }
 
 
 /*!
- \brief Get all dirs & images from database, populate stats and determine thumbnails
- for parent & sub-dirs as follows: Use user cover, if assigned. Otherwise derive
-4 thumbnails from: first 4 images, then 1st thumbnail from first 4 sub-dirs,
-then 2nd thumbnail from sub-dirs etc
- \param files List to fill with images
- \param dirs List to fill with sub-dirs
- \param parent Parent dir
+ \brief Cache displayed dir
+ \param dir Dir image
+ \param thumbCount Number of populated thumbnails
 */
-void DirectoryView::GetDbTree(ImageList &files,
-                              ImageList &dirs,
-                              ImageItem *parent) const
+void DirectoryView::Cache(ImageItemK &dir, int thumbCount)
 {
-    if (!parent)
-        return;
-
-    // Load child images & dirs and set parent stats
-    parent->m_fileCount = m_db->ReadDbChildFiles(
-        files, QString::number(parent->m_id), false, true);
-    parent->m_dirCount = m_db->ReadDbChildDirs(
-        dirs, QString::number(parent->m_id), false, true);
-
-    const ImageItem *userIm = NULL;
-
-    // Load thumbs for child dirs
-    foreach (ImageItem *im, dirs)
-    {
-        // Load sufficient thumbs from each dir as subsequent dirs may be empty
-        GetDbSubTree(im, kMaxFolderThumbnails);
+    // Cache counts & thumbnails for each dir so that we don't need to reload its
+    // children from Db each time it's displayed
+    DirCacheEntry cacheEntry(dir.m_parentId, dir.m_dirCount, dir.m_fileCount,
+                             dir.m_thumbNails, thumbCount);
 
-        // Locate user thumbnail amongst dirs
-        if (!userIm && im->m_id == parent->m_userThumbnail)
-            userIm = im;
-    }
+    m_dirCache.insert(dir.m_id, cacheEntry);
 
-    // Try user assigned thumb, if defined
-    if (parent->m_userThumbnail != 0)
+    // Cache images used by dir thumbnails
+    foreach (const ThumbPair &thumb, dir.m_thumbNails)
     {
-        if (!userIm)
-            // Locate user thumb amongst images
-            foreach (ImageItem *im, files)
-            {
-                if (im->m_id == parent->m_userThumbnail)
-                {
-                    userIm = im;
-                    break;
-                }
-            }
-
-        if (userIm)
-        {
-            // Using user assigned thumbnail
-            parent->m_thumbIds   = userIm->m_thumbIds;
-            parent->m_thumbNails = userIm->m_thumbNails;
-            return;
-        }
-    }
-
-    // Fill parent thumbs from images
-    foreach (const ImageItem *im, files.mid(0, kMaxFolderThumbnails))
-    {
-        parent->m_thumbIds.append(im->m_id);
-        parent->m_thumbNails.append(im->m_thumbNails.at(0));
+        // Do not overwrite any existing image url nor parent.
+        // Image url is cached when image is displayed as a child, but not as a
+        // ancestor dir thumbnail
+        // First cache attempt will be by parent. Subsequent attempts may be
+        // by ancestor dirs.
+        if (!m_fileCache.contains(thumb.first))
+            FlatView::Cache(thumb.first, dir.m_id, "", thumb.second);
     }
+    LOG(VB_FILE, LOG_DEBUG, LOC + "Caching " + cacheEntry.ToString(dir.m_id));
+}
 
-    // If sufficient images, we're done
-    int thumbsNeeded = kMaxFolderThumbnails - files.size();
-    if (thumbsNeeded <= 0)
-        return;
 
-    // Resort to dirs. Use 1st thumb from each dir, then 2nd from each, etc.
-    for (int i = 0; i < kMaxFolderThumbnails; ++i)
-        foreach (const ImageItem *im, dirs)
-        {
-            if (i < im->m_thumbIds.size())
-            {
-                parent->m_thumbIds.append(im->m_thumbIds.at(i));
-                parent->m_thumbNails.append(im->m_thumbNails.at(i));
-                if (--thumbsNeeded == 0)
-                    // Found enough
-                    return;
-            }
-        }
+/*!
+ \brief Clears UI cache
+*/
+void DirectoryView::ClearCache()
+{
+    LOG(VB_FILE, LOG_DEBUG, LOC + "Cleared Dir cache");
+    m_dirCache.clear();
+    FlatView::ClearCache();
 }
 
 
 /*!
- \brief Populate directory stats & thumbnails recursively from database as follows:
-Use user cover, if assigned. Otherwise derive 4 thumbnails from: first 4 images,
-then 1st thumbnail from first 4 sub-dirs, then 2nd thumbnail from sub-dirs etc
- \param parent The parent dir
- \param limit Number of thumbnails required
- \param level Recursion level (to detect recursion deadlocks)
+ \brief Clear file/dir and all its ancestors from UI cache so that ancestor
+ thumbnails are recalculated. Optionally deletes file/dir from view.
+ \param id Image id
+ \param remove If true, file is also deleted from view
+ \return QStringList Url of image & thumbnail to remove from image cache
 */
-void DirectoryView::GetDbSubTree(ImageItem *parent, int limit, int level) const
+QStringList DirectoryView::RemoveImage(int id, bool deleted)
 {
-    // Load child images & dirs
-    ImageList files, dirs;
-    int       imageCount = m_db->ReadDbChildFiles(
-                files, QString::number(parent->m_id), false, true);
-    int       dirCount = m_db->ReadDbChildDirs(
-                dirs, QString::number(parent->m_id), false, true);
-
-    // Set parent stats
-    parent->m_fileCount = imageCount;
-    parent->m_dirCount  = dirCount;
+    QStringList urls;
+    int dirId = id;
 
-    // Try user assigned thumb, if defined
-    if (parent->m_userThumbnail != 0)
+    if (deleted)
     {
-        // Locate user thumb amongst images
-        bool found = false;
-        for (int i = 0; i < files.size(); ++i)
-            if (files.at(i)->m_id == parent->m_userThumbnail)
-            {
-                // Only need this image so move it to front
-                found = true;
-                limit = 1;
-                if (i != 0)
-                    files.move(i, 0);
-                break;
-            }
-
-        if (!found)
-        {
-            // Locate user thumb amongst dirs
-            foreach (const ImageItem *im, dirs)
-            {
-                if (im->m_id == parent->m_userThumbnail)
-                {
-                    // Discard all children & use this dir only
-                    ImageItem *tmp = new ImageItem(*im);
-                    qDeleteAll(files);
-                    files.clear();
-                    qDeleteAll(dirs);
-                    dirs.clear();
-                    dirs.append(tmp);
-                    break;
-                }
-            }
-        }
-
+        m_marked.remove(id);
+        m_prevMarked.remove(id);
     }
 
-    // Fill parent thumbs from images
-    foreach (const ImageItem *im, files)
+    // If id is a file then start with its parent
+    if (m_fileCache.contains(id))
     {
-        parent->m_thumbIds.append(im->m_id);
-        parent->m_thumbNails.append(im->m_thumbNails.at(0));
-        if (--limit == 0)
-            break;
+        // Clear file cache & start from its parent dir
+        dirId = m_fileCache.value(id).m_parent;
+        urls = FlatView::ClearImage(id, deleted);
     }
 
-    if (limit > 0)
+    // Clear ancestor dirs
+    while (m_dirCache.contains(dirId))
     {
-        // Prevent lengthy/infinite recursion due to deep/cyclic folder
-        // structures
-        if (++level > 10)
-            LOG(VB_GENERAL, LOG_NOTICE,
-                "Directory thumbnails are more than 10 levels deep");
-        else
-        {
-            // Recursively load subdir thumbs to try to get 1 thumb from each
-            foreach (ImageItem *im, dirs)
-            {
-                // Load sufficient thumbs from each dir as subsequent dirs may
-                // be empty
-                GetDbSubTree(im, limit, level);
-
-                if (im->m_thumbIds.size() > 0)
-                {
-                    // Add first thumbnail to parent thumb
-                    parent->m_thumbIds.append(im->m_thumbIds.at(0));
-                    parent->m_thumbNails.append(im->m_thumbNails.at(0));
-
-                    // Quit when we have sufficient thumbs
-                    if (--limit == 0)
-                        break;
-                }
-            }
-
-            if (limit > 0)
-                // Insufficient dirs to supply 1 thumb per dir so use other dir
-                // thumbs as well
-                for (int i = 1; i < kMaxFolderThumbnails; ++i)
-                    foreach (const ImageItem *im, dirs)
-                    {
-                        if (i < im->m_thumbIds.size())
-                        {
-                            parent->m_thumbIds.append(im->m_thumbIds.at(i));
-                            parent->m_thumbNails.append(im->m_thumbNails.at(i));
-                            if (--limit == 0)
-                                break;
-                        }
-                    }
-        }
+        LOG(VB_FILE, LOG_DEBUG, LOC + QString("Cleared %1 from dir cache").arg(dirId));
+        DirCacheEntry dir = m_dirCache.take(dirId);
+        dirId = dir.m_parent;
     }
-    qDeleteAll(files);
-    qDeleteAll(dirs);
+    return urls;
 }
 
 
@@ -1032,20 +911,15 @@ order of a tree is depth-first traversal
 */
 bool TreeView::LoadFromDb(int parentId)
 {
-    if (parentId > 0)
-        m_parentId = parentId;
+    m_parentId = parentId;
 
     // Load visible subtree of the parent
-    // Ordered images of parent first, then depth-first recursion of ordered dirs
-    ImageList  files, dirs;
-    QStringList root = QStringList() << QString::number(m_parentId);
-    m_db->ReadDbTree(files, dirs, root, false, true);
+    // Ordered images of parent first, then breadth-first recursion of ordered dirs
+    ImageList files;
+    m_mgr.GetImageTree(m_parentId, files);
 
     // Load view
     Populate(files);
 
-    // Discard dirs
-    qDeleteAll(dirs);
-
     return !files.isEmpty();
 }
diff --git a/mythtv/programs/mythfrontend/galleryviews.h b/mythtv/programs/mythfrontend/galleryviews.h
index e8d9eef..8044176 100644
--- a/mythtv/programs/mythfrontend/galleryviews.h
+++ b/mythtv/programs/mythfrontend/galleryviews.h
@@ -11,12 +11,7 @@
 #ifndef GALLERYVIEWS_H
 #define GALLERYVIEWS_H
 
-#include <QVector>
-
-#include <mythscreentype.h>
-#include <mythuibuttonlist.h>
-#include <imagemetadata.h>
-#include <imageutils.h>
+#include "imagemanager.h"
 
 
 //! Order of images in slideshow
@@ -27,36 +22,10 @@ enum SlideOrderType {
     kSeasonal = 3  //!< Biased random selection so that images are more likely to appear on anniversaries
 };
 
-//! Displayed info/details about an image.
-enum InfoVisibleState { kNoInfo,    //!< Details not displayed
-                        kBasicInfo, //!< Shows just the most useful exif tags
-                        kFullInfo   //!< Shows all exif tags
-                      };
 
 //! Seasonal weightings for images in a view
 typedef QVector<double> WeightList;
 
-//! The image info/details buttonlist overlay that displays exif tags
-class InfoList
-{
-public:
-    static InfoList *Create(MythScreenType *, bool, QString);
-
-    void             Toggle(const ImageItem *);
-    bool             Hide();
-    void             Update(const ImageItem *);
-    InfoVisibleState GetState();
-
-private:
-    InfoList(MythScreenType *, bool, QString, MythUIButtonList *infoList);
-    void              CreateButton(QString, QString);
-
-    MythScreenType   *m_screen;
-    MythUIButtonList *m_btnList;
-    InfoVisibleState  m_infoVisible;
-    QString           m_undefinedText;
-};
-
 
 //! A snapshot of current selection, markings & dir info when menu is invoked
 class MenuSubjects
@@ -64,87 +33,130 @@ class MenuSubjects
 public:
     void Clear();
 
-    ImageItem   *m_selected;       //!< Selected item
-    bool         m_selectedMarked; //!< Is selected item marked ?
-    ImageIdList  m_markedId;       //!< Ids of all marked items
-    ImageIdList  m_prevMarkedId;   //!< Ids of marked items in previous dir
-    int          m_childCount;     //!< Number of images & dirs excl parent
-    bool         m_hiddenMarked;   //!< Is any marked item hidden ?
-    bool         m_unhiddenMarked; //!< Is any marked item unhidden ?
+    ImagePtrK   m_selected;       //!< Selected item
+    bool        m_selectedMarked; //!< Is selected item marked ?
+    ImageIdList m_markedId;       //!< Ids of all marked items
+    ImageIdList m_prevMarkedId;   //!< Ids of marked items in previous dir
+    int         m_childCount;     //!< Number of images & dirs excl parent
+    bool        m_hiddenMarked;   //!< Is any marked item hidden ?
+    bool        m_unhiddenMarked; //!< Is any marked item unhidden ?
 };
 
 
-//! A manager of images/dirs that have been marked
-class MarkedFiles
+//! A container of images/dirs that have been marked
+class MarkedFiles : public QSet<int>
 {
 public:
-                MarkedFiles(void): parent(-1) {}
-    void        Reset(int id = -1)      { ids.clear(); parent = id; }
-    void        Add(int id)             { ids.insert(id); }
-    void        Add(ImageIdList newIds) { ids += newIds.toSet(); }
-    void        Remove(int id)          { ids.remove(id); }
-    void        Invert(ImageIdList all) { ids = all.toSet() - ids; }
-    bool        Contains(int id) const  { return ids.contains(id); }
-    bool        IsEmpty()               { return ids.isEmpty(); }
-    bool        IsFor(int id)           { return parent == id; }
-    ImageIdList GetIds()                { return ids.toList(); }
+    MarkedFiles() : QSet(), m_valid(false), m_parent(0) {}
+    void Initialise(int id)      { m_valid = true; m_parent = id; clear();}
+    void Clear()                 { m_valid = false; clear(); }
+    bool IsFor(int id)           { return m_valid && m_parent == id; }
+    void Add(ImageIdList newIds) { unite(newIds.toSet()); }
+    void Add(int id)             { insert(id); }
+    void Invert(ImageIdList all) { QSet tmp(all.toSet() - *this); swap(tmp); }
+
 private:
-    int       parent;
-    QSet<int> ids;
+    bool m_valid;
+    int  m_parent;
 };
 
 
+//! Records info of displayed image files to enable clean-up of the UI image cache
+class FileCacheEntry
+{
+public:
+    // Default constructor for QHash 'undefined entry'
+    FileCacheEntry() : m_parent(GALLERY_DB_ID), m_url(), m_thumbUrl() {}
+
+    FileCacheEntry(int parent, const QString &url, const QString &thumbUrl)
+        : m_parent(parent), m_url(url), m_thumbUrl(thumbUrl)  {}
+
+    QString ToString(int id)
+    { return QString("File %1 Parent %2").arg(id).arg(m_parent); }
+
+    int     m_parent;
+    QString m_url;
+    QString m_thumbUrl;
+};
+
 
 /*!
  \brief A datastore of images for display by a screen.
  \details A flat view provides a list of ordered images (no dirs) from a single
-directory, as required by a Normal Slideshow.
+ directory (as required by a slideshow of a directory).
 */
 class FlatView
 {
 public:
-    FlatView(SlideOrderType order, ImageDbReader *db)
-        : m_parentId(-1), m_order(order), m_db(db), m_images(), m_sequence(), m_active(0) {}
-    virtual ~FlatView()             { Clear(); }
-
-    int           GetParentId() const { return m_parentId; }
-    ImageList     GetAllNodes() const;
-    ImageItem    *GetSelected() const;
-    ImageItem    *HasNext() const;
-    ImageItem    *HasPrev() const;
-    ImageItem    *Next();
-    ImageItem    *Prev();
-    QString       GetPosition() const;
-    bool          Select(int id, int fallback = 0);
-    virtual bool  LoadFromDb(int parentId = -1);
-    bool          Remove(const QStringList);
-    bool          Update(int);
-    void          Rotate(int id, int offset = 0);
-    void          Clear(bool resetParent = true);
+    FlatView(SlideOrderType order)
+        : m_parentId(-1), m_order(order), m_mgr(ImageManagerFe::getInstance()),
+          m_images(), m_sequence(), m_active(0) {}
+    virtual ~FlatView()         { Clear(); }
+
+    int          GetParentId() const { return m_parentId; }
+    ImageListK   GetAllNodes() const;
+    ImagePtrK    GetSelected() const;
+    ImagePtrK    HasNext() const;
+    ImagePtrK    HasPrev() const;
+    ImagePtrK    Next();
+    ImagePtrK    Prev();
+    QString      GetPosition() const;
+    bool         Select(int id, int fallback = 0);
+    virtual bool LoadFromDb(int parentId);
+    QStringList  ClearImage(int id, bool remove = false);
+    void         ClearCache();
+    bool         Update(int id);
+    void         Rotate(int id);
+    void         Clear(bool resetParent = true);
+
+    QString      GetCachedThumbUrl(int id) const
+    { return m_fileCache.value(id).m_thumbUrl; }
 
 protected:
     static WeightList CalculateSeasonalWeights(ImageList &files);
 
-    void              Populate(ImageList &files);
+    void Populate(ImageList &files);
+    void Cache(int id, int parent, const QString &url, const QString &thumb);
+
+    int                   m_parentId;
+    SlideOrderType        m_order;
+    ImageManagerFe       &m_mgr;
+    QHash<int, ImagePtrK> m_images;   //!< Image objects currently displayed
+    ImageIdList           m_sequence; //!< The sequence in which to display images.
+    int                   m_active;   //!< Sequence index of current selected image
+
+    //! Caches displayed image files
+    QHash<int, FileCacheEntry> m_fileCache;
+};
 
-    //! A pointer to a list slot that contains a pointer to an image
-    typedef ImageItem *const *ImageRef;
 
-    int             m_parentId;
-    SlideOrderType  m_order;
-    ImageDbReader  *m_db;
-    //! The set of images (from Db) used by this view. Ordered as per GallerySortOrder
-    ImageList       m_images;
-    //! The sequence in which to display images. References slots in m_images as
-    //! random sequences may contain a specific image many times
-    QList<ImageRef> m_sequence;
-    int             m_active;   //!< Sequence index of current selected image
+//! Records dir info for every displayed dir. Populating dir thumbnails may
+//! entail lengthy interrogation of the dir subtree even though it doesn't change
+//! often. Caching this info improves browsing response.
+class DirCacheEntry
+{
+public:
+    DirCacheEntry()
+        : m_parent(), m_thumbCount(),
+          m_dirCount(-1), m_fileCount(-1), m_thumbs() {}
+
+    DirCacheEntry(int parentId, int dirs, int files,
+                  const QList<ThumbPair> &thumbs, int thumbCount)
+        : m_parent(parentId), m_thumbCount(thumbCount),
+          m_dirCount(dirs), m_fileCount(files), m_thumbs(thumbs) {}
+
+    QString ToString(int id) const;
+
+    int              m_parent;
+    int              m_thumbCount;
+    int              m_dirCount;
+    int              m_fileCount;
+    QList<ThumbPair> m_thumbs;
 };
 
 
 /*!
  \brief A datastore of images for display by a screen.
-
 Provides an ordered list of dirs & images from a single directory, as
 required by a Thumbnail view. Permits marking of items and populates dir
 thumbnails from their subtree
@@ -152,45 +164,53 @@ thumbnails from their subtree
 class DirectoryView : public FlatView
 {
 public:
-    DirectoryView(SlideOrderType, ImageDbReader *);
+    DirectoryView(SlideOrderType);
+
+    ImagePtrK GetParent() const
+    { return m_sequence.isEmpty() ? ImagePtrK() : m_images.value(m_sequence.at(0)); }
 
-    ImageItem   *GetParent() const { return m_sequence.isEmpty() ? NULL : *m_sequence[0]; }
-    bool         LoadFromDb(int parentId = -1);
+    QString      GetPosition() const;
+    bool         LoadFromDb(int parentId);
     void         Clear(bool resetParent = true);
+    MenuSubjects GetMenuSubjects();
+    QStringList  RemoveImage(int id, bool deleted = false);
+    void         ClearCache();
     void         MarkAll();
     void         Mark(int, bool);
     void         InvertMarked();
     void         ClearMarked();
     bool         IsMarked(int id) const
-    { return m_marked.Contains(id) || m_prevMarked.Contains(id); }
-
-    MenuSubjects GetMenuSubjects();
+    { return m_marked.contains(id) || m_prevMarked.contains(id); }
 
 protected:
     void         SetDirectory(int);
-    ImageIdList  GetChildren() const;
-    ImageItem   *GetDbParent(int ) const;
-    void         GetDbTree(ImageList &, ImageList &, ImageItem * = NULL) const;
-    void         GetDbSubTree(ImageItem *, int limit, int level = 0) const;
+    void         LoadDirThumbs(ImageItem &, int limit, int level = 0);
+    void         PopulateThumbs(ImageItem &, int limit,
+                                const ImageList &files, const ImageList &dirs,
+                                int level = 0);
+    ImageIdList  GetChildren() const  { return m_sequence.mid(1); }
+    bool         PopulateFromCache(ImageItem &, int required);
+    void         Cache(ImageItemK &, int thumbCount);
 
     MarkedFiles m_marked;       //!< Marked items in current dir/view
     MarkedFiles m_prevMarked;   //!< Marked items in previous dir
+
+    //! Caches displayed image dirs
+    QHash<int, DirCacheEntry>  m_dirCache;
 };
 
 
 /*!
  \brief A datastore of images for display by a screen.
-
 Provides an ordered list of images (no dirs) from a directory subtree.
 Default ordering is a depth-first traversal of the tree
 */
 class TreeView : public FlatView
 {
 public:
-    TreeView(SlideOrderType order, ImageDbReader *db)
-        : FlatView(order, db) {}
+    TreeView(SlideOrderType order) : FlatView(order) {}
 
-    bool LoadFromDb(int parentId = -1);
+    bool LoadFromDb(int parentId);
 };
 
 
diff --git a/mythtv/programs/mythfrontend/main.cpp b/mythtv/programs/mythfrontend/main.cpp
index 213c12c..6529eef 100644
--- a/mythtv/programs/mythfrontend/main.cpp
+++ b/mythtv/programs/mythfrontend/main.cpp
@@ -810,6 +810,39 @@ static void handleDVDMedia(MythMediaDevice *dvd)
     }
 }
 
+static void handleGalleryMedia(MythMediaDevice *dev)
+{
+    // Only handle events for media that are newly mounted
+    if (!dev || (dev->getStatus() != MEDIASTAT_MOUNTED
+                  && dev->getStatus() != MEDIASTAT_USEABLE))
+        return;
+
+    // Check if gallery is already running
+    QVector<MythScreenType*> screens;
+    GetMythMainWindow()->GetMainStack()->GetScreenList(screens);
+
+    QVector<MythScreenType*>::const_iterator it    = screens.begin();
+    QVector<MythScreenType*>::const_iterator itend = screens.end();
+
+    for (; it != itend; ++it)
+    {
+        if (dynamic_cast<GalleryThumbView*>(*it))
+        {
+            // Running gallery will receive this event later
+            LOG(VB_MEDIA, LOG_INFO, "Main: Ignoring new gallery media - already running");
+            return;
+        }
+    }
+
+    if (gCoreContext->GetNumSetting("GalleryAutoLoad", 0))
+    {
+        LOG(VB_GUI, LOG_INFO, "Main: Autostarting Gallery for new media");
+        GetMythMainWindow()->JumpTo(JUMP_GALLERY_DEFAULT);
+    }
+    else
+        LOG(VB_MEDIA, LOG_INFO, "Main: Ignoring new gallery media - autorun not set");
+}
+
 static void TVMenuCallback(void *data, QString &selection)
 {
     (void)data;
@@ -1364,6 +1397,11 @@ static void InitJumpPoints(void)
      REG_JUMP("Play Disc", QT_TRANSLATE_NOOP("MythControls",
          "Play an Optical Disc"), "", playDisc);
 
+     // Gallery
+
+     REG_JUMP(JUMP_GALLERY_DEFAULT, QT_TRANSLATE_NOOP("MythControls",
+         "Image Gallery"), "", RunGallery);
+
      REG_JUMPEX(QT_TRANSLATE_NOOP("MythControls", "Toggle Show Widget Borders"),
          "", "", setDebugShowBorders, false);
      REG_JUMPEX(QT_TRANSLATE_NOOP("MythControls", "Toggle Show Widget Names"),
@@ -1371,11 +1409,6 @@ static void InitJumpPoints(void)
      REG_JUMPEX(QT_TRANSLATE_NOOP("MythControls", "Reset All Keys"),
          QT_TRANSLATE_NOOP("MythControls", "Reset all keys to defaults"),
          "", resetAllKeys, false);
-
-     // Gallery
-
-     REG_JUMP(JUMP_GALLERY_DEFAULT, QT_TRANSLATE_NOOP("MythControls",
-         "The Gallery Default View"), "", RunGallery);
 }
 
 static void ReloadJumpPoints(void)
@@ -1403,12 +1436,8 @@ static void InitKeys(void)
          "Display Item Detail Popup"), "");
 
      // Gallery keybindings
-     REG_KEY("Images", "SLIDESHOW", QT_TRANSLATE_NOOP("MythControls",
-         "Start Slideshow"), "P");
-     REG_KEY("Images", "PAUSE", QT_TRANSLATE_NOOP("MythControls",
-         "Pause Slideshow"), "Ctrl+P");
-     REG_KEY("Images", "STOP", QT_TRANSLATE_NOOP("MythControls",
-         "Stop Slideshow"), "Alt+P");
+     REG_KEY("Images", "PLAY", QT_TRANSLATE_NOOP("MythControls",
+         "Start/Stop Slideshow"), "P");
      REG_KEY("Images", "RECURSIVESHOW", QT_TRANSLATE_NOOP("MythControls",
          "Start Recursive Slideshow"), "R");
      REG_KEY("Images", "ROTRIGHT", QT_TRANSLATE_NOOP("MythControls",
@@ -1496,6 +1525,17 @@ static int internal_media_init()
     REG_MEDIA_HANDLER(QT_TRANSLATE_NOOP("MythControls",
         "MythDVD DVD Media Handler"), "", "", handleDVDMedia,
         MEDIATYPE_DVD, QString::null);
+    REG_MEDIA_HANDLER(QT_TRANSLATE_NOOP("MythControls",
+        "MythImage Media Handler 1/2"), "", "", handleGalleryMedia,
+        MEDIATYPE_DATA | MEDIATYPE_MIXED, QString::null);
+
+    QStringList extensions;
+    foreach (const QByteArray &ext, QImageReader::supportedImageFormats())
+        extensions << QString(ext);
+
+    REG_MEDIA_HANDLER(QT_TRANSLATE_NOOP("MythControls",
+        "MythImage Media Handler 2/2"), "", "", handleGalleryMedia,
+        MEDIATYPE_MGALLERY, extensions.join(","));
     return 0;
 }
 
diff --git a/mythtv/programs/mythfrontend/mythfrontend.pro b/mythtv/programs/mythfrontend/mythfrontend.pro
index db1c47d..f18845b 100644
--- a/mythtv/programs/mythfrontend/mythfrontend.pro
+++ b/mythtv/programs/mythfrontend/mythfrontend.pro
@@ -54,8 +54,8 @@ HEADERS += videoglobalsettings.h        upnpscanner.h
 HEADERS += commandlineparser.h          idlescreen.h
 HEADERS += gallerythumbview.h           galleryslideview.h
 HEADERS += galleryconfig.h              galleryviews.h
-HEADERS += gallerycommhelper.h          gallerytransitions.h
-HEADERS += galleryslide.h
+HEADERS += galleryslide.h               gallerytransitions.h
+HEADERS += galleryinfo.h
 
 SOURCES += main.cpp playbackbox.cpp viewscheduled.cpp audiogeneralsettings.cpp
 SOURCES += globalsettings.cpp manualschedule.cpp programrecpriority.cpp
@@ -79,8 +79,8 @@ SOURCES += videoglobalsettings.cpp      upnpscanner.cpp
 SOURCES += commandlineparser.cpp        idlescreen.cpp
 SOURCES += gallerythumbview.cpp         galleryslideview.cpp
 SOURCES += galleryconfig.cpp            galleryviews.cpp
-SOURCES += gallerycommhelper.cpp        gallerytransitions.cpp
-SOURCES += galleryslide.cpp
+SOURCES += galleryslide.cpp             gallerytransitions.cpp
+SOURCES += galleryinfo.cpp
 
 HEADERS += serviceHosts/frontendServiceHost.h
 HEADERS += services/frontend.h
diff --git a/mythtv/themes/default/base.xml b/mythtv/themes/default/base.xml
index 75bc071..2f0c6d2 100644
--- a/mythtv/themes/default/base.xml
+++ b/mythtv/themes/default/base.xml
@@ -747,14 +747,7 @@
                     <filename>shared/folder-reg.png</filename>
                 </imagetype>
             </state>
-            <state name="root" from="subfolder"/>
-            <state name="upfolder" from="subfolder">
-                <imagetype name="icon">
-                    <area>10%,2%,40%,13%</area>
-                    <filename>shared/updirectory.png</filename>
-                    <preserveaspect>yes</preserveaspect>
-                </imagetype>
-            </state>
+            <state name="device" from="subfolder"/>
             <state name="image">
                 <area>0,0,100%,100%</area>
                 <imagetype name="background">
@@ -773,9 +766,9 @@
         </statetype>
         <!-- Show how many images / directories are in this directory -->
         <textarea name="childcount" from="basetextarea">
-            <area>0,0,55%,15%</area>
+            <area>5%,0,100%,15%</area>
             <font>gallerytext</font>
-            <align>allcenter</align>
+            <align>left,vcenter</align>
         </textarea>
         <!-- Shows a picture image -->
         <imagetype name="buttonimage">
@@ -809,6 +802,19 @@
             <area>51%,57%,92%,93%</area>
             <preserveaspect>false</preserveaspect>
         </imagetype>
+        <!-- Show up arrow on parent dir with ancestors -->
+        <statetype name="parenttype">
+            <area>0,0,100%,100%</area>
+            <state name="upfolder">
+                <area>0,0,100%,100%</area>
+                <imagetype name="icon">
+                    <area>4%,14%,10%,20%</area>
+                    <filename>uparrow.png</filename>
+                    <preserveaspect>no</preserveaspect>
+                    <alpha>208</alpha>
+                </imagetype>
+            </state>
+        </statetype>
         <!-- Darken hidden files/ folders -->
         <statetype name="buttonstate">
             <area>0,0,100%,100%</area>
@@ -840,7 +846,7 @@
             </state>
         </statetype>
         <textarea name="buttontext">
-            <area>0,100%-22,100%,22</area>
+            <area>2%,100%-22,99%,22</area>
             <font>gallerytext</font>
             <align>allcenter</align>
         </textarea>
@@ -858,21 +864,14 @@
                     <filename>shared/folder-sel.png</filename>
                 </imagetype>
             </state>
-            <state name="root" from="subfolder"/>
-            <state name="upfolder" from="subfolder">
-                <imagetype name="icon">
-                    <area>10%,2%,40%,13%</area>
-                    <filename>shared/updirectory.png</filename>
-                    <preserveaspect>yes</preserveaspect>
-                </imagetype>
-            </state>
+            <state name="device" from="subfolder"/>
             <state name="image">
                 <area>0,0,100%,100%</area>
                 <imagetype name="background">
-    <area>0,0,100%,100%</area>
-    <filename>shared/grid_back_sel.png</filename>
-    <alpha>255</alpha>
-    </imagetype>
+                    <area>0,0,100%,100%</area>
+                    <filename>shared/grid_back_sel.png</filename>
+                    <alpha>255</alpha>
+                </imagetype>
             </state>
             <state name="video">
                 <area>0,0,100%,100%</area>
@@ -902,13 +901,13 @@
                     </fill>
                 </shape>
                 <textarea name="name" from="basetextarea">
-                    <area>2%,0%,35%,100%</area>
+                    <area>1%,0%,33%,100%</area>
                     <align>vcenter</align>
                 </textarea>
                 <textarea name="value" from="name">
-                    <area>40%,0%,98%,100%</area>
+                    <area>35%,0%,99%,100%</area>
                 </textarea>
-                </state>
+            </state>
             <state name="selectedactive" from="active">
                 <shape name="buttonbackground">
                     <area>0,0,100%,100%</area>
@@ -916,6 +915,15 @@
                         <gradient start="#52CA38" end="#349838" alpha="255"/>
                     </fill>
                 </shape>
+                <textarea name="name" from="basetextarea">
+                    <area>1%,0%,33%,100%</area>
+                    <align>vcenter</align>
+                    <cutdown>no</cutdown>
+                    <scroll direction="horizontal" startdelay="0" returndelay="0"/>
+                </textarea>
+                <textarea name="value" from="name">
+                    <area>35%,0%,99%,100%</area>
+                </textarea>
             </state>
             <state name="inactive" from="active"/>
             <state name="selectedinactive" from="active"/>
@@ -929,7 +937,7 @@
             </state>
         </statetype>
         <statetype name="downscrollarrow">
-            <position>46%,97%</position>
+            <position>46%,98%</position>
             <state type="full">
                 <imagetype name="dnoff">
                      <filename>lb-dnarrow-sel.png</filename>
@@ -1307,165 +1315,6 @@
 
     </window>
 
-    <window name="MythMultiFileBrowser">
-        <area>0,0,100%,100%</area>
-        <imagetype name="backimg">
-            <area>0,0,100%,100%</area>
-            <filename>mythfilebrowser-background.png</filename>
-        </imagetype>
-
-        <textedit name="location" from="basetextedit">
-            <area>4%,20,60%,50</area>
-        </textedit>
-
-        <buttonlist name="filelist">
-            <area>0,0,100%,100%</area>
-            <layout>grid</layout>
-            <buttonarea>2%,78,72%,100%-80</buttonarea>
-            <spacing>2</spacing>
-            <statetype name="buttonitem">
-                <state name="active">
-                    <area>0,0,176,126</area>
-                    <shape name="buttonbackground"/>
-                    <statetype name="nodetype">
-                        <area>0,0,100%,100%</area>
-                        <state name="folder">
-                            <area>4%,4%,92%,66%</area>
-                            <imagetype name="icon">
-                                <area>0,0,100%,100%</area>
-                                <filename>shared/directory.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder" from="folder">
-                            <area>4%,4%,92%,66%</area>
-                            <imagetype name="icon">
-                                <area>0,0,100%,100%</area>
-                                <filename>shared/updirectory.png</filename>
-                            </imagetype>
-                        </state>
-                        <state name="executable" from="folder">
-                            <area>4%,4%,92%,66%</area>
-                            <imagetype name="icon">
-                                <area>0,0,100%,100%</area>
-                                <filename>shared/executable.png</filename>
-                            </imagetype>
-                        </state>
-                        <state name="file" from="folder">
-                            <area>4%,4%,92%,66%</area>
-                            <imagetype name="icon">
-                                <area>0,0,100%,100%</area>
-                                <filename>shared/file.png</filename>
-                            </imagetype>
-                        </state>
-                    </statetype>
-                    <imagetype name="buttonimage">
-                        <area>2%,3%,96%,97%-30</area>
-                        <preserveaspect>true</preserveaspect>
-                    </imagetype>
-                    <textarea name="buttontext" from="basetextarea">
-                        <area>0,100%-28,100%,26</area>
-                        <align>allcenter</align>
-                    </textarea>
-            <statetype name="buttoncheck">
-                <area>0,0,100%,100%</area>
-                <state type="full">
-                    <area>40%,35%,40%,40%</area>
-                    <imagetype name="marked">
-                        <area>0,0,100%,100%</area>
-                        <filename>playlist_yes.png</filename>
-                    </imagetype>
-                </state>
-            </statetype>
-                </state>
-                <state name="inactive" from="active"/>
-                <state name="selectedinactive" from="active"/>
-                <state name="selectedactive" from="active">
-                    <area>0,0,176,126</area>
-                    <shape name="buttonbackground">
-                        <area>0,0,100%,100%</area>
-                        <fill style="gradient">
-                            <gradient start="#999999" end="#666666" alpha="220"/>
-                        </fill>
-                    </shape>
-                </state>
-            </statetype>
-            <statetype name="upscrollarrow">
-                <position>73%,78</position>
-                <state type="off">
-                    <imagetype name="upon">
-                        <filename>lb-uparrow-reg.png</filename>
-                    </imagetype>
-                </state>
-                <state type="full">
-                    <imagetype name="upoff">
-                        <filename>lb-uparrow-sel.png</filename>
-                    </imagetype>
-                </state>
-            </statetype>
-            <statetype name="downscrollarrow">
-                <position>73%,100%-100</position>
-                <state type="off">
-                    <imagetype name="dnon">
-                        <filename>lb-dnarrow-reg.png</filename>
-                    </imagetype>
-                </state>
-                <state type="full">
-                    <imagetype name="dnoff">
-                        <filename>lb-dnarrow-sel.png</filename>
-                    </imagetype>
-                </state>
-            </statetype>
-        </buttonlist>
-
-        <!--<button name="back" from="basebutton">
-            <position>79%,20</position>
-            <value>Up Level</value>
-        </button>-->
-
-        <!--<button name="home" from="basebutton">
-            <position>79%,70</position>
-            <value>Home</value>
-        </button>-->
-
-        <button name="selectall" from="basebutton">
-            <position>79%,3%</position>
-            <value>Select All</value>
-        </button>
-
-        <button name="clearall" from="basebutton">
-            <position>79%,10%</position>
-            <value>Clear All</value>
-        </button>
-
-        <textarea name="selectcount" from="basetextarea">
-            <area>72%,19%,92%,30</area>
-            <align>allcenter</align>
-            <template>%n selection(s)</template>
-        </textarea>
-
-        <imagetype name="preview">
-            <area>72%,23%,92%,70%</area>
-            <preserveaspect>true</preserveaspect>
-        </imagetype>
-
-        <textarea name="info" from="basetextarea">
-            <area>72%,78%,100%,30</area>
-            <align>allcenter</align>
-        </textarea>
-
-        <button name="cancel" from="basebutton">
-            <position>79%,83%</position>
-            <value>Cancel</value>
-        </button>
-
-        <button name="ok" from="basebutton">
-            <position>79%,90%</position>
-            <value>Import</value>
-        </button>
-
-    </window>
-
     <window name="MythTimeInputDialog">
         <area>-1,-1,580,165</area>
 
diff --git a/mythtv/themes/default/image-ui.xml b/mythtv/themes/default/image-ui.xml
index 3490dbb..05b80ba 100644
--- a/mythtv/themes/default/image-ui.xml
+++ b/mythtv/themes/default/image-ui.xml
@@ -4,51 +4,25 @@
 
     <window name="gallery">
 
-        <!--Shows scan progress-->
-        <progressbar name="scanprogressbar" from="baseprogressbar">
-            <area>25%,5,50%,40</area>
-            <imagetype name="background">
-                <area>0,0,100%,100%</area>
-            </imagetype>
-            <imagetype name="progressimage">
-                <area>0,0,100%,100%</area>
-            </imagetype>
-        </progressbar>
-
-        <!--Shows numerical scan progress-->
-        <textarea name="scanprogresstext" from="basetextarea">
-            <area>25%,10,50%,30</area>
-            <align>center</align>
-        </textarea>
-
         <!--shows path to current image -->
         <textarea name="breadcrumbs" from="basetextarea">
-            <area>20,5,70%,30</area>
+            <area>15,5,100%-170,30</area>
             <font>title</font>
-            <cutdown>yes</cutdown>
+            <cutdown>no</cutdown>
+            <scroll direction="horizontal" startdelay="0" returndelay="0"/>
         </textarea>
 
         <!-- shows the name of the folder or image -->
         <textarea name="caption" from="basetextarea">
-            <area>20,30,70%,30</area>
-            <cutdown>yes</cutdown>
+            <area>15,30,100%-100,30</area>
             <font>title</font>
-            <align>left</align>
-        </textarea>
-
-        <!-- shows state of hidden filter -->
-        <textarea name="hidefilter" from="basetextarea">
-            <area>65%,5,120,30</area>
-        </textarea>
-
-        <!-- shows state of type filter -->
-        <textarea name="typefilter" from="basetextarea">
-            <area>75%,5,130,30</area>
+            <cutdown>no</cutdown>
+            <scroll direction="horizontal" startdelay="0" returndelay="0"/>
         </textarea>
 
         <!-- shows current position in grid eg '1/123' -->
         <textarea name="position" from="basetextarea">
-            <area>100%-160,5,140,30</area>
+            <area>100%-170,5,155,30</area>
             <font>title</font>
             <align>right</align>
         </textarea>
@@ -154,6 +128,48 @@
             <drawfrombottom>true</drawfrombottom>
         </buttonlist>
 
+        <!--Shows scan progress-->
+        <group name="progress">
+            <area>0,0,100%,100%</area>
+            <animation trigger="AboutToShow">
+                <section duration="2000">
+                    <alpha start="0" end="255" easingcurve="OutQuad"/>
+                </section>
+            </animation>
+            <animation trigger="AboutToHide">
+                <section duration="2000">
+                    <alpha start="255" end="0" easingcurve="InQuad"/>
+                </section>
+            </animation>
+            <!-- Progress bar-->
+            <progressbar name="scanprogressbar" from="baseprogressbar">
+                <area>20%,100%-28,75%,28</area>
+                <imagetype name="background">
+                    <area>0,0,100%,100%</area>
+                </imagetype>
+                <imagetype name="progressimage">
+                    <area>0,0,100%,100%</area>
+                </imagetype>
+            </progressbar>
+            <!--Shows numerical scan progress-->
+            <textarea name="scanprogresstext" from="basetextarea">
+                <area>20%,100%-29,75%,30</area>
+                <align>center</align>
+            </textarea>
+        </group>
+
+        <!-- shows state of type filter -->
+        <textarea name="typefilter" from="basetextarea">
+            <area>15,100%-29,180,30</area>
+            <align>vcenter</align>
+        </textarea>
+
+        <!-- shows state of hidden filter -->
+        <textarea name="hidefilter" from="basetextarea">
+            <area>100%-180,100%-29,165,30</area>
+            <align>vcenter,right</align>
+        </textarea>
+
     </window>
 
     <!-- Gallery Slideshow window which shows the a single image only or a slideshow. -->
@@ -185,7 +201,7 @@
 
         <!-- End/Loading/Failed to load status -->
         <textarea name="status" from="basetextarea" depends="!hidecaptions">
-            <area>10,0,400,30</area>
+            <area>10,0,100%-200,30</area>
             <font>gallerytext</font>
         </textarea>
 
@@ -196,11 +212,13 @@
             <align>right, vcentre</align>
         </textarea>
 
-        <!-- Name/date/Comment -->
+        <!-- Date/Comment -->
         <textarea name="caption" from="basetextarea" depends="!hidecaptions">
-            <area>10,100%-30,100%-20,30</area>
+            <area>10,100%-28,100%-20,30</area>
             <font>gallerytext</font>
             <align>centre, vcentre</align>
+            <cutdown>no</cutdown>
+            <scroll direction="horizontal"/>
         </textarea>
 
       <!-- Shows file info overlay -->
-- 
2.1.4

