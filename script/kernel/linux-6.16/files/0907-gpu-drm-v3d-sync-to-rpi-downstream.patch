diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_drv.c linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_drv.c
--- linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_drv.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_drv.c	2025-06-16 10:30:23.604912099 +0200
@@ -25,6 +25,9 @@
 
 #include <drm/drm_drv.h>
 #include <drm/drm_managed.h>
+
+#include <soc/bcm2835/raspberrypi-firmware.h>
+
 #include <uapi/drm/v3d_drm.h>
 
 #include "v3d_drv.h"
@@ -303,6 +306,8 @@
 static int v3d_platform_drm_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	struct rpi_firmware *firmware;
+	struct device_node *node;
 	struct drm_device *drm;
 	struct v3d_dev *v3d;
 	enum v3d_gen gen;
@@ -388,6 +393,31 @@
 		}
 	}
 
+	node = rpi_firmware_find_node();
+	if (!node) {
+		ret = -EINVAL;
+		goto clk_disable;
+	}
+
+	firmware = rpi_firmware_get(node);
+	of_node_put(node);
+	if (!firmware) {
+		ret = -EPROBE_DEFER;
+		goto clk_disable;
+	}
+
+	v3d->clk_up_rate = rpi_firmware_clk_get_max_rate(firmware,
+							 RPI_FIRMWARE_V3D_CLK_ID);
+	rpi_firmware_put(firmware);
+
+	/* For downclocking, drop it to the minimum frequency we can get from
+	 * the CPRMAN clock generator dividing off our parent.  The divider is
+	 * 4 bits, but ask for just higher than that so that rounding doesn't
+	 * make cprman reject our rate.
+	 */
+	v3d->clk_down_rate =
+		(clk_get_rate(clk_get_parent(v3d->clk)) / (1 << 4)) + 10000;
+
 	if (v3d->ver < V3D_GEN_41) {
 		ret = map_regs(v3d, &v3d->gca_regs, "gca");
 		if (ret)
@@ -417,6 +447,8 @@
 	ret = v3d_sysfs_init(dev);
 	if (ret)
 		goto drm_unregister;
+	ret = clk_set_min_rate(v3d->clk, v3d->clk_down_rate);
+	WARN_ON_ONCE(ret != 0);
 
 	return 0;
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_drv.h linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_drv.h
--- linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_drv.h	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_drv.h	2025-06-16 10:30:23.604912099 +0200
@@ -120,6 +120,12 @@
 	void __iomem *gca_regs;
 	void __iomem *sms_regs;
 	struct clk *clk;
+	struct delayed_work clk_down_work;
+	unsigned long clk_up_rate, clk_down_rate;
+	struct mutex clk_lock;
+	u32 clk_refcount;
+	bool clk_up;
+
 	struct reset_control *reset;
 
 	/* Virtual and DMA addresses of the single shared page table. */
@@ -623,3 +629,4 @@
 /* v3d_sysfs.c */
 int v3d_sysfs_init(struct device *dev);
 void v3d_sysfs_destroy(struct device *dev);
+void v3d_submit_init(struct drm_device *dev);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_gem.c linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_gem.c
--- linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_gem.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_gem.c	2025-06-16 10:30:23.604912099 +0200
@@ -4,6 +4,7 @@
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
+#include <linux/clk.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/reset.h>
@@ -286,6 +287,8 @@
 	if (ret)
 		return ret;
 
+	v3d_submit_init(dev);
+
 	/* Note: We don't allocate address 0.  Various bits of HW
 	 * treat 0 as special, such as the occlusion query counters
 	 * where 0 means "disabled".
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_irq.c linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_irq.c
--- linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_irq.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_irq.c	2025-06-16 10:30:23.604912099 +0200
@@ -211,6 +211,7 @@
 			{0x7F, 0x80, "GMP"},
 		};
 		const char *client = "?";
+		static int logged_error;
 
 		V3D_WRITE(V3D_MMU_CTL, V3D_READ(V3D_MMU_CTL));
 
@@ -238,6 +239,7 @@
 			}
 		}
 
+		if (!logged_error)
 		dev_err(v3d->drm.dev, "MMU error from client %s (0x%x) at 0x%llx%s%s%s\n",
 			client, axi_id, (long long)vio_addr,
 			((intsts & V3D_HUB_INT_MMU_WRV) ?
@@ -246,6 +248,7 @@
 			 ", pte invalid" : ""),
 			((intsts & V3D_HUB_INT_MMU_CAP) ?
 			 ", cap exceeded" : ""));
+		logged_error = 1;
 		status = IRQ_HANDLED;
 	}
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_submit.c linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_submit.c
--- linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_submit.c	2025-06-15 22:49:41.000000000 +0200
+++ linux-6.16-rc2/drivers/gpu/drm/v3d/v3d_submit.c	2025-06-16 10:30:23.604912099 +0200
@@ -5,11 +5,52 @@
  */
 
 #include <drm/drm_syncobj.h>
+#include <linux/clk.h>
 
 #include "v3d_drv.h"
 #include "v3d_regs.h"
 #include "v3d_trace.h"
 
+static void
+v3d_clock_down_work(struct work_struct *work)
+{
+	struct v3d_dev *v3d =
+		container_of(work, struct v3d_dev, clk_down_work.work);
+	int ret;
+
+	ret = clk_set_min_rate(v3d->clk, v3d->clk_down_rate);
+	v3d->clk_up = false;
+	WARN_ON_ONCE(ret != 0);
+}
+
+static void
+v3d_clock_up_get(struct v3d_dev *v3d)
+{
+	mutex_lock(&v3d->clk_lock);
+	if (v3d->clk_refcount++ == 0) {
+		cancel_delayed_work_sync(&v3d->clk_down_work);
+		if (!v3d->clk_up)  {
+			int ret;
+
+			ret = clk_set_min_rate(v3d->clk, v3d->clk_up_rate);
+			WARN_ON_ONCE(ret != 0);
+			v3d->clk_up = true;
+		}
+	}
+	mutex_unlock(&v3d->clk_lock);
+}
+
+static void
+v3d_clock_up_put(struct v3d_dev *v3d)
+{
+	mutex_lock(&v3d->clk_lock);
+	if (--v3d->clk_refcount == 0) {
+		schedule_delayed_work(&v3d->clk_down_work,
+			msecs_to_jiffies(100));
+	}
+	mutex_unlock(&v3d->clk_lock);
+}
+
 /* Takes the reservation lock on all the BOs being referenced, so that
  * we can attach fences and update the reservations after pushing the job
  * to the queue.
@@ -85,9 +126,10 @@
 }
 
 static void
-v3d_job_free(struct kref *ref)
+v3d_job_free_common(struct v3d_job *job,
+		    bool is_gpu_job)
 {
-	struct v3d_job *job = container_of(ref, struct v3d_job, refcount);
+	struct v3d_dev *v3d = job->v3d;
 	int i;
 
 	if (job->bo) {
@@ -99,6 +141,9 @@
 	dma_fence_put(job->irq_fence);
 	dma_fence_put(job->done_fence);
 
+	if (is_gpu_job)
+		v3d_clock_up_put(v3d);
+
 	if (job->perfmon)
 		v3d_perfmon_put(job->perfmon);
 
@@ -106,6 +151,22 @@
 }
 
 static void
+v3d_job_free(struct kref *ref)
+{
+	struct v3d_job *job = container_of(ref, struct v3d_job, refcount);
+
+	v3d_job_free_common(job, true);
+}
+
+static void
+v3d_cpu_job_free(struct kref *ref)
+{
+	struct v3d_job *job = container_of(ref, struct v3d_job, refcount);
+
+	v3d_job_free_common(job, false);
+}
+
+static void
 v3d_render_job_free(struct kref *ref)
 {
 	struct v3d_render_job *job = container_of(ref, struct v3d_render_job,
@@ -199,6 +260,8 @@
 		if (ret && ret != -ENOENT)
 			goto fail_deps;
 	}
+	if (queue != V3D_CPU)
+		v3d_clock_up_get(v3d);
 
 	kref_init(&job->refcount);
 
@@ -1316,7 +1379,7 @@
 	trace_v3d_submit_cpu_ioctl(&v3d->drm, cpu_job->job_type);
 
 	ret = v3d_job_init(v3d, file_priv, &cpu_job->base,
-			   v3d_job_free, 0, &se, V3D_CPU);
+			   v3d_cpu_job_free, 0, &se, V3D_CPU);
 	if (ret) {
 		v3d_job_deallocate((void *)&cpu_job);
 		goto fail;
@@ -1404,3 +1467,14 @@
 
 	return ret;
 }
+
+void v3d_submit_init(struct drm_device *dev) {
+	struct v3d_dev *v3d = to_v3d_dev(dev);
+
+	mutex_init(&v3d->clk_lock);
+	INIT_DELAYED_WORK(&v3d->clk_down_work, v3d_clock_down_work);
+
+	/* kick the clock so firmware knows we are using firmware clock interface */
+	v3d_clock_up_get(v3d);
+	v3d_clock_up_put(v3d);
+}
\ No newline at end of file
