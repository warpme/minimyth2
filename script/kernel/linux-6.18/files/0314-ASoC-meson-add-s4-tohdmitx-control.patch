
From: jiebing chen <jiebing.chen@amlogic.com>
Subject: [PATCH 2/2] ASoC: meson: add s4 tohdmitx control

Add support for the hdmitx control glue of the Amlogic S4 SoC family.
This glue links the 3 TDM and 2 SPDIF output interfaces of the SoC to
the related inputs of the Synopsys HDMI controller found in these SoCs.

Signed-off-by: jiebing chen <jiebing.chen@amlogic.com>
---
 .../bindings/sound/amlogic,g12a-tohdmitx.yaml |  1 +
 sound/soc/meson/g12a-tohdmitx.c               | 78 ++++++++++++++++++-
 4 files changed, 87 insertions(+), 4 deletions(-)

diff --git a/Documentation/devicetree/bindings/sound/amlogic,g12a-tohdmitx.yaml b/Documentation/devicetree/bindings/sound/amlogic,g12a-tohdmitx.yaml
index b4b78475c5b8..016d3cd3eb03 100644
--- a/Documentation/devicetree/bindings/sound/amlogic,g12a-tohdmitx.yaml
+++ b/Documentation/devicetree/bindings/sound/amlogic,g12a-tohdmitx.yaml
@@ -22,6 +22,7 @@ properties:
           - const: amlogic,g12a-tohdmitx
       - items:
           - enum:
+              - amlogic,s4-tohdmitx
               - amlogic,sm1-tohdmitx
           - const: amlogic,g12a-tohdmitx
 
diff --git a/sound/soc/meson/g12a-tohdmitx.c b/sound/soc/meson/g12a-tohdmitx.c
index d541ca4acfaf..55a361f4b531 100644
--- a/sound/soc/meson/g12a-tohdmitx.c
+++ b/sound/soc/meson/g12a-tohdmitx.c
@@ -31,6 +31,15 @@
 #define  CTRL0_SPDIF_SEL		(0x1 << CTRL0_SPDIF_SEL_SHIFT)
 #define  CTRL0_SPDIF_CLK_SEL		BIT(0)
 
+#define  CTRL0_I2S_DATA_SHIFT		29
+#define  CTRL0_I2S_CLK_SHIFT		28
+#define  CTRL0_SPDIF_DATA_SHIFT		31
+#define  CTRL0_SPDIF_CLK_SHIFT		30
+
+struct g12a_tohdmitx_match_data {
+	const struct snd_soc_component_driver *component_drv;
+};
+
 static const char * const g12a_tohdmitx_i2s_mux_texts[] = {
 	"I2S A", "I2S B", "I2S C",
 };
@@ -130,6 +139,13 @@ static const struct snd_kcontrol_new g12a_tohdmitx_out_enable =
 	SOC_DAPM_SINGLE_AUTODISABLE("Switch", TOHDMITX_CTRL0,
 				    CTRL0_ENABLE_SHIFT, 1, 0);
 
+static const struct snd_kcontrol_new s4_i2s_out_enable =
+	SOC_DAPM_SINGLE_AUTODISABLE("Switch", TOHDMITX_CTRL0,
+				    CTRL0_I2S_DATA_SHIFT, 1, 0);
+static const struct snd_kcontrol_new s4_spdif_out_enable =
+	SOC_DAPM_SINGLE_AUTODISABLE("Switch", TOHDMITX_CTRL0,
+				    CTRL0_I2S_DATA_SHIFT, 1, 0);
+
 static const struct snd_soc_dapm_widget g12a_tohdmitx_widgets[] = {
 	SND_SOC_DAPM_MUX("I2S SRC", SND_SOC_NOPM, 0, 0,
 			 &g12a_tohdmitx_i2s_mux),
@@ -141,6 +157,19 @@ static const struct snd_soc_dapm_widget g12a_tohdmitx_widgets[] = {
 			    &g12a_tohdmitx_out_enable),
 };
 
+static const struct snd_soc_dapm_widget s4_tohdmitx_widgets[] = {
+	SND_SOC_DAPM_MUX("I2S SRC", SND_SOC_NOPM, 0, 0,
+			 &g12a_tohdmitx_i2s_mux),
+	SND_SOC_DAPM_SWITCH("I2S OUT EN", SND_SOC_NOPM, 0, 0,
+			    &s4_i2s_out_enable),
+	SND_SOC_DAPM_MUX("SPDIF SRC", SND_SOC_NOPM, 0, 0,
+			 &g12a_tohdmitx_spdif_mux),
+	SND_SOC_DAPM_SWITCH("SPDIF OUT EN", SND_SOC_NOPM, 0, 0,
+			    &s4_spdif_out_enable),
+	SND_SOC_DAPM_SUPPLY("I2S CLK Gate", TOHDMITX_CTRL0, CTRL0_I2S_CLK_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("SPDIF CLK Gate", TOHDMITX_CTRL0, CTRL0_SPDIF_CLK_SHIFT, 0, NULL, 0),
+};
+
 static const struct snd_soc_dai_ops g12a_tohdmitx_input_ops = {
 	.probe		= meson_codec_glue_input_dai_probe,
 	.remove		= meson_codec_glue_input_dai_remove,
@@ -221,6 +250,20 @@ static const struct snd_soc_dapm_route g12a_tohdmitx_routes[] = {
 	{ "SPDIF OUT Capture", NULL, "SPDIF OUT EN" },
 };
 
+static const struct snd_soc_dapm_route s4_tohdmitx_routes[] = {
+	{ "I2S SRC", "I2S A", "I2S IN A Playback" },
+	{ "I2S SRC", "I2S B", "I2S IN B Playback" },
+	{ "I2S SRC", "I2S C", "I2S IN C Playback" },
+	{ "I2S OUT EN", "Switch", "I2S SRC" },
+	{ "I2S OUT EN", NULL, "I2S CLK Gate"},
+	{ "I2S OUT Capture", NULL, "I2S OUT EN" },
+	{ "SPDIF SRC", "SPDIF A", "SPDIF IN A Playback" },
+	{ "SPDIF SRC", "SPDIF B", "SPDIF IN B Playback" },
+	{ "SPDIF OUT EN", "Switch", "SPDIF SRC" },
+	{ "SPDIF OUT EN", NULL, "SPDIF CLK Gate" },
+	{ "SPDIF OUT Capture", NULL, "SPDIF OUT EN" },
+};
+
 static const struct snd_soc_component_driver g12a_tohdmitx_component_drv = {
 	.probe			= g12a_tohdmi_component_probe,
 	.dapm_widgets		= g12a_tohdmitx_widgets,
@@ -230,25 +273,56 @@ static const struct snd_soc_component_driver g12a_tohdmitx_component_drv = {
 	.endianness		= 1,
 };
 
+static const struct snd_soc_component_driver s4_tohdmitx_component_drv = {
+	.probe			= g12a_tohdmi_component_probe,
+	.dapm_widgets		= s4_tohdmitx_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(s4_tohdmitx_widgets),
+	.dapm_routes		= s4_tohdmitx_routes,
+	.num_dapm_routes	= ARRAY_SIZE(s4_tohdmitx_routes),
+	.endianness		= 1,
+};
+
 static const struct regmap_config g12a_tohdmitx_regmap_cfg = {
 	.reg_bits	= 32,
 	.val_bits	= 32,
 	.reg_stride	= 4,
 };
 
+static const struct g12a_tohdmitx_match_data g12a_hdmitx_match_data = {
+	.component_drv	= &g12a_tohdmitx_component_drv,
+};
+
+static const struct g12a_tohdmitx_match_data s4_hdmitx_match_data = {
+	.component_drv	= &s4_tohdmitx_component_drv,
+};
+
 static const struct of_device_id g12a_tohdmitx_of_match[] = {
-	{ .compatible = "amlogic,g12a-tohdmitx", },
+	{
+		.compatible = "amlogic,g12a-tohdmitx",
+		.data = &g12a_hdmitx_match_data,
+	},
+	{
+		.compatible = "amlogic,s4-tohdmitx",
+		.data = &s4_hdmitx_match_data,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, g12a_tohdmitx_of_match);
 
 static int g12a_tohdmitx_probe(struct platform_device *pdev)
 {
+	const struct g12a_tohdmitx_match_data *data;
 	struct device *dev = &pdev->dev;
 	void __iomem *regs;
 	struct regmap *map;
 	int ret;
 
+	data = device_get_match_data(dev);
+	if (!data) {
+		dev_err(dev, "failed to match device\n");
+		return -ENODEV;
+	}
+
 	ret = device_reset(dev);
 	if (ret)
 		return ret;
@@ -265,7 +339,7 @@ static int g12a_tohdmitx_probe(struct platform_device *pdev)
 	}
 
 	return devm_snd_soc_register_component(dev,
-			&g12a_tohdmitx_component_drv, g12a_tohdmitx_dai_drv,
+			data->component_drv, g12a_tohdmitx_dai_drv,
 			ARRAY_SIZE(g12a_tohdmitx_dai_drv));
 }
 
-- 
2.52.0

